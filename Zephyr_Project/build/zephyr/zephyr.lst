
zephyr.elf:     file format elf64-x86-64


Disassembly of section .locore:

0000000000001000 <__start>:
 */
.section .locore,"ax"
.code32
.globl __start
__start:
	jmp __start32
    1000:	eb 08                	jmp    100a <__start32>
	nop
    1002:	90                   	nop
	nop
    1003:	90                   	nop
	nop
    1004:	90                   	nop
	nop
    1005:	90                   	nop
	nop
    1006:	90                   	nop
	nop
    1007:	90                   	nop
	nop
    1008:	90                   	nop
	nop
    1009:	90                   	nop

000000000000100a <__start32>:
	 * kernel execution begins here in 32-bit mode, with flat-mode
	 * descriptors in all segment registers, interrupts disabled.
	 */

	/* See note above, re: OUTRAGEOUS HACK */
	movl $__start, %ebp
    100a:	bd 00 10 00 00       	mov    $0x1000,%ebp
	movb $0x90, 0(%ebp)
    100f:	c6 45 00 90          	movb   $0x90,0x0(%rbp)
	movb $0x90, 1(%ebp)
    1013:	c6 45 01 90          	movb   $0x90,0x1(%rbp)
	movb $0x90, 2(%ebp)
    1017:	c6 45 02 90          	movb   $0x90,0x2(%rbp)
	movb $0x90, 3(%ebp)
    101b:	c6 45 03 90          	movb   $0x90,0x3(%rbp)
	movb $0x90, 4(%ebp)
    101f:	c6 45 04 90          	movb   $0x90,0x4(%rbp)
	movb $0x90, 5(%ebp)
    1023:	c6 45 05 90          	movb   $0x90,0x5(%rbp)
	movb $0x90, 6(%ebp)
    1027:	c6 45 06 90          	movb   $0x90,0x6(%rbp)
	movb $0x90, 7(%ebp)
    102b:	c6 45 07 90          	movb   $0x90,0x7(%rbp)
	wbinvd
    102f:	0f 09                	wbinvd 

	lgdt gdt48
    1031:	0f 01 15 d0 60 00 00 	lgdt   0x60d0(%rip)        # 7108 <_lodata_end+0x108>
	lidt idt48
    1038:	0f 01 1d 00 30 00 00 	lidt   0x3000(%rip)        # 403f <_lodata_start+0x3f>
	 * "Disable" legacy i8259 interrupt controllers. Note that we
	 * can't actually disable them, but we mask all their interrupt
	 * sources which is effectively the same thing (almost).
	 */

	movb $0xff, %al
    103f:	b0 ff                	mov    $0xff,%al
	outb %al, $0x21
    1041:	e6 21                	out    %al,$0x21
	outb %al, $0xA1
    1043:	e6 a1                	out    %al,$0xa1
#endif

#ifdef CONFIG_MULTIBOOT
	jmp 1f
    1045:	eb 0d                	jmp    1054 <__start32+0x4a>
    1047:	90                   	nop
    1048:	02 b0 ad 1b 02 00    	add    0x21bad(%rax),%dh
    104e:	00 00                	add    %al,(%rax)
    1050:	fc                   	cld    
    1051:	4f 52                	rex.WRXB push %r10
    1053:	e4 bd                	in     $0xbd,%al
	/*
	 * N.B.: if multiboot info struct is present, "common.S"
	 * has left a pointer to it in EBX.
	 */

	movl $x86_cpuboot, %ebp		/* BSP is always logical CPU id 0 */
    1055:	a0                   	.byte 0xa0
    1056:	10 5e 00             	adc    %bl,0x0(%rsi)
	movl %ebx, __x86_cpuboot_t_arg_OFFSET(%ebp)	/* multiboot info */
    1059:	89 5d 28             	mov    %ebx,0x28(%rbp)

000000000000105c <go64>:


go64:	/* Install page tables and transition to long mode */
	install_pagetables_32
    105c:	0f 20 e0             	mov    %cr4,%rax
    105f:	0d 20 02 00 00       	or     $0x220,%eax
    1064:	0f 22 e0             	mov    %rax,%cr4
    1067:	0f 06                	clts   
    1069:	b8 00 40 6e 00       	mov    $0x6e4000,%eax
    106e:	0f 22 d8             	mov    %rax,%cr3
    1071:	b9 80 00 00 c0       	mov    $0xc0000080,%ecx
    1076:	0f 32                	rdmsr  
    1078:	0d 01 09 00 00       	or     $0x901,%eax
    107d:	0f 30                	wrmsr  
    107f:	0f 20 c0             	mov    %cr0,%rax
    1082:	0d 00 00 01 80       	or     $0x80010000,%eax
    1087:	0f 22 c0             	mov    %rax,%cr0
	jmpl $X86_KERNEL_CS, $enter_code64
    108a:	ea                   	(bad)  
    108b:	91                   	xchg   %eax,%ecx
    108c:	10 00                	adc    %al,(%rax)
    108e:	00 18                	add    %bl,(%rax)
	...

0000000000001091 <enter_code64>:
	 * Here we reload the segment registers,
	 * and configure per-CPU stuff: GS, task register, stack.
	 */
	.code64
enter_code64:
	movl $X86_KERNEL_DS, %eax
    1091:	b8 20 00 00 00       	mov    $0x20,%eax
	movw %ax, %ds
    1096:	8e d8                	mov    %eax,%ds
	movw %ax, %es
    1098:	8e c0                	mov    %eax,%es
	movw %ax, %ss
    109a:	8e d0                	mov    %eax,%ss
	movw %ax, %fs
    109c:	8e e0                	mov    %eax,%fs
	 * zero, GS_BASE is also being set to zero. This would interfere
	 * with the actual use of GS_BASE for usespace. To avoid accidentally
	 * clearing GS_BASE, simply set GS to 0 at boot, so any subsequent
	 * clearing of GS will not clear GS_BASE.
	 */
	mov $0, %eax
    109e:	b8 00 00 00 00       	mov    $0x0,%eax
	movw %ax, %gs
    10a3:	8e e8                	mov    %eax,%gs

	movw __x86_cpuboot_t_tr_OFFSET(%rbp), %ax
    10a5:	66 8b 45 04          	mov    0x4(%rbp),%ax
	ltr %ax
    10a9:	0f 00 d8             	ltr    %ax

	/* Set up MSRs for GS / KERNEL_GS base */
	movq __x86_cpuboot_t_gs_base_OFFSET(%rbp), %rax
    10ac:	48 8b 45 08          	mov    0x8(%rbp),%rax
	movq %rax, %rdx
    10b0:	48 89 c2             	mov    %rax,%rdx
	shrq $32, %rdx
    10b3:	48 c1 ea 20          	shr    $0x20,%rdx
	/* X86_KERNEL_GS_BASE and X86_GS_BASE are swapped by the 'swapgs'
	 * instruction.
	 */
	movl $X86_KERNEL_GS_BASE, %ecx
    10b7:	b9 02 01 00 c0       	mov    $0xc0000102,%ecx
	wrmsr
    10bc:	0f 30                	wrmsr  
	/* X86_GS_BASE shadows base fields of %gs, effectively setting %gs */
	movl $X86_GS_BASE, %ecx
    10be:	b9 01 01 00 c0       	mov    $0xc0000101,%ecx
	wrmsr
    10c3:	0f 30                	wrmsr  

	movq __x86_cpuboot_t_sp_OFFSET(%rbp), %rsp
    10c5:	48 8b 65 10          	mov    0x10(%rbp),%rsp
	movq %rsp, %gs:__x86_tss64_t_ist1_OFFSET
    10c9:	65 48 89 24 25 24 00 	mov    %rsp,%gs:0x24
    10d0:	00 00 

	/* finally, complete environment for the C runtime and go. */
	cld	/* GCC presumes a clear direction flag */
    10d2:	fc                   	cld    

#ifdef CONFIG_INIT_STACKS
	movq $0xAAAAAAAAAAAAAAAA, %rax
    10d3:	48 b8 aa aa aa aa aa 	movabs $0xaaaaaaaaaaaaaaaa,%rax
    10da:	aa aa aa 
	movq %rsp, %rdi
    10dd:	48 89 e7             	mov    %rsp,%rdi
	subq __x86_cpuboot_t_stack_size_OFFSET(%rbp), %rdi
    10e0:	48 2b 7d 18          	sub    0x18(%rbp),%rdi
	movq __x86_cpuboot_t_stack_size_OFFSET(%rbp), %rcx
    10e4:	48 8b 4d 18          	mov    0x18(%rbp),%rcx
	shr $3, %rcx /* moving 8 bytes a time, so fewer repeats */
    10e8:	48 c1 e9 03          	shr    $0x3,%rcx
	rep stosq
    10ec:	f3 48 ab             	rep stos %rax,%es:(%rdi)
#endif

	/* Enter C domain now that we have a stack set up, never to return */
	movq %rbp, %rdi
    10ef:	48 89 ef             	mov    %rbp,%rdi
	call z_x86_cpu_init
    10f2:	e8 0b 88 10 00       	callq  109902 <z_x86_cpu_init>

00000000000010f7 <__start64>:
	 * 32 bit startup does.
	 */
.globl __start64
__start64:
	/* Zero the TSC */
	xorq %rax, %rax
    10f7:	48 31 c0             	xor    %rax,%rax
	xorq %rdx, %rdx
    10fa:	48 31 d2             	xor    %rdx,%rdx
	movq $X86_TIME_STAMP_COUNTER_MSR, %rcx
    10fd:	48 c7 c1 10 00 00 00 	mov    $0x10,%rcx
	wrmsr
    1104:	0f 30                	wrmsr  

	lidt idt80
    1106:	0f 01 1c 25 06 30 00 	lidt   0x3006
    110d:	00 
	lgdt gdt80
    110e:	0f 01 14 25 d6 60 00 	lgdt   0x60d6
    1115:	00 

	install_pagetables_64
    1116:	0f 20 e0             	mov    %cr4,%rax
    1119:	48 0d 20 02 00 00    	or     $0x220,%rax
    111f:	0f 22 e0             	mov    %rax,%cr4
    1122:	0f 06                	clts   
    1124:	48 c7 c0 00 40 6e 00 	mov    $0x6e4000,%rax
    112b:	0f 22 d8             	mov    %rax,%cr3
    112e:	b9 80 00 00 c0       	mov    $0xc0000080,%ecx
    1133:	0f 32                	rdmsr  
    1135:	0d 01 09 00 00       	or     $0x901,%eax
    113a:	0f 30                	wrmsr  
    113c:	0f 20 c0             	mov    %cr0,%rax
    113f:	0d 00 00 01 80       	or     $0x80010000,%eax
    1144:	0f 22 c0             	mov    %rax,%cr0

	/* Disable 8259 PIT.  Almost certainly not needed on modern
	 * UEFI platforms taking this code path, but...
	 */
	movb $0xff, %al
    1147:	b0 ff                	mov    $0xff,%al
	outb %al, $0x21
    1149:	e6 21                	out    %al,$0x21
	outb %al, $0xA1
    114b:	e6 a1                	out    %al,$0xa1

	/* Far call into the Zephyr code segment */
	movq $x86_cpuboot, %rbp
    114d:	48 c7 c5 a0 10 5e 00 	mov    $0x5e10a0,%rbp
	mov jmpdesc, %rax
    1154:	48 8b 04 25 5e 11 00 	mov    0x115e,%rax
    115b:	00 
	jmp *%rax
    115c:	ff e0                	jmpq   *%rax

000000000000115e <jmpdesc>:
    115e:	91                   	xchg   %eax,%ecx
    115f:	10 00                	adc    %al,(%rax)
    1161:	00 00                	add    %al,(%rax)
    1163:	00 00                	add    %al,(%rax)
    1165:	00 18                	add    %bl,(%rax)
	...

0000000000001168 <x86_sse_init>:
 * not NULL, then the resulting FP state is saved to thread->arch.sse.
 */

.global x86_sse_init
x86_sse_init:
	fninit
    1168:	db e3                	fninit 
	ldmxcsr mxcsr
    116a:	0f ae 14 25 7f 11 00 	ldmxcsr 0x117f
    1171:	00 
	testq %rdi, %rdi
    1172:	48 85 ff             	test   %rdi,%rdi
	jz 1f
    1175:	74 07                	je     117e <x86_sse_init+0x16>
	fxsave _thread_offset_to_sse(%rdi)
    1177:	0f ae 87 e0 01 00 00 	fxsave 0x1e0(%rdi)
1:	retq
    117e:	c3                   	retq   

000000000000117f <mxcsr>:
    117f:	80 1f 00             	sbbb   $0x0,(%rdi)
	...

0000000000001183 <z_x86_switch>:
z_x86_switch:
	/* RSI contains the switch_handle field to which we are
	 * notionally supposed to store.  Offset it to get back to the
	 * thread handle instead.
	 */
	subq $___thread_t_switch_handle_OFFSET, %rsi
    1183:	48 81 ee 50 01 00 00 	sub    $0x150,%rsi

	andb $~X86_THREAD_FLAG_ALL, _thread_offset_to_flags(%rsi)
    118a:	80 a6 70 01 00 00 fe 	andb   $0xfe,0x170(%rsi)

	popq %rax
    1191:	58                   	pop    %rax
	movq %rax, _thread_offset_to_rip(%rsi)
    1192:	48 89 86 80 00 00 00 	mov    %rax,0x80(%rsi)
	pushfq
    1199:	9c                   	pushfq 
	popq %rax
    119a:	58                   	pop    %rax
	movq %rax, _thread_offset_to_rflags(%rsi)
    119b:	48 89 86 88 00 00 00 	mov    %rax,0x88(%rsi)
	movq %rsp, _thread_offset_to_rsp(%rsi)
    11a2:	48 89 66 48          	mov    %rsp,0x48(%rsi)
	movq %rbx, _thread_offset_to_rbx(%rsi)
    11a6:	48 89 5e 50          	mov    %rbx,0x50(%rsi)
	movq %rbp, _thread_offset_to_rbp(%rsi)
    11aa:	48 89 6e 58          	mov    %rbp,0x58(%rsi)
	movq %r12, _thread_offset_to_r12(%rsi)
    11ae:	4c 89 66 60          	mov    %r12,0x60(%rsi)
	movq %r13, _thread_offset_to_r13(%rsi)
    11b2:	4c 89 6e 68          	mov    %r13,0x68(%rsi)
	movq %r14, _thread_offset_to_r14(%rsi)
    11b6:	4c 89 76 70          	mov    %r14,0x70(%rsi)
	movq %r15, _thread_offset_to_r15(%rsi)
    11ba:	4c 89 7e 78          	mov    %r15,0x78(%rsi)
#ifdef CONFIG_USERSPACE
	/* We're always in supervisor mode if we get here, the other case
	 * is when __resume is invoked from irq_dispatch
	 */
	movq $X86_KERNEL_CS, _thread_offset_to_cs(%rsi)
    11be:	48 c7 86 90 01 00 00 	movq   $0x18,0x190(%rsi)
    11c5:	18 00 00 00 
	movq $X86_KERNEL_DS, _thread_offset_to_ss(%rsi)
    11c9:	48 c7 86 88 01 00 00 	movq   $0x20,0x188(%rsi)
    11d0:	20 00 00 00 
	/* Store the handle (i.e. our thread struct address) into the
	 * switch handle field, this is a synchronization signal that
	 * must occur after the last data from the old context is
	 * saved.
	 */
	movq %rsi, ___thread_t_switch_handle_OFFSET(%rsi)
    11d4:	48 89 b6 50 01 00 00 	mov    %rsi,0x150(%rsi)

	movq %gs:__x86_tss64_t_ist1_OFFSET, %rsp
    11db:	65 48 8b 24 25 24 00 	mov    %gs:0x24,%rsp
    11e2:	00 00 

00000000000011e4 <__resume>:
 */

__resume:
#if (!defined(CONFIG_X86_KPTI) && defined(CONFIG_USERSPACE)) \
		|| defined(CONFIG_INSTRUMENT_THREAD_SWITCHING)
	pushq %rdi	/* Caller-saved, stash it */
    11e4:	57                   	push   %rdi
	 * when trampolining back to user mode
	 */
	call z_x86_swap_update_page_tables
#endif
#ifdef CONFIG_INSTRUMENT_THREAD_SWITCHING
	call z_thread_mark_switched_in
    11e5:	e8 99 d3 10 00       	callq  10e583 <z_thread_mark_switched_in>
#endif
	popq %rdi
    11ea:	5f                   	pop    %rdi
#endif /* (!CONFIG_X86_KPTI && CONFIG_USERSPACE) || \
	   CONFIG_INSTRUMENT_THREAD_SWITCHING */

#ifdef CONFIG_USERSPACE
	/* Set up exception return stack frame */
	pushq _thread_offset_to_ss(%rdi)	/* SS */
    11eb:	ff b7 88 01 00 00    	pushq  0x188(%rdi)
#else
	pushq $X86_KERNEL_DS			/* SS */
#endif /* CONFIG_USERSPACE */
	pushq _thread_offset_to_rsp(%rdi)	/* RSP */
    11f1:	ff 77 48             	pushq  0x48(%rdi)
	pushq _thread_offset_to_rflags(%rdi)	/* RFLAGS */
    11f4:	ff b7 88 00 00 00    	pushq  0x88(%rdi)
#ifdef CONFIG_USERSPACE
	pushq _thread_offset_to_cs(%rdi)	/* CS */
    11fa:	ff b7 90 01 00 00    	pushq  0x190(%rdi)
#else
	pushq $X86_KERNEL_CS			/* CS */
#endif
	pushq _thread_offset_to_rip(%rdi)	/* RIP */
    1200:	ff b7 80 00 00 00    	pushq  0x80(%rdi)
	 * recognizable value near NULL, to easily catch reuse of the
	 * thread object across CPUs in SMP.  Strictly speaking this
	 * is not an assertion, but it's very cheap and worth having
	 * on during routine testing.
	 */
	movq $0xB9, _thread_offset_to_rip(%rdi)
    1206:	48 c7 87 80 00 00 00 	movq   $0xb9,0x80(%rdi)
    120d:	b9 00 00 00 
	movq _thread_offset_to_tls(%rdi), %rdx
	shrq $32, %rdx
	wrmsr
#endif

	movq _thread_offset_to_rbx(%rdi), %rbx
    1211:	48 8b 5f 50          	mov    0x50(%rdi),%rbx
	movq _thread_offset_to_rbp(%rdi), %rbp
    1215:	48 8b 6f 58          	mov    0x58(%rdi),%rbp
	movq _thread_offset_to_r12(%rdi), %r12
    1219:	4c 8b 67 60          	mov    0x60(%rdi),%r12
	movq _thread_offset_to_r13(%rdi), %r13
    121d:	4c 8b 6f 68          	mov    0x68(%rdi),%r13
	movq _thread_offset_to_r14(%rdi), %r14
    1221:	4c 8b 77 70          	mov    0x70(%rdi),%r14
	movq _thread_offset_to_r15(%rdi), %r15
    1225:	4c 8b 7f 78          	mov    0x78(%rdi),%r15
#ifdef CONFIG_USERSPACE
	/* Set correct privilege elevation stack to manually switch to in
	 * z_x86_syscall_entry_stub()
	 */
	movq _thread_offset_to_psp(%rdi), %rax
    1229:	48 8b 87 80 01 00 00 	mov    0x180(%rdi),%rax
	movq %rax, %gs:__x86_tss64_t_psp_OFFSET
    1230:	65 48 89 04 25 70 00 	mov    %rax,%gs:0x70
    1237:	00 00 
#endif

	testb $X86_THREAD_FLAG_ALL, _thread_offset_to_flags(%rdi)
    1239:	f6 87 70 01 00 00 01 	testb  $0x1,0x170(%rdi)
	jz 1f
    1240:	74 52                	je     1294 <__resume+0xb0>

	fxrstor _thread_offset_to_sse(%rdi)
    1242:	0f ae 8f e0 01 00 00 	fxrstor 0x1e0(%rdi)
	movq _thread_offset_to_rax(%rdi), %rax
    1249:	48 8b 87 98 01 00 00 	mov    0x198(%rdi),%rax
	movq _thread_offset_to_rcx(%rdi), %rcx
    1250:	48 8b 8f a0 01 00 00 	mov    0x1a0(%rdi),%rcx
	movq _thread_offset_to_rdx(%rdi), %rdx
    1257:	48 8b 97 a8 01 00 00 	mov    0x1a8(%rdi),%rdx
	movq _thread_offset_to_rsi(%rdi), %rsi
    125e:	48 8b b7 b0 01 00 00 	mov    0x1b0(%rdi),%rsi
	movq _thread_offset_to_r8(%rdi), %r8
    1265:	4c 8b 87 c0 01 00 00 	mov    0x1c0(%rdi),%r8
	movq _thread_offset_to_r9(%rdi), %r9
    126c:	4c 8b 8f c8 01 00 00 	mov    0x1c8(%rdi),%r9
	movq _thread_offset_to_r10(%rdi), %r10
    1273:	4c 8b 97 d0 01 00 00 	mov    0x1d0(%rdi),%r10
	movq _thread_offset_to_r11(%rdi), %r11
    127a:	4c 8b 9f d8 01 00 00 	mov    0x1d8(%rdi),%r11
	movq _thread_offset_to_rdi(%rdi), %rdi  /* do last :-) */
    1281:	48 8b bf b8 01 00 00 	mov    0x1b8(%rdi),%rdi

#ifdef CONFIG_USERSPACE
	/* Swap GS register values if we are returning to user mode */
	testb $0x3, 8(%rsp)
    1288:	f6 44 24 08 03       	testb  $0x3,0x8(%rsp)
	jz 1f
    128d:	74 05                	je     1294 <__resume+0xb0>
#ifdef CONFIG_X86_KPTI
	jmp z_x86_trampoline_to_user
    128f:	e9 6c ed 0f 00       	jmpq   100000 <CONFIG_KERNEL_VM_OFFSET>
#endif /* CONFIG_X86_KPTI */
#endif /* CONFIG_USERSPACE */
1:
#ifdef CONFIG_X86_BOUNDS_CHECK_BYPASS_MITIGATION
	/* swapgs variant of Spectre V1. Disable speculation past this point */
	lfence
    1294:	0f ae e8             	lfence 
#endif /* CONFIG_X86_BOUNDS_CHECK_BYPASS_MITIGATION */
	iretq
    1297:	48 cf                	iretq  

0000000000001299 <except>:
except: /*
	 * finish struct NANO_ESF on stack. 'vector' .. 'ss' are
	 * already there from hardware trap and EXCEPT_*() stub.
	 */

	pushq %r11
    1299:	41 53                	push   %r11

#ifdef CONFIG_USERSPACE
	/* Swap GS register values and page tables if we came from user mode */
	testb $0x3, 40(%rsp)
    129b:	f6 44 24 28 03       	testb  $0x3,0x28(%rsp)
	jz 1f
    12a0:	74 0e                	je     12b0 <except+0x17>
	swapgs
    12a2:	0f 01 f8             	swapgs 
#ifdef CONFIG_X86_KPTI
	/* Load kernel's page table. NOTE: Presumes phys=virt */
	movq $z_x86_kernel_ptables, %r11
    12a5:	49 c7 c3 00 40 6e 00 	mov    $0x6e4000,%r11
	movq %r11, %cr3
    12ac:	41 0f 22 db          	mov    %r11,%cr3
#endif /* CONFIG_X86_KPTI */
1:
#ifdef CONFIG_X86_BOUNDS_CHECK_BYPASS_MITIGATION
	/* swapgs variant of Spectre V1. Disable speculation past this point */
	lfence
    12b0:	0f ae e8             	lfence 
#endif /* CONFIG_X86_BOUNDS_CHECK_BYPASS_MITIGATION */
#ifdef CONFIG_X86_KPTI
	/* Save old trampoline stack pointer in R11 */
	movq %rsp, %r11
    12b3:	49 89 e3             	mov    %rsp,%r11

	/* Switch to the correct stack */
	movq 16(%r11), %rsp
    12b6:	49 8b 63 10          	mov    0x10(%r11),%rsp

	/* Transplant trampoline stack contents */
	pushq 64(%r11)	/* SS */
    12ba:	41 ff 73 40          	pushq  0x40(%r11)
	pushq 56(%r11)	/* RSP */
    12be:	41 ff 73 38          	pushq  0x38(%r11)
	pushq 48(%r11)	/* RFLAGS */
    12c2:	41 ff 73 30          	pushq  0x30(%r11)
	pushq 40(%r11)	/* CS */
    12c6:	41 ff 73 28          	pushq  0x28(%r11)
	pushq 32(%r11)	/* RIP */
    12ca:	41 ff 73 20          	pushq  0x20(%r11)
	pushq 24(%r11)	/* Error code */
    12ce:	41 ff 73 18          	pushq  0x18(%r11)
	pushq 8(%r11)	/* Vector */
    12d2:	41 ff 73 08          	pushq  0x8(%r11)
	pushq (%r11)	/* Stashed R11 */
    12d6:	41 ff 33             	pushq  (%r11)
	movq $0, (%r11) /* Cover our tracks */
    12d9:	49 c7 03 00 00 00 00 	movq   $0x0,(%r11)

	/* We're done, it's safe to re-enable interrupts. */
	sti
    12e0:	fb                   	sti    

	/* In addition to r11, push the rest of the caller-saved regs */
	/* Positioning of this fxsave is important, RSP must be 16-byte
	 * aligned
	 */
	subq $X86_FXSAVE_SIZE, %rsp
    12e1:	48 81 ec 00 02 00 00 	sub    $0x200,%rsp
	fxsave (%rsp)
    12e8:	0f ae 04 24          	fxsave (%rsp)
	pushq %r10
    12ec:	41 52                	push   %r10
	pushq %r9
    12ee:	41 51                	push   %r9
	pushq %r8
    12f0:	41 50                	push   %r8
	pushq %rdi
    12f2:	57                   	push   %rdi
	pushq %rsi
    12f3:	56                   	push   %rsi
	pushq %rdx
    12f4:	52                   	push   %rdx
	pushq %rcx
    12f5:	51                   	push   %rcx
	pushq %rax
    12f6:	50                   	push   %rax
	pushq %rbp
    12f7:	55                   	push   %rbp
#ifdef CONFIG_EXCEPTION_DEBUG
	/* Callee saved regs */
	pushq %r15
    12f8:	41 57                	push   %r15
	pushq %r14
    12fa:	41 56                	push   %r14
	pushq %r13
    12fc:	41 55                	push   %r13
	pushq %r12
    12fe:	41 54                	push   %r12
	pushq %rbx
    1300:	53                   	push   %rbx
#endif /* CONFIG_EXCEPTION_DEBUG */
	movq %rsp, %rdi
    1301:	48 89 e7             	mov    %rsp,%rdi

	call z_x86_exception
    1304:	e8 ab 88 10 00       	callq  109bb4 <z_x86_exception>

	/* If we returned, the exception was handled successfully and the
	 * thread may resume (the pushed RIP may have been modified)
	 */
#ifdef CONFIG_EXCEPTION_DEBUG
	popq %rbx
    1309:	5b                   	pop    %rbx
	popq %r12
    130a:	41 5c                	pop    %r12
	popq %r13
    130c:	41 5d                	pop    %r13
	popq %r14
    130e:	41 5e                	pop    %r14
	popq %r15
    1310:	41 5f                	pop    %r15
#endif /* CONFIG_EXCEPTION_DEBUG */
	popq %rbp
    1312:	5d                   	pop    %rbp
	popq %rax
    1313:	58                   	pop    %rax
	popq %rcx
    1314:	59                   	pop    %rcx
	popq %rdx
    1315:	5a                   	pop    %rdx
	popq %rsi
    1316:	5e                   	pop    %rsi
	popq %rdi
    1317:	5f                   	pop    %rdi
	popq %r8
    1318:	41 58                	pop    %r8
	popq %r9
    131a:	41 59                	pop    %r9
	popq %r10
    131c:	41 5a                	pop    %r10
	fxrstor (%rsp)
    131e:	0f ae 0c 24          	fxrstor (%rsp)
	addq $X86_FXSAVE_SIZE, %rsp
    1322:	48 81 c4 00 02 00 00 	add    $0x200,%rsp
	popq %r11
    1329:	41 5b                	pop    %r11

	/* Drop the vector/err code pushed by the HW or EXCEPT_*() stub */
	add $16, %rsp
    132b:	48 83 c4 10          	add    $0x10,%rsp

#ifdef CONFIG_USERSPACE
	/* Swap GS register values if we are returning to user mode */
	testb $0x3, 8(%rsp)
    132f:	f6 44 24 08 03       	testb  $0x3,0x8(%rsp)
	jz 1f
    1334:	74 06                	je     133c <except+0xa3>
	cli
    1336:	fa                   	cli    
#ifdef CONFIG_X86_KPTI
	jmp z_x86_trampoline_to_user
    1337:	e9 c4 ec 0f 00       	jmpq   100000 <CONFIG_KERNEL_VM_OFFSET>
	swapgs
#endif /* CONFIG_X86_KPTI */
1:
#endif /* CONFIG_USERSPACE */

	iretq
    133c:	48 cf                	iretq  

000000000000133e <vector_0>:

#ifdef CONFIG_X86_KPTI
EXCEPT      ( 0, 7); EXCEPT      ( 1, 7); EXCEPT       (2, 6); EXCEPT      ( 3, 7)
    133e:	6a 00                	pushq  $0x0
    1340:	65 ff 34 25 54 00 00 	pushq  %gs:0x54
    1347:	00 
    1348:	6a 00                	pushq  $0x0
    134a:	e9 4a ff ff ff       	jmpq   1299 <except>

000000000000134f <vector_1>:
    134f:	6a 00                	pushq  $0x0
    1351:	65 ff 34 25 54 00 00 	pushq  %gs:0x54
    1358:	00 
    1359:	6a 01                	pushq  $0x1
    135b:	e9 39 ff ff ff       	jmpq   1299 <except>

0000000000001360 <vector_2>:
    1360:	6a 00                	pushq  $0x0
    1362:	65 ff 34 25 4c 00 00 	pushq  %gs:0x4c
    1369:	00 
    136a:	6a 02                	pushq  $0x2
    136c:	e9 28 ff ff ff       	jmpq   1299 <except>

0000000000001371 <vector_3>:
    1371:	6a 00                	pushq  $0x0
    1373:	65 ff 34 25 54 00 00 	pushq  %gs:0x54
    137a:	00 
    137b:	6a 03                	pushq  $0x3
    137d:	e9 17 ff ff ff       	jmpq   1299 <except>

0000000000001382 <vector_4>:
EXCEPT      ( 4, 7); EXCEPT      ( 5, 7); EXCEPT       (6, 7); EXCEPT      ( 7, 7)
    1382:	6a 00                	pushq  $0x0
    1384:	65 ff 34 25 54 00 00 	pushq  %gs:0x54
    138b:	00 
    138c:	6a 04                	pushq  $0x4
    138e:	e9 06 ff ff ff       	jmpq   1299 <except>

0000000000001393 <vector_5>:
    1393:	6a 00                	pushq  $0x0
    1395:	65 ff 34 25 54 00 00 	pushq  %gs:0x54
    139c:	00 
    139d:	6a 05                	pushq  $0x5
    139f:	e9 f5 fe ff ff       	jmpq   1299 <except>

00000000000013a4 <vector_6>:
    13a4:	6a 00                	pushq  $0x0
    13a6:	65 ff 34 25 54 00 00 	pushq  %gs:0x54
    13ad:	00 
    13ae:	6a 06                	pushq  $0x6
    13b0:	e9 e4 fe ff ff       	jmpq   1299 <except>

00000000000013b5 <vector_7>:
    13b5:	6a 00                	pushq  $0x0
    13b7:	65 ff 34 25 54 00 00 	pushq  %gs:0x54
    13be:	00 
    13bf:	6a 07                	pushq  $0x7
    13c1:	e9 d3 fe ff ff       	jmpq   1299 <except>

00000000000013c6 <vector_8>:
EXCEPT_CODE ( 8, 7); EXCEPT      ( 9, 7); EXCEPT_CODE (10, 7); EXCEPT_CODE (11, 7)
    13c6:	65 ff 34 25 54 00 00 	pushq  %gs:0x54
    13cd:	00 
    13ce:	6a 08                	pushq  $0x8
    13d0:	e9 c4 fe ff ff       	jmpq   1299 <except>

00000000000013d5 <vector_9>:
    13d5:	6a 00                	pushq  $0x0
    13d7:	65 ff 34 25 54 00 00 	pushq  %gs:0x54
    13de:	00 
    13df:	6a 09                	pushq  $0x9
    13e1:	e9 b3 fe ff ff       	jmpq   1299 <except>

00000000000013e6 <vector_10>:
    13e6:	65 ff 34 25 54 00 00 	pushq  %gs:0x54
    13ed:	00 
    13ee:	6a 0a                	pushq  $0xa
    13f0:	e9 a4 fe ff ff       	jmpq   1299 <except>

00000000000013f5 <vector_11>:
    13f5:	65 ff 34 25 54 00 00 	pushq  %gs:0x54
    13fc:	00 
    13fd:	6a 0b                	pushq  $0xb
    13ff:	e9 95 fe ff ff       	jmpq   1299 <except>

0000000000001404 <vector_12>:
EXCEPT_CODE (12, 7); EXCEPT_CODE (13, 7); EXCEPT_CODE (14, 7); EXCEPT      (15, 7)
    1404:	65 ff 34 25 54 00 00 	pushq  %gs:0x54
    140b:	00 
    140c:	6a 0c                	pushq  $0xc
    140e:	e9 86 fe ff ff       	jmpq   1299 <except>

0000000000001413 <vector_13>:
    1413:	65 ff 34 25 54 00 00 	pushq  %gs:0x54
    141a:	00 
    141b:	6a 0d                	pushq  $0xd
    141d:	e9 77 fe ff ff       	jmpq   1299 <except>

0000000000001422 <vector_14>:
    1422:	65 ff 34 25 54 00 00 	pushq  %gs:0x54
    1429:	00 
    142a:	6a 0e                	pushq  $0xe
    142c:	e9 68 fe ff ff       	jmpq   1299 <except>

0000000000001431 <vector_15>:
    1431:	6a 00                	pushq  $0x0
    1433:	65 ff 34 25 54 00 00 	pushq  %gs:0x54
    143a:	00 
    143b:	6a 0f                	pushq  $0xf
    143d:	e9 57 fe ff ff       	jmpq   1299 <except>

0000000000001442 <vector_16>:
EXCEPT      (16, 7); EXCEPT_CODE (17, 7); EXCEPT      (18, 7); EXCEPT      (19, 7)
    1442:	6a 00                	pushq  $0x0
    1444:	65 ff 34 25 54 00 00 	pushq  %gs:0x54
    144b:	00 
    144c:	6a 10                	pushq  $0x10
    144e:	e9 46 fe ff ff       	jmpq   1299 <except>

0000000000001453 <vector_17>:
    1453:	65 ff 34 25 54 00 00 	pushq  %gs:0x54
    145a:	00 
    145b:	6a 11                	pushq  $0x11
    145d:	e9 37 fe ff ff       	jmpq   1299 <except>

0000000000001462 <vector_18>:
    1462:	6a 00                	pushq  $0x0
    1464:	65 ff 34 25 54 00 00 	pushq  %gs:0x54
    146b:	00 
    146c:	6a 12                	pushq  $0x12
    146e:	e9 26 fe ff ff       	jmpq   1299 <except>

0000000000001473 <vector_19>:
    1473:	6a 00                	pushq  $0x0
    1475:	65 ff 34 25 54 00 00 	pushq  %gs:0x54
    147c:	00 
    147d:	6a 13                	pushq  $0x13
    147f:	e9 15 fe ff ff       	jmpq   1299 <except>

0000000000001484 <vector_20>:
EXCEPT      (20, 7); EXCEPT      (21, 7); EXCEPT      (22, 7); EXCEPT      (23, 7)
    1484:	6a 00                	pushq  $0x0
    1486:	65 ff 34 25 54 00 00 	pushq  %gs:0x54
    148d:	00 
    148e:	6a 14                	pushq  $0x14
    1490:	e9 04 fe ff ff       	jmpq   1299 <except>

0000000000001495 <vector_21>:
    1495:	6a 00                	pushq  $0x0
    1497:	65 ff 34 25 54 00 00 	pushq  %gs:0x54
    149e:	00 
    149f:	6a 15                	pushq  $0x15
    14a1:	e9 f3 fd ff ff       	jmpq   1299 <except>

00000000000014a6 <vector_22>:
    14a6:	6a 00                	pushq  $0x0
    14a8:	65 ff 34 25 54 00 00 	pushq  %gs:0x54
    14af:	00 
    14b0:	6a 16                	pushq  $0x16
    14b2:	e9 e2 fd ff ff       	jmpq   1299 <except>

00000000000014b7 <vector_23>:
    14b7:	6a 00                	pushq  $0x0
    14b9:	65 ff 34 25 54 00 00 	pushq  %gs:0x54
    14c0:	00 
    14c1:	6a 17                	pushq  $0x17
    14c3:	e9 d1 fd ff ff       	jmpq   1299 <except>

00000000000014c8 <vector_24>:
EXCEPT      (24, 7); EXCEPT      (25, 7); EXCEPT      (26, 7); EXCEPT      (27, 7)
    14c8:	6a 00                	pushq  $0x0
    14ca:	65 ff 34 25 54 00 00 	pushq  %gs:0x54
    14d1:	00 
    14d2:	6a 18                	pushq  $0x18
    14d4:	e9 c0 fd ff ff       	jmpq   1299 <except>

00000000000014d9 <vector_25>:
    14d9:	6a 00                	pushq  $0x0
    14db:	65 ff 34 25 54 00 00 	pushq  %gs:0x54
    14e2:	00 
    14e3:	6a 19                	pushq  $0x19
    14e5:	e9 af fd ff ff       	jmpq   1299 <except>

00000000000014ea <vector_26>:
    14ea:	6a 00                	pushq  $0x0
    14ec:	65 ff 34 25 54 00 00 	pushq  %gs:0x54
    14f3:	00 
    14f4:	6a 1a                	pushq  $0x1a
    14f6:	e9 9e fd ff ff       	jmpq   1299 <except>

00000000000014fb <vector_27>:
    14fb:	6a 00                	pushq  $0x0
    14fd:	65 ff 34 25 54 00 00 	pushq  %gs:0x54
    1504:	00 
    1505:	6a 1b                	pushq  $0x1b
    1507:	e9 8d fd ff ff       	jmpq   1299 <except>

000000000000150c <vector_28>:
EXCEPT      (28, 7); EXCEPT      (29, 7); EXCEPT      (30, 7); EXCEPT      (31, 7)
    150c:	6a 00                	pushq  $0x0
    150e:	65 ff 34 25 54 00 00 	pushq  %gs:0x54
    1515:	00 
    1516:	6a 1c                	pushq  $0x1c
    1518:	e9 7c fd ff ff       	jmpq   1299 <except>

000000000000151d <vector_29>:
    151d:	6a 00                	pushq  $0x0
    151f:	65 ff 34 25 54 00 00 	pushq  %gs:0x54
    1526:	00 
    1527:	6a 1d                	pushq  $0x1d
    1529:	e9 6b fd ff ff       	jmpq   1299 <except>

000000000000152e <vector_30>:
    152e:	6a 00                	pushq  $0x0
    1530:	65 ff 34 25 54 00 00 	pushq  %gs:0x54
    1537:	00 
    1538:	6a 1e                	pushq  $0x1e
    153a:	e9 5a fd ff ff       	jmpq   1299 <except>

000000000000153f <vector_31>:
    153f:	6a 00                	pushq  $0x0
    1541:	65 ff 34 25 54 00 00 	pushq  %gs:0x54
    1548:	00 
    1549:	6a 1f                	pushq  $0x1f
    154b:	e9 49 fd ff ff       	jmpq   1299 <except>

0000000000001550 <vector_Z_X86_OOPS_VECTOR>:

/* Vector reserved for handling a kernel oops; treat as an exception
 * and not an interrupt
 */
EXCEPT(Z_X86_OOPS_VECTOR, 7);
    1550:	6a 00                	pushq  $0x0
    1552:	65 ff 34 25 54 00 00 	pushq  %gs:0x54
    1559:	00 
    155a:	6a 20                	pushq  $0x20
    155c:	e9 38 fd ff ff       	jmpq   1299 <except>

0000000000001561 <irq>:

.globl x86_irq_funcs	/* see irq_manage.c .. */
.globl x86_irq_args	/* .. for these definitions */

irq:
	pushq %rsi
    1561:	56                   	push   %rsi

#ifdef CONFIG_USERSPACE
	/* Swap GS register values if we came in from user mode */
	testb $0x3, 24(%rsp)
    1562:	f6 44 24 18 03       	testb  $0x3,0x18(%rsp)
	jz 1f
    1567:	74 0d                	je     1576 <irq+0x15>
	swapgs
    1569:	0f 01 f8             	swapgs 
#ifdef CONFIG_X86_KPTI
	/* Load kernel's page table. NOTE: presumes phys=virt */
	movq $z_x86_kernel_ptables, %rsi
    156c:	48 c7 c6 00 40 6e 00 	mov    $0x6e4000,%rsi
	movq %rsi, %cr3
    1573:	0f 22 de             	mov    %rsi,%cr3
#endif /* CONFIG_X86_KPTI */
1:
#ifdef CONFIG_X86_BOUNDS_CHECK_BYPASS_MITIGATION
	/* swapgs variant of Spectre V1. Disable speculation past this point */
	lfence
    1576:	0f ae e8             	lfence 
#endif /* CONFIG_X86_BOUNDS_CHECK_BYPASS_MITIGATION */
#ifdef CONFIG_X86_KPTI
	/* Save old trampoline stack pointer in RSI */
	movq %rsp, %rsi
    1579:	48 89 e6             	mov    %rsp,%rsi

	/* Switch to the interrupt stack stack */
	movq %gs:__x86_tss64_t_ist1_OFFSET, %rsp
    157c:	65 48 8b 24 25 24 00 	mov    %gs:0x24,%rsp
    1583:	00 00 

	/* Transplant trampoline stack contents */
	pushq 48(%rsi)	/* SS */
    1585:	ff 76 30             	pushq  0x30(%rsi)
	pushq 40(%rsi)	/* RSP */
    1588:	ff 76 28             	pushq  0x28(%rsi)
	pushq 32(%rsi)	/* RFLAGS */
    158b:	ff 76 20             	pushq  0x20(%rsi)
	pushq 24(%rsi)	/* CS */
    158e:	ff 76 18             	pushq  0x18(%rsi)
	pushq 16(%rsi)	/* RIP */
    1591:	ff 76 10             	pushq  0x10(%rsi)
	pushq 8(%rsi)	/* Vector */
    1594:	ff 76 08             	pushq  0x8(%rsi)
	pushq (%rsi)	/* Stashed RSI value */
    1597:	ff 36                	pushq  (%rsi)
	movq $0, (%rsi) /* Cover our tracks, stashed RSI might be sensitive */
    1599:	48 c7 06 00 00 00 00 	movq   $0x0,(%rsi)
#endif /* CONFIG_X86_KPTI */
#endif /* CONFIG_USERSPACE */

	movq %gs:__x86_tss64_t_cpu_OFFSET, %rsi
    15a0:	65 48 8b 34 25 68 00 	mov    %gs:0x68,%rsi
    15a7:	00 00 
	 * Bump the IRQ nesting count and move to the next IRQ stack.
	 * That's sufficient to safely re-enable interrupts, so if we
	 * haven't reached the maximum nesting depth yet, do it.
	 */

	incl ___cpu_t_nested_OFFSET(%rsi)
    15a9:	ff 06                	incl   (%rsi)
	subq $CONFIG_ISR_SUBSTACK_SIZE, %gs:__x86_tss64_t_ist1_OFFSET
    15ab:	65 48 81 2c 25 24 00 	subq   $0x1000,%gs:0x24
    15b2:	00 00 00 10 00 00 
	cmpl $CONFIG_ISR_DEPTH, ___cpu_t_nested_OFFSET(%rsi)
    15b8:	83 3e 04             	cmpl   $0x4,(%rsi)
	jz 1f
    15bb:	74 01                	je     15be <irq+0x5d>
	sti
    15bd:	fb                   	sti    
1:	cmpl $1, ___cpu_t_nested_OFFSET(%rsi)
    15be:	83 3e 01             	cmpl   $0x1,(%rsi)
	je irq_enter_unnested
    15c1:	74 25                	je     15e8 <irq_enter_unnested>

00000000000015c3 <irq_enter_nested>:
	 * note that the final value of RSP must be 16-byte aligned here,
	 * both to satisfy FXSAVE/FXRSTOR but also to honor the C ABI.
	 */

irq_enter_nested: /* Nested IRQ: dump register state to stack. */
	pushq %rcx
    15c3:	51                   	push   %rcx
	movq 16(%rsp), %rcx /* RCX = vector */
    15c4:	48 8b 4c 24 10       	mov    0x10(%rsp),%rcx
	movq %rax, 16(%rsp) /* looks like we pushed RAX, not the vector */
    15c9:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
	pushq %rdx
    15ce:	52                   	push   %rdx
	pushq %rdi
    15cf:	57                   	push   %rdi
	pushq %r8
    15d0:	41 50                	push   %r8
	pushq %r9
    15d2:	41 51                	push   %r9
	pushq %r10
    15d4:	41 52                	push   %r10
	pushq %r11
    15d6:	41 53                	push   %r11
	subq $X86_FXSAVE_SIZE, %rsp
    15d8:	48 81 ec 00 02 00 00 	sub    $0x200,%rsp
	fxsave (%rsp)
    15df:	0f ae 04 24          	fxsave (%rsp)
	jmp irq_dispatch
    15e3:	e9 90 00 00 00       	jmpq   1678 <irq_dispatch>

00000000000015e8 <irq_enter_unnested>:

irq_enter_unnested: /* Not nested: dump state to thread struct for __resume */
	movq ___cpu_t_current_OFFSET(%rsi), %rsi
    15e8:	48 8b 76 10          	mov    0x10(%rsi),%rsi
	orb $X86_THREAD_FLAG_ALL, _thread_offset_to_flags(%rsi)
    15ec:	80 8e 70 01 00 00 01 	orb    $0x1,0x170(%rsi)
	fxsave _thread_offset_to_sse(%rsi)
    15f3:	0f ae 86 e0 01 00 00 	fxsave 0x1e0(%rsi)
	movq %rbx, _thread_offset_to_rbx(%rsi)
    15fa:	48 89 5e 50          	mov    %rbx,0x50(%rsi)
	movq %rbp, _thread_offset_to_rbp(%rsi)
    15fe:	48 89 6e 58          	mov    %rbp,0x58(%rsi)
	movq %r12, _thread_offset_to_r12(%rsi)
    1602:	4c 89 66 60          	mov    %r12,0x60(%rsi)
	movq %r13, _thread_offset_to_r13(%rsi)
    1606:	4c 89 6e 68          	mov    %r13,0x68(%rsi)
	movq %r14, _thread_offset_to_r14(%rsi)
    160a:	4c 89 76 70          	mov    %r14,0x70(%rsi)
	movq %r15, _thread_offset_to_r15(%rsi)
    160e:	4c 89 7e 78          	mov    %r15,0x78(%rsi)
	movq %rax, _thread_offset_to_rax(%rsi)
    1612:	48 89 86 98 01 00 00 	mov    %rax,0x198(%rsi)
	movq %rcx, _thread_offset_to_rcx(%rsi)
    1619:	48 89 8e a0 01 00 00 	mov    %rcx,0x1a0(%rsi)
	movq %rdx, _thread_offset_to_rdx(%rsi)
    1620:	48 89 96 a8 01 00 00 	mov    %rdx,0x1a8(%rsi)
	movq %rdi, _thread_offset_to_rdi(%rsi)
    1627:	48 89 be b8 01 00 00 	mov    %rdi,0x1b8(%rsi)
	movq %r8, _thread_offset_to_r8(%rsi)
    162e:	4c 89 86 c0 01 00 00 	mov    %r8,0x1c0(%rsi)
	movq %r9, _thread_offset_to_r9(%rsi)
    1635:	4c 89 8e c8 01 00 00 	mov    %r9,0x1c8(%rsi)
	movq %r10, _thread_offset_to_r10(%rsi)
    163c:	4c 89 96 d0 01 00 00 	mov    %r10,0x1d0(%rsi)
	movq %r11, _thread_offset_to_r11(%rsi)
    1643:	4c 89 9e d8 01 00 00 	mov    %r11,0x1d8(%rsi)
	popq %rax /* RSI */
    164a:	58                   	pop    %rax
	movq %rax, _thread_offset_to_rsi(%rsi)
    164b:	48 89 86 b0 01 00 00 	mov    %rax,0x1b0(%rsi)
	popq %rcx /* vector number */
    1652:	59                   	pop    %rcx
	popq %rax /* RIP */
    1653:	58                   	pop    %rax
	movq %rax, _thread_offset_to_rip(%rsi)
    1654:	48 89 86 80 00 00 00 	mov    %rax,0x80(%rsi)
	popq %rax /* CS */
    165b:	58                   	pop    %rax
#ifdef CONFIG_USERSPACE
	movq %rax, _thread_offset_to_cs(%rsi)
    165c:	48 89 86 90 01 00 00 	mov    %rax,0x190(%rsi)
#endif
	popq %rax /* RFLAGS */
    1663:	58                   	pop    %rax
	movq %rax, _thread_offset_to_rflags(%rsi)
    1664:	48 89 86 88 00 00 00 	mov    %rax,0x88(%rsi)
	popq %rax /* RSP */
    166b:	58                   	pop    %rax
	movq %rax, _thread_offset_to_rsp(%rsi)
    166c:	48 89 46 48          	mov    %rax,0x48(%rsi)
	popq %rax /* SS */
    1670:	58                   	pop    %rax
#ifdef CONFIG_USERSPACE
	movq %rax, _thread_offset_to_ss(%rsi)
    1671:	48 89 86 88 01 00 00 	mov    %rax,0x188(%rsi)

0000000000001678 <irq_dispatch>:
#endif

irq_dispatch:
	movq x86_irq_funcs(,%rcx,8), %rax
    1678:	48 8b 04 cd 20 74 12 	mov    0x127420(,%rcx,8),%rax
    167f:	00 
	movq x86_irq_args(,%rcx,8), %rdi
    1680:	48 8b 3c cd 20 6d 12 	mov    0x126d20(,%rcx,8),%rdi
    1687:	00 
	call *%rax
    1688:	ff d0                	callq  *%rax

	xorq %rax, %rax
    168a:	48 31 c0             	xor    %rax,%rax
#ifdef CONFIG_X2APIC
	xorl %edx, %edx
    168d:	31 d2                	xor    %edx,%edx
	movl $(X86_X2APIC_BASE_MSR + (LOAPIC_EOI >> 4)), %ecx
    168f:	b9 0b 08 00 00       	mov    $0x80b,%ecx
	wrmsr
    1694:	0f 30                	wrmsr  
#else /* xAPIC */
	movq z_loapic_regs, %rdx
	movl %eax, LOAPIC_EOI(%rdx)
#endif /* CONFIG_X2APIC */

	movq %gs:__x86_tss64_t_cpu_OFFSET, %rsi
    1696:	65 48 8b 34 25 68 00 	mov    %gs:0x68,%rsi
    169d:	00 00 

	cli
    169f:	fa                   	cli    
	addq $CONFIG_ISR_SUBSTACK_SIZE, %gs:__x86_tss64_t_ist1_OFFSET
    16a0:	65 48 81 04 25 24 00 	addq   $0x1000,%gs:0x24
    16a7:	00 00 00 10 00 00 
	decl ___cpu_t_nested_OFFSET(%rsi)
    16ad:	ff 0e                	decl   (%rsi)
	jnz irq_exit_nested
    16af:	75 11                	jne    16c2 <irq_exit_nested>

	/* not nested; ask the scheduler who's up next and resume it */

	movq ___cpu_t_current_OFFSET(%rsi), %rdi
    16b1:	48 8b 7e 10          	mov    0x10(%rsi),%rdi
	call z_get_next_switch_handle
    16b5:	e8 8b f8 10 00       	callq  110f45 <z_get_next_switch_handle>
	movq %rax, %rdi
    16ba:	48 89 c7             	mov    %rax,%rdi
	jmp __resume
    16bd:	e9 22 fb ff ff       	jmpq   11e4 <__resume>

00000000000016c2 <irq_exit_nested>:

irq_exit_nested:
	fxrstor (%rsp)
    16c2:	0f ae 0c 24          	fxrstor (%rsp)
	addq $X86_FXSAVE_SIZE, %rsp
    16c6:	48 81 c4 00 02 00 00 	add    $0x200,%rsp
	popq %r11
    16cd:	41 5b                	pop    %r11
	popq %r10
    16cf:	41 5a                	pop    %r10
	popq %r9
    16d1:	41 59                	pop    %r9
	popq %r8
    16d3:	41 58                	pop    %r8
	popq %rdi
    16d5:	5f                   	pop    %rdi
	popq %rdx
    16d6:	5a                   	pop    %rdx
	popq %rcx
    16d7:	59                   	pop    %rcx
	popq %rsi
    16d8:	5e                   	pop    %rsi
	popq %rax
    16d9:	58                   	pop    %rax
	iretq
    16da:	48 cf                	iretq  

00000000000016dc <vector_33>:

#define IRQ(nr) vector_ ## nr: pushq $(nr - IV_IRQS); jmp irq

IRQ( 33); IRQ( 34); IRQ( 35); IRQ( 36); IRQ( 37); IRQ( 38); IRQ( 39)
    16dc:	6a 01                	pushq  $0x1
    16de:	e9 7e fe ff ff       	jmpq   1561 <irq>

00000000000016e3 <vector_34>:
    16e3:	6a 02                	pushq  $0x2
    16e5:	e9 77 fe ff ff       	jmpq   1561 <irq>

00000000000016ea <vector_35>:
    16ea:	6a 03                	pushq  $0x3
    16ec:	e9 70 fe ff ff       	jmpq   1561 <irq>

00000000000016f1 <vector_36>:
    16f1:	6a 04                	pushq  $0x4
    16f3:	e9 69 fe ff ff       	jmpq   1561 <irq>

00000000000016f8 <vector_37>:
    16f8:	6a 05                	pushq  $0x5
    16fa:	e9 62 fe ff ff       	jmpq   1561 <irq>

00000000000016ff <vector_38>:
    16ff:	6a 06                	pushq  $0x6
    1701:	e9 5b fe ff ff       	jmpq   1561 <irq>

0000000000001706 <vector_39>:
    1706:	6a 07                	pushq  $0x7
    1708:	e9 54 fe ff ff       	jmpq   1561 <irq>

000000000000170d <vector_40>:
IRQ( 40); IRQ( 41); IRQ( 42); IRQ( 43); IRQ( 44); IRQ( 45); IRQ( 46); IRQ( 47)
    170d:	6a 08                	pushq  $0x8
    170f:	e9 4d fe ff ff       	jmpq   1561 <irq>

0000000000001714 <vector_41>:
    1714:	6a 09                	pushq  $0x9
    1716:	e9 46 fe ff ff       	jmpq   1561 <irq>

000000000000171b <vector_42>:
    171b:	6a 0a                	pushq  $0xa
    171d:	e9 3f fe ff ff       	jmpq   1561 <irq>

0000000000001722 <vector_43>:
    1722:	6a 0b                	pushq  $0xb
    1724:	e9 38 fe ff ff       	jmpq   1561 <irq>

0000000000001729 <vector_44>:
    1729:	6a 0c                	pushq  $0xc
    172b:	e9 31 fe ff ff       	jmpq   1561 <irq>

0000000000001730 <vector_45>:
    1730:	6a 0d                	pushq  $0xd
    1732:	e9 2a fe ff ff       	jmpq   1561 <irq>

0000000000001737 <vector_46>:
    1737:	6a 0e                	pushq  $0xe
    1739:	e9 23 fe ff ff       	jmpq   1561 <irq>

000000000000173e <vector_47>:
    173e:	6a 0f                	pushq  $0xf
    1740:	e9 1c fe ff ff       	jmpq   1561 <irq>

0000000000001745 <vector_48>:
IRQ( 48); IRQ( 49); IRQ( 50); IRQ( 51); IRQ( 52); IRQ( 53); IRQ( 54); IRQ( 55)
    1745:	6a 10                	pushq  $0x10
    1747:	e9 15 fe ff ff       	jmpq   1561 <irq>

000000000000174c <vector_49>:
    174c:	6a 11                	pushq  $0x11
    174e:	e9 0e fe ff ff       	jmpq   1561 <irq>

0000000000001753 <vector_50>:
    1753:	6a 12                	pushq  $0x12
    1755:	e9 07 fe ff ff       	jmpq   1561 <irq>

000000000000175a <vector_51>:
    175a:	6a 13                	pushq  $0x13
    175c:	e9 00 fe ff ff       	jmpq   1561 <irq>

0000000000001761 <vector_52>:
    1761:	6a 14                	pushq  $0x14
    1763:	e9 f9 fd ff ff       	jmpq   1561 <irq>

0000000000001768 <vector_53>:
    1768:	6a 15                	pushq  $0x15
    176a:	e9 f2 fd ff ff       	jmpq   1561 <irq>

000000000000176f <vector_54>:
    176f:	6a 16                	pushq  $0x16
    1771:	e9 eb fd ff ff       	jmpq   1561 <irq>

0000000000001776 <vector_55>:
    1776:	6a 17                	pushq  $0x17
    1778:	e9 e4 fd ff ff       	jmpq   1561 <irq>

000000000000177d <vector_56>:
IRQ( 56); IRQ( 57); IRQ( 58); IRQ( 59); IRQ( 60); IRQ( 61); IRQ( 62); IRQ( 63)
    177d:	6a 18                	pushq  $0x18
    177f:	e9 dd fd ff ff       	jmpq   1561 <irq>

0000000000001784 <vector_57>:
    1784:	6a 19                	pushq  $0x19
    1786:	e9 d6 fd ff ff       	jmpq   1561 <irq>

000000000000178b <vector_58>:
    178b:	6a 1a                	pushq  $0x1a
    178d:	e9 cf fd ff ff       	jmpq   1561 <irq>

0000000000001792 <vector_59>:
    1792:	6a 1b                	pushq  $0x1b
    1794:	e9 c8 fd ff ff       	jmpq   1561 <irq>

0000000000001799 <vector_60>:
    1799:	6a 1c                	pushq  $0x1c
    179b:	e9 c1 fd ff ff       	jmpq   1561 <irq>

00000000000017a0 <vector_61>:
    17a0:	6a 1d                	pushq  $0x1d
    17a2:	e9 ba fd ff ff       	jmpq   1561 <irq>

00000000000017a7 <vector_62>:
    17a7:	6a 1e                	pushq  $0x1e
    17a9:	e9 b3 fd ff ff       	jmpq   1561 <irq>

00000000000017ae <vector_63>:
    17ae:	6a 1f                	pushq  $0x1f
    17b0:	e9 ac fd ff ff       	jmpq   1561 <irq>

00000000000017b5 <vector_64>:
IRQ( 64); IRQ( 65); IRQ( 66); IRQ( 67); IRQ( 68); IRQ( 69); IRQ( 70); IRQ( 71)
    17b5:	6a 20                	pushq  $0x20
    17b7:	e9 a5 fd ff ff       	jmpq   1561 <irq>

00000000000017bc <vector_65>:
    17bc:	6a 21                	pushq  $0x21
    17be:	e9 9e fd ff ff       	jmpq   1561 <irq>

00000000000017c3 <vector_66>:
    17c3:	6a 22                	pushq  $0x22
    17c5:	e9 97 fd ff ff       	jmpq   1561 <irq>

00000000000017ca <vector_67>:
    17ca:	6a 23                	pushq  $0x23
    17cc:	e9 90 fd ff ff       	jmpq   1561 <irq>

00000000000017d1 <vector_68>:
    17d1:	6a 24                	pushq  $0x24
    17d3:	e9 89 fd ff ff       	jmpq   1561 <irq>

00000000000017d8 <vector_69>:
    17d8:	6a 25                	pushq  $0x25
    17da:	e9 82 fd ff ff       	jmpq   1561 <irq>

00000000000017df <vector_70>:
    17df:	6a 26                	pushq  $0x26
    17e1:	e9 7b fd ff ff       	jmpq   1561 <irq>

00000000000017e6 <vector_71>:
    17e6:	6a 27                	pushq  $0x27
    17e8:	e9 74 fd ff ff       	jmpq   1561 <irq>

00000000000017ed <vector_72>:
IRQ( 72); IRQ( 73); IRQ( 74); IRQ( 75); IRQ( 76); IRQ( 77); IRQ( 78); IRQ( 79)
    17ed:	6a 28                	pushq  $0x28
    17ef:	e9 6d fd ff ff       	jmpq   1561 <irq>

00000000000017f4 <vector_73>:
    17f4:	6a 29                	pushq  $0x29
    17f6:	e9 66 fd ff ff       	jmpq   1561 <irq>

00000000000017fb <vector_74>:
    17fb:	6a 2a                	pushq  $0x2a
    17fd:	e9 5f fd ff ff       	jmpq   1561 <irq>

0000000000001802 <vector_75>:
    1802:	6a 2b                	pushq  $0x2b
    1804:	e9 58 fd ff ff       	jmpq   1561 <irq>

0000000000001809 <vector_76>:
    1809:	6a 2c                	pushq  $0x2c
    180b:	e9 51 fd ff ff       	jmpq   1561 <irq>

0000000000001810 <vector_77>:
    1810:	6a 2d                	pushq  $0x2d
    1812:	e9 4a fd ff ff       	jmpq   1561 <irq>

0000000000001817 <vector_78>:
    1817:	6a 2e                	pushq  $0x2e
    1819:	e9 43 fd ff ff       	jmpq   1561 <irq>

000000000000181e <vector_79>:
    181e:	6a 2f                	pushq  $0x2f
    1820:	e9 3c fd ff ff       	jmpq   1561 <irq>

0000000000001825 <vector_80>:
IRQ( 80); IRQ( 81); IRQ( 82); IRQ( 83); IRQ( 84); IRQ( 85); IRQ( 86); IRQ( 87)
    1825:	6a 30                	pushq  $0x30
    1827:	e9 35 fd ff ff       	jmpq   1561 <irq>

000000000000182c <vector_81>:
    182c:	6a 31                	pushq  $0x31
    182e:	e9 2e fd ff ff       	jmpq   1561 <irq>

0000000000001833 <vector_82>:
    1833:	6a 32                	pushq  $0x32
    1835:	e9 27 fd ff ff       	jmpq   1561 <irq>

000000000000183a <vector_83>:
    183a:	6a 33                	pushq  $0x33
    183c:	e9 20 fd ff ff       	jmpq   1561 <irq>

0000000000001841 <vector_84>:
    1841:	6a 34                	pushq  $0x34
    1843:	e9 19 fd ff ff       	jmpq   1561 <irq>

0000000000001848 <vector_85>:
    1848:	6a 35                	pushq  $0x35
    184a:	e9 12 fd ff ff       	jmpq   1561 <irq>

000000000000184f <vector_86>:
    184f:	6a 36                	pushq  $0x36
    1851:	e9 0b fd ff ff       	jmpq   1561 <irq>

0000000000001856 <vector_87>:
    1856:	6a 37                	pushq  $0x37
    1858:	e9 04 fd ff ff       	jmpq   1561 <irq>

000000000000185d <vector_88>:
IRQ( 88); IRQ( 89); IRQ( 90); IRQ( 91); IRQ( 92); IRQ( 93); IRQ( 94); IRQ( 95)
    185d:	6a 38                	pushq  $0x38
    185f:	e9 fd fc ff ff       	jmpq   1561 <irq>

0000000000001864 <vector_89>:
    1864:	6a 39                	pushq  $0x39
    1866:	e9 f6 fc ff ff       	jmpq   1561 <irq>

000000000000186b <vector_90>:
    186b:	6a 3a                	pushq  $0x3a
    186d:	e9 ef fc ff ff       	jmpq   1561 <irq>

0000000000001872 <vector_91>:
    1872:	6a 3b                	pushq  $0x3b
    1874:	e9 e8 fc ff ff       	jmpq   1561 <irq>

0000000000001879 <vector_92>:
    1879:	6a 3c                	pushq  $0x3c
    187b:	e9 e1 fc ff ff       	jmpq   1561 <irq>

0000000000001880 <vector_93>:
    1880:	6a 3d                	pushq  $0x3d
    1882:	e9 da fc ff ff       	jmpq   1561 <irq>

0000000000001887 <vector_94>:
    1887:	6a 3e                	pushq  $0x3e
    1889:	e9 d3 fc ff ff       	jmpq   1561 <irq>

000000000000188e <vector_95>:
    188e:	6a 3f                	pushq  $0x3f
    1890:	e9 cc fc ff ff       	jmpq   1561 <irq>

0000000000001895 <vector_96>:
IRQ( 96); IRQ( 97); IRQ( 98); IRQ( 99); IRQ(100); IRQ(101); IRQ(102); IRQ(103)
    1895:	6a 40                	pushq  $0x40
    1897:	e9 c5 fc ff ff       	jmpq   1561 <irq>

000000000000189c <vector_97>:
    189c:	6a 41                	pushq  $0x41
    189e:	e9 be fc ff ff       	jmpq   1561 <irq>

00000000000018a3 <vector_98>:
    18a3:	6a 42                	pushq  $0x42
    18a5:	e9 b7 fc ff ff       	jmpq   1561 <irq>

00000000000018aa <vector_99>:
    18aa:	6a 43                	pushq  $0x43
    18ac:	e9 b0 fc ff ff       	jmpq   1561 <irq>

00000000000018b1 <vector_100>:
    18b1:	6a 44                	pushq  $0x44
    18b3:	e9 a9 fc ff ff       	jmpq   1561 <irq>

00000000000018b8 <vector_101>:
    18b8:	6a 45                	pushq  $0x45
    18ba:	e9 a2 fc ff ff       	jmpq   1561 <irq>

00000000000018bf <vector_102>:
    18bf:	6a 46                	pushq  $0x46
    18c1:	e9 9b fc ff ff       	jmpq   1561 <irq>

00000000000018c6 <vector_103>:
    18c6:	6a 47                	pushq  $0x47
    18c8:	e9 94 fc ff ff       	jmpq   1561 <irq>

00000000000018cd <vector_104>:
IRQ(104); IRQ(105); IRQ(106); IRQ(107); IRQ(108); IRQ(109); IRQ(110); IRQ(111)
    18cd:	6a 48                	pushq  $0x48
    18cf:	e9 8d fc ff ff       	jmpq   1561 <irq>

00000000000018d4 <vector_105>:
    18d4:	6a 49                	pushq  $0x49
    18d6:	e9 86 fc ff ff       	jmpq   1561 <irq>

00000000000018db <vector_106>:
    18db:	6a 4a                	pushq  $0x4a
    18dd:	e9 7f fc ff ff       	jmpq   1561 <irq>

00000000000018e2 <vector_107>:
    18e2:	6a 4b                	pushq  $0x4b
    18e4:	e9 78 fc ff ff       	jmpq   1561 <irq>

00000000000018e9 <vector_108>:
    18e9:	6a 4c                	pushq  $0x4c
    18eb:	e9 71 fc ff ff       	jmpq   1561 <irq>

00000000000018f0 <vector_109>:
    18f0:	6a 4d                	pushq  $0x4d
    18f2:	e9 6a fc ff ff       	jmpq   1561 <irq>

00000000000018f7 <vector_110>:
    18f7:	6a 4e                	pushq  $0x4e
    18f9:	e9 63 fc ff ff       	jmpq   1561 <irq>

00000000000018fe <vector_111>:
    18fe:	6a 4f                	pushq  $0x4f
    1900:	e9 5c fc ff ff       	jmpq   1561 <irq>

0000000000001905 <vector_112>:
IRQ(112); IRQ(113); IRQ(114); IRQ(115); IRQ(116); IRQ(117); IRQ(118); IRQ(119)
    1905:	6a 50                	pushq  $0x50
    1907:	e9 55 fc ff ff       	jmpq   1561 <irq>

000000000000190c <vector_113>:
    190c:	6a 51                	pushq  $0x51
    190e:	e9 4e fc ff ff       	jmpq   1561 <irq>

0000000000001913 <vector_114>:
    1913:	6a 52                	pushq  $0x52
    1915:	e9 47 fc ff ff       	jmpq   1561 <irq>

000000000000191a <vector_115>:
    191a:	6a 53                	pushq  $0x53
    191c:	e9 40 fc ff ff       	jmpq   1561 <irq>

0000000000001921 <vector_116>:
    1921:	6a 54                	pushq  $0x54
    1923:	e9 39 fc ff ff       	jmpq   1561 <irq>

0000000000001928 <vector_117>:
    1928:	6a 55                	pushq  $0x55
    192a:	e9 32 fc ff ff       	jmpq   1561 <irq>

000000000000192f <vector_118>:
    192f:	6a 56                	pushq  $0x56
    1931:	e9 2b fc ff ff       	jmpq   1561 <irq>

0000000000001936 <vector_119>:
    1936:	6a 57                	pushq  $0x57
    1938:	e9 24 fc ff ff       	jmpq   1561 <irq>

000000000000193d <vector_120>:
IRQ(120); IRQ(121); IRQ(122); IRQ(123); IRQ(124); IRQ(125); IRQ(126); IRQ(127)
    193d:	6a 58                	pushq  $0x58
    193f:	e9 1d fc ff ff       	jmpq   1561 <irq>

0000000000001944 <vector_121>:
    1944:	6a 59                	pushq  $0x59
    1946:	e9 16 fc ff ff       	jmpq   1561 <irq>

000000000000194b <vector_122>:
    194b:	6a 5a                	pushq  $0x5a
    194d:	e9 0f fc ff ff       	jmpq   1561 <irq>

0000000000001952 <vector_123>:
    1952:	6a 5b                	pushq  $0x5b
    1954:	e9 08 fc ff ff       	jmpq   1561 <irq>

0000000000001959 <vector_124>:
    1959:	6a 5c                	pushq  $0x5c
    195b:	e9 01 fc ff ff       	jmpq   1561 <irq>

0000000000001960 <vector_125>:
    1960:	6a 5d                	pushq  $0x5d
    1962:	e9 fa fb ff ff       	jmpq   1561 <irq>

0000000000001967 <vector_126>:
    1967:	6a 5e                	pushq  $0x5e
    1969:	e9 f3 fb ff ff       	jmpq   1561 <irq>

000000000000196e <vector_127>:
    196e:	6a 5f                	pushq  $0x5f
    1970:	e9 ec fb ff ff       	jmpq   1561 <irq>

0000000000001975 <vector_128>:
IRQ(128); IRQ(129); IRQ(130); IRQ(131); IRQ(132); IRQ(133); IRQ(134); IRQ(135)
    1975:	6a 60                	pushq  $0x60
    1977:	e9 e5 fb ff ff       	jmpq   1561 <irq>

000000000000197c <vector_129>:
    197c:	6a 61                	pushq  $0x61
    197e:	e9 de fb ff ff       	jmpq   1561 <irq>

0000000000001983 <vector_130>:
    1983:	6a 62                	pushq  $0x62
    1985:	e9 d7 fb ff ff       	jmpq   1561 <irq>

000000000000198a <vector_131>:
    198a:	6a 63                	pushq  $0x63
    198c:	e9 d0 fb ff ff       	jmpq   1561 <irq>

0000000000001991 <vector_132>:
    1991:	6a 64                	pushq  $0x64
    1993:	e9 c9 fb ff ff       	jmpq   1561 <irq>

0000000000001998 <vector_133>:
    1998:	6a 65                	pushq  $0x65
    199a:	e9 c2 fb ff ff       	jmpq   1561 <irq>

000000000000199f <vector_134>:
    199f:	6a 66                	pushq  $0x66
    19a1:	e9 bb fb ff ff       	jmpq   1561 <irq>

00000000000019a6 <vector_135>:
    19a6:	6a 67                	pushq  $0x67
    19a8:	e9 b4 fb ff ff       	jmpq   1561 <irq>

00000000000019ad <vector_136>:
IRQ(136); IRQ(137); IRQ(138); IRQ(139); IRQ(140); IRQ(141); IRQ(142); IRQ(143)
    19ad:	6a 68                	pushq  $0x68
    19af:	e9 ad fb ff ff       	jmpq   1561 <irq>

00000000000019b4 <vector_137>:
    19b4:	6a 69                	pushq  $0x69
    19b6:	e9 a6 fb ff ff       	jmpq   1561 <irq>

00000000000019bb <vector_138>:
    19bb:	6a 6a                	pushq  $0x6a
    19bd:	e9 9f fb ff ff       	jmpq   1561 <irq>

00000000000019c2 <vector_139>:
    19c2:	6a 6b                	pushq  $0x6b
    19c4:	e9 98 fb ff ff       	jmpq   1561 <irq>

00000000000019c9 <vector_140>:
    19c9:	6a 6c                	pushq  $0x6c
    19cb:	e9 91 fb ff ff       	jmpq   1561 <irq>

00000000000019d0 <vector_141>:
    19d0:	6a 6d                	pushq  $0x6d
    19d2:	e9 8a fb ff ff       	jmpq   1561 <irq>

00000000000019d7 <vector_142>:
    19d7:	6a 6e                	pushq  $0x6e
    19d9:	e9 83 fb ff ff       	jmpq   1561 <irq>

00000000000019de <vector_143>:
    19de:	6a 6f                	pushq  $0x6f
    19e0:	e9 7c fb ff ff       	jmpq   1561 <irq>

00000000000019e5 <vector_144>:
IRQ(144); IRQ(145); IRQ(146); IRQ(147); IRQ(148); IRQ(149); IRQ(150); IRQ(151)
    19e5:	6a 70                	pushq  $0x70
    19e7:	e9 75 fb ff ff       	jmpq   1561 <irq>

00000000000019ec <vector_145>:
    19ec:	6a 71                	pushq  $0x71
    19ee:	e9 6e fb ff ff       	jmpq   1561 <irq>

00000000000019f3 <vector_146>:
    19f3:	6a 72                	pushq  $0x72
    19f5:	e9 67 fb ff ff       	jmpq   1561 <irq>

00000000000019fa <vector_147>:
    19fa:	6a 73                	pushq  $0x73
    19fc:	e9 60 fb ff ff       	jmpq   1561 <irq>

0000000000001a01 <vector_148>:
    1a01:	6a 74                	pushq  $0x74
    1a03:	e9 59 fb ff ff       	jmpq   1561 <irq>

0000000000001a08 <vector_149>:
    1a08:	6a 75                	pushq  $0x75
    1a0a:	e9 52 fb ff ff       	jmpq   1561 <irq>

0000000000001a0f <vector_150>:
    1a0f:	6a 76                	pushq  $0x76
    1a11:	e9 4b fb ff ff       	jmpq   1561 <irq>

0000000000001a16 <vector_151>:
    1a16:	6a 77                	pushq  $0x77
    1a18:	e9 44 fb ff ff       	jmpq   1561 <irq>

0000000000001a1d <vector_152>:
IRQ(152); IRQ(153); IRQ(154); IRQ(155); IRQ(156); IRQ(157); IRQ(158); IRQ(159)
    1a1d:	6a 78                	pushq  $0x78
    1a1f:	e9 3d fb ff ff       	jmpq   1561 <irq>

0000000000001a24 <vector_153>:
    1a24:	6a 79                	pushq  $0x79
    1a26:	e9 36 fb ff ff       	jmpq   1561 <irq>

0000000000001a2b <vector_154>:
    1a2b:	6a 7a                	pushq  $0x7a
    1a2d:	e9 2f fb ff ff       	jmpq   1561 <irq>

0000000000001a32 <vector_155>:
    1a32:	6a 7b                	pushq  $0x7b
    1a34:	e9 28 fb ff ff       	jmpq   1561 <irq>

0000000000001a39 <vector_156>:
    1a39:	6a 7c                	pushq  $0x7c
    1a3b:	e9 21 fb ff ff       	jmpq   1561 <irq>

0000000000001a40 <vector_157>:
    1a40:	6a 7d                	pushq  $0x7d
    1a42:	e9 1a fb ff ff       	jmpq   1561 <irq>

0000000000001a47 <vector_158>:
    1a47:	6a 7e                	pushq  $0x7e
    1a49:	e9 13 fb ff ff       	jmpq   1561 <irq>

0000000000001a4e <vector_159>:
    1a4e:	6a 7f                	pushq  $0x7f
    1a50:	e9 0c fb ff ff       	jmpq   1561 <irq>

0000000000001a55 <vector_160>:
IRQ(160); IRQ(161); IRQ(162); IRQ(163); IRQ(164); IRQ(165); IRQ(166); IRQ(167)
    1a55:	68 80 00 00 00       	pushq  $0x80
    1a5a:	e9 02 fb ff ff       	jmpq   1561 <irq>

0000000000001a5f <vector_161>:
    1a5f:	68 81 00 00 00       	pushq  $0x81
    1a64:	e9 f8 fa ff ff       	jmpq   1561 <irq>

0000000000001a69 <vector_162>:
    1a69:	68 82 00 00 00       	pushq  $0x82
    1a6e:	e9 ee fa ff ff       	jmpq   1561 <irq>

0000000000001a73 <vector_163>:
    1a73:	68 83 00 00 00       	pushq  $0x83
    1a78:	e9 e4 fa ff ff       	jmpq   1561 <irq>

0000000000001a7d <vector_164>:
    1a7d:	68 84 00 00 00       	pushq  $0x84
    1a82:	e9 da fa ff ff       	jmpq   1561 <irq>

0000000000001a87 <vector_165>:
    1a87:	68 85 00 00 00       	pushq  $0x85
    1a8c:	e9 d0 fa ff ff       	jmpq   1561 <irq>

0000000000001a91 <vector_166>:
    1a91:	68 86 00 00 00       	pushq  $0x86
    1a96:	e9 c6 fa ff ff       	jmpq   1561 <irq>

0000000000001a9b <vector_167>:
    1a9b:	68 87 00 00 00       	pushq  $0x87
    1aa0:	e9 bc fa ff ff       	jmpq   1561 <irq>

0000000000001aa5 <vector_168>:
IRQ(168); IRQ(169); IRQ(170); IRQ(171); IRQ(172); IRQ(173); IRQ(174); IRQ(175)
    1aa5:	68 88 00 00 00       	pushq  $0x88
    1aaa:	e9 b2 fa ff ff       	jmpq   1561 <irq>

0000000000001aaf <vector_169>:
    1aaf:	68 89 00 00 00       	pushq  $0x89
    1ab4:	e9 a8 fa ff ff       	jmpq   1561 <irq>

0000000000001ab9 <vector_170>:
    1ab9:	68 8a 00 00 00       	pushq  $0x8a
    1abe:	e9 9e fa ff ff       	jmpq   1561 <irq>

0000000000001ac3 <vector_171>:
    1ac3:	68 8b 00 00 00       	pushq  $0x8b
    1ac8:	e9 94 fa ff ff       	jmpq   1561 <irq>

0000000000001acd <vector_172>:
    1acd:	68 8c 00 00 00       	pushq  $0x8c
    1ad2:	e9 8a fa ff ff       	jmpq   1561 <irq>

0000000000001ad7 <vector_173>:
    1ad7:	68 8d 00 00 00       	pushq  $0x8d
    1adc:	e9 80 fa ff ff       	jmpq   1561 <irq>

0000000000001ae1 <vector_174>:
    1ae1:	68 8e 00 00 00       	pushq  $0x8e
    1ae6:	e9 76 fa ff ff       	jmpq   1561 <irq>

0000000000001aeb <vector_175>:
    1aeb:	68 8f 00 00 00       	pushq  $0x8f
    1af0:	e9 6c fa ff ff       	jmpq   1561 <irq>

0000000000001af5 <vector_176>:
IRQ(176); IRQ(177); IRQ(178); IRQ(179); IRQ(180); IRQ(181); IRQ(182); IRQ(183)
    1af5:	68 90 00 00 00       	pushq  $0x90
    1afa:	e9 62 fa ff ff       	jmpq   1561 <irq>

0000000000001aff <vector_177>:
    1aff:	68 91 00 00 00       	pushq  $0x91
    1b04:	e9 58 fa ff ff       	jmpq   1561 <irq>

0000000000001b09 <vector_178>:
    1b09:	68 92 00 00 00       	pushq  $0x92
    1b0e:	e9 4e fa ff ff       	jmpq   1561 <irq>

0000000000001b13 <vector_179>:
    1b13:	68 93 00 00 00       	pushq  $0x93
    1b18:	e9 44 fa ff ff       	jmpq   1561 <irq>

0000000000001b1d <vector_180>:
    1b1d:	68 94 00 00 00       	pushq  $0x94
    1b22:	e9 3a fa ff ff       	jmpq   1561 <irq>

0000000000001b27 <vector_181>:
    1b27:	68 95 00 00 00       	pushq  $0x95
    1b2c:	e9 30 fa ff ff       	jmpq   1561 <irq>

0000000000001b31 <vector_182>:
    1b31:	68 96 00 00 00       	pushq  $0x96
    1b36:	e9 26 fa ff ff       	jmpq   1561 <irq>

0000000000001b3b <vector_183>:
    1b3b:	68 97 00 00 00       	pushq  $0x97
    1b40:	e9 1c fa ff ff       	jmpq   1561 <irq>

0000000000001b45 <vector_184>:
IRQ(184); IRQ(185); IRQ(186); IRQ(187); IRQ(188); IRQ(189); IRQ(190); IRQ(191)
    1b45:	68 98 00 00 00       	pushq  $0x98
    1b4a:	e9 12 fa ff ff       	jmpq   1561 <irq>

0000000000001b4f <vector_185>:
    1b4f:	68 99 00 00 00       	pushq  $0x99
    1b54:	e9 08 fa ff ff       	jmpq   1561 <irq>

0000000000001b59 <vector_186>:
    1b59:	68 9a 00 00 00       	pushq  $0x9a
    1b5e:	e9 fe f9 ff ff       	jmpq   1561 <irq>

0000000000001b63 <vector_187>:
    1b63:	68 9b 00 00 00       	pushq  $0x9b
    1b68:	e9 f4 f9 ff ff       	jmpq   1561 <irq>

0000000000001b6d <vector_188>:
    1b6d:	68 9c 00 00 00       	pushq  $0x9c
    1b72:	e9 ea f9 ff ff       	jmpq   1561 <irq>

0000000000001b77 <vector_189>:
    1b77:	68 9d 00 00 00       	pushq  $0x9d
    1b7c:	e9 e0 f9 ff ff       	jmpq   1561 <irq>

0000000000001b81 <vector_190>:
    1b81:	68 9e 00 00 00       	pushq  $0x9e
    1b86:	e9 d6 f9 ff ff       	jmpq   1561 <irq>

0000000000001b8b <vector_191>:
    1b8b:	68 9f 00 00 00       	pushq  $0x9f
    1b90:	e9 cc f9 ff ff       	jmpq   1561 <irq>

0000000000001b95 <vector_192>:
IRQ(192); IRQ(193); IRQ(194); IRQ(195); IRQ(196); IRQ(197); IRQ(198); IRQ(199)
    1b95:	68 a0 00 00 00       	pushq  $0xa0
    1b9a:	e9 c2 f9 ff ff       	jmpq   1561 <irq>

0000000000001b9f <vector_193>:
    1b9f:	68 a1 00 00 00       	pushq  $0xa1
    1ba4:	e9 b8 f9 ff ff       	jmpq   1561 <irq>

0000000000001ba9 <vector_194>:
    1ba9:	68 a2 00 00 00       	pushq  $0xa2
    1bae:	e9 ae f9 ff ff       	jmpq   1561 <irq>

0000000000001bb3 <vector_195>:
    1bb3:	68 a3 00 00 00       	pushq  $0xa3
    1bb8:	e9 a4 f9 ff ff       	jmpq   1561 <irq>

0000000000001bbd <vector_196>:
    1bbd:	68 a4 00 00 00       	pushq  $0xa4
    1bc2:	e9 9a f9 ff ff       	jmpq   1561 <irq>

0000000000001bc7 <vector_197>:
    1bc7:	68 a5 00 00 00       	pushq  $0xa5
    1bcc:	e9 90 f9 ff ff       	jmpq   1561 <irq>

0000000000001bd1 <vector_198>:
    1bd1:	68 a6 00 00 00       	pushq  $0xa6
    1bd6:	e9 86 f9 ff ff       	jmpq   1561 <irq>

0000000000001bdb <vector_199>:
    1bdb:	68 a7 00 00 00       	pushq  $0xa7
    1be0:	e9 7c f9 ff ff       	jmpq   1561 <irq>

0000000000001be5 <vector_200>:
IRQ(200); IRQ(201); IRQ(202); IRQ(203); IRQ(204); IRQ(205); IRQ(206); IRQ(207)
    1be5:	68 a8 00 00 00       	pushq  $0xa8
    1bea:	e9 72 f9 ff ff       	jmpq   1561 <irq>

0000000000001bef <vector_201>:
    1bef:	68 a9 00 00 00       	pushq  $0xa9
    1bf4:	e9 68 f9 ff ff       	jmpq   1561 <irq>

0000000000001bf9 <vector_202>:
    1bf9:	68 aa 00 00 00       	pushq  $0xaa
    1bfe:	e9 5e f9 ff ff       	jmpq   1561 <irq>

0000000000001c03 <vector_203>:
    1c03:	68 ab 00 00 00       	pushq  $0xab
    1c08:	e9 54 f9 ff ff       	jmpq   1561 <irq>

0000000000001c0d <vector_204>:
    1c0d:	68 ac 00 00 00       	pushq  $0xac
    1c12:	e9 4a f9 ff ff       	jmpq   1561 <irq>

0000000000001c17 <vector_205>:
    1c17:	68 ad 00 00 00       	pushq  $0xad
    1c1c:	e9 40 f9 ff ff       	jmpq   1561 <irq>

0000000000001c21 <vector_206>:
    1c21:	68 ae 00 00 00       	pushq  $0xae
    1c26:	e9 36 f9 ff ff       	jmpq   1561 <irq>

0000000000001c2b <vector_207>:
    1c2b:	68 af 00 00 00       	pushq  $0xaf
    1c30:	e9 2c f9 ff ff       	jmpq   1561 <irq>

0000000000001c35 <vector_208>:
IRQ(208); IRQ(209); IRQ(210); IRQ(211); IRQ(212); IRQ(213); IRQ(214); IRQ(215)
    1c35:	68 b0 00 00 00       	pushq  $0xb0
    1c3a:	e9 22 f9 ff ff       	jmpq   1561 <irq>

0000000000001c3f <vector_209>:
    1c3f:	68 b1 00 00 00       	pushq  $0xb1
    1c44:	e9 18 f9 ff ff       	jmpq   1561 <irq>

0000000000001c49 <vector_210>:
    1c49:	68 b2 00 00 00       	pushq  $0xb2
    1c4e:	e9 0e f9 ff ff       	jmpq   1561 <irq>

0000000000001c53 <vector_211>:
    1c53:	68 b3 00 00 00       	pushq  $0xb3
    1c58:	e9 04 f9 ff ff       	jmpq   1561 <irq>

0000000000001c5d <vector_212>:
    1c5d:	68 b4 00 00 00       	pushq  $0xb4
    1c62:	e9 fa f8 ff ff       	jmpq   1561 <irq>

0000000000001c67 <vector_213>:
    1c67:	68 b5 00 00 00       	pushq  $0xb5
    1c6c:	e9 f0 f8 ff ff       	jmpq   1561 <irq>

0000000000001c71 <vector_214>:
    1c71:	68 b6 00 00 00       	pushq  $0xb6
    1c76:	e9 e6 f8 ff ff       	jmpq   1561 <irq>

0000000000001c7b <vector_215>:
    1c7b:	68 b7 00 00 00       	pushq  $0xb7
    1c80:	e9 dc f8 ff ff       	jmpq   1561 <irq>

0000000000001c85 <vector_216>:
IRQ(216); IRQ(217); IRQ(218); IRQ(219); IRQ(220); IRQ(221); IRQ(222); IRQ(223)
    1c85:	68 b8 00 00 00       	pushq  $0xb8
    1c8a:	e9 d2 f8 ff ff       	jmpq   1561 <irq>

0000000000001c8f <vector_217>:
    1c8f:	68 b9 00 00 00       	pushq  $0xb9
    1c94:	e9 c8 f8 ff ff       	jmpq   1561 <irq>

0000000000001c99 <vector_218>:
    1c99:	68 ba 00 00 00       	pushq  $0xba
    1c9e:	e9 be f8 ff ff       	jmpq   1561 <irq>

0000000000001ca3 <vector_219>:
    1ca3:	68 bb 00 00 00       	pushq  $0xbb
    1ca8:	e9 b4 f8 ff ff       	jmpq   1561 <irq>

0000000000001cad <vector_220>:
    1cad:	68 bc 00 00 00       	pushq  $0xbc
    1cb2:	e9 aa f8 ff ff       	jmpq   1561 <irq>

0000000000001cb7 <vector_221>:
    1cb7:	68 bd 00 00 00       	pushq  $0xbd
    1cbc:	e9 a0 f8 ff ff       	jmpq   1561 <irq>

0000000000001cc1 <vector_222>:
    1cc1:	68 be 00 00 00       	pushq  $0xbe
    1cc6:	e9 96 f8 ff ff       	jmpq   1561 <irq>

0000000000001ccb <vector_223>:
    1ccb:	68 bf 00 00 00       	pushq  $0xbf
    1cd0:	e9 8c f8 ff ff       	jmpq   1561 <irq>

0000000000001cd5 <vector_224>:
IRQ(224); IRQ(225); IRQ(226); IRQ(227); IRQ(228); IRQ(229); IRQ(230); IRQ(231)
    1cd5:	68 c0 00 00 00       	pushq  $0xc0
    1cda:	e9 82 f8 ff ff       	jmpq   1561 <irq>

0000000000001cdf <vector_225>:
    1cdf:	68 c1 00 00 00       	pushq  $0xc1
    1ce4:	e9 78 f8 ff ff       	jmpq   1561 <irq>

0000000000001ce9 <vector_226>:
    1ce9:	68 c2 00 00 00       	pushq  $0xc2
    1cee:	e9 6e f8 ff ff       	jmpq   1561 <irq>

0000000000001cf3 <vector_227>:
    1cf3:	68 c3 00 00 00       	pushq  $0xc3
    1cf8:	e9 64 f8 ff ff       	jmpq   1561 <irq>

0000000000001cfd <vector_228>:
    1cfd:	68 c4 00 00 00       	pushq  $0xc4
    1d02:	e9 5a f8 ff ff       	jmpq   1561 <irq>

0000000000001d07 <vector_229>:
    1d07:	68 c5 00 00 00       	pushq  $0xc5
    1d0c:	e9 50 f8 ff ff       	jmpq   1561 <irq>

0000000000001d11 <vector_230>:
    1d11:	68 c6 00 00 00       	pushq  $0xc6
    1d16:	e9 46 f8 ff ff       	jmpq   1561 <irq>

0000000000001d1b <vector_231>:
    1d1b:	68 c7 00 00 00       	pushq  $0xc7
    1d20:	e9 3c f8 ff ff       	jmpq   1561 <irq>

0000000000001d25 <vector_232>:
IRQ(232); IRQ(233); IRQ(234); IRQ(235); IRQ(236); IRQ(237); IRQ(238); IRQ(239)
    1d25:	68 c8 00 00 00       	pushq  $0xc8
    1d2a:	e9 32 f8 ff ff       	jmpq   1561 <irq>

0000000000001d2f <vector_233>:
    1d2f:	68 c9 00 00 00       	pushq  $0xc9
    1d34:	e9 28 f8 ff ff       	jmpq   1561 <irq>

0000000000001d39 <vector_234>:
    1d39:	68 ca 00 00 00       	pushq  $0xca
    1d3e:	e9 1e f8 ff ff       	jmpq   1561 <irq>

0000000000001d43 <vector_235>:
    1d43:	68 cb 00 00 00       	pushq  $0xcb
    1d48:	e9 14 f8 ff ff       	jmpq   1561 <irq>

0000000000001d4d <vector_236>:
    1d4d:	68 cc 00 00 00       	pushq  $0xcc
    1d52:	e9 0a f8 ff ff       	jmpq   1561 <irq>

0000000000001d57 <vector_237>:
    1d57:	68 cd 00 00 00       	pushq  $0xcd
    1d5c:	e9 00 f8 ff ff       	jmpq   1561 <irq>

0000000000001d61 <vector_238>:
    1d61:	68 ce 00 00 00       	pushq  $0xce
    1d66:	e9 f6 f7 ff ff       	jmpq   1561 <irq>

0000000000001d6b <vector_239>:
    1d6b:	68 cf 00 00 00       	pushq  $0xcf
    1d70:	e9 ec f7 ff ff       	jmpq   1561 <irq>

0000000000001d75 <vector_240>:
IRQ(240); IRQ(241); IRQ(242); IRQ(243); IRQ(244); IRQ(245); IRQ(246); IRQ(247)
    1d75:	68 d0 00 00 00       	pushq  $0xd0
    1d7a:	e9 e2 f7 ff ff       	jmpq   1561 <irq>

0000000000001d7f <vector_241>:
    1d7f:	68 d1 00 00 00       	pushq  $0xd1
    1d84:	e9 d8 f7 ff ff       	jmpq   1561 <irq>

0000000000001d89 <vector_242>:
    1d89:	68 d2 00 00 00       	pushq  $0xd2
    1d8e:	e9 ce f7 ff ff       	jmpq   1561 <irq>

0000000000001d93 <vector_243>:
    1d93:	68 d3 00 00 00       	pushq  $0xd3
    1d98:	e9 c4 f7 ff ff       	jmpq   1561 <irq>

0000000000001d9d <vector_244>:
    1d9d:	68 d4 00 00 00       	pushq  $0xd4
    1da2:	e9 ba f7 ff ff       	jmpq   1561 <irq>

0000000000001da7 <vector_245>:
    1da7:	68 d5 00 00 00       	pushq  $0xd5
    1dac:	e9 b0 f7 ff ff       	jmpq   1561 <irq>

0000000000001db1 <vector_246>:
    1db1:	68 d6 00 00 00       	pushq  $0xd6
    1db6:	e9 a6 f7 ff ff       	jmpq   1561 <irq>

0000000000001dbb <vector_247>:
    1dbb:	68 d7 00 00 00       	pushq  $0xd7
    1dc0:	e9 9c f7 ff ff       	jmpq   1561 <irq>

0000000000001dc5 <vector_248>:
IRQ(248); IRQ(249); IRQ(250); IRQ(251); IRQ(252); IRQ(253); IRQ(254); IRQ(255)
    1dc5:	68 d8 00 00 00       	pushq  $0xd8
    1dca:	e9 92 f7 ff ff       	jmpq   1561 <irq>

0000000000001dcf <vector_249>:
    1dcf:	68 d9 00 00 00       	pushq  $0xd9
    1dd4:	e9 88 f7 ff ff       	jmpq   1561 <irq>

0000000000001dd9 <vector_250>:
    1dd9:	68 da 00 00 00       	pushq  $0xda
    1dde:	e9 7e f7 ff ff       	jmpq   1561 <irq>

0000000000001de3 <vector_251>:
    1de3:	68 db 00 00 00       	pushq  $0xdb
    1de8:	e9 74 f7 ff ff       	jmpq   1561 <irq>

0000000000001ded <vector_252>:
    1ded:	68 dc 00 00 00       	pushq  $0xdc
    1df2:	e9 6a f7 ff ff       	jmpq   1561 <irq>

0000000000001df7 <vector_253>:
    1df7:	68 dd 00 00 00       	pushq  $0xdd
    1dfc:	e9 60 f7 ff ff       	jmpq   1561 <irq>

0000000000001e01 <vector_254>:
    1e01:	68 de 00 00 00       	pushq  $0xde
    1e06:	e9 56 f7 ff ff       	jmpq   1561 <irq>

0000000000001e0b <vector_255>:
    1e0b:	68 df 00 00 00       	pushq  $0xdf
    1e10:	e9 4c f7 ff ff       	jmpq   1561 <irq>
    1e15:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    1e1c:	00 00 00 
    1e1f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    1e26:	00 00 00 
    1e29:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    1e30:	00 00 00 
    1e33:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    1e3a:	00 00 00 
    1e3d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    1e44:	00 00 00 
    1e47:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    1e4e:	00 00 00 
    1e51:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    1e58:	00 00 00 
    1e5b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    1e62:	00 00 00 
    1e65:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    1e6c:	00 00 00 
    1e6f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    1e76:	00 00 00 
    1e79:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    1e80:	00 00 00 
    1e83:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    1e8a:	00 00 00 
    1e8d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    1e94:	00 00 00 
    1e97:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    1e9e:	00 00 00 
    1ea1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    1ea8:	00 00 00 
    1eab:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    1eb2:	00 00 00 
    1eb5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    1ebc:	00 00 00 
    1ebf:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    1ec6:	00 00 00 
    1ec9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    1ed0:	00 00 00 
    1ed3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    1eda:	00 00 00 
    1edd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    1ee4:	00 00 00 
    1ee7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    1eee:	00 00 00 
    1ef1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    1ef8:	00 00 00 
    1efb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    1f02:	00 00 00 
    1f05:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    1f0c:	00 00 00 
    1f0f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    1f16:	00 00 00 
    1f19:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    1f20:	00 00 00 
    1f23:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    1f2a:	00 00 00 
    1f2d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    1f34:	00 00 00 
    1f37:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    1f3e:	00 00 00 
    1f41:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    1f48:	00 00 00 
    1f4b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    1f52:	00 00 00 
    1f55:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    1f5c:	00 00 00 
    1f5f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    1f66:	00 00 00 
    1f69:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    1f70:	00 00 00 
    1f73:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    1f7a:	00 00 00 
    1f7d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    1f84:	00 00 00 
    1f87:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    1f8e:	00 00 00 
    1f91:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    1f98:	00 00 00 
    1f9b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    1fa2:	00 00 00 
    1fa5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    1fac:	00 00 00 
    1faf:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    1fb6:	00 00 00 
    1fb9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    1fc0:	00 00 00 
    1fc3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    1fca:	00 00 00 
    1fcd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    1fd4:	00 00 00 
    1fd7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    1fde:	00 00 00 
    1fe1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    1fe8:	00 00 00 
    1feb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    1ff2:	00 00 00 
    1ff5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    1ffc:	00 00 00 
    1fff:	90                   	nop

0000000000002000 <_locore_end>:
    2000:	3e 13 18             	adc    %ds:(%rax),%ebx
    2003:	00 02                	add    %al,(%rdx)
    2005:	8e 00                	mov    (%rax),%es
	...
    200f:	00 4f 13             	add    %cl,0x13(%rdi)
    2012:	18 00                	sbb    %al,(%rax)
    2014:	02 8e 00 00 00 00    	add    0x0(%rsi),%cl
    201a:	00 00                	add    %al,(%rax)
    201c:	00 00                	add    %al,(%rax)
    201e:	00 00                	add    %al,(%rax)
    2020:	60                   	(bad)  
    2021:	13 18                	adc    (%rax),%ebx
    2023:	00 02                	add    %al,(%rdx)
    2025:	8e 00                	mov    (%rax),%es
	...
    202f:	00 71 13             	add    %dh,0x13(%rcx)
    2032:	18 00                	sbb    %al,(%rax)
    2034:	02 8e 00 00 00 00    	add    0x0(%rsi),%cl
    203a:	00 00                	add    %al,(%rax)
    203c:	00 00                	add    %al,(%rax)
    203e:	00 00                	add    %al,(%rax)
    2040:	82                   	(bad)  
    2041:	13 18                	adc    (%rax),%ebx
    2043:	00 02                	add    %al,(%rdx)
    2045:	8e 00                	mov    (%rax),%es
	...
    204f:	00 93 13 18 00 02    	add    %dl,0x2001813(%rbx)
    2055:	8e 00                	mov    (%rax),%es
	...
    205f:	00 a4 13 18 00 02 8e 	add    %ah,-0x71fdffe8(%rbx,%rdx,1)
	...
    206e:	00 00                	add    %al,(%rax)
    2070:	b5 13                	mov    $0x13,%ch
    2072:	18 00                	sbb    %al,(%rax)
    2074:	02 8e 00 00 00 00    	add    0x0(%rsi),%cl
    207a:	00 00                	add    %al,(%rax)
    207c:	00 00                	add    %al,(%rax)
    207e:	00 00                	add    %al,(%rax)
    2080:	c6                   	(bad)  
    2081:	13 18                	adc    (%rax),%ebx
    2083:	00 02                	add    %al,(%rdx)
    2085:	8e 00                	mov    (%rax),%es
	...
    208f:	00 d5                	add    %dl,%ch
    2091:	13 18                	adc    (%rax),%ebx
    2093:	00 02                	add    %al,(%rdx)
    2095:	8e 00                	mov    (%rax),%es
	...
    209f:	00 e6                	add    %ah,%dh
    20a1:	13 18                	adc    (%rax),%ebx
    20a3:	00 02                	add    %al,(%rdx)
    20a5:	8e 00                	mov    (%rax),%es
	...
    20af:	00 f5                	add    %dh,%ch
    20b1:	13 18                	adc    (%rax),%ebx
    20b3:	00 02                	add    %al,(%rdx)
    20b5:	8e 00                	mov    (%rax),%es
	...
    20bf:	00 04 14             	add    %al,(%rsp,%rdx,1)
    20c2:	18 00                	sbb    %al,(%rax)
    20c4:	02 8e 00 00 00 00    	add    0x0(%rsi),%cl
    20ca:	00 00                	add    %al,(%rax)
    20cc:	00 00                	add    %al,(%rax)
    20ce:	00 00                	add    %al,(%rax)
    20d0:	13 14 18             	adc    (%rax,%rbx,1),%edx
    20d3:	00 02                	add    %al,(%rdx)
    20d5:	8e 00                	mov    (%rax),%es
	...
    20df:	00 22                	add    %ah,(%rdx)
    20e1:	14 18                	adc    $0x18,%al
    20e3:	00 02                	add    %al,(%rdx)
    20e5:	8e 00                	mov    (%rax),%es
	...
    20ef:	00 31                	add    %dh,(%rcx)
    20f1:	14 18                	adc    $0x18,%al
    20f3:	00 02                	add    %al,(%rdx)
    20f5:	8e 00                	mov    (%rax),%es
	...
    20ff:	00 42 14             	add    %al,0x14(%rdx)
    2102:	18 00                	sbb    %al,(%rax)
    2104:	02 8e 00 00 00 00    	add    0x0(%rsi),%cl
    210a:	00 00                	add    %al,(%rax)
    210c:	00 00                	add    %al,(%rax)
    210e:	00 00                	add    %al,(%rax)
    2110:	53                   	push   %rbx
    2111:	14 18                	adc    $0x18,%al
    2113:	00 02                	add    %al,(%rdx)
    2115:	8e 00                	mov    (%rax),%es
	...
    211f:	00 62 14             	add    %ah,0x14(%rdx)
    2122:	18 00                	sbb    %al,(%rax)
    2124:	02 8e 00 00 00 00    	add    0x0(%rsi),%cl
    212a:	00 00                	add    %al,(%rax)
    212c:	00 00                	add    %al,(%rax)
    212e:	00 00                	add    %al,(%rax)
    2130:	73 14                	jae    2146 <_locore_end+0x146>
    2132:	18 00                	sbb    %al,(%rax)
    2134:	02 8e 00 00 00 00    	add    0x0(%rsi),%cl
    213a:	00 00                	add    %al,(%rax)
    213c:	00 00                	add    %al,(%rax)
    213e:	00 00                	add    %al,(%rax)
    2140:	84 14 18             	test   %dl,(%rax,%rbx,1)
    2143:	00 02                	add    %al,(%rdx)
    2145:	8e 00                	mov    (%rax),%es
	...
    214f:	00 95 14 18 00 02    	add    %dl,0x2001814(%rbp)
    2155:	8e 00                	mov    (%rax),%es
	...
    215f:	00 a6 14 18 00 02    	add    %ah,0x2001814(%rsi)
    2165:	8e 00                	mov    (%rax),%es
	...
    216f:	00 b7 14 18 00 02    	add    %dh,0x2001814(%rdi)
    2175:	8e 00                	mov    (%rax),%es
	...
    217f:	00 c8                	add    %cl,%al
    2181:	14 18                	adc    $0x18,%al
    2183:	00 02                	add    %al,(%rdx)
    2185:	8e 00                	mov    (%rax),%es
	...
    218f:	00 d9                	add    %bl,%cl
    2191:	14 18                	adc    $0x18,%al
    2193:	00 02                	add    %al,(%rdx)
    2195:	8e 00                	mov    (%rax),%es
	...
    219f:	00 ea                	add    %ch,%dl
    21a1:	14 18                	adc    $0x18,%al
    21a3:	00 02                	add    %al,(%rdx)
    21a5:	8e 00                	mov    (%rax),%es
	...
    21af:	00 fb                	add    %bh,%bl
    21b1:	14 18                	adc    $0x18,%al
    21b3:	00 02                	add    %al,(%rdx)
    21b5:	8e 00                	mov    (%rax),%es
	...
    21bf:	00 0c 15 18 00 02 8e 	add    %cl,-0x71fdffe8(,%rdx,1)
	...
    21ce:	00 00                	add    %al,(%rax)
    21d0:	1d 15 18 00 02       	sbb    $0x2001815,%eax
    21d5:	8e 00                	mov    (%rax),%es
	...
    21df:	00 2e                	add    %ch,(%rsi)
    21e1:	15 18 00 02 8e       	adc    $0x8e020018,%eax
	...
    21ee:	00 00                	add    %al,(%rax)
    21f0:	3f                   	(bad)  
    21f1:	15 18 00 02 8e       	adc    $0x8e020018,%eax
	...
    21fe:	00 00                	add    %al,(%rax)
    2200:	50                   	push   %rax
    2201:	15 18 00 02 ee       	adc    $0xee020018,%eax
	...
    220e:	00 00                	add    %al,(%rax)
    2210:	dc 16                	fcoml  (%rsi)
    2212:	18 00                	sbb    %al,(%rax)
    2214:	02 8e 00 00 00 00    	add    0x0(%rsi),%cl
    221a:	00 00                	add    %al,(%rax)
    221c:	00 00                	add    %al,(%rax)
    221e:	00 00                	add    %al,(%rax)
    2220:	e3 16                	jrcxz  2238 <_locore_end+0x238>
    2222:	18 00                	sbb    %al,(%rax)
    2224:	02 8e 00 00 00 00    	add    0x0(%rsi),%cl
    222a:	00 00                	add    %al,(%rax)
    222c:	00 00                	add    %al,(%rax)
    222e:	00 00                	add    %al,(%rax)
    2230:	ea                   	(bad)  
    2231:	16                   	(bad)  
    2232:	18 00                	sbb    %al,(%rax)
    2234:	02 8e 00 00 00 00    	add    0x0(%rsi),%cl
    223a:	00 00                	add    %al,(%rax)
    223c:	00 00                	add    %al,(%rax)
    223e:	00 00                	add    %al,(%rax)
    2240:	f1                   	icebp  
    2241:	16                   	(bad)  
    2242:	18 00                	sbb    %al,(%rax)
    2244:	02 8e 00 00 00 00    	add    0x0(%rsi),%cl
    224a:	00 00                	add    %al,(%rax)
    224c:	00 00                	add    %al,(%rax)
    224e:	00 00                	add    %al,(%rax)
    2250:	f8                   	clc    
    2251:	16                   	(bad)  
    2252:	18 00                	sbb    %al,(%rax)
    2254:	02 8e 00 00 00 00    	add    0x0(%rsi),%cl
    225a:	00 00                	add    %al,(%rax)
    225c:	00 00                	add    %al,(%rax)
    225e:	00 00                	add    %al,(%rax)
    2260:	ff 16                	callq  *(%rsi)
    2262:	18 00                	sbb    %al,(%rax)
    2264:	02 8e 00 00 00 00    	add    0x0(%rsi),%cl
    226a:	00 00                	add    %al,(%rax)
    226c:	00 00                	add    %al,(%rax)
    226e:	00 00                	add    %al,(%rax)
    2270:	06                   	(bad)  
    2271:	17                   	(bad)  
    2272:	18 00                	sbb    %al,(%rax)
    2274:	02 8e 00 00 00 00    	add    0x0(%rsi),%cl
    227a:	00 00                	add    %al,(%rax)
    227c:	00 00                	add    %al,(%rax)
    227e:	00 00                	add    %al,(%rax)
    2280:	0d 17 18 00 02       	or     $0x2001817,%eax
    2285:	8e 00                	mov    (%rax),%es
	...
    228f:	00 14 17             	add    %dl,(%rdi,%rdx,1)
    2292:	18 00                	sbb    %al,(%rax)
    2294:	02 8e 00 00 00 00    	add    0x0(%rsi),%cl
    229a:	00 00                	add    %al,(%rax)
    229c:	00 00                	add    %al,(%rax)
    229e:	00 00                	add    %al,(%rax)
    22a0:	1b 17                	sbb    (%rdi),%edx
    22a2:	18 00                	sbb    %al,(%rax)
    22a4:	02 8e 00 00 00 00    	add    0x0(%rsi),%cl
    22aa:	00 00                	add    %al,(%rax)
    22ac:	00 00                	add    %al,(%rax)
    22ae:	00 00                	add    %al,(%rax)
    22b0:	22 17                	and    (%rdi),%dl
    22b2:	18 00                	sbb    %al,(%rax)
    22b4:	02 8e 00 00 00 00    	add    0x0(%rsi),%cl
    22ba:	00 00                	add    %al,(%rax)
    22bc:	00 00                	add    %al,(%rax)
    22be:	00 00                	add    %al,(%rax)
    22c0:	29 17                	sub    %edx,(%rdi)
    22c2:	18 00                	sbb    %al,(%rax)
    22c4:	02 8e 00 00 00 00    	add    0x0(%rsi),%cl
    22ca:	00 00                	add    %al,(%rax)
    22cc:	00 00                	add    %al,(%rax)
    22ce:	00 00                	add    %al,(%rax)
    22d0:	30 17                	xor    %dl,(%rdi)
    22d2:	18 00                	sbb    %al,(%rax)
    22d4:	02 8e 00 00 00 00    	add    0x0(%rsi),%cl
    22da:	00 00                	add    %al,(%rax)
    22dc:	00 00                	add    %al,(%rax)
    22de:	00 00                	add    %al,(%rax)
    22e0:	37                   	(bad)  
    22e1:	17                   	(bad)  
    22e2:	18 00                	sbb    %al,(%rax)
    22e4:	02 8e 00 00 00 00    	add    0x0(%rsi),%cl
    22ea:	00 00                	add    %al,(%rax)
    22ec:	00 00                	add    %al,(%rax)
    22ee:	00 00                	add    %al,(%rax)
    22f0:	3e 17                	ds (bad) 
    22f2:	18 00                	sbb    %al,(%rax)
    22f4:	02 8e 00 00 00 00    	add    0x0(%rsi),%cl
    22fa:	00 00                	add    %al,(%rax)
    22fc:	00 00                	add    %al,(%rax)
    22fe:	00 00                	add    %al,(%rax)
    2300:	45 17                	rex.RB (bad) 
    2302:	18 00                	sbb    %al,(%rax)
    2304:	02 8e 00 00 00 00    	add    0x0(%rsi),%cl
    230a:	00 00                	add    %al,(%rax)
    230c:	00 00                	add    %al,(%rax)
    230e:	00 00                	add    %al,(%rax)
    2310:	4c 17                	rex.WR (bad) 
    2312:	18 00                	sbb    %al,(%rax)
    2314:	02 8e 00 00 00 00    	add    0x0(%rsi),%cl
    231a:	00 00                	add    %al,(%rax)
    231c:	00 00                	add    %al,(%rax)
    231e:	00 00                	add    %al,(%rax)
    2320:	53                   	push   %rbx
    2321:	17                   	(bad)  
    2322:	18 00                	sbb    %al,(%rax)
    2324:	02 8e 00 00 00 00    	add    0x0(%rsi),%cl
    232a:	00 00                	add    %al,(%rax)
    232c:	00 00                	add    %al,(%rax)
    232e:	00 00                	add    %al,(%rax)
    2330:	5a                   	pop    %rdx
    2331:	17                   	(bad)  
    2332:	18 00                	sbb    %al,(%rax)
    2334:	02 8e 00 00 00 00    	add    0x0(%rsi),%cl
    233a:	00 00                	add    %al,(%rax)
    233c:	00 00                	add    %al,(%rax)
    233e:	00 00                	add    %al,(%rax)
    2340:	61                   	(bad)  
    2341:	17                   	(bad)  
    2342:	18 00                	sbb    %al,(%rax)
    2344:	02 8e 00 00 00 00    	add    0x0(%rsi),%cl
    234a:	00 00                	add    %al,(%rax)
    234c:	00 00                	add    %al,(%rax)
    234e:	00 00                	add    %al,(%rax)
    2350:	68 17 18 00 02       	pushq  $0x2001817
    2355:	8e 00                	mov    (%rax),%es
	...
    235f:	00 6f 17             	add    %ch,0x17(%rdi)
    2362:	18 00                	sbb    %al,(%rax)
    2364:	02 8e 00 00 00 00    	add    0x0(%rsi),%cl
    236a:	00 00                	add    %al,(%rax)
    236c:	00 00                	add    %al,(%rax)
    236e:	00 00                	add    %al,(%rax)
    2370:	76 17                	jbe    2389 <_locore_end+0x389>
    2372:	18 00                	sbb    %al,(%rax)
    2374:	02 8e 00 00 00 00    	add    0x0(%rsi),%cl
    237a:	00 00                	add    %al,(%rax)
    237c:	00 00                	add    %al,(%rax)
    237e:	00 00                	add    %al,(%rax)
    2380:	7d 17                	jge    2399 <_locore_end+0x399>
    2382:	18 00                	sbb    %al,(%rax)
    2384:	02 8e 00 00 00 00    	add    0x0(%rsi),%cl
    238a:	00 00                	add    %al,(%rax)
    238c:	00 00                	add    %al,(%rax)
    238e:	00 00                	add    %al,(%rax)
    2390:	84 17                	test   %dl,(%rdi)
    2392:	18 00                	sbb    %al,(%rax)
    2394:	02 8e 00 00 00 00    	add    0x0(%rsi),%cl
    239a:	00 00                	add    %al,(%rax)
    239c:	00 00                	add    %al,(%rax)
    239e:	00 00                	add    %al,(%rax)
    23a0:	8b 17                	mov    (%rdi),%edx
    23a2:	18 00                	sbb    %al,(%rax)
    23a4:	02 8e 00 00 00 00    	add    0x0(%rsi),%cl
    23aa:	00 00                	add    %al,(%rax)
    23ac:	00 00                	add    %al,(%rax)
    23ae:	00 00                	add    %al,(%rax)
    23b0:	92                   	xchg   %eax,%edx
    23b1:	17                   	(bad)  
    23b2:	18 00                	sbb    %al,(%rax)
    23b4:	02 8e 00 00 00 00    	add    0x0(%rsi),%cl
    23ba:	00 00                	add    %al,(%rax)
    23bc:	00 00                	add    %al,(%rax)
    23be:	00 00                	add    %al,(%rax)
    23c0:	99                   	cltd   
    23c1:	17                   	(bad)  
    23c2:	18 00                	sbb    %al,(%rax)
    23c4:	02 8e 00 00 00 00    	add    0x0(%rsi),%cl
    23ca:	00 00                	add    %al,(%rax)
    23cc:	00 00                	add    %al,(%rax)
    23ce:	00 00                	add    %al,(%rax)
    23d0:	a0 17 18 00 02 8e 00 	movabs 0x8e02001817,%al
    23d7:	00 00 
    23d9:	00 00                	add    %al,(%rax)
    23db:	00 00                	add    %al,(%rax)
    23dd:	00 00                	add    %al,(%rax)
    23df:	00 a7 17 18 00 02    	add    %ah,0x2001817(%rdi)
    23e5:	8e 00                	mov    (%rax),%es
	...
    23ef:	00 ae 17 18 00 02    	add    %ch,0x2001817(%rsi)
    23f5:	8e 00                	mov    (%rax),%es
	...
    23ff:	00 b5 17 18 00 02    	add    %dh,0x2001817(%rbp)
    2405:	8e 00                	mov    (%rax),%es
	...
    240f:	00 bc 17 18 00 02 8e 	add    %bh,-0x71fdffe8(%rdi,%rdx,1)
	...
    241e:	00 00                	add    %al,(%rax)
    2420:	c3                   	retq   
    2421:	17                   	(bad)  
    2422:	18 00                	sbb    %al,(%rax)
    2424:	02 8e 00 00 00 00    	add    0x0(%rsi),%cl
    242a:	00 00                	add    %al,(%rax)
    242c:	00 00                	add    %al,(%rax)
    242e:	00 00                	add    %al,(%rax)
    2430:	ca 17 18             	lret   $0x1817
    2433:	00 02                	add    %al,(%rdx)
    2435:	8e 00                	mov    (%rax),%es
	...
    243f:	00 d1                	add    %dl,%cl
    2441:	17                   	(bad)  
    2442:	18 00                	sbb    %al,(%rax)
    2444:	02 8e 00 00 00 00    	add    0x0(%rsi),%cl
    244a:	00 00                	add    %al,(%rax)
    244c:	00 00                	add    %al,(%rax)
    244e:	00 00                	add    %al,(%rax)
    2450:	d8 17                	fcoms  (%rdi)
    2452:	18 00                	sbb    %al,(%rax)
    2454:	02 8e 00 00 00 00    	add    0x0(%rsi),%cl
    245a:	00 00                	add    %al,(%rax)
    245c:	00 00                	add    %al,(%rax)
    245e:	00 00                	add    %al,(%rax)
    2460:	df 17                	fists  (%rdi)
    2462:	18 00                	sbb    %al,(%rax)
    2464:	02 8e 00 00 00 00    	add    0x0(%rsi),%cl
    246a:	00 00                	add    %al,(%rax)
    246c:	00 00                	add    %al,(%rax)
    246e:	00 00                	add    %al,(%rax)
    2470:	e6 17                	out    %al,$0x17
    2472:	18 00                	sbb    %al,(%rax)
    2474:	02 8e 00 00 00 00    	add    0x0(%rsi),%cl
    247a:	00 00                	add    %al,(%rax)
    247c:	00 00                	add    %al,(%rax)
    247e:	00 00                	add    %al,(%rax)
    2480:	ed                   	in     (%dx),%eax
    2481:	17                   	(bad)  
    2482:	18 00                	sbb    %al,(%rax)
    2484:	02 8e 00 00 00 00    	add    0x0(%rsi),%cl
    248a:	00 00                	add    %al,(%rax)
    248c:	00 00                	add    %al,(%rax)
    248e:	00 00                	add    %al,(%rax)
    2490:	f4                   	hlt    
    2491:	17                   	(bad)  
    2492:	18 00                	sbb    %al,(%rax)
    2494:	02 8e 00 00 00 00    	add    0x0(%rsi),%cl
    249a:	00 00                	add    %al,(%rax)
    249c:	00 00                	add    %al,(%rax)
    249e:	00 00                	add    %al,(%rax)
    24a0:	fb                   	sti    
    24a1:	17                   	(bad)  
    24a2:	18 00                	sbb    %al,(%rax)
    24a4:	02 8e 00 00 00 00    	add    0x0(%rsi),%cl
    24aa:	00 00                	add    %al,(%rax)
    24ac:	00 00                	add    %al,(%rax)
    24ae:	00 00                	add    %al,(%rax)
    24b0:	02 18                	add    (%rax),%bl
    24b2:	18 00                	sbb    %al,(%rax)
    24b4:	02 8e 00 00 00 00    	add    0x0(%rsi),%cl
    24ba:	00 00                	add    %al,(%rax)
    24bc:	00 00                	add    %al,(%rax)
    24be:	00 00                	add    %al,(%rax)
    24c0:	09 18                	or     %ebx,(%rax)
    24c2:	18 00                	sbb    %al,(%rax)
    24c4:	02 8e 00 00 00 00    	add    0x0(%rsi),%cl
    24ca:	00 00                	add    %al,(%rax)
    24cc:	00 00                	add    %al,(%rax)
    24ce:	00 00                	add    %al,(%rax)
    24d0:	10 18                	adc    %bl,(%rax)
    24d2:	18 00                	sbb    %al,(%rax)
    24d4:	02 8e 00 00 00 00    	add    0x0(%rsi),%cl
    24da:	00 00                	add    %al,(%rax)
    24dc:	00 00                	add    %al,(%rax)
    24de:	00 00                	add    %al,(%rax)
    24e0:	17                   	(bad)  
    24e1:	18 18                	sbb    %bl,(%rax)
    24e3:	00 02                	add    %al,(%rdx)
    24e5:	8e 00                	mov    (%rax),%es
	...
    24ef:	00 1e                	add    %bl,(%rsi)
    24f1:	18 18                	sbb    %bl,(%rax)
    24f3:	00 02                	add    %al,(%rdx)
    24f5:	8e 00                	mov    (%rax),%es
	...
    24ff:	00 25 18 18 00 02    	add    %ah,0x2001818(%rip)        # 2003d1d <_end+0x191dd1d>
    2505:	8e 00                	mov    (%rax),%es
	...
    250f:	00 2c 18             	add    %ch,(%rax,%rbx,1)
    2512:	18 00                	sbb    %al,(%rax)
    2514:	02 8e 00 00 00 00    	add    0x0(%rsi),%cl
    251a:	00 00                	add    %al,(%rax)
    251c:	00 00                	add    %al,(%rax)
    251e:	00 00                	add    %al,(%rax)
    2520:	33 18                	xor    (%rax),%ebx
    2522:	18 00                	sbb    %al,(%rax)
    2524:	02 8e 00 00 00 00    	add    0x0(%rsi),%cl
    252a:	00 00                	add    %al,(%rax)
    252c:	00 00                	add    %al,(%rax)
    252e:	00 00                	add    %al,(%rax)
    2530:	3a 18                	cmp    (%rax),%bl
    2532:	18 00                	sbb    %al,(%rax)
    2534:	02 8e 00 00 00 00    	add    0x0(%rsi),%cl
    253a:	00 00                	add    %al,(%rax)
    253c:	00 00                	add    %al,(%rax)
    253e:	00 00                	add    %al,(%rax)
    2540:	41 18 18             	sbb    %bl,(%r8)
    2543:	00 02                	add    %al,(%rdx)
    2545:	8e 00                	mov    (%rax),%es
	...
    254f:	00 48 18             	add    %cl,0x18(%rax)
    2552:	18 00                	sbb    %al,(%rax)
    2554:	02 8e 00 00 00 00    	add    0x0(%rsi),%cl
    255a:	00 00                	add    %al,(%rax)
    255c:	00 00                	add    %al,(%rax)
    255e:	00 00                	add    %al,(%rax)
    2560:	4f 18 18             	rex.WRXB sbb %r11b,(%r8)
    2563:	00 02                	add    %al,(%rdx)
    2565:	8e 00                	mov    (%rax),%es
	...
    256f:	00 56 18             	add    %dl,0x18(%rsi)
    2572:	18 00                	sbb    %al,(%rax)
    2574:	02 8e 00 00 00 00    	add    0x0(%rsi),%cl
    257a:	00 00                	add    %al,(%rax)
    257c:	00 00                	add    %al,(%rax)
    257e:	00 00                	add    %al,(%rax)
    2580:	5d                   	pop    %rbp
    2581:	18 18                	sbb    %bl,(%rax)
    2583:	00 02                	add    %al,(%rdx)
    2585:	8e 00                	mov    (%rax),%es
	...
    258f:	00 64 18 18          	add    %ah,0x18(%rax,%rbx,1)
    2593:	00 02                	add    %al,(%rdx)
    2595:	8e 00                	mov    (%rax),%es
	...
    259f:	00 6b 18             	add    %ch,0x18(%rbx)
    25a2:	18 00                	sbb    %al,(%rax)
    25a4:	02 8e 00 00 00 00    	add    0x0(%rsi),%cl
    25aa:	00 00                	add    %al,(%rax)
    25ac:	00 00                	add    %al,(%rax)
    25ae:	00 00                	add    %al,(%rax)
    25b0:	72 18                	jb     25ca <_locore_end+0x5ca>
    25b2:	18 00                	sbb    %al,(%rax)
    25b4:	02 8e 00 00 00 00    	add    0x0(%rsi),%cl
    25ba:	00 00                	add    %al,(%rax)
    25bc:	00 00                	add    %al,(%rax)
    25be:	00 00                	add    %al,(%rax)
    25c0:	79 18                	jns    25da <_locore_end+0x5da>
    25c2:	18 00                	sbb    %al,(%rax)
    25c4:	02 8e 00 00 00 00    	add    0x0(%rsi),%cl
    25ca:	00 00                	add    %al,(%rax)
    25cc:	00 00                	add    %al,(%rax)
    25ce:	00 00                	add    %al,(%rax)
    25d0:	80 18 18             	sbbb   $0x18,(%rax)
    25d3:	00 02                	add    %al,(%rdx)
    25d5:	8e 00                	mov    (%rax),%es
	...
    25df:	00 87 18 18 00 02    	add    %al,0x2001818(%rdi)
    25e5:	8e 00                	mov    (%rax),%es
	...
    25ef:	00 8e 18 18 00 02    	add    %cl,0x2001818(%rsi)
    25f5:	8e 00                	mov    (%rax),%es
	...
    25ff:	00 95 18 18 00 02    	add    %dl,0x2001818(%rbp)
    2605:	8e 00                	mov    (%rax),%es
	...
    260f:	00 9c 18 18 00 02 8e 	add    %bl,-0x71fdffe8(%rax,%rbx,1)
	...
    261e:	00 00                	add    %al,(%rax)
    2620:	a3 18 18 00 02 8e 00 	movabs %eax,0x8e02001818
    2627:	00 00 
    2629:	00 00                	add    %al,(%rax)
    262b:	00 00                	add    %al,(%rax)
    262d:	00 00                	add    %al,(%rax)
    262f:	00 aa 18 18 00 02    	add    %ch,0x2001818(%rdx)
    2635:	8e 00                	mov    (%rax),%es
	...
    263f:	00 b1 18 18 00 02    	add    %dh,0x2001818(%rcx)
    2645:	8e 00                	mov    (%rax),%es
	...
    264f:	00 b8 18 18 00 02    	add    %bh,0x2001818(%rax)
    2655:	8e 00                	mov    (%rax),%es
	...
    265f:	00 bf 18 18 00 02    	add    %bh,0x2001818(%rdi)
    2665:	8e 00                	mov    (%rax),%es
	...
    266f:	00 c6                	add    %al,%dh
    2671:	18 18                	sbb    %bl,(%rax)
    2673:	00 02                	add    %al,(%rdx)
    2675:	8e 00                	mov    (%rax),%es
	...
    267f:	00 cd                	add    %cl,%ch
    2681:	18 18                	sbb    %bl,(%rax)
    2683:	00 02                	add    %al,(%rdx)
    2685:	8e 00                	mov    (%rax),%es
	...
    268f:	00 d4                	add    %dl,%ah
    2691:	18 18                	sbb    %bl,(%rax)
    2693:	00 02                	add    %al,(%rdx)
    2695:	8e 00                	mov    (%rax),%es
	...
    269f:	00 db                	add    %bl,%bl
    26a1:	18 18                	sbb    %bl,(%rax)
    26a3:	00 02                	add    %al,(%rdx)
    26a5:	8e 00                	mov    (%rax),%es
	...
    26af:	00 e2                	add    %ah,%dl
    26b1:	18 18                	sbb    %bl,(%rax)
    26b3:	00 02                	add    %al,(%rdx)
    26b5:	8e 00                	mov    (%rax),%es
	...
    26bf:	00 e9                	add    %ch,%cl
    26c1:	18 18                	sbb    %bl,(%rax)
    26c3:	00 02                	add    %al,(%rdx)
    26c5:	8e 00                	mov    (%rax),%es
	...
    26cf:	00 f0                	add    %dh,%al
    26d1:	18 18                	sbb    %bl,(%rax)
    26d3:	00 02                	add    %al,(%rdx)
    26d5:	8e 00                	mov    (%rax),%es
	...
    26df:	00 f7                	add    %dh,%bh
    26e1:	18 18                	sbb    %bl,(%rax)
    26e3:	00 02                	add    %al,(%rdx)
    26e5:	8e 00                	mov    (%rax),%es
	...
    26ef:	00 fe                	add    %bh,%dh
    26f1:	18 18                	sbb    %bl,(%rax)
    26f3:	00 02                	add    %al,(%rdx)
    26f5:	8e 00                	mov    (%rax),%es
	...
    26ff:	00 05 19 18 00 02    	add    %al,0x2001819(%rip)        # 2003f1e <_end+0x191df1e>
    2705:	8e 00                	mov    (%rax),%es
	...
    270f:	00 0c 19             	add    %cl,(%rcx,%rbx,1)
    2712:	18 00                	sbb    %al,(%rax)
    2714:	02 8e 00 00 00 00    	add    0x0(%rsi),%cl
    271a:	00 00                	add    %al,(%rax)
    271c:	00 00                	add    %al,(%rax)
    271e:	00 00                	add    %al,(%rax)
    2720:	13 19                	adc    (%rcx),%ebx
    2722:	18 00                	sbb    %al,(%rax)
    2724:	02 8e 00 00 00 00    	add    0x0(%rsi),%cl
    272a:	00 00                	add    %al,(%rax)
    272c:	00 00                	add    %al,(%rax)
    272e:	00 00                	add    %al,(%rax)
    2730:	1a 19                	sbb    (%rcx),%bl
    2732:	18 00                	sbb    %al,(%rax)
    2734:	02 8e 00 00 00 00    	add    0x0(%rsi),%cl
    273a:	00 00                	add    %al,(%rax)
    273c:	00 00                	add    %al,(%rax)
    273e:	00 00                	add    %al,(%rax)
    2740:	21 19                	and    %ebx,(%rcx)
    2742:	18 00                	sbb    %al,(%rax)
    2744:	02 8e 00 00 00 00    	add    0x0(%rsi),%cl
    274a:	00 00                	add    %al,(%rax)
    274c:	00 00                	add    %al,(%rax)
    274e:	00 00                	add    %al,(%rax)
    2750:	28 19                	sub    %bl,(%rcx)
    2752:	18 00                	sbb    %al,(%rax)
    2754:	02 8e 00 00 00 00    	add    0x0(%rsi),%cl
    275a:	00 00                	add    %al,(%rax)
    275c:	00 00                	add    %al,(%rax)
    275e:	00 00                	add    %al,(%rax)
    2760:	2f                   	(bad)  
    2761:	19 18                	sbb    %ebx,(%rax)
    2763:	00 02                	add    %al,(%rdx)
    2765:	8e 00                	mov    (%rax),%es
	...
    276f:	00 36                	add    %dh,(%rsi)
    2771:	19 18                	sbb    %ebx,(%rax)
    2773:	00 02                	add    %al,(%rdx)
    2775:	8e 00                	mov    (%rax),%es
	...
    277f:	00 3d 19 18 00 02    	add    %bh,0x2001819(%rip)        # 2003f9e <_end+0x191df9e>
    2785:	8e 00                	mov    (%rax),%es
	...
    278f:	00 44 19 18          	add    %al,0x18(%rcx,%rbx,1)
    2793:	00 02                	add    %al,(%rdx)
    2795:	8e 00                	mov    (%rax),%es
	...
    279f:	00 4b 19             	add    %cl,0x19(%rbx)
    27a2:	18 00                	sbb    %al,(%rax)
    27a4:	02 8e 00 00 00 00    	add    0x0(%rsi),%cl
    27aa:	00 00                	add    %al,(%rax)
    27ac:	00 00                	add    %al,(%rax)
    27ae:	00 00                	add    %al,(%rax)
    27b0:	52                   	push   %rdx
    27b1:	19 18                	sbb    %ebx,(%rax)
    27b3:	00 02                	add    %al,(%rdx)
    27b5:	8e 00                	mov    (%rax),%es
	...
    27bf:	00 59 19             	add    %bl,0x19(%rcx)
    27c2:	18 00                	sbb    %al,(%rax)
    27c4:	02 8e 00 00 00 00    	add    0x0(%rsi),%cl
    27ca:	00 00                	add    %al,(%rax)
    27cc:	00 00                	add    %al,(%rax)
    27ce:	00 00                	add    %al,(%rax)
    27d0:	60                   	(bad)  
    27d1:	19 18                	sbb    %ebx,(%rax)
    27d3:	00 02                	add    %al,(%rdx)
    27d5:	8e 00                	mov    (%rax),%es
	...
    27df:	00 67 19             	add    %ah,0x19(%rdi)
    27e2:	18 00                	sbb    %al,(%rax)
    27e4:	02 8e 00 00 00 00    	add    0x0(%rsi),%cl
    27ea:	00 00                	add    %al,(%rax)
    27ec:	00 00                	add    %al,(%rax)
    27ee:	00 00                	add    %al,(%rax)
    27f0:	6e                   	outsb  %ds:(%rsi),(%dx)
    27f1:	19 18                	sbb    %ebx,(%rax)
    27f3:	00 02                	add    %al,(%rdx)
    27f5:	8e 00                	mov    (%rax),%es
	...
    27ff:	00 75 19             	add    %dh,0x19(%rbp)
    2802:	18 00                	sbb    %al,(%rax)
    2804:	02 8e 00 00 00 00    	add    0x0(%rsi),%cl
    280a:	00 00                	add    %al,(%rax)
    280c:	00 00                	add    %al,(%rax)
    280e:	00 00                	add    %al,(%rax)
    2810:	7c 19                	jl     282b <CONFIG_SYS_CLOCK_TICKS_PER_SEC+0x11b>
    2812:	18 00                	sbb    %al,(%rax)
    2814:	02 8e 00 00 00 00    	add    0x0(%rsi),%cl
    281a:	00 00                	add    %al,(%rax)
    281c:	00 00                	add    %al,(%rax)
    281e:	00 00                	add    %al,(%rax)
    2820:	83 19 18             	sbbl   $0x18,(%rcx)
    2823:	00 02                	add    %al,(%rdx)
    2825:	8e 00                	mov    (%rax),%es
	...
    282f:	00 8a 19 18 00 02    	add    %cl,0x2001819(%rdx)
    2835:	8e 00                	mov    (%rax),%es
	...
    283f:	00 91 19 18 00 02    	add    %dl,0x2001819(%rcx)
    2845:	8e 00                	mov    (%rax),%es
	...
    284f:	00 98 19 18 00 02    	add    %bl,0x2001819(%rax)
    2855:	8e 00                	mov    (%rax),%es
	...
    285f:	00 9f 19 18 00 02    	add    %bl,0x2001819(%rdi)
    2865:	8e 00                	mov    (%rax),%es
	...
    286f:	00 a6 19 18 00 02    	add    %ah,0x2001819(%rsi)
    2875:	8e 00                	mov    (%rax),%es
	...
    287f:	00 ad 19 18 00 02    	add    %ch,0x2001819(%rbp)
    2885:	8e 00                	mov    (%rax),%es
	...
    288f:	00 b4 19 18 00 02 8e 	add    %dh,-0x71fdffe8(%rcx,%rbx,1)
	...
    289e:	00 00                	add    %al,(%rax)
    28a0:	bb 19 18 00 02       	mov    $0x2001819,%ebx
    28a5:	8e 00                	mov    (%rax),%es
	...
    28af:	00 c2                	add    %al,%dl
    28b1:	19 18                	sbb    %ebx,(%rax)
    28b3:	00 02                	add    %al,(%rdx)
    28b5:	8e 00                	mov    (%rax),%es
	...
    28bf:	00 c9                	add    %cl,%cl
    28c1:	19 18                	sbb    %ebx,(%rax)
    28c3:	00 02                	add    %al,(%rdx)
    28c5:	8e 00                	mov    (%rax),%es
	...
    28cf:	00 d0                	add    %dl,%al
    28d1:	19 18                	sbb    %ebx,(%rax)
    28d3:	00 02                	add    %al,(%rdx)
    28d5:	8e 00                	mov    (%rax),%es
	...
    28df:	00 d7                	add    %dl,%bh
    28e1:	19 18                	sbb    %ebx,(%rax)
    28e3:	00 02                	add    %al,(%rdx)
    28e5:	8e 00                	mov    (%rax),%es
	...
    28ef:	00 de                	add    %bl,%dh
    28f1:	19 18                	sbb    %ebx,(%rax)
    28f3:	00 02                	add    %al,(%rdx)
    28f5:	8e 00                	mov    (%rax),%es
	...
    28ff:	00 e5                	add    %ah,%ch
    2901:	19 18                	sbb    %ebx,(%rax)
    2903:	00 02                	add    %al,(%rdx)
    2905:	8e 00                	mov    (%rax),%es
	...
    290f:	00 ec                	add    %ch,%ah
    2911:	19 18                	sbb    %ebx,(%rax)
    2913:	00 02                	add    %al,(%rdx)
    2915:	8e 00                	mov    (%rax),%es
	...
    291f:	00 f3                	add    %dh,%bl
    2921:	19 18                	sbb    %ebx,(%rax)
    2923:	00 02                	add    %al,(%rdx)
    2925:	8e 00                	mov    (%rax),%es
	...
    292f:	00 fa                	add    %bh,%dl
    2931:	19 18                	sbb    %ebx,(%rax)
    2933:	00 02                	add    %al,(%rdx)
    2935:	8e 00                	mov    (%rax),%es
	...
    293f:	00 01                	add    %al,(%rcx)
    2941:	1a 18                	sbb    (%rax),%bl
    2943:	00 02                	add    %al,(%rdx)
    2945:	8e 00                	mov    (%rax),%es
	...
    294f:	00 08                	add    %cl,(%rax)
    2951:	1a 18                	sbb    (%rax),%bl
    2953:	00 02                	add    %al,(%rdx)
    2955:	8e 00                	mov    (%rax),%es
	...
    295f:	00 0f                	add    %cl,(%rdi)
    2961:	1a 18                	sbb    (%rax),%bl
    2963:	00 02                	add    %al,(%rdx)
    2965:	8e 00                	mov    (%rax),%es
	...
    296f:	00 16                	add    %dl,(%rsi)
    2971:	1a 18                	sbb    (%rax),%bl
    2973:	00 02                	add    %al,(%rdx)
    2975:	8e 00                	mov    (%rax),%es
	...
    297f:	00 1d 1a 18 00 02    	add    %bl,0x200181a(%rip)        # 200419f <_end+0x191e19f>
    2985:	8e 00                	mov    (%rax),%es
	...
    298f:	00 24 1a             	add    %ah,(%rdx,%rbx,1)
    2992:	18 00                	sbb    %al,(%rax)
    2994:	02 8e 00 00 00 00    	add    0x0(%rsi),%cl
    299a:	00 00                	add    %al,(%rax)
    299c:	00 00                	add    %al,(%rax)
    299e:	00 00                	add    %al,(%rax)
    29a0:	2b 1a                	sub    (%rdx),%ebx
    29a2:	18 00                	sbb    %al,(%rax)
    29a4:	02 8e 00 00 00 00    	add    0x0(%rsi),%cl
    29aa:	00 00                	add    %al,(%rax)
    29ac:	00 00                	add    %al,(%rax)
    29ae:	00 00                	add    %al,(%rax)
    29b0:	32 1a                	xor    (%rdx),%bl
    29b2:	18 00                	sbb    %al,(%rax)
    29b4:	02 8e 00 00 00 00    	add    0x0(%rsi),%cl
    29ba:	00 00                	add    %al,(%rax)
    29bc:	00 00                	add    %al,(%rax)
    29be:	00 00                	add    %al,(%rax)
    29c0:	39 1a                	cmp    %ebx,(%rdx)
    29c2:	18 00                	sbb    %al,(%rax)
    29c4:	02 8e 00 00 00 00    	add    0x0(%rsi),%cl
    29ca:	00 00                	add    %al,(%rax)
    29cc:	00 00                	add    %al,(%rax)
    29ce:	00 00                	add    %al,(%rax)
    29d0:	40 1a 18             	sbb    (%rax),%bl
    29d3:	00 02                	add    %al,(%rdx)
    29d5:	8e 00                	mov    (%rax),%es
	...
    29df:	00 47 1a             	add    %al,0x1a(%rdi)
    29e2:	18 00                	sbb    %al,(%rax)
    29e4:	02 8e 00 00 00 00    	add    0x0(%rsi),%cl
    29ea:	00 00                	add    %al,(%rax)
    29ec:	00 00                	add    %al,(%rax)
    29ee:	00 00                	add    %al,(%rax)
    29f0:	4e 1a 18             	rex.WRX sbb (%rax),%r11b
    29f3:	00 02                	add    %al,(%rdx)
    29f5:	8e 00                	mov    (%rax),%es
	...
    29ff:	00 55 1a             	add    %dl,0x1a(%rbp)
    2a02:	18 00                	sbb    %al,(%rax)
    2a04:	02 8e 00 00 00 00    	add    0x0(%rsi),%cl
    2a0a:	00 00                	add    %al,(%rax)
    2a0c:	00 00                	add    %al,(%rax)
    2a0e:	00 00                	add    %al,(%rax)
    2a10:	5f                   	pop    %rdi
    2a11:	1a 18                	sbb    (%rax),%bl
    2a13:	00 02                	add    %al,(%rdx)
    2a15:	8e 00                	mov    (%rax),%es
	...
    2a1f:	00 69 1a             	add    %ch,0x1a(%rcx)
    2a22:	18 00                	sbb    %al,(%rax)
    2a24:	02 8e 00 00 00 00    	add    0x0(%rsi),%cl
    2a2a:	00 00                	add    %al,(%rax)
    2a2c:	00 00                	add    %al,(%rax)
    2a2e:	00 00                	add    %al,(%rax)
    2a30:	73 1a                	jae    2a4c <CONFIG_SYS_CLOCK_TICKS_PER_SEC+0x33c>
    2a32:	18 00                	sbb    %al,(%rax)
    2a34:	02 8e 00 00 00 00    	add    0x0(%rsi),%cl
    2a3a:	00 00                	add    %al,(%rax)
    2a3c:	00 00                	add    %al,(%rax)
    2a3e:	00 00                	add    %al,(%rax)
    2a40:	7d 1a                	jge    2a5c <CONFIG_SYS_CLOCK_TICKS_PER_SEC+0x34c>
    2a42:	18 00                	sbb    %al,(%rax)
    2a44:	02 8e 00 00 00 00    	add    0x0(%rsi),%cl
    2a4a:	00 00                	add    %al,(%rax)
    2a4c:	00 00                	add    %al,(%rax)
    2a4e:	00 00                	add    %al,(%rax)
    2a50:	87 1a                	xchg   %ebx,(%rdx)
    2a52:	18 00                	sbb    %al,(%rax)
    2a54:	02 8e 00 00 00 00    	add    0x0(%rsi),%cl
    2a5a:	00 00                	add    %al,(%rax)
    2a5c:	00 00                	add    %al,(%rax)
    2a5e:	00 00                	add    %al,(%rax)
    2a60:	91                   	xchg   %eax,%ecx
    2a61:	1a 18                	sbb    (%rax),%bl
    2a63:	00 02                	add    %al,(%rdx)
    2a65:	8e 00                	mov    (%rax),%es
	...
    2a6f:	00 9b 1a 18 00 02    	add    %bl,0x200181a(%rbx)
    2a75:	8e 00                	mov    (%rax),%es
	...
    2a7f:	00 a5 1a 18 00 02    	add    %ah,0x200181a(%rbp)
    2a85:	8e 00                	mov    (%rax),%es
	...
    2a8f:	00 af 1a 18 00 02    	add    %ch,0x200181a(%rdi)
    2a95:	8e 00                	mov    (%rax),%es
	...
    2a9f:	00 b9 1a 18 00 02    	add    %bh,0x200181a(%rcx)
    2aa5:	8e 00                	mov    (%rax),%es
	...
    2aaf:	00 c3                	add    %al,%bl
    2ab1:	1a 18                	sbb    (%rax),%bl
    2ab3:	00 02                	add    %al,(%rdx)
    2ab5:	8e 00                	mov    (%rax),%es
	...
    2abf:	00 cd                	add    %cl,%ch
    2ac1:	1a 18                	sbb    (%rax),%bl
    2ac3:	00 02                	add    %al,(%rdx)
    2ac5:	8e 00                	mov    (%rax),%es
	...
    2acf:	00 d7                	add    %dl,%bh
    2ad1:	1a 18                	sbb    (%rax),%bl
    2ad3:	00 02                	add    %al,(%rdx)
    2ad5:	8e 00                	mov    (%rax),%es
	...
    2adf:	00 e1                	add    %ah,%cl
    2ae1:	1a 18                	sbb    (%rax),%bl
    2ae3:	00 02                	add    %al,(%rdx)
    2ae5:	8e 00                	mov    (%rax),%es
	...
    2aef:	00 eb                	add    %ch,%bl
    2af1:	1a 18                	sbb    (%rax),%bl
    2af3:	00 02                	add    %al,(%rdx)
    2af5:	8e 00                	mov    (%rax),%es
	...
    2aff:	00 f5                	add    %dh,%ch
    2b01:	1a 18                	sbb    (%rax),%bl
    2b03:	00 02                	add    %al,(%rdx)
    2b05:	8e 00                	mov    (%rax),%es
	...
    2b0f:	00 ff                	add    %bh,%bh
    2b11:	1a 18                	sbb    (%rax),%bl
    2b13:	00 02                	add    %al,(%rdx)
    2b15:	8e 00                	mov    (%rax),%es
	...
    2b1f:	00 09                	add    %cl,(%rcx)
    2b21:	1b 18                	sbb    (%rax),%ebx
    2b23:	00 02                	add    %al,(%rdx)
    2b25:	8e 00                	mov    (%rax),%es
	...
    2b2f:	00 13                	add    %dl,(%rbx)
    2b31:	1b 18                	sbb    (%rax),%ebx
    2b33:	00 02                	add    %al,(%rdx)
    2b35:	8e 00                	mov    (%rax),%es
	...
    2b3f:	00 1d 1b 18 00 02    	add    %bl,0x200181b(%rip)        # 2004360 <_end+0x191e360>
    2b45:	8e 00                	mov    (%rax),%es
	...
    2b4f:	00 27                	add    %ah,(%rdi)
    2b51:	1b 18                	sbb    (%rax),%ebx
    2b53:	00 02                	add    %al,(%rdx)
    2b55:	8e 00                	mov    (%rax),%es
	...
    2b5f:	00 31                	add    %dh,(%rcx)
    2b61:	1b 18                	sbb    (%rax),%ebx
    2b63:	00 02                	add    %al,(%rdx)
    2b65:	8e 00                	mov    (%rax),%es
	...
    2b6f:	00 3b                	add    %bh,(%rbx)
    2b71:	1b 18                	sbb    (%rax),%ebx
    2b73:	00 02                	add    %al,(%rdx)
    2b75:	8e 00                	mov    (%rax),%es
	...
    2b7f:	00 45 1b             	add    %al,0x1b(%rbp)
    2b82:	18 00                	sbb    %al,(%rax)
    2b84:	02 8e 00 00 00 00    	add    0x0(%rsi),%cl
    2b8a:	00 00                	add    %al,(%rax)
    2b8c:	00 00                	add    %al,(%rax)
    2b8e:	00 00                	add    %al,(%rax)
    2b90:	4f 1b 18             	rex.WRXB sbb (%r8),%r11
    2b93:	00 02                	add    %al,(%rdx)
    2b95:	8e 00                	mov    (%rax),%es
	...
    2b9f:	00 59 1b             	add    %bl,0x1b(%rcx)
    2ba2:	18 00                	sbb    %al,(%rax)
    2ba4:	02 8e 00 00 00 00    	add    0x0(%rsi),%cl
    2baa:	00 00                	add    %al,(%rax)
    2bac:	00 00                	add    %al,(%rax)
    2bae:	00 00                	add    %al,(%rax)
    2bb0:	63 1b                	movsxd (%rbx),%ebx
    2bb2:	18 00                	sbb    %al,(%rax)
    2bb4:	02 8e 00 00 00 00    	add    0x0(%rsi),%cl
    2bba:	00 00                	add    %al,(%rax)
    2bbc:	00 00                	add    %al,(%rax)
    2bbe:	00 00                	add    %al,(%rax)
    2bc0:	6d                   	insl   (%dx),%es:(%rdi)
    2bc1:	1b 18                	sbb    (%rax),%ebx
    2bc3:	00 02                	add    %al,(%rdx)
    2bc5:	8e 00                	mov    (%rax),%es
	...
    2bcf:	00 77 1b             	add    %dh,0x1b(%rdi)
    2bd2:	18 00                	sbb    %al,(%rax)
    2bd4:	02 8e 00 00 00 00    	add    0x0(%rsi),%cl
    2bda:	00 00                	add    %al,(%rax)
    2bdc:	00 00                	add    %al,(%rax)
    2bde:	00 00                	add    %al,(%rax)
    2be0:	81 1b 18 00 02 8e    	sbbl   $0x8e020018,(%rbx)
	...
    2bee:	00 00                	add    %al,(%rax)
    2bf0:	8b 1b                	mov    (%rbx),%ebx
    2bf2:	18 00                	sbb    %al,(%rax)
    2bf4:	02 8e 00 00 00 00    	add    0x0(%rsi),%cl
    2bfa:	00 00                	add    %al,(%rax)
    2bfc:	00 00                	add    %al,(%rax)
    2bfe:	00 00                	add    %al,(%rax)
    2c00:	95                   	xchg   %eax,%ebp
    2c01:	1b 18                	sbb    (%rax),%ebx
    2c03:	00 02                	add    %al,(%rdx)
    2c05:	8e 00                	mov    (%rax),%es
	...
    2c0f:	00 9f 1b 18 00 02    	add    %bl,0x200181b(%rdi)
    2c15:	8e 00                	mov    (%rax),%es
	...
    2c1f:	00 a9 1b 18 00 02    	add    %ch,0x200181b(%rcx)
    2c25:	8e 00                	mov    (%rax),%es
	...
    2c2f:	00 b3 1b 18 00 02    	add    %dh,0x200181b(%rbx)
    2c35:	8e 00                	mov    (%rax),%es
	...
    2c3f:	00 bd 1b 18 00 02    	add    %bh,0x200181b(%rbp)
    2c45:	8e 00                	mov    (%rax),%es
	...
    2c4f:	00 c7                	add    %al,%bh
    2c51:	1b 18                	sbb    (%rax),%ebx
    2c53:	00 02                	add    %al,(%rdx)
    2c55:	8e 00                	mov    (%rax),%es
	...
    2c5f:	00 d1                	add    %dl,%cl
    2c61:	1b 18                	sbb    (%rax),%ebx
    2c63:	00 02                	add    %al,(%rdx)
    2c65:	8e 00                	mov    (%rax),%es
	...
    2c6f:	00 db                	add    %bl,%bl
    2c71:	1b 18                	sbb    (%rax),%ebx
    2c73:	00 02                	add    %al,(%rdx)
    2c75:	8e 00                	mov    (%rax),%es
	...
    2c7f:	00 e5                	add    %ah,%ch
    2c81:	1b 18                	sbb    (%rax),%ebx
    2c83:	00 02                	add    %al,(%rdx)
    2c85:	8e 00                	mov    (%rax),%es
	...
    2c8f:	00 ef                	add    %ch,%bh
    2c91:	1b 18                	sbb    (%rax),%ebx
    2c93:	00 02                	add    %al,(%rdx)
    2c95:	8e 00                	mov    (%rax),%es
	...
    2c9f:	00 f9                	add    %bh,%cl
    2ca1:	1b 18                	sbb    (%rax),%ebx
    2ca3:	00 02                	add    %al,(%rdx)
    2ca5:	8e 00                	mov    (%rax),%es
	...
    2caf:	00 03                	add    %al,(%rbx)
    2cb1:	1c 18                	sbb    $0x18,%al
    2cb3:	00 02                	add    %al,(%rdx)
    2cb5:	8e 00                	mov    (%rax),%es
	...
    2cbf:	00 0d 1c 18 00 02    	add    %cl,0x200181c(%rip)        # 20044e1 <_end+0x191e4e1>
    2cc5:	8e 00                	mov    (%rax),%es
	...
    2ccf:	00 17                	add    %dl,(%rdi)
    2cd1:	1c 18                	sbb    $0x18,%al
    2cd3:	00 02                	add    %al,(%rdx)
    2cd5:	8e 00                	mov    (%rax),%es
	...
    2cdf:	00 21                	add    %ah,(%rcx)
    2ce1:	1c 18                	sbb    $0x18,%al
    2ce3:	00 02                	add    %al,(%rdx)
    2ce5:	8e 00                	mov    (%rax),%es
	...
    2cef:	00 2b                	add    %ch,(%rbx)
    2cf1:	1c 18                	sbb    $0x18,%al
    2cf3:	00 02                	add    %al,(%rdx)
    2cf5:	8e 00                	mov    (%rax),%es
	...
    2cff:	00 35 1c 18 00 02    	add    %dh,0x200181c(%rip)        # 2004521 <_end+0x191e521>
    2d05:	8e 00                	mov    (%rax),%es
	...
    2d0f:	00 3f                	add    %bh,(%rdi)
    2d11:	1c 18                	sbb    $0x18,%al
    2d13:	00 02                	add    %al,(%rdx)
    2d15:	8e 00                	mov    (%rax),%es
	...
    2d1f:	00 49 1c             	add    %cl,0x1c(%rcx)
    2d22:	18 00                	sbb    %al,(%rax)
    2d24:	02 8e 00 00 00 00    	add    0x0(%rsi),%cl
    2d2a:	00 00                	add    %al,(%rax)
    2d2c:	00 00                	add    %al,(%rax)
    2d2e:	00 00                	add    %al,(%rax)
    2d30:	53                   	push   %rbx
    2d31:	1c 18                	sbb    $0x18,%al
    2d33:	00 02                	add    %al,(%rdx)
    2d35:	8e 00                	mov    (%rax),%es
	...
    2d3f:	00 5d 1c             	add    %bl,0x1c(%rbp)
    2d42:	18 00                	sbb    %al,(%rax)
    2d44:	02 8e 00 00 00 00    	add    0x0(%rsi),%cl
    2d4a:	00 00                	add    %al,(%rax)
    2d4c:	00 00                	add    %al,(%rax)
    2d4e:	00 00                	add    %al,(%rax)
    2d50:	67 1c 18             	addr32 sbb $0x18,%al
    2d53:	00 02                	add    %al,(%rdx)
    2d55:	8e 00                	mov    (%rax),%es
	...
    2d5f:	00 71 1c             	add    %dh,0x1c(%rcx)
    2d62:	18 00                	sbb    %al,(%rax)
    2d64:	02 8e 00 00 00 00    	add    0x0(%rsi),%cl
    2d6a:	00 00                	add    %al,(%rax)
    2d6c:	00 00                	add    %al,(%rax)
    2d6e:	00 00                	add    %al,(%rax)
    2d70:	7b 1c                	jnp    2d8e <CONFIG_SYS_CLOCK_TICKS_PER_SEC+0x67e>
    2d72:	18 00                	sbb    %al,(%rax)
    2d74:	02 8e 00 00 00 00    	add    0x0(%rsi),%cl
    2d7a:	00 00                	add    %al,(%rax)
    2d7c:	00 00                	add    %al,(%rax)
    2d7e:	00 00                	add    %al,(%rax)
    2d80:	85 1c 18             	test   %ebx,(%rax,%rbx,1)
    2d83:	00 02                	add    %al,(%rdx)
    2d85:	8e 00                	mov    (%rax),%es
	...
    2d8f:	00 8f 1c 18 00 02    	add    %cl,0x200181c(%rdi)
    2d95:	8e 00                	mov    (%rax),%es
	...
    2d9f:	00 99 1c 18 00 02    	add    %bl,0x200181c(%rcx)
    2da5:	8e 00                	mov    (%rax),%es
	...
    2daf:	00 a3 1c 18 00 02    	add    %ah,0x200181c(%rbx)
    2db5:	8e 00                	mov    (%rax),%es
	...
    2dbf:	00 ad 1c 18 00 02    	add    %ch,0x200181c(%rbp)
    2dc5:	8e 00                	mov    (%rax),%es
	...
    2dcf:	00 b7 1c 18 00 02    	add    %dh,0x200181c(%rdi)
    2dd5:	8e 00                	mov    (%rax),%es
	...
    2ddf:	00 c1                	add    %al,%cl
    2de1:	1c 18                	sbb    $0x18,%al
    2de3:	00 02                	add    %al,(%rdx)
    2de5:	8e 00                	mov    (%rax),%es
	...
    2def:	00 cb                	add    %cl,%bl
    2df1:	1c 18                	sbb    $0x18,%al
    2df3:	00 02                	add    %al,(%rdx)
    2df5:	8e 00                	mov    (%rax),%es
	...
    2dff:	00 d5                	add    %dl,%ch
    2e01:	1c 18                	sbb    $0x18,%al
    2e03:	00 02                	add    %al,(%rdx)
    2e05:	8e 00                	mov    (%rax),%es
	...
    2e0f:	00 df                	add    %bl,%bh
    2e11:	1c 18                	sbb    $0x18,%al
    2e13:	00 02                	add    %al,(%rdx)
    2e15:	8e 00                	mov    (%rax),%es
	...
    2e1f:	00 e9                	add    %ch,%cl
    2e21:	1c 18                	sbb    $0x18,%al
    2e23:	00 02                	add    %al,(%rdx)
    2e25:	8e 00                	mov    (%rax),%es
	...
    2e2f:	00 f3                	add    %dh,%bl
    2e31:	1c 18                	sbb    $0x18,%al
    2e33:	00 02                	add    %al,(%rdx)
    2e35:	8e 00                	mov    (%rax),%es
	...
    2e3f:	00 fd                	add    %bh,%ch
    2e41:	1c 18                	sbb    $0x18,%al
    2e43:	00 02                	add    %al,(%rdx)
    2e45:	8e 00                	mov    (%rax),%es
	...
    2e4f:	00 07                	add    %al,(%rdi)
    2e51:	1d 18 00 02 8e       	sbb    $0x8e020018,%eax
	...
    2e5e:	00 00                	add    %al,(%rax)
    2e60:	11 1d 18 00 02 8e    	adc    %ebx,-0x71fdffe8(%rip)        # ffffffff8e022e7e <CONFIG_LOAPIC_BASE_ADDRESS+0xfffffffe8f222e7e>
	...
    2e6e:	00 00                	add    %al,(%rax)
    2e70:	1b 1d 18 00 02 8e    	sbb    -0x71fdffe8(%rip),%ebx        # ffffffff8e022e8e <CONFIG_LOAPIC_BASE_ADDRESS+0xfffffffe8f222e8e>
	...
    2e7e:	00 00                	add    %al,(%rax)
    2e80:	25 1d 18 00 02       	and    $0x200181d,%eax
    2e85:	8e 00                	mov    (%rax),%es
	...
    2e8f:	00 2f                	add    %ch,(%rdi)
    2e91:	1d 18 00 02 8e       	sbb    $0x8e020018,%eax
	...
    2e9e:	00 00                	add    %al,(%rax)
    2ea0:	39 1d 18 00 02 8e    	cmp    %ebx,-0x71fdffe8(%rip)        # ffffffff8e022ebe <CONFIG_LOAPIC_BASE_ADDRESS+0xfffffffe8f222ebe>
	...
    2eae:	00 00                	add    %al,(%rax)
    2eb0:	43 1d 18 00 02 8e    	rex.XB sbb $0x8e020018,%eax
	...
    2ebe:	00 00                	add    %al,(%rax)
    2ec0:	4d 1d 18 00 02 8e    	rex.WRB sbb $0xffffffff8e020018,%rax
	...
    2ece:	00 00                	add    %al,(%rax)
    2ed0:	57                   	push   %rdi
    2ed1:	1d 18 00 02 8e       	sbb    $0x8e020018,%eax
	...
    2ede:	00 00                	add    %al,(%rax)
    2ee0:	61                   	(bad)  
    2ee1:	1d 18 00 02 8e       	sbb    $0x8e020018,%eax
	...
    2eee:	00 00                	add    %al,(%rax)
    2ef0:	6b 1d 18 00 02 8e 00 	imul   $0x0,-0x71fdffe8(%rip),%ebx        # ffffffff8e022f0f <CONFIG_LOAPIC_BASE_ADDRESS+0xfffffffe8f222f0f>
	...
    2eff:	00 75 1d             	add    %dh,0x1d(%rbp)
    2f02:	18 00                	sbb    %al,(%rax)
    2f04:	02 8e 00 00 00 00    	add    0x0(%rsi),%cl
    2f0a:	00 00                	add    %al,(%rax)
    2f0c:	00 00                	add    %al,(%rax)
    2f0e:	00 00                	add    %al,(%rax)
    2f10:	7f 1d                	jg     2f2f <CONFIG_SYS_CLOCK_TICKS_PER_SEC+0x81f>
    2f12:	18 00                	sbb    %al,(%rax)
    2f14:	02 8e 00 00 00 00    	add    0x0(%rsi),%cl
    2f1a:	00 00                	add    %al,(%rax)
    2f1c:	00 00                	add    %al,(%rax)
    2f1e:	00 00                	add    %al,(%rax)
    2f20:	89 1d 18 00 02 8e    	mov    %ebx,-0x71fdffe8(%rip)        # ffffffff8e022f3e <CONFIG_LOAPIC_BASE_ADDRESS+0xfffffffe8f222f3e>
	...
    2f2e:	00 00                	add    %al,(%rax)
    2f30:	93                   	xchg   %eax,%ebx
    2f31:	1d 18 00 02 8e       	sbb    $0x8e020018,%eax
	...
    2f3e:	00 00                	add    %al,(%rax)
    2f40:	9d                   	popfq  
    2f41:	1d 18 00 02 8e       	sbb    $0x8e020018,%eax
	...
    2f4e:	00 00                	add    %al,(%rax)
    2f50:	a7                   	cmpsl  %es:(%rdi),%ds:(%rsi)
    2f51:	1d 18 00 02 8e       	sbb    $0x8e020018,%eax
	...
    2f5e:	00 00                	add    %al,(%rax)
    2f60:	b1 1d                	mov    $0x1d,%cl
    2f62:	18 00                	sbb    %al,(%rax)
    2f64:	02 8e 00 00 00 00    	add    0x0(%rsi),%cl
    2f6a:	00 00                	add    %al,(%rax)
    2f6c:	00 00                	add    %al,(%rax)
    2f6e:	00 00                	add    %al,(%rax)
    2f70:	bb 1d 18 00 02       	mov    $0x200181d,%ebx
    2f75:	8e 00                	mov    (%rax),%es
	...
    2f7f:	00 c5                	add    %al,%ch
    2f81:	1d 18 00 02 8e       	sbb    $0x8e020018,%eax
	...
    2f8e:	00 00                	add    %al,(%rax)
    2f90:	cf                   	iret   
    2f91:	1d 18 00 02 8e       	sbb    $0x8e020018,%eax
	...
    2f9e:	00 00                	add    %al,(%rax)
    2fa0:	d9 1d 18 00 02 8e    	fstps  -0x71fdffe8(%rip)        # ffffffff8e022fbe <CONFIG_LOAPIC_BASE_ADDRESS+0xfffffffe8f222fbe>
	...
    2fae:	00 00                	add    %al,(%rax)
    2fb0:	e3 1d                	jrcxz  2fcf <CONFIG_SYS_CLOCK_TICKS_PER_SEC+0x8bf>
    2fb2:	18 00                	sbb    %al,(%rax)
    2fb4:	02 8e 00 00 00 00    	add    0x0(%rsi),%cl
    2fba:	00 00                	add    %al,(%rax)
    2fbc:	00 00                	add    %al,(%rax)
    2fbe:	00 00                	add    %al,(%rax)
    2fc0:	ed                   	in     (%dx),%eax
    2fc1:	1d 18 00 02 8e       	sbb    $0x8e020018,%eax
	...
    2fce:	00 00                	add    %al,(%rax)
    2fd0:	f7 1d 18 00 02 8e    	negl   -0x71fdffe8(%rip)        # ffffffff8e022fee <CONFIG_LOAPIC_BASE_ADDRESS+0xfffffffe8f222fee>
	...
    2fde:	00 00                	add    %al,(%rax)
    2fe0:	01 1e                	add    %ebx,(%rsi)
    2fe2:	18 00                	sbb    %al,(%rax)
    2fe4:	02 8e 00 00 00 00    	add    0x0(%rsi),%cl
    2fea:	00 00                	add    %al,(%rax)
    2fec:	00 00                	add    %al,(%rax)
    2fee:	00 00                	add    %al,(%rax)
    2ff0:	0b 1e                	or     (%rsi),%ebx
    2ff2:	18 00                	sbb    %al,(%rax)
    2ff4:	02 8e 00 00 00 00    	add    0x0(%rsi),%cl
    2ffa:	00 00                	add    %al,(%rax)
    2ffc:	00 00                	add    %al,(%rax)
	...

0000000000003000 <idt48>:
    3000:	ff 0f                	decl   (%rdi)
    3002:	00 20                	add    %ah,(%rax)
	...

0000000000003006 <idt80>:
    3006:	ff 0f                	decl   (%rdi)
    3008:	00 20                	add    %ah,(%rax)
    300a:	00 00                	add    %al,(%rax)
    300c:	00 00                	add    %al,(%rax)
    300e:	00 00                	add    %al,(%rax)
    3010:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3017:	00 00 00 
    301a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3021:	00 00 00 
    3024:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    302b:	00 00 00 
    302e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3035:	00 00 00 
    3038:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    303f:	00 00 00 
    3042:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3049:	00 00 00 
    304c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3053:	00 00 00 
    3056:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    305d:	00 00 00 
    3060:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3067:	00 00 00 
    306a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3071:	00 00 00 
    3074:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    307b:	00 00 00 
    307e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3085:	00 00 00 
    3088:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    308f:	00 00 00 
    3092:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3099:	00 00 00 
    309c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    30a3:	00 00 00 
    30a6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    30ad:	00 00 00 
    30b0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    30b7:	00 00 00 
    30ba:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    30c1:	00 00 00 
    30c4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    30cb:	00 00 00 
    30ce:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    30d5:	00 00 00 
    30d8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    30df:	00 00 00 
    30e2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    30e9:	00 00 00 
    30ec:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    30f3:	00 00 00 
    30f6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    30fd:	00 00 00 
    3100:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3107:	00 00 00 
    310a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3111:	00 00 00 
    3114:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    311b:	00 00 00 
    311e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3125:	00 00 00 
    3128:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    312f:	00 00 00 
    3132:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3139:	00 00 00 
    313c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3143:	00 00 00 
    3146:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    314d:	00 00 00 
    3150:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3157:	00 00 00 
    315a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3161:	00 00 00 
    3164:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    316b:	00 00 00 
    316e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3175:	00 00 00 
    3178:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    317f:	00 00 00 
    3182:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3189:	00 00 00 
    318c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3193:	00 00 00 
    3196:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    319d:	00 00 00 
    31a0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    31a7:	00 00 00 
    31aa:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    31b1:	00 00 00 
    31b4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    31bb:	00 00 00 
    31be:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    31c5:	00 00 00 
    31c8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    31cf:	00 00 00 
    31d2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    31d9:	00 00 00 
    31dc:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    31e3:	00 00 00 
    31e6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    31ed:	00 00 00 
    31f0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    31f7:	00 00 00 
    31fa:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3201:	00 00 00 
    3204:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    320b:	00 00 00 
    320e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3215:	00 00 00 
    3218:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    321f:	00 00 00 
    3222:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3229:	00 00 00 
    322c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3233:	00 00 00 
    3236:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    323d:	00 00 00 
    3240:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3247:	00 00 00 
    324a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3251:	00 00 00 
    3254:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    325b:	00 00 00 
    325e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3265:	00 00 00 
    3268:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    326f:	00 00 00 
    3272:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3279:	00 00 00 
    327c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3283:	00 00 00 
    3286:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    328d:	00 00 00 
    3290:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3297:	00 00 00 
    329a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    32a1:	00 00 00 
    32a4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    32ab:	00 00 00 
    32ae:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    32b5:	00 00 00 
    32b8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    32bf:	00 00 00 
    32c2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    32c9:	00 00 00 
    32cc:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    32d3:	00 00 00 
    32d6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    32dd:	00 00 00 
    32e0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    32e7:	00 00 00 
    32ea:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    32f1:	00 00 00 
    32f4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    32fb:	00 00 00 
    32fe:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3305:	00 00 00 
    3308:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    330f:	00 00 00 
    3312:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3319:	00 00 00 
    331c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3323:	00 00 00 
    3326:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    332d:	00 00 00 
    3330:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3337:	00 00 00 
    333a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3341:	00 00 00 
    3344:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    334b:	00 00 00 
    334e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3355:	00 00 00 
    3358:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    335f:	00 00 00 
    3362:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3369:	00 00 00 
    336c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3373:	00 00 00 
    3376:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    337d:	00 00 00 
    3380:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3387:	00 00 00 
    338a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3391:	00 00 00 
    3394:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    339b:	00 00 00 
    339e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    33a5:	00 00 00 
    33a8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    33af:	00 00 00 
    33b2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    33b9:	00 00 00 
    33bc:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    33c3:	00 00 00 
    33c6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    33cd:	00 00 00 
    33d0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    33d7:	00 00 00 
    33da:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    33e1:	00 00 00 
    33e4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    33eb:	00 00 00 
    33ee:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    33f5:	00 00 00 
    33f8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    33ff:	00 00 00 
    3402:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3409:	00 00 00 
    340c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3413:	00 00 00 
    3416:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    341d:	00 00 00 
    3420:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3427:	00 00 00 
    342a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3431:	00 00 00 
    3434:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    343b:	00 00 00 
    343e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3445:	00 00 00 
    3448:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    344f:	00 00 00 
    3452:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3459:	00 00 00 
    345c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3463:	00 00 00 
    3466:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    346d:	00 00 00 
    3470:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3477:	00 00 00 
    347a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3481:	00 00 00 
    3484:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    348b:	00 00 00 
    348e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3495:	00 00 00 
    3498:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    349f:	00 00 00 
    34a2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    34a9:	00 00 00 
    34ac:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    34b3:	00 00 00 
    34b6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    34bd:	00 00 00 
    34c0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    34c7:	00 00 00 
    34ca:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    34d1:	00 00 00 
    34d4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    34db:	00 00 00 
    34de:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    34e5:	00 00 00 
    34e8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    34ef:	00 00 00 
    34f2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    34f9:	00 00 00 
    34fc:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3503:	00 00 00 
    3506:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    350d:	00 00 00 
    3510:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3517:	00 00 00 
    351a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3521:	00 00 00 
    3524:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    352b:	00 00 00 
    352e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3535:	00 00 00 
    3538:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    353f:	00 00 00 
    3542:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3549:	00 00 00 
    354c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3553:	00 00 00 
    3556:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    355d:	00 00 00 
    3560:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3567:	00 00 00 
    356a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3571:	00 00 00 
    3574:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    357b:	00 00 00 
    357e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3585:	00 00 00 
    3588:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    358f:	00 00 00 
    3592:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3599:	00 00 00 
    359c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    35a3:	00 00 00 
    35a6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    35ad:	00 00 00 
    35b0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    35b7:	00 00 00 
    35ba:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    35c1:	00 00 00 
    35c4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    35cb:	00 00 00 
    35ce:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    35d5:	00 00 00 
    35d8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    35df:	00 00 00 
    35e2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    35e9:	00 00 00 
    35ec:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    35f3:	00 00 00 
    35f6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    35fd:	00 00 00 
    3600:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3607:	00 00 00 
    360a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3611:	00 00 00 
    3614:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    361b:	00 00 00 
    361e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3625:	00 00 00 
    3628:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    362f:	00 00 00 
    3632:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3639:	00 00 00 
    363c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3643:	00 00 00 
    3646:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    364d:	00 00 00 
    3650:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3657:	00 00 00 
    365a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3661:	00 00 00 
    3664:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    366b:	00 00 00 
    366e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3675:	00 00 00 
    3678:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    367f:	00 00 00 
    3682:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3689:	00 00 00 
    368c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3693:	00 00 00 
    3696:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    369d:	00 00 00 
    36a0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    36a7:	00 00 00 
    36aa:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    36b1:	00 00 00 
    36b4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    36bb:	00 00 00 
    36be:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    36c5:	00 00 00 
    36c8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    36cf:	00 00 00 
    36d2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    36d9:	00 00 00 
    36dc:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    36e3:	00 00 00 
    36e6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    36ed:	00 00 00 
    36f0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    36f7:	00 00 00 
    36fa:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3701:	00 00 00 
    3704:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    370b:	00 00 00 
    370e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3715:	00 00 00 
    3718:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    371f:	00 00 00 
    3722:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3729:	00 00 00 
    372c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3733:	00 00 00 
    3736:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    373d:	00 00 00 
    3740:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3747:	00 00 00 
    374a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3751:	00 00 00 
    3754:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    375b:	00 00 00 
    375e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3765:	00 00 00 
    3768:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    376f:	00 00 00 
    3772:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3779:	00 00 00 
    377c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3783:	00 00 00 
    3786:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    378d:	00 00 00 
    3790:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3797:	00 00 00 
    379a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    37a1:	00 00 00 
    37a4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    37ab:	00 00 00 
    37ae:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    37b5:	00 00 00 
    37b8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    37bf:	00 00 00 
    37c2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    37c9:	00 00 00 
    37cc:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    37d3:	00 00 00 
    37d6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    37dd:	00 00 00 
    37e0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    37e7:	00 00 00 
    37ea:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    37f1:	00 00 00 
    37f4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    37fb:	00 00 00 
    37fe:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3805:	00 00 00 
    3808:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    380f:	00 00 00 
    3812:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3819:	00 00 00 
    381c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3823:	00 00 00 
    3826:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    382d:	00 00 00 
    3830:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3837:	00 00 00 
    383a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3841:	00 00 00 
    3844:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    384b:	00 00 00 
    384e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3855:	00 00 00 
    3858:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    385f:	00 00 00 
    3862:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3869:	00 00 00 
    386c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3873:	00 00 00 
    3876:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    387d:	00 00 00 
    3880:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3887:	00 00 00 
    388a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3891:	00 00 00 
    3894:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    389b:	00 00 00 
    389e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    38a5:	00 00 00 
    38a8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    38af:	00 00 00 
    38b2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    38b9:	00 00 00 
    38bc:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    38c3:	00 00 00 
    38c6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    38cd:	00 00 00 
    38d0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    38d7:	00 00 00 
    38da:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    38e1:	00 00 00 
    38e4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    38eb:	00 00 00 
    38ee:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    38f5:	00 00 00 
    38f8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    38ff:	00 00 00 
    3902:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3909:	00 00 00 
    390c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3913:	00 00 00 
    3916:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    391d:	00 00 00 
    3920:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3927:	00 00 00 
    392a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3931:	00 00 00 
    3934:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    393b:	00 00 00 
    393e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3945:	00 00 00 
    3948:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    394f:	00 00 00 
    3952:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3959:	00 00 00 
    395c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3963:	00 00 00 
    3966:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    396d:	00 00 00 
    3970:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3977:	00 00 00 
    397a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3981:	00 00 00 
    3984:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    398b:	00 00 00 
    398e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3995:	00 00 00 
    3998:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    399f:	00 00 00 
    39a2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    39a9:	00 00 00 
    39ac:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    39b3:	00 00 00 
    39b6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    39bd:	00 00 00 
    39c0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    39c7:	00 00 00 
    39ca:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    39d1:	00 00 00 
    39d4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    39db:	00 00 00 
    39de:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    39e5:	00 00 00 
    39e8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    39ef:	00 00 00 
    39f2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    39f9:	00 00 00 
    39fc:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3a03:	00 00 00 
    3a06:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3a0d:	00 00 00 
    3a10:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3a17:	00 00 00 
    3a1a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3a21:	00 00 00 
    3a24:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3a2b:	00 00 00 
    3a2e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3a35:	00 00 00 
    3a38:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3a3f:	00 00 00 
    3a42:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3a49:	00 00 00 
    3a4c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3a53:	00 00 00 
    3a56:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3a5d:	00 00 00 
    3a60:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3a67:	00 00 00 
    3a6a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3a71:	00 00 00 
    3a74:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3a7b:	00 00 00 
    3a7e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3a85:	00 00 00 
    3a88:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3a8f:	00 00 00 
    3a92:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3a99:	00 00 00 
    3a9c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3aa3:	00 00 00 
    3aa6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3aad:	00 00 00 
    3ab0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3ab7:	00 00 00 
    3aba:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3ac1:	00 00 00 
    3ac4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3acb:	00 00 00 
    3ace:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3ad5:	00 00 00 
    3ad8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3adf:	00 00 00 
    3ae2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3ae9:	00 00 00 
    3aec:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3af3:	00 00 00 
    3af6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3afd:	00 00 00 
    3b00:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3b07:	00 00 00 
    3b0a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3b11:	00 00 00 
    3b14:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3b1b:	00 00 00 
    3b1e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3b25:	00 00 00 
    3b28:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3b2f:	00 00 00 
    3b32:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3b39:	00 00 00 
    3b3c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3b43:	00 00 00 
    3b46:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3b4d:	00 00 00 
    3b50:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3b57:	00 00 00 
    3b5a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3b61:	00 00 00 
    3b64:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3b6b:	00 00 00 
    3b6e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3b75:	00 00 00 
    3b78:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3b7f:	00 00 00 
    3b82:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3b89:	00 00 00 
    3b8c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3b93:	00 00 00 
    3b96:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3b9d:	00 00 00 
    3ba0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3ba7:	00 00 00 
    3baa:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3bb1:	00 00 00 
    3bb4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3bbb:	00 00 00 
    3bbe:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3bc5:	00 00 00 
    3bc8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3bcf:	00 00 00 
    3bd2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3bd9:	00 00 00 
    3bdc:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3be3:	00 00 00 
    3be6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3bed:	00 00 00 
    3bf0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3bf7:	00 00 00 
    3bfa:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3c01:	00 00 00 
    3c04:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3c0b:	00 00 00 
    3c0e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3c15:	00 00 00 
    3c18:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3c1f:	00 00 00 
    3c22:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3c29:	00 00 00 
    3c2c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3c33:	00 00 00 
    3c36:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3c3d:	00 00 00 
    3c40:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3c47:	00 00 00 
    3c4a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3c51:	00 00 00 
    3c54:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3c5b:	00 00 00 
    3c5e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3c65:	00 00 00 
    3c68:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3c6f:	00 00 00 
    3c72:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3c79:	00 00 00 
    3c7c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3c83:	00 00 00 
    3c86:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3c8d:	00 00 00 
    3c90:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3c97:	00 00 00 
    3c9a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3ca1:	00 00 00 
    3ca4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3cab:	00 00 00 
    3cae:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3cb5:	00 00 00 
    3cb8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3cbf:	00 00 00 
    3cc2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3cc9:	00 00 00 
    3ccc:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3cd3:	00 00 00 
    3cd6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3cdd:	00 00 00 
    3ce0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3ce7:	00 00 00 
    3cea:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3cf1:	00 00 00 
    3cf4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3cfb:	00 00 00 
    3cfe:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3d05:	00 00 00 
    3d08:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3d0f:	00 00 00 
    3d12:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3d19:	00 00 00 
    3d1c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3d23:	00 00 00 
    3d26:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3d2d:	00 00 00 
    3d30:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3d37:	00 00 00 
    3d3a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3d41:	00 00 00 
    3d44:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3d4b:	00 00 00 
    3d4e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3d55:	00 00 00 
    3d58:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3d5f:	00 00 00 
    3d62:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3d69:	00 00 00 
    3d6c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3d73:	00 00 00 
    3d76:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3d7d:	00 00 00 
    3d80:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3d87:	00 00 00 
    3d8a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3d91:	00 00 00 
    3d94:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3d9b:	00 00 00 
    3d9e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3da5:	00 00 00 
    3da8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3daf:	00 00 00 
    3db2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3db9:	00 00 00 
    3dbc:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3dc3:	00 00 00 
    3dc6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3dcd:	00 00 00 
    3dd0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3dd7:	00 00 00 
    3dda:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3de1:	00 00 00 
    3de4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3deb:	00 00 00 
    3dee:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3df5:	00 00 00 
    3df8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3dff:	00 00 00 
    3e02:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3e09:	00 00 00 
    3e0c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3e13:	00 00 00 
    3e16:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3e1d:	00 00 00 
    3e20:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3e27:	00 00 00 
    3e2a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3e31:	00 00 00 
    3e34:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3e3b:	00 00 00 
    3e3e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3e45:	00 00 00 
    3e48:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3e4f:	00 00 00 
    3e52:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3e59:	00 00 00 
    3e5c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3e63:	00 00 00 
    3e66:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3e6d:	00 00 00 
    3e70:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3e77:	00 00 00 
    3e7a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3e81:	00 00 00 
    3e84:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3e8b:	00 00 00 
    3e8e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3e95:	00 00 00 
    3e98:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3e9f:	00 00 00 
    3ea2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3ea9:	00 00 00 
    3eac:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3eb3:	00 00 00 
    3eb6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3ebd:	00 00 00 
    3ec0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3ec7:	00 00 00 
    3eca:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3ed1:	00 00 00 
    3ed4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3edb:	00 00 00 
    3ede:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3ee5:	00 00 00 
    3ee8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3eef:	00 00 00 
    3ef2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3ef9:	00 00 00 
    3efc:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3f03:	00 00 00 
    3f06:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3f0d:	00 00 00 
    3f10:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3f17:	00 00 00 
    3f1a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3f21:	00 00 00 
    3f24:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3f2b:	00 00 00 
    3f2e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3f35:	00 00 00 
    3f38:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3f3f:	00 00 00 
    3f42:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3f49:	00 00 00 
    3f4c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3f53:	00 00 00 
    3f56:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3f5d:	00 00 00 
    3f60:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3f67:	00 00 00 
    3f6a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3f71:	00 00 00 
    3f74:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3f7b:	00 00 00 
    3f7e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3f85:	00 00 00 
    3f88:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3f8f:	00 00 00 
    3f92:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3f99:	00 00 00 
    3f9c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3fa3:	00 00 00 
    3fa6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3fad:	00 00 00 
    3fb0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3fb7:	00 00 00 
    3fba:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3fc1:	00 00 00 
    3fc4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3fcb:	00 00 00 
    3fce:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3fd5:	00 00 00 
    3fd8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3fdf:	00 00 00 
    3fe2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3fe9:	00 00 00 
    3fec:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3ff3:	00 00 00 
    3ff6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3ffd:	00 00 00 

0000000000004000 <_lodata_start>:
    4000:	aa                   	stos   %al,%es:(%rdi)
    4001:	aa                   	stos   %al,%es:(%rdi)
    4002:	aa                   	stos   %al,%es:(%rdi)
    4003:	aa                   	stos   %al,%es:(%rdi)
    4004:	aa                   	stos   %al,%es:(%rdi)
    4005:	aa                   	stos   %al,%es:(%rdi)
    4006:	aa                   	stos   %al,%es:(%rdi)
    4007:	aa                   	stos   %al,%es:(%rdi)
    4008:	aa                   	stos   %al,%es:(%rdi)
    4009:	aa                   	stos   %al,%es:(%rdi)
    400a:	aa                   	stos   %al,%es:(%rdi)
    400b:	aa                   	stos   %al,%es:(%rdi)
    400c:	aa                   	stos   %al,%es:(%rdi)
    400d:	aa                   	stos   %al,%es:(%rdi)
    400e:	aa                   	stos   %al,%es:(%rdi)
    400f:	aa                   	stos   %al,%es:(%rdi)
    4010:	aa                   	stos   %al,%es:(%rdi)
    4011:	aa                   	stos   %al,%es:(%rdi)
    4012:	aa                   	stos   %al,%es:(%rdi)
    4013:	aa                   	stos   %al,%es:(%rdi)
    4014:	aa                   	stos   %al,%es:(%rdi)
    4015:	aa                   	stos   %al,%es:(%rdi)
    4016:	aa                   	stos   %al,%es:(%rdi)
    4017:	aa                   	stos   %al,%es:(%rdi)
    4018:	aa                   	stos   %al,%es:(%rdi)
    4019:	aa                   	stos   %al,%es:(%rdi)
    401a:	aa                   	stos   %al,%es:(%rdi)
    401b:	aa                   	stos   %al,%es:(%rdi)
    401c:	aa                   	stos   %al,%es:(%rdi)
    401d:	aa                   	stos   %al,%es:(%rdi)
    401e:	aa                   	stos   %al,%es:(%rdi)
    401f:	aa                   	stos   %al,%es:(%rdi)
    4020:	aa                   	stos   %al,%es:(%rdi)
    4021:	aa                   	stos   %al,%es:(%rdi)
    4022:	aa                   	stos   %al,%es:(%rdi)
    4023:	aa                   	stos   %al,%es:(%rdi)
    4024:	aa                   	stos   %al,%es:(%rdi)
    4025:	aa                   	stos   %al,%es:(%rdi)
    4026:	aa                   	stos   %al,%es:(%rdi)
    4027:	aa                   	stos   %al,%es:(%rdi)
    4028:	aa                   	stos   %al,%es:(%rdi)
    4029:	aa                   	stos   %al,%es:(%rdi)
    402a:	aa                   	stos   %al,%es:(%rdi)
    402b:	aa                   	stos   %al,%es:(%rdi)
    402c:	aa                   	stos   %al,%es:(%rdi)
    402d:	aa                   	stos   %al,%es:(%rdi)
    402e:	aa                   	stos   %al,%es:(%rdi)
    402f:	aa                   	stos   %al,%es:(%rdi)
    4030:	aa                   	stos   %al,%es:(%rdi)
    4031:	aa                   	stos   %al,%es:(%rdi)
    4032:	aa                   	stos   %al,%es:(%rdi)
    4033:	aa                   	stos   %al,%es:(%rdi)
    4034:	aa                   	stos   %al,%es:(%rdi)
    4035:	aa                   	stos   %al,%es:(%rdi)
    4036:	aa                   	stos   %al,%es:(%rdi)
    4037:	aa                   	stos   %al,%es:(%rdi)
    4038:	aa                   	stos   %al,%es:(%rdi)
    4039:	aa                   	stos   %al,%es:(%rdi)
    403a:	aa                   	stos   %al,%es:(%rdi)
    403b:	aa                   	stos   %al,%es:(%rdi)
    403c:	aa                   	stos   %al,%es:(%rdi)
    403d:	aa                   	stos   %al,%es:(%rdi)
    403e:	aa                   	stos   %al,%es:(%rdi)
    403f:	aa                   	stos   %al,%es:(%rdi)
    4040:	aa                   	stos   %al,%es:(%rdi)
    4041:	aa                   	stos   %al,%es:(%rdi)
    4042:	aa                   	stos   %al,%es:(%rdi)
    4043:	aa                   	stos   %al,%es:(%rdi)
    4044:	aa                   	stos   %al,%es:(%rdi)
    4045:	aa                   	stos   %al,%es:(%rdi)
    4046:	aa                   	stos   %al,%es:(%rdi)
    4047:	aa                   	stos   %al,%es:(%rdi)
    4048:	aa                   	stos   %al,%es:(%rdi)
    4049:	aa                   	stos   %al,%es:(%rdi)
    404a:	aa                   	stos   %al,%es:(%rdi)
    404b:	aa                   	stos   %al,%es:(%rdi)
    404c:	aa                   	stos   %al,%es:(%rdi)
    404d:	aa                   	stos   %al,%es:(%rdi)
    404e:	aa                   	stos   %al,%es:(%rdi)
    404f:	aa                   	stos   %al,%es:(%rdi)
    4050:	aa                   	stos   %al,%es:(%rdi)
    4051:	aa                   	stos   %al,%es:(%rdi)
    4052:	aa                   	stos   %al,%es:(%rdi)
    4053:	aa                   	stos   %al,%es:(%rdi)
    4054:	aa                   	stos   %al,%es:(%rdi)
    4055:	aa                   	stos   %al,%es:(%rdi)
    4056:	aa                   	stos   %al,%es:(%rdi)
    4057:	aa                   	stos   %al,%es:(%rdi)
    4058:	aa                   	stos   %al,%es:(%rdi)
    4059:	aa                   	stos   %al,%es:(%rdi)
    405a:	aa                   	stos   %al,%es:(%rdi)
    405b:	aa                   	stos   %al,%es:(%rdi)
    405c:	aa                   	stos   %al,%es:(%rdi)
    405d:	aa                   	stos   %al,%es:(%rdi)
    405e:	aa                   	stos   %al,%es:(%rdi)
    405f:	aa                   	stos   %al,%es:(%rdi)
    4060:	aa                   	stos   %al,%es:(%rdi)
    4061:	aa                   	stos   %al,%es:(%rdi)
    4062:	aa                   	stos   %al,%es:(%rdi)
    4063:	aa                   	stos   %al,%es:(%rdi)
    4064:	aa                   	stos   %al,%es:(%rdi)
    4065:	aa                   	stos   %al,%es:(%rdi)
    4066:	aa                   	stos   %al,%es:(%rdi)
    4067:	aa                   	stos   %al,%es:(%rdi)
    4068:	aa                   	stos   %al,%es:(%rdi)
    4069:	aa                   	stos   %al,%es:(%rdi)
    406a:	aa                   	stos   %al,%es:(%rdi)
    406b:	aa                   	stos   %al,%es:(%rdi)
    406c:	aa                   	stos   %al,%es:(%rdi)
    406d:	aa                   	stos   %al,%es:(%rdi)
    406e:	aa                   	stos   %al,%es:(%rdi)
    406f:	aa                   	stos   %al,%es:(%rdi)
    4070:	aa                   	stos   %al,%es:(%rdi)
    4071:	aa                   	stos   %al,%es:(%rdi)
    4072:	aa                   	stos   %al,%es:(%rdi)
    4073:	aa                   	stos   %al,%es:(%rdi)
    4074:	aa                   	stos   %al,%es:(%rdi)
    4075:	aa                   	stos   %al,%es:(%rdi)
    4076:	aa                   	stos   %al,%es:(%rdi)
    4077:	aa                   	stos   %al,%es:(%rdi)
    4078:	aa                   	stos   %al,%es:(%rdi)
    4079:	aa                   	stos   %al,%es:(%rdi)
    407a:	aa                   	stos   %al,%es:(%rdi)
    407b:	aa                   	stos   %al,%es:(%rdi)
    407c:	aa                   	stos   %al,%es:(%rdi)
    407d:	aa                   	stos   %al,%es:(%rdi)
    407e:	aa                   	stos   %al,%es:(%rdi)
    407f:	aa                   	stos   %al,%es:(%rdi)
    4080:	aa                   	stos   %al,%es:(%rdi)
    4081:	aa                   	stos   %al,%es:(%rdi)
    4082:	aa                   	stos   %al,%es:(%rdi)
    4083:	aa                   	stos   %al,%es:(%rdi)
    4084:	aa                   	stos   %al,%es:(%rdi)
    4085:	aa                   	stos   %al,%es:(%rdi)
    4086:	aa                   	stos   %al,%es:(%rdi)
    4087:	aa                   	stos   %al,%es:(%rdi)
    4088:	aa                   	stos   %al,%es:(%rdi)
    4089:	aa                   	stos   %al,%es:(%rdi)
    408a:	aa                   	stos   %al,%es:(%rdi)
    408b:	aa                   	stos   %al,%es:(%rdi)
    408c:	aa                   	stos   %al,%es:(%rdi)
    408d:	aa                   	stos   %al,%es:(%rdi)
    408e:	aa                   	stos   %al,%es:(%rdi)
    408f:	aa                   	stos   %al,%es:(%rdi)
    4090:	aa                   	stos   %al,%es:(%rdi)
    4091:	aa                   	stos   %al,%es:(%rdi)
    4092:	aa                   	stos   %al,%es:(%rdi)
    4093:	aa                   	stos   %al,%es:(%rdi)
    4094:	aa                   	stos   %al,%es:(%rdi)
    4095:	aa                   	stos   %al,%es:(%rdi)
    4096:	aa                   	stos   %al,%es:(%rdi)
    4097:	aa                   	stos   %al,%es:(%rdi)
    4098:	aa                   	stos   %al,%es:(%rdi)
    4099:	aa                   	stos   %al,%es:(%rdi)
    409a:	aa                   	stos   %al,%es:(%rdi)
    409b:	aa                   	stos   %al,%es:(%rdi)
    409c:	aa                   	stos   %al,%es:(%rdi)
    409d:	aa                   	stos   %al,%es:(%rdi)
    409e:	aa                   	stos   %al,%es:(%rdi)
    409f:	aa                   	stos   %al,%es:(%rdi)
    40a0:	aa                   	stos   %al,%es:(%rdi)
    40a1:	aa                   	stos   %al,%es:(%rdi)
    40a2:	aa                   	stos   %al,%es:(%rdi)
    40a3:	aa                   	stos   %al,%es:(%rdi)
    40a4:	aa                   	stos   %al,%es:(%rdi)
    40a5:	aa                   	stos   %al,%es:(%rdi)
    40a6:	aa                   	stos   %al,%es:(%rdi)
    40a7:	aa                   	stos   %al,%es:(%rdi)
    40a8:	aa                   	stos   %al,%es:(%rdi)
    40a9:	aa                   	stos   %al,%es:(%rdi)
    40aa:	aa                   	stos   %al,%es:(%rdi)
    40ab:	aa                   	stos   %al,%es:(%rdi)
    40ac:	aa                   	stos   %al,%es:(%rdi)
    40ad:	aa                   	stos   %al,%es:(%rdi)
    40ae:	aa                   	stos   %al,%es:(%rdi)
    40af:	aa                   	stos   %al,%es:(%rdi)
    40b0:	aa                   	stos   %al,%es:(%rdi)
    40b1:	aa                   	stos   %al,%es:(%rdi)
    40b2:	aa                   	stos   %al,%es:(%rdi)
    40b3:	aa                   	stos   %al,%es:(%rdi)
    40b4:	aa                   	stos   %al,%es:(%rdi)
    40b5:	aa                   	stos   %al,%es:(%rdi)
    40b6:	aa                   	stos   %al,%es:(%rdi)
    40b7:	aa                   	stos   %al,%es:(%rdi)
    40b8:	aa                   	stos   %al,%es:(%rdi)
    40b9:	aa                   	stos   %al,%es:(%rdi)
    40ba:	aa                   	stos   %al,%es:(%rdi)
    40bb:	aa                   	stos   %al,%es:(%rdi)
    40bc:	aa                   	stos   %al,%es:(%rdi)
    40bd:	aa                   	stos   %al,%es:(%rdi)
    40be:	aa                   	stos   %al,%es:(%rdi)
    40bf:	aa                   	stos   %al,%es:(%rdi)
    40c0:	aa                   	stos   %al,%es:(%rdi)
    40c1:	aa                   	stos   %al,%es:(%rdi)
    40c2:	aa                   	stos   %al,%es:(%rdi)
    40c3:	aa                   	stos   %al,%es:(%rdi)
    40c4:	aa                   	stos   %al,%es:(%rdi)
    40c5:	aa                   	stos   %al,%es:(%rdi)
    40c6:	aa                   	stos   %al,%es:(%rdi)
    40c7:	aa                   	stos   %al,%es:(%rdi)
    40c8:	aa                   	stos   %al,%es:(%rdi)
    40c9:	aa                   	stos   %al,%es:(%rdi)
    40ca:	aa                   	stos   %al,%es:(%rdi)
    40cb:	aa                   	stos   %al,%es:(%rdi)
    40cc:	aa                   	stos   %al,%es:(%rdi)
    40cd:	aa                   	stos   %al,%es:(%rdi)
    40ce:	aa                   	stos   %al,%es:(%rdi)
    40cf:	aa                   	stos   %al,%es:(%rdi)
    40d0:	aa                   	stos   %al,%es:(%rdi)
    40d1:	aa                   	stos   %al,%es:(%rdi)
    40d2:	aa                   	stos   %al,%es:(%rdi)
    40d3:	aa                   	stos   %al,%es:(%rdi)
    40d4:	aa                   	stos   %al,%es:(%rdi)
    40d5:	aa                   	stos   %al,%es:(%rdi)
    40d6:	aa                   	stos   %al,%es:(%rdi)
    40d7:	aa                   	stos   %al,%es:(%rdi)
    40d8:	aa                   	stos   %al,%es:(%rdi)
    40d9:	aa                   	stos   %al,%es:(%rdi)
    40da:	aa                   	stos   %al,%es:(%rdi)
    40db:	aa                   	stos   %al,%es:(%rdi)
    40dc:	aa                   	stos   %al,%es:(%rdi)
    40dd:	aa                   	stos   %al,%es:(%rdi)
    40de:	aa                   	stos   %al,%es:(%rdi)
    40df:	aa                   	stos   %al,%es:(%rdi)
    40e0:	aa                   	stos   %al,%es:(%rdi)
    40e1:	aa                   	stos   %al,%es:(%rdi)
    40e2:	aa                   	stos   %al,%es:(%rdi)
    40e3:	aa                   	stos   %al,%es:(%rdi)
    40e4:	aa                   	stos   %al,%es:(%rdi)
    40e5:	aa                   	stos   %al,%es:(%rdi)
    40e6:	aa                   	stos   %al,%es:(%rdi)
    40e7:	aa                   	stos   %al,%es:(%rdi)
    40e8:	aa                   	stos   %al,%es:(%rdi)
    40e9:	aa                   	stos   %al,%es:(%rdi)
    40ea:	aa                   	stos   %al,%es:(%rdi)
    40eb:	aa                   	stos   %al,%es:(%rdi)
    40ec:	aa                   	stos   %al,%es:(%rdi)
    40ed:	aa                   	stos   %al,%es:(%rdi)
    40ee:	aa                   	stos   %al,%es:(%rdi)
    40ef:	aa                   	stos   %al,%es:(%rdi)
    40f0:	aa                   	stos   %al,%es:(%rdi)
    40f1:	aa                   	stos   %al,%es:(%rdi)
    40f2:	aa                   	stos   %al,%es:(%rdi)
    40f3:	aa                   	stos   %al,%es:(%rdi)
    40f4:	aa                   	stos   %al,%es:(%rdi)
    40f5:	aa                   	stos   %al,%es:(%rdi)
    40f6:	aa                   	stos   %al,%es:(%rdi)
    40f7:	aa                   	stos   %al,%es:(%rdi)
    40f8:	aa                   	stos   %al,%es:(%rdi)
    40f9:	aa                   	stos   %al,%es:(%rdi)
    40fa:	aa                   	stos   %al,%es:(%rdi)
    40fb:	aa                   	stos   %al,%es:(%rdi)
    40fc:	aa                   	stos   %al,%es:(%rdi)
    40fd:	aa                   	stos   %al,%es:(%rdi)
    40fe:	aa                   	stos   %al,%es:(%rdi)
    40ff:	aa                   	stos   %al,%es:(%rdi)
    4100:	aa                   	stos   %al,%es:(%rdi)
    4101:	aa                   	stos   %al,%es:(%rdi)
    4102:	aa                   	stos   %al,%es:(%rdi)
    4103:	aa                   	stos   %al,%es:(%rdi)
    4104:	aa                   	stos   %al,%es:(%rdi)
    4105:	aa                   	stos   %al,%es:(%rdi)
    4106:	aa                   	stos   %al,%es:(%rdi)
    4107:	aa                   	stos   %al,%es:(%rdi)
    4108:	aa                   	stos   %al,%es:(%rdi)
    4109:	aa                   	stos   %al,%es:(%rdi)
    410a:	aa                   	stos   %al,%es:(%rdi)
    410b:	aa                   	stos   %al,%es:(%rdi)
    410c:	aa                   	stos   %al,%es:(%rdi)
    410d:	aa                   	stos   %al,%es:(%rdi)
    410e:	aa                   	stos   %al,%es:(%rdi)
    410f:	aa                   	stos   %al,%es:(%rdi)
    4110:	aa                   	stos   %al,%es:(%rdi)
    4111:	aa                   	stos   %al,%es:(%rdi)
    4112:	aa                   	stos   %al,%es:(%rdi)
    4113:	aa                   	stos   %al,%es:(%rdi)
    4114:	aa                   	stos   %al,%es:(%rdi)
    4115:	aa                   	stos   %al,%es:(%rdi)
    4116:	aa                   	stos   %al,%es:(%rdi)
    4117:	aa                   	stos   %al,%es:(%rdi)
    4118:	aa                   	stos   %al,%es:(%rdi)
    4119:	aa                   	stos   %al,%es:(%rdi)
    411a:	aa                   	stos   %al,%es:(%rdi)
    411b:	aa                   	stos   %al,%es:(%rdi)
    411c:	aa                   	stos   %al,%es:(%rdi)
    411d:	aa                   	stos   %al,%es:(%rdi)
    411e:	aa                   	stos   %al,%es:(%rdi)
    411f:	aa                   	stos   %al,%es:(%rdi)
    4120:	aa                   	stos   %al,%es:(%rdi)
    4121:	aa                   	stos   %al,%es:(%rdi)
    4122:	aa                   	stos   %al,%es:(%rdi)
    4123:	aa                   	stos   %al,%es:(%rdi)
    4124:	aa                   	stos   %al,%es:(%rdi)
    4125:	aa                   	stos   %al,%es:(%rdi)
    4126:	aa                   	stos   %al,%es:(%rdi)
    4127:	aa                   	stos   %al,%es:(%rdi)
    4128:	aa                   	stos   %al,%es:(%rdi)
    4129:	aa                   	stos   %al,%es:(%rdi)
    412a:	aa                   	stos   %al,%es:(%rdi)
    412b:	aa                   	stos   %al,%es:(%rdi)
    412c:	aa                   	stos   %al,%es:(%rdi)
    412d:	aa                   	stos   %al,%es:(%rdi)
    412e:	aa                   	stos   %al,%es:(%rdi)
    412f:	aa                   	stos   %al,%es:(%rdi)
    4130:	aa                   	stos   %al,%es:(%rdi)
    4131:	aa                   	stos   %al,%es:(%rdi)
    4132:	aa                   	stos   %al,%es:(%rdi)
    4133:	aa                   	stos   %al,%es:(%rdi)
    4134:	aa                   	stos   %al,%es:(%rdi)
    4135:	aa                   	stos   %al,%es:(%rdi)
    4136:	aa                   	stos   %al,%es:(%rdi)
    4137:	aa                   	stos   %al,%es:(%rdi)
    4138:	aa                   	stos   %al,%es:(%rdi)
    4139:	aa                   	stos   %al,%es:(%rdi)
    413a:	aa                   	stos   %al,%es:(%rdi)
    413b:	aa                   	stos   %al,%es:(%rdi)
    413c:	aa                   	stos   %al,%es:(%rdi)
    413d:	aa                   	stos   %al,%es:(%rdi)
    413e:	aa                   	stos   %al,%es:(%rdi)
    413f:	aa                   	stos   %al,%es:(%rdi)
    4140:	aa                   	stos   %al,%es:(%rdi)
    4141:	aa                   	stos   %al,%es:(%rdi)
    4142:	aa                   	stos   %al,%es:(%rdi)
    4143:	aa                   	stos   %al,%es:(%rdi)
    4144:	aa                   	stos   %al,%es:(%rdi)
    4145:	aa                   	stos   %al,%es:(%rdi)
    4146:	aa                   	stos   %al,%es:(%rdi)
    4147:	aa                   	stos   %al,%es:(%rdi)
    4148:	aa                   	stos   %al,%es:(%rdi)
    4149:	aa                   	stos   %al,%es:(%rdi)
    414a:	aa                   	stos   %al,%es:(%rdi)
    414b:	aa                   	stos   %al,%es:(%rdi)
    414c:	aa                   	stos   %al,%es:(%rdi)
    414d:	aa                   	stos   %al,%es:(%rdi)
    414e:	aa                   	stos   %al,%es:(%rdi)
    414f:	aa                   	stos   %al,%es:(%rdi)
    4150:	aa                   	stos   %al,%es:(%rdi)
    4151:	aa                   	stos   %al,%es:(%rdi)
    4152:	aa                   	stos   %al,%es:(%rdi)
    4153:	aa                   	stos   %al,%es:(%rdi)
    4154:	aa                   	stos   %al,%es:(%rdi)
    4155:	aa                   	stos   %al,%es:(%rdi)
    4156:	aa                   	stos   %al,%es:(%rdi)
    4157:	aa                   	stos   %al,%es:(%rdi)
    4158:	aa                   	stos   %al,%es:(%rdi)
    4159:	aa                   	stos   %al,%es:(%rdi)
    415a:	aa                   	stos   %al,%es:(%rdi)
    415b:	aa                   	stos   %al,%es:(%rdi)
    415c:	aa                   	stos   %al,%es:(%rdi)
    415d:	aa                   	stos   %al,%es:(%rdi)
    415e:	aa                   	stos   %al,%es:(%rdi)
    415f:	aa                   	stos   %al,%es:(%rdi)
    4160:	aa                   	stos   %al,%es:(%rdi)
    4161:	aa                   	stos   %al,%es:(%rdi)
    4162:	aa                   	stos   %al,%es:(%rdi)
    4163:	aa                   	stos   %al,%es:(%rdi)
    4164:	aa                   	stos   %al,%es:(%rdi)
    4165:	aa                   	stos   %al,%es:(%rdi)
    4166:	aa                   	stos   %al,%es:(%rdi)
    4167:	aa                   	stos   %al,%es:(%rdi)
    4168:	aa                   	stos   %al,%es:(%rdi)
    4169:	aa                   	stos   %al,%es:(%rdi)
    416a:	aa                   	stos   %al,%es:(%rdi)
    416b:	aa                   	stos   %al,%es:(%rdi)
    416c:	aa                   	stos   %al,%es:(%rdi)
    416d:	aa                   	stos   %al,%es:(%rdi)
    416e:	aa                   	stos   %al,%es:(%rdi)
    416f:	aa                   	stos   %al,%es:(%rdi)
    4170:	aa                   	stos   %al,%es:(%rdi)
    4171:	aa                   	stos   %al,%es:(%rdi)
    4172:	aa                   	stos   %al,%es:(%rdi)
    4173:	aa                   	stos   %al,%es:(%rdi)
    4174:	aa                   	stos   %al,%es:(%rdi)
    4175:	aa                   	stos   %al,%es:(%rdi)
    4176:	aa                   	stos   %al,%es:(%rdi)
    4177:	aa                   	stos   %al,%es:(%rdi)
    4178:	aa                   	stos   %al,%es:(%rdi)
    4179:	aa                   	stos   %al,%es:(%rdi)
    417a:	aa                   	stos   %al,%es:(%rdi)
    417b:	aa                   	stos   %al,%es:(%rdi)
    417c:	aa                   	stos   %al,%es:(%rdi)
    417d:	aa                   	stos   %al,%es:(%rdi)
    417e:	aa                   	stos   %al,%es:(%rdi)
    417f:	aa                   	stos   %al,%es:(%rdi)
    4180:	aa                   	stos   %al,%es:(%rdi)
    4181:	aa                   	stos   %al,%es:(%rdi)
    4182:	aa                   	stos   %al,%es:(%rdi)
    4183:	aa                   	stos   %al,%es:(%rdi)
    4184:	aa                   	stos   %al,%es:(%rdi)
    4185:	aa                   	stos   %al,%es:(%rdi)
    4186:	aa                   	stos   %al,%es:(%rdi)
    4187:	aa                   	stos   %al,%es:(%rdi)
    4188:	aa                   	stos   %al,%es:(%rdi)
    4189:	aa                   	stos   %al,%es:(%rdi)
    418a:	aa                   	stos   %al,%es:(%rdi)
    418b:	aa                   	stos   %al,%es:(%rdi)
    418c:	aa                   	stos   %al,%es:(%rdi)
    418d:	aa                   	stos   %al,%es:(%rdi)
    418e:	aa                   	stos   %al,%es:(%rdi)
    418f:	aa                   	stos   %al,%es:(%rdi)
    4190:	aa                   	stos   %al,%es:(%rdi)
    4191:	aa                   	stos   %al,%es:(%rdi)
    4192:	aa                   	stos   %al,%es:(%rdi)
    4193:	aa                   	stos   %al,%es:(%rdi)
    4194:	aa                   	stos   %al,%es:(%rdi)
    4195:	aa                   	stos   %al,%es:(%rdi)
    4196:	aa                   	stos   %al,%es:(%rdi)
    4197:	aa                   	stos   %al,%es:(%rdi)
    4198:	aa                   	stos   %al,%es:(%rdi)
    4199:	aa                   	stos   %al,%es:(%rdi)
    419a:	aa                   	stos   %al,%es:(%rdi)
    419b:	aa                   	stos   %al,%es:(%rdi)
    419c:	aa                   	stos   %al,%es:(%rdi)
    419d:	aa                   	stos   %al,%es:(%rdi)
    419e:	aa                   	stos   %al,%es:(%rdi)
    419f:	aa                   	stos   %al,%es:(%rdi)
    41a0:	aa                   	stos   %al,%es:(%rdi)
    41a1:	aa                   	stos   %al,%es:(%rdi)
    41a2:	aa                   	stos   %al,%es:(%rdi)
    41a3:	aa                   	stos   %al,%es:(%rdi)
    41a4:	aa                   	stos   %al,%es:(%rdi)
    41a5:	aa                   	stos   %al,%es:(%rdi)
    41a6:	aa                   	stos   %al,%es:(%rdi)
    41a7:	aa                   	stos   %al,%es:(%rdi)
    41a8:	aa                   	stos   %al,%es:(%rdi)
    41a9:	aa                   	stos   %al,%es:(%rdi)
    41aa:	aa                   	stos   %al,%es:(%rdi)
    41ab:	aa                   	stos   %al,%es:(%rdi)
    41ac:	aa                   	stos   %al,%es:(%rdi)
    41ad:	aa                   	stos   %al,%es:(%rdi)
    41ae:	aa                   	stos   %al,%es:(%rdi)
    41af:	aa                   	stos   %al,%es:(%rdi)
    41b0:	aa                   	stos   %al,%es:(%rdi)
    41b1:	aa                   	stos   %al,%es:(%rdi)
    41b2:	aa                   	stos   %al,%es:(%rdi)
    41b3:	aa                   	stos   %al,%es:(%rdi)
    41b4:	aa                   	stos   %al,%es:(%rdi)
    41b5:	aa                   	stos   %al,%es:(%rdi)
    41b6:	aa                   	stos   %al,%es:(%rdi)
    41b7:	aa                   	stos   %al,%es:(%rdi)
    41b8:	aa                   	stos   %al,%es:(%rdi)
    41b9:	aa                   	stos   %al,%es:(%rdi)
    41ba:	aa                   	stos   %al,%es:(%rdi)
    41bb:	aa                   	stos   %al,%es:(%rdi)
    41bc:	aa                   	stos   %al,%es:(%rdi)
    41bd:	aa                   	stos   %al,%es:(%rdi)
    41be:	aa                   	stos   %al,%es:(%rdi)
    41bf:	aa                   	stos   %al,%es:(%rdi)
    41c0:	aa                   	stos   %al,%es:(%rdi)
    41c1:	aa                   	stos   %al,%es:(%rdi)
    41c2:	aa                   	stos   %al,%es:(%rdi)
    41c3:	aa                   	stos   %al,%es:(%rdi)
    41c4:	aa                   	stos   %al,%es:(%rdi)
    41c5:	aa                   	stos   %al,%es:(%rdi)
    41c6:	aa                   	stos   %al,%es:(%rdi)
    41c7:	aa                   	stos   %al,%es:(%rdi)
    41c8:	aa                   	stos   %al,%es:(%rdi)
    41c9:	aa                   	stos   %al,%es:(%rdi)
    41ca:	aa                   	stos   %al,%es:(%rdi)
    41cb:	aa                   	stos   %al,%es:(%rdi)
    41cc:	aa                   	stos   %al,%es:(%rdi)
    41cd:	aa                   	stos   %al,%es:(%rdi)
    41ce:	aa                   	stos   %al,%es:(%rdi)
    41cf:	aa                   	stos   %al,%es:(%rdi)
    41d0:	aa                   	stos   %al,%es:(%rdi)
    41d1:	aa                   	stos   %al,%es:(%rdi)
    41d2:	aa                   	stos   %al,%es:(%rdi)
    41d3:	aa                   	stos   %al,%es:(%rdi)
    41d4:	aa                   	stos   %al,%es:(%rdi)
    41d5:	aa                   	stos   %al,%es:(%rdi)
    41d6:	aa                   	stos   %al,%es:(%rdi)
    41d7:	aa                   	stos   %al,%es:(%rdi)
    41d8:	aa                   	stos   %al,%es:(%rdi)
    41d9:	aa                   	stos   %al,%es:(%rdi)
    41da:	aa                   	stos   %al,%es:(%rdi)
    41db:	aa                   	stos   %al,%es:(%rdi)
    41dc:	aa                   	stos   %al,%es:(%rdi)
    41dd:	aa                   	stos   %al,%es:(%rdi)
    41de:	aa                   	stos   %al,%es:(%rdi)
    41df:	aa                   	stos   %al,%es:(%rdi)
    41e0:	aa                   	stos   %al,%es:(%rdi)
    41e1:	aa                   	stos   %al,%es:(%rdi)
    41e2:	aa                   	stos   %al,%es:(%rdi)
    41e3:	aa                   	stos   %al,%es:(%rdi)
    41e4:	aa                   	stos   %al,%es:(%rdi)
    41e5:	aa                   	stos   %al,%es:(%rdi)
    41e6:	aa                   	stos   %al,%es:(%rdi)
    41e7:	aa                   	stos   %al,%es:(%rdi)
    41e8:	aa                   	stos   %al,%es:(%rdi)
    41e9:	aa                   	stos   %al,%es:(%rdi)
    41ea:	aa                   	stos   %al,%es:(%rdi)
    41eb:	aa                   	stos   %al,%es:(%rdi)
    41ec:	aa                   	stos   %al,%es:(%rdi)
    41ed:	aa                   	stos   %al,%es:(%rdi)
    41ee:	aa                   	stos   %al,%es:(%rdi)
    41ef:	aa                   	stos   %al,%es:(%rdi)
    41f0:	aa                   	stos   %al,%es:(%rdi)
    41f1:	aa                   	stos   %al,%es:(%rdi)
    41f2:	aa                   	stos   %al,%es:(%rdi)
    41f3:	aa                   	stos   %al,%es:(%rdi)
    41f4:	aa                   	stos   %al,%es:(%rdi)
    41f5:	aa                   	stos   %al,%es:(%rdi)
    41f6:	aa                   	stos   %al,%es:(%rdi)
    41f7:	aa                   	stos   %al,%es:(%rdi)
    41f8:	aa                   	stos   %al,%es:(%rdi)
    41f9:	aa                   	stos   %al,%es:(%rdi)
    41fa:	aa                   	stos   %al,%es:(%rdi)
    41fb:	aa                   	stos   %al,%es:(%rdi)
    41fc:	aa                   	stos   %al,%es:(%rdi)
    41fd:	aa                   	stos   %al,%es:(%rdi)
    41fe:	aa                   	stos   %al,%es:(%rdi)
    41ff:	aa                   	stos   %al,%es:(%rdi)
    4200:	aa                   	stos   %al,%es:(%rdi)
    4201:	aa                   	stos   %al,%es:(%rdi)
    4202:	aa                   	stos   %al,%es:(%rdi)
    4203:	aa                   	stos   %al,%es:(%rdi)
    4204:	aa                   	stos   %al,%es:(%rdi)
    4205:	aa                   	stos   %al,%es:(%rdi)
    4206:	aa                   	stos   %al,%es:(%rdi)
    4207:	aa                   	stos   %al,%es:(%rdi)
    4208:	aa                   	stos   %al,%es:(%rdi)
    4209:	aa                   	stos   %al,%es:(%rdi)
    420a:	aa                   	stos   %al,%es:(%rdi)
    420b:	aa                   	stos   %al,%es:(%rdi)
    420c:	aa                   	stos   %al,%es:(%rdi)
    420d:	aa                   	stos   %al,%es:(%rdi)
    420e:	aa                   	stos   %al,%es:(%rdi)
    420f:	aa                   	stos   %al,%es:(%rdi)
    4210:	aa                   	stos   %al,%es:(%rdi)
    4211:	aa                   	stos   %al,%es:(%rdi)
    4212:	aa                   	stos   %al,%es:(%rdi)
    4213:	aa                   	stos   %al,%es:(%rdi)
    4214:	aa                   	stos   %al,%es:(%rdi)
    4215:	aa                   	stos   %al,%es:(%rdi)
    4216:	aa                   	stos   %al,%es:(%rdi)
    4217:	aa                   	stos   %al,%es:(%rdi)
    4218:	aa                   	stos   %al,%es:(%rdi)
    4219:	aa                   	stos   %al,%es:(%rdi)
    421a:	aa                   	stos   %al,%es:(%rdi)
    421b:	aa                   	stos   %al,%es:(%rdi)
    421c:	aa                   	stos   %al,%es:(%rdi)
    421d:	aa                   	stos   %al,%es:(%rdi)
    421e:	aa                   	stos   %al,%es:(%rdi)
    421f:	aa                   	stos   %al,%es:(%rdi)
    4220:	aa                   	stos   %al,%es:(%rdi)
    4221:	aa                   	stos   %al,%es:(%rdi)
    4222:	aa                   	stos   %al,%es:(%rdi)
    4223:	aa                   	stos   %al,%es:(%rdi)
    4224:	aa                   	stos   %al,%es:(%rdi)
    4225:	aa                   	stos   %al,%es:(%rdi)
    4226:	aa                   	stos   %al,%es:(%rdi)
    4227:	aa                   	stos   %al,%es:(%rdi)
    4228:	aa                   	stos   %al,%es:(%rdi)
    4229:	aa                   	stos   %al,%es:(%rdi)
    422a:	aa                   	stos   %al,%es:(%rdi)
    422b:	aa                   	stos   %al,%es:(%rdi)
    422c:	aa                   	stos   %al,%es:(%rdi)
    422d:	aa                   	stos   %al,%es:(%rdi)
    422e:	aa                   	stos   %al,%es:(%rdi)
    422f:	aa                   	stos   %al,%es:(%rdi)
    4230:	aa                   	stos   %al,%es:(%rdi)
    4231:	aa                   	stos   %al,%es:(%rdi)
    4232:	aa                   	stos   %al,%es:(%rdi)
    4233:	aa                   	stos   %al,%es:(%rdi)
    4234:	aa                   	stos   %al,%es:(%rdi)
    4235:	aa                   	stos   %al,%es:(%rdi)
    4236:	aa                   	stos   %al,%es:(%rdi)
    4237:	aa                   	stos   %al,%es:(%rdi)
    4238:	aa                   	stos   %al,%es:(%rdi)
    4239:	aa                   	stos   %al,%es:(%rdi)
    423a:	aa                   	stos   %al,%es:(%rdi)
    423b:	aa                   	stos   %al,%es:(%rdi)
    423c:	aa                   	stos   %al,%es:(%rdi)
    423d:	aa                   	stos   %al,%es:(%rdi)
    423e:	aa                   	stos   %al,%es:(%rdi)
    423f:	aa                   	stos   %al,%es:(%rdi)
    4240:	aa                   	stos   %al,%es:(%rdi)
    4241:	aa                   	stos   %al,%es:(%rdi)
    4242:	aa                   	stos   %al,%es:(%rdi)
    4243:	aa                   	stos   %al,%es:(%rdi)
    4244:	aa                   	stos   %al,%es:(%rdi)
    4245:	aa                   	stos   %al,%es:(%rdi)
    4246:	aa                   	stos   %al,%es:(%rdi)
    4247:	aa                   	stos   %al,%es:(%rdi)
    4248:	aa                   	stos   %al,%es:(%rdi)
    4249:	aa                   	stos   %al,%es:(%rdi)
    424a:	aa                   	stos   %al,%es:(%rdi)
    424b:	aa                   	stos   %al,%es:(%rdi)
    424c:	aa                   	stos   %al,%es:(%rdi)
    424d:	aa                   	stos   %al,%es:(%rdi)
    424e:	aa                   	stos   %al,%es:(%rdi)
    424f:	aa                   	stos   %al,%es:(%rdi)
    4250:	aa                   	stos   %al,%es:(%rdi)
    4251:	aa                   	stos   %al,%es:(%rdi)
    4252:	aa                   	stos   %al,%es:(%rdi)
    4253:	aa                   	stos   %al,%es:(%rdi)
    4254:	aa                   	stos   %al,%es:(%rdi)
    4255:	aa                   	stos   %al,%es:(%rdi)
    4256:	aa                   	stos   %al,%es:(%rdi)
    4257:	aa                   	stos   %al,%es:(%rdi)
    4258:	aa                   	stos   %al,%es:(%rdi)
    4259:	aa                   	stos   %al,%es:(%rdi)
    425a:	aa                   	stos   %al,%es:(%rdi)
    425b:	aa                   	stos   %al,%es:(%rdi)
    425c:	aa                   	stos   %al,%es:(%rdi)
    425d:	aa                   	stos   %al,%es:(%rdi)
    425e:	aa                   	stos   %al,%es:(%rdi)
    425f:	aa                   	stos   %al,%es:(%rdi)
    4260:	aa                   	stos   %al,%es:(%rdi)
    4261:	aa                   	stos   %al,%es:(%rdi)
    4262:	aa                   	stos   %al,%es:(%rdi)
    4263:	aa                   	stos   %al,%es:(%rdi)
    4264:	aa                   	stos   %al,%es:(%rdi)
    4265:	aa                   	stos   %al,%es:(%rdi)
    4266:	aa                   	stos   %al,%es:(%rdi)
    4267:	aa                   	stos   %al,%es:(%rdi)
    4268:	aa                   	stos   %al,%es:(%rdi)
    4269:	aa                   	stos   %al,%es:(%rdi)
    426a:	aa                   	stos   %al,%es:(%rdi)
    426b:	aa                   	stos   %al,%es:(%rdi)
    426c:	aa                   	stos   %al,%es:(%rdi)
    426d:	aa                   	stos   %al,%es:(%rdi)
    426e:	aa                   	stos   %al,%es:(%rdi)
    426f:	aa                   	stos   %al,%es:(%rdi)
    4270:	aa                   	stos   %al,%es:(%rdi)
    4271:	aa                   	stos   %al,%es:(%rdi)
    4272:	aa                   	stos   %al,%es:(%rdi)
    4273:	aa                   	stos   %al,%es:(%rdi)
    4274:	aa                   	stos   %al,%es:(%rdi)
    4275:	aa                   	stos   %al,%es:(%rdi)
    4276:	aa                   	stos   %al,%es:(%rdi)
    4277:	aa                   	stos   %al,%es:(%rdi)
    4278:	aa                   	stos   %al,%es:(%rdi)
    4279:	aa                   	stos   %al,%es:(%rdi)
    427a:	aa                   	stos   %al,%es:(%rdi)
    427b:	aa                   	stos   %al,%es:(%rdi)
    427c:	aa                   	stos   %al,%es:(%rdi)
    427d:	aa                   	stos   %al,%es:(%rdi)
    427e:	aa                   	stos   %al,%es:(%rdi)
    427f:	aa                   	stos   %al,%es:(%rdi)
    4280:	aa                   	stos   %al,%es:(%rdi)
    4281:	aa                   	stos   %al,%es:(%rdi)
    4282:	aa                   	stos   %al,%es:(%rdi)
    4283:	aa                   	stos   %al,%es:(%rdi)
    4284:	aa                   	stos   %al,%es:(%rdi)
    4285:	aa                   	stos   %al,%es:(%rdi)
    4286:	aa                   	stos   %al,%es:(%rdi)
    4287:	aa                   	stos   %al,%es:(%rdi)
    4288:	aa                   	stos   %al,%es:(%rdi)
    4289:	aa                   	stos   %al,%es:(%rdi)
    428a:	aa                   	stos   %al,%es:(%rdi)
    428b:	aa                   	stos   %al,%es:(%rdi)
    428c:	aa                   	stos   %al,%es:(%rdi)
    428d:	aa                   	stos   %al,%es:(%rdi)
    428e:	aa                   	stos   %al,%es:(%rdi)
    428f:	aa                   	stos   %al,%es:(%rdi)
    4290:	aa                   	stos   %al,%es:(%rdi)
    4291:	aa                   	stos   %al,%es:(%rdi)
    4292:	aa                   	stos   %al,%es:(%rdi)
    4293:	aa                   	stos   %al,%es:(%rdi)
    4294:	aa                   	stos   %al,%es:(%rdi)
    4295:	aa                   	stos   %al,%es:(%rdi)
    4296:	aa                   	stos   %al,%es:(%rdi)
    4297:	aa                   	stos   %al,%es:(%rdi)
    4298:	aa                   	stos   %al,%es:(%rdi)
    4299:	aa                   	stos   %al,%es:(%rdi)
    429a:	aa                   	stos   %al,%es:(%rdi)
    429b:	aa                   	stos   %al,%es:(%rdi)
    429c:	aa                   	stos   %al,%es:(%rdi)
    429d:	aa                   	stos   %al,%es:(%rdi)
    429e:	aa                   	stos   %al,%es:(%rdi)
    429f:	aa                   	stos   %al,%es:(%rdi)
    42a0:	aa                   	stos   %al,%es:(%rdi)
    42a1:	aa                   	stos   %al,%es:(%rdi)
    42a2:	aa                   	stos   %al,%es:(%rdi)
    42a3:	aa                   	stos   %al,%es:(%rdi)
    42a4:	aa                   	stos   %al,%es:(%rdi)
    42a5:	aa                   	stos   %al,%es:(%rdi)
    42a6:	aa                   	stos   %al,%es:(%rdi)
    42a7:	aa                   	stos   %al,%es:(%rdi)
    42a8:	aa                   	stos   %al,%es:(%rdi)
    42a9:	aa                   	stos   %al,%es:(%rdi)
    42aa:	aa                   	stos   %al,%es:(%rdi)
    42ab:	aa                   	stos   %al,%es:(%rdi)
    42ac:	aa                   	stos   %al,%es:(%rdi)
    42ad:	aa                   	stos   %al,%es:(%rdi)
    42ae:	aa                   	stos   %al,%es:(%rdi)
    42af:	aa                   	stos   %al,%es:(%rdi)
    42b0:	aa                   	stos   %al,%es:(%rdi)
    42b1:	aa                   	stos   %al,%es:(%rdi)
    42b2:	aa                   	stos   %al,%es:(%rdi)
    42b3:	aa                   	stos   %al,%es:(%rdi)
    42b4:	aa                   	stos   %al,%es:(%rdi)
    42b5:	aa                   	stos   %al,%es:(%rdi)
    42b6:	aa                   	stos   %al,%es:(%rdi)
    42b7:	aa                   	stos   %al,%es:(%rdi)
    42b8:	aa                   	stos   %al,%es:(%rdi)
    42b9:	aa                   	stos   %al,%es:(%rdi)
    42ba:	aa                   	stos   %al,%es:(%rdi)
    42bb:	aa                   	stos   %al,%es:(%rdi)
    42bc:	aa                   	stos   %al,%es:(%rdi)
    42bd:	aa                   	stos   %al,%es:(%rdi)
    42be:	aa                   	stos   %al,%es:(%rdi)
    42bf:	aa                   	stos   %al,%es:(%rdi)
    42c0:	aa                   	stos   %al,%es:(%rdi)
    42c1:	aa                   	stos   %al,%es:(%rdi)
    42c2:	aa                   	stos   %al,%es:(%rdi)
    42c3:	aa                   	stos   %al,%es:(%rdi)
    42c4:	aa                   	stos   %al,%es:(%rdi)
    42c5:	aa                   	stos   %al,%es:(%rdi)
    42c6:	aa                   	stos   %al,%es:(%rdi)
    42c7:	aa                   	stos   %al,%es:(%rdi)
    42c8:	aa                   	stos   %al,%es:(%rdi)
    42c9:	aa                   	stos   %al,%es:(%rdi)
    42ca:	aa                   	stos   %al,%es:(%rdi)
    42cb:	aa                   	stos   %al,%es:(%rdi)
    42cc:	aa                   	stos   %al,%es:(%rdi)
    42cd:	aa                   	stos   %al,%es:(%rdi)
    42ce:	aa                   	stos   %al,%es:(%rdi)
    42cf:	aa                   	stos   %al,%es:(%rdi)
    42d0:	aa                   	stos   %al,%es:(%rdi)
    42d1:	aa                   	stos   %al,%es:(%rdi)
    42d2:	aa                   	stos   %al,%es:(%rdi)
    42d3:	aa                   	stos   %al,%es:(%rdi)
    42d4:	aa                   	stos   %al,%es:(%rdi)
    42d5:	aa                   	stos   %al,%es:(%rdi)
    42d6:	aa                   	stos   %al,%es:(%rdi)
    42d7:	aa                   	stos   %al,%es:(%rdi)
    42d8:	aa                   	stos   %al,%es:(%rdi)
    42d9:	aa                   	stos   %al,%es:(%rdi)
    42da:	aa                   	stos   %al,%es:(%rdi)
    42db:	aa                   	stos   %al,%es:(%rdi)
    42dc:	aa                   	stos   %al,%es:(%rdi)
    42dd:	aa                   	stos   %al,%es:(%rdi)
    42de:	aa                   	stos   %al,%es:(%rdi)
    42df:	aa                   	stos   %al,%es:(%rdi)
    42e0:	aa                   	stos   %al,%es:(%rdi)
    42e1:	aa                   	stos   %al,%es:(%rdi)
    42e2:	aa                   	stos   %al,%es:(%rdi)
    42e3:	aa                   	stos   %al,%es:(%rdi)
    42e4:	aa                   	stos   %al,%es:(%rdi)
    42e5:	aa                   	stos   %al,%es:(%rdi)
    42e6:	aa                   	stos   %al,%es:(%rdi)
    42e7:	aa                   	stos   %al,%es:(%rdi)
    42e8:	aa                   	stos   %al,%es:(%rdi)
    42e9:	aa                   	stos   %al,%es:(%rdi)
    42ea:	aa                   	stos   %al,%es:(%rdi)
    42eb:	aa                   	stos   %al,%es:(%rdi)
    42ec:	aa                   	stos   %al,%es:(%rdi)
    42ed:	aa                   	stos   %al,%es:(%rdi)
    42ee:	aa                   	stos   %al,%es:(%rdi)
    42ef:	aa                   	stos   %al,%es:(%rdi)
    42f0:	aa                   	stos   %al,%es:(%rdi)
    42f1:	aa                   	stos   %al,%es:(%rdi)
    42f2:	aa                   	stos   %al,%es:(%rdi)
    42f3:	aa                   	stos   %al,%es:(%rdi)
    42f4:	aa                   	stos   %al,%es:(%rdi)
    42f5:	aa                   	stos   %al,%es:(%rdi)
    42f6:	aa                   	stos   %al,%es:(%rdi)
    42f7:	aa                   	stos   %al,%es:(%rdi)
    42f8:	aa                   	stos   %al,%es:(%rdi)
    42f9:	aa                   	stos   %al,%es:(%rdi)
    42fa:	aa                   	stos   %al,%es:(%rdi)
    42fb:	aa                   	stos   %al,%es:(%rdi)
    42fc:	aa                   	stos   %al,%es:(%rdi)
    42fd:	aa                   	stos   %al,%es:(%rdi)
    42fe:	aa                   	stos   %al,%es:(%rdi)
    42ff:	aa                   	stos   %al,%es:(%rdi)
    4300:	aa                   	stos   %al,%es:(%rdi)
    4301:	aa                   	stos   %al,%es:(%rdi)
    4302:	aa                   	stos   %al,%es:(%rdi)
    4303:	aa                   	stos   %al,%es:(%rdi)
    4304:	aa                   	stos   %al,%es:(%rdi)
    4305:	aa                   	stos   %al,%es:(%rdi)
    4306:	aa                   	stos   %al,%es:(%rdi)
    4307:	aa                   	stos   %al,%es:(%rdi)
    4308:	aa                   	stos   %al,%es:(%rdi)
    4309:	aa                   	stos   %al,%es:(%rdi)
    430a:	aa                   	stos   %al,%es:(%rdi)
    430b:	aa                   	stos   %al,%es:(%rdi)
    430c:	aa                   	stos   %al,%es:(%rdi)
    430d:	aa                   	stos   %al,%es:(%rdi)
    430e:	aa                   	stos   %al,%es:(%rdi)
    430f:	aa                   	stos   %al,%es:(%rdi)
    4310:	aa                   	stos   %al,%es:(%rdi)
    4311:	aa                   	stos   %al,%es:(%rdi)
    4312:	aa                   	stos   %al,%es:(%rdi)
    4313:	aa                   	stos   %al,%es:(%rdi)
    4314:	aa                   	stos   %al,%es:(%rdi)
    4315:	aa                   	stos   %al,%es:(%rdi)
    4316:	aa                   	stos   %al,%es:(%rdi)
    4317:	aa                   	stos   %al,%es:(%rdi)
    4318:	aa                   	stos   %al,%es:(%rdi)
    4319:	aa                   	stos   %al,%es:(%rdi)
    431a:	aa                   	stos   %al,%es:(%rdi)
    431b:	aa                   	stos   %al,%es:(%rdi)
    431c:	aa                   	stos   %al,%es:(%rdi)
    431d:	aa                   	stos   %al,%es:(%rdi)
    431e:	aa                   	stos   %al,%es:(%rdi)
    431f:	aa                   	stos   %al,%es:(%rdi)
    4320:	aa                   	stos   %al,%es:(%rdi)
    4321:	aa                   	stos   %al,%es:(%rdi)
    4322:	aa                   	stos   %al,%es:(%rdi)
    4323:	aa                   	stos   %al,%es:(%rdi)
    4324:	aa                   	stos   %al,%es:(%rdi)
    4325:	aa                   	stos   %al,%es:(%rdi)
    4326:	aa                   	stos   %al,%es:(%rdi)
    4327:	aa                   	stos   %al,%es:(%rdi)
    4328:	aa                   	stos   %al,%es:(%rdi)
    4329:	aa                   	stos   %al,%es:(%rdi)
    432a:	aa                   	stos   %al,%es:(%rdi)
    432b:	aa                   	stos   %al,%es:(%rdi)
    432c:	aa                   	stos   %al,%es:(%rdi)
    432d:	aa                   	stos   %al,%es:(%rdi)
    432e:	aa                   	stos   %al,%es:(%rdi)
    432f:	aa                   	stos   %al,%es:(%rdi)
    4330:	aa                   	stos   %al,%es:(%rdi)
    4331:	aa                   	stos   %al,%es:(%rdi)
    4332:	aa                   	stos   %al,%es:(%rdi)
    4333:	aa                   	stos   %al,%es:(%rdi)
    4334:	aa                   	stos   %al,%es:(%rdi)
    4335:	aa                   	stos   %al,%es:(%rdi)
    4336:	aa                   	stos   %al,%es:(%rdi)
    4337:	aa                   	stos   %al,%es:(%rdi)
    4338:	aa                   	stos   %al,%es:(%rdi)
    4339:	aa                   	stos   %al,%es:(%rdi)
    433a:	aa                   	stos   %al,%es:(%rdi)
    433b:	aa                   	stos   %al,%es:(%rdi)
    433c:	aa                   	stos   %al,%es:(%rdi)
    433d:	aa                   	stos   %al,%es:(%rdi)
    433e:	aa                   	stos   %al,%es:(%rdi)
    433f:	aa                   	stos   %al,%es:(%rdi)
    4340:	aa                   	stos   %al,%es:(%rdi)
    4341:	aa                   	stos   %al,%es:(%rdi)
    4342:	aa                   	stos   %al,%es:(%rdi)
    4343:	aa                   	stos   %al,%es:(%rdi)
    4344:	aa                   	stos   %al,%es:(%rdi)
    4345:	aa                   	stos   %al,%es:(%rdi)
    4346:	aa                   	stos   %al,%es:(%rdi)
    4347:	aa                   	stos   %al,%es:(%rdi)
    4348:	aa                   	stos   %al,%es:(%rdi)
    4349:	aa                   	stos   %al,%es:(%rdi)
    434a:	aa                   	stos   %al,%es:(%rdi)
    434b:	aa                   	stos   %al,%es:(%rdi)
    434c:	aa                   	stos   %al,%es:(%rdi)
    434d:	aa                   	stos   %al,%es:(%rdi)
    434e:	aa                   	stos   %al,%es:(%rdi)
    434f:	aa                   	stos   %al,%es:(%rdi)
    4350:	aa                   	stos   %al,%es:(%rdi)
    4351:	aa                   	stos   %al,%es:(%rdi)
    4352:	aa                   	stos   %al,%es:(%rdi)
    4353:	aa                   	stos   %al,%es:(%rdi)
    4354:	aa                   	stos   %al,%es:(%rdi)
    4355:	aa                   	stos   %al,%es:(%rdi)
    4356:	aa                   	stos   %al,%es:(%rdi)
    4357:	aa                   	stos   %al,%es:(%rdi)
    4358:	aa                   	stos   %al,%es:(%rdi)
    4359:	aa                   	stos   %al,%es:(%rdi)
    435a:	aa                   	stos   %al,%es:(%rdi)
    435b:	aa                   	stos   %al,%es:(%rdi)
    435c:	aa                   	stos   %al,%es:(%rdi)
    435d:	aa                   	stos   %al,%es:(%rdi)
    435e:	aa                   	stos   %al,%es:(%rdi)
    435f:	aa                   	stos   %al,%es:(%rdi)
    4360:	aa                   	stos   %al,%es:(%rdi)
    4361:	aa                   	stos   %al,%es:(%rdi)
    4362:	aa                   	stos   %al,%es:(%rdi)
    4363:	aa                   	stos   %al,%es:(%rdi)
    4364:	aa                   	stos   %al,%es:(%rdi)
    4365:	aa                   	stos   %al,%es:(%rdi)
    4366:	aa                   	stos   %al,%es:(%rdi)
    4367:	aa                   	stos   %al,%es:(%rdi)
    4368:	aa                   	stos   %al,%es:(%rdi)
    4369:	aa                   	stos   %al,%es:(%rdi)
    436a:	aa                   	stos   %al,%es:(%rdi)
    436b:	aa                   	stos   %al,%es:(%rdi)
    436c:	aa                   	stos   %al,%es:(%rdi)
    436d:	aa                   	stos   %al,%es:(%rdi)
    436e:	aa                   	stos   %al,%es:(%rdi)
    436f:	aa                   	stos   %al,%es:(%rdi)
    4370:	aa                   	stos   %al,%es:(%rdi)
    4371:	aa                   	stos   %al,%es:(%rdi)
    4372:	aa                   	stos   %al,%es:(%rdi)
    4373:	aa                   	stos   %al,%es:(%rdi)
    4374:	aa                   	stos   %al,%es:(%rdi)
    4375:	aa                   	stos   %al,%es:(%rdi)
    4376:	aa                   	stos   %al,%es:(%rdi)
    4377:	aa                   	stos   %al,%es:(%rdi)
    4378:	aa                   	stos   %al,%es:(%rdi)
    4379:	aa                   	stos   %al,%es:(%rdi)
    437a:	aa                   	stos   %al,%es:(%rdi)
    437b:	aa                   	stos   %al,%es:(%rdi)
    437c:	aa                   	stos   %al,%es:(%rdi)
    437d:	aa                   	stos   %al,%es:(%rdi)
    437e:	aa                   	stos   %al,%es:(%rdi)
    437f:	aa                   	stos   %al,%es:(%rdi)
    4380:	aa                   	stos   %al,%es:(%rdi)
    4381:	aa                   	stos   %al,%es:(%rdi)
    4382:	aa                   	stos   %al,%es:(%rdi)
    4383:	aa                   	stos   %al,%es:(%rdi)
    4384:	aa                   	stos   %al,%es:(%rdi)
    4385:	aa                   	stos   %al,%es:(%rdi)
    4386:	aa                   	stos   %al,%es:(%rdi)
    4387:	aa                   	stos   %al,%es:(%rdi)
    4388:	aa                   	stos   %al,%es:(%rdi)
    4389:	aa                   	stos   %al,%es:(%rdi)
    438a:	aa                   	stos   %al,%es:(%rdi)
    438b:	aa                   	stos   %al,%es:(%rdi)
    438c:	aa                   	stos   %al,%es:(%rdi)
    438d:	aa                   	stos   %al,%es:(%rdi)
    438e:	aa                   	stos   %al,%es:(%rdi)
    438f:	aa                   	stos   %al,%es:(%rdi)
    4390:	aa                   	stos   %al,%es:(%rdi)
    4391:	aa                   	stos   %al,%es:(%rdi)
    4392:	aa                   	stos   %al,%es:(%rdi)
    4393:	aa                   	stos   %al,%es:(%rdi)
    4394:	aa                   	stos   %al,%es:(%rdi)
    4395:	aa                   	stos   %al,%es:(%rdi)
    4396:	aa                   	stos   %al,%es:(%rdi)
    4397:	aa                   	stos   %al,%es:(%rdi)
    4398:	aa                   	stos   %al,%es:(%rdi)
    4399:	aa                   	stos   %al,%es:(%rdi)
    439a:	aa                   	stos   %al,%es:(%rdi)
    439b:	aa                   	stos   %al,%es:(%rdi)
    439c:	aa                   	stos   %al,%es:(%rdi)
    439d:	aa                   	stos   %al,%es:(%rdi)
    439e:	aa                   	stos   %al,%es:(%rdi)
    439f:	aa                   	stos   %al,%es:(%rdi)
    43a0:	aa                   	stos   %al,%es:(%rdi)
    43a1:	aa                   	stos   %al,%es:(%rdi)
    43a2:	aa                   	stos   %al,%es:(%rdi)
    43a3:	aa                   	stos   %al,%es:(%rdi)
    43a4:	aa                   	stos   %al,%es:(%rdi)
    43a5:	aa                   	stos   %al,%es:(%rdi)
    43a6:	aa                   	stos   %al,%es:(%rdi)
    43a7:	aa                   	stos   %al,%es:(%rdi)
    43a8:	aa                   	stos   %al,%es:(%rdi)
    43a9:	aa                   	stos   %al,%es:(%rdi)
    43aa:	aa                   	stos   %al,%es:(%rdi)
    43ab:	aa                   	stos   %al,%es:(%rdi)
    43ac:	aa                   	stos   %al,%es:(%rdi)
    43ad:	aa                   	stos   %al,%es:(%rdi)
    43ae:	aa                   	stos   %al,%es:(%rdi)
    43af:	aa                   	stos   %al,%es:(%rdi)
    43b0:	aa                   	stos   %al,%es:(%rdi)
    43b1:	aa                   	stos   %al,%es:(%rdi)
    43b2:	aa                   	stos   %al,%es:(%rdi)
    43b3:	aa                   	stos   %al,%es:(%rdi)
    43b4:	aa                   	stos   %al,%es:(%rdi)
    43b5:	aa                   	stos   %al,%es:(%rdi)
    43b6:	aa                   	stos   %al,%es:(%rdi)
    43b7:	aa                   	stos   %al,%es:(%rdi)
    43b8:	aa                   	stos   %al,%es:(%rdi)
    43b9:	aa                   	stos   %al,%es:(%rdi)
    43ba:	aa                   	stos   %al,%es:(%rdi)
    43bb:	aa                   	stos   %al,%es:(%rdi)
    43bc:	aa                   	stos   %al,%es:(%rdi)
    43bd:	aa                   	stos   %al,%es:(%rdi)
    43be:	aa                   	stos   %al,%es:(%rdi)
    43bf:	aa                   	stos   %al,%es:(%rdi)
    43c0:	aa                   	stos   %al,%es:(%rdi)
    43c1:	aa                   	stos   %al,%es:(%rdi)
    43c2:	aa                   	stos   %al,%es:(%rdi)
    43c3:	aa                   	stos   %al,%es:(%rdi)
    43c4:	aa                   	stos   %al,%es:(%rdi)
    43c5:	aa                   	stos   %al,%es:(%rdi)
    43c6:	aa                   	stos   %al,%es:(%rdi)
    43c7:	aa                   	stos   %al,%es:(%rdi)
    43c8:	aa                   	stos   %al,%es:(%rdi)
    43c9:	aa                   	stos   %al,%es:(%rdi)
    43ca:	aa                   	stos   %al,%es:(%rdi)
    43cb:	aa                   	stos   %al,%es:(%rdi)
    43cc:	aa                   	stos   %al,%es:(%rdi)
    43cd:	aa                   	stos   %al,%es:(%rdi)
    43ce:	aa                   	stos   %al,%es:(%rdi)
    43cf:	aa                   	stos   %al,%es:(%rdi)
    43d0:	aa                   	stos   %al,%es:(%rdi)
    43d1:	aa                   	stos   %al,%es:(%rdi)
    43d2:	aa                   	stos   %al,%es:(%rdi)
    43d3:	aa                   	stos   %al,%es:(%rdi)
    43d4:	aa                   	stos   %al,%es:(%rdi)
    43d5:	aa                   	stos   %al,%es:(%rdi)
    43d6:	aa                   	stos   %al,%es:(%rdi)
    43d7:	aa                   	stos   %al,%es:(%rdi)
    43d8:	aa                   	stos   %al,%es:(%rdi)
    43d9:	aa                   	stos   %al,%es:(%rdi)
    43da:	aa                   	stos   %al,%es:(%rdi)
    43db:	aa                   	stos   %al,%es:(%rdi)
    43dc:	aa                   	stos   %al,%es:(%rdi)
    43dd:	aa                   	stos   %al,%es:(%rdi)
    43de:	aa                   	stos   %al,%es:(%rdi)
    43df:	aa                   	stos   %al,%es:(%rdi)
    43e0:	aa                   	stos   %al,%es:(%rdi)
    43e1:	aa                   	stos   %al,%es:(%rdi)
    43e2:	aa                   	stos   %al,%es:(%rdi)
    43e3:	aa                   	stos   %al,%es:(%rdi)
    43e4:	aa                   	stos   %al,%es:(%rdi)
    43e5:	aa                   	stos   %al,%es:(%rdi)
    43e6:	aa                   	stos   %al,%es:(%rdi)
    43e7:	aa                   	stos   %al,%es:(%rdi)
    43e8:	aa                   	stos   %al,%es:(%rdi)
    43e9:	aa                   	stos   %al,%es:(%rdi)
    43ea:	aa                   	stos   %al,%es:(%rdi)
    43eb:	aa                   	stos   %al,%es:(%rdi)
    43ec:	aa                   	stos   %al,%es:(%rdi)
    43ed:	aa                   	stos   %al,%es:(%rdi)
    43ee:	aa                   	stos   %al,%es:(%rdi)
    43ef:	aa                   	stos   %al,%es:(%rdi)
    43f0:	aa                   	stos   %al,%es:(%rdi)
    43f1:	aa                   	stos   %al,%es:(%rdi)
    43f2:	aa                   	stos   %al,%es:(%rdi)
    43f3:	aa                   	stos   %al,%es:(%rdi)
    43f4:	aa                   	stos   %al,%es:(%rdi)
    43f5:	aa                   	stos   %al,%es:(%rdi)
    43f6:	aa                   	stos   %al,%es:(%rdi)
    43f7:	aa                   	stos   %al,%es:(%rdi)
    43f8:	aa                   	stos   %al,%es:(%rdi)
    43f9:	aa                   	stos   %al,%es:(%rdi)
    43fa:	aa                   	stos   %al,%es:(%rdi)
    43fb:	aa                   	stos   %al,%es:(%rdi)
    43fc:	aa                   	stos   %al,%es:(%rdi)
    43fd:	aa                   	stos   %al,%es:(%rdi)
    43fe:	aa                   	stos   %al,%es:(%rdi)
    43ff:	aa                   	stos   %al,%es:(%rdi)
    4400:	aa                   	stos   %al,%es:(%rdi)
    4401:	aa                   	stos   %al,%es:(%rdi)
    4402:	aa                   	stos   %al,%es:(%rdi)
    4403:	aa                   	stos   %al,%es:(%rdi)
    4404:	aa                   	stos   %al,%es:(%rdi)
    4405:	aa                   	stos   %al,%es:(%rdi)
    4406:	aa                   	stos   %al,%es:(%rdi)
    4407:	aa                   	stos   %al,%es:(%rdi)
    4408:	aa                   	stos   %al,%es:(%rdi)
    4409:	aa                   	stos   %al,%es:(%rdi)
    440a:	aa                   	stos   %al,%es:(%rdi)
    440b:	aa                   	stos   %al,%es:(%rdi)
    440c:	aa                   	stos   %al,%es:(%rdi)
    440d:	aa                   	stos   %al,%es:(%rdi)
    440e:	aa                   	stos   %al,%es:(%rdi)
    440f:	aa                   	stos   %al,%es:(%rdi)
    4410:	aa                   	stos   %al,%es:(%rdi)
    4411:	aa                   	stos   %al,%es:(%rdi)
    4412:	aa                   	stos   %al,%es:(%rdi)
    4413:	aa                   	stos   %al,%es:(%rdi)
    4414:	aa                   	stos   %al,%es:(%rdi)
    4415:	aa                   	stos   %al,%es:(%rdi)
    4416:	aa                   	stos   %al,%es:(%rdi)
    4417:	aa                   	stos   %al,%es:(%rdi)
    4418:	aa                   	stos   %al,%es:(%rdi)
    4419:	aa                   	stos   %al,%es:(%rdi)
    441a:	aa                   	stos   %al,%es:(%rdi)
    441b:	aa                   	stos   %al,%es:(%rdi)
    441c:	aa                   	stos   %al,%es:(%rdi)
    441d:	aa                   	stos   %al,%es:(%rdi)
    441e:	aa                   	stos   %al,%es:(%rdi)
    441f:	aa                   	stos   %al,%es:(%rdi)
    4420:	aa                   	stos   %al,%es:(%rdi)
    4421:	aa                   	stos   %al,%es:(%rdi)
    4422:	aa                   	stos   %al,%es:(%rdi)
    4423:	aa                   	stos   %al,%es:(%rdi)
    4424:	aa                   	stos   %al,%es:(%rdi)
    4425:	aa                   	stos   %al,%es:(%rdi)
    4426:	aa                   	stos   %al,%es:(%rdi)
    4427:	aa                   	stos   %al,%es:(%rdi)
    4428:	aa                   	stos   %al,%es:(%rdi)
    4429:	aa                   	stos   %al,%es:(%rdi)
    442a:	aa                   	stos   %al,%es:(%rdi)
    442b:	aa                   	stos   %al,%es:(%rdi)
    442c:	aa                   	stos   %al,%es:(%rdi)
    442d:	aa                   	stos   %al,%es:(%rdi)
    442e:	aa                   	stos   %al,%es:(%rdi)
    442f:	aa                   	stos   %al,%es:(%rdi)
    4430:	aa                   	stos   %al,%es:(%rdi)
    4431:	aa                   	stos   %al,%es:(%rdi)
    4432:	aa                   	stos   %al,%es:(%rdi)
    4433:	aa                   	stos   %al,%es:(%rdi)
    4434:	aa                   	stos   %al,%es:(%rdi)
    4435:	aa                   	stos   %al,%es:(%rdi)
    4436:	aa                   	stos   %al,%es:(%rdi)
    4437:	aa                   	stos   %al,%es:(%rdi)
    4438:	aa                   	stos   %al,%es:(%rdi)
    4439:	aa                   	stos   %al,%es:(%rdi)
    443a:	aa                   	stos   %al,%es:(%rdi)
    443b:	aa                   	stos   %al,%es:(%rdi)
    443c:	aa                   	stos   %al,%es:(%rdi)
    443d:	aa                   	stos   %al,%es:(%rdi)
    443e:	aa                   	stos   %al,%es:(%rdi)
    443f:	aa                   	stos   %al,%es:(%rdi)
    4440:	aa                   	stos   %al,%es:(%rdi)
    4441:	aa                   	stos   %al,%es:(%rdi)
    4442:	aa                   	stos   %al,%es:(%rdi)
    4443:	aa                   	stos   %al,%es:(%rdi)
    4444:	aa                   	stos   %al,%es:(%rdi)
    4445:	aa                   	stos   %al,%es:(%rdi)
    4446:	aa                   	stos   %al,%es:(%rdi)
    4447:	aa                   	stos   %al,%es:(%rdi)
    4448:	aa                   	stos   %al,%es:(%rdi)
    4449:	aa                   	stos   %al,%es:(%rdi)
    444a:	aa                   	stos   %al,%es:(%rdi)
    444b:	aa                   	stos   %al,%es:(%rdi)
    444c:	aa                   	stos   %al,%es:(%rdi)
    444d:	aa                   	stos   %al,%es:(%rdi)
    444e:	aa                   	stos   %al,%es:(%rdi)
    444f:	aa                   	stos   %al,%es:(%rdi)
    4450:	aa                   	stos   %al,%es:(%rdi)
    4451:	aa                   	stos   %al,%es:(%rdi)
    4452:	aa                   	stos   %al,%es:(%rdi)
    4453:	aa                   	stos   %al,%es:(%rdi)
    4454:	aa                   	stos   %al,%es:(%rdi)
    4455:	aa                   	stos   %al,%es:(%rdi)
    4456:	aa                   	stos   %al,%es:(%rdi)
    4457:	aa                   	stos   %al,%es:(%rdi)
    4458:	aa                   	stos   %al,%es:(%rdi)
    4459:	aa                   	stos   %al,%es:(%rdi)
    445a:	aa                   	stos   %al,%es:(%rdi)
    445b:	aa                   	stos   %al,%es:(%rdi)
    445c:	aa                   	stos   %al,%es:(%rdi)
    445d:	aa                   	stos   %al,%es:(%rdi)
    445e:	aa                   	stos   %al,%es:(%rdi)
    445f:	aa                   	stos   %al,%es:(%rdi)
    4460:	aa                   	stos   %al,%es:(%rdi)
    4461:	aa                   	stos   %al,%es:(%rdi)
    4462:	aa                   	stos   %al,%es:(%rdi)
    4463:	aa                   	stos   %al,%es:(%rdi)
    4464:	aa                   	stos   %al,%es:(%rdi)
    4465:	aa                   	stos   %al,%es:(%rdi)
    4466:	aa                   	stos   %al,%es:(%rdi)
    4467:	aa                   	stos   %al,%es:(%rdi)
    4468:	aa                   	stos   %al,%es:(%rdi)
    4469:	aa                   	stos   %al,%es:(%rdi)
    446a:	aa                   	stos   %al,%es:(%rdi)
    446b:	aa                   	stos   %al,%es:(%rdi)
    446c:	aa                   	stos   %al,%es:(%rdi)
    446d:	aa                   	stos   %al,%es:(%rdi)
    446e:	aa                   	stos   %al,%es:(%rdi)
    446f:	aa                   	stos   %al,%es:(%rdi)
    4470:	aa                   	stos   %al,%es:(%rdi)
    4471:	aa                   	stos   %al,%es:(%rdi)
    4472:	aa                   	stos   %al,%es:(%rdi)
    4473:	aa                   	stos   %al,%es:(%rdi)
    4474:	aa                   	stos   %al,%es:(%rdi)
    4475:	aa                   	stos   %al,%es:(%rdi)
    4476:	aa                   	stos   %al,%es:(%rdi)
    4477:	aa                   	stos   %al,%es:(%rdi)
    4478:	aa                   	stos   %al,%es:(%rdi)
    4479:	aa                   	stos   %al,%es:(%rdi)
    447a:	aa                   	stos   %al,%es:(%rdi)
    447b:	aa                   	stos   %al,%es:(%rdi)
    447c:	aa                   	stos   %al,%es:(%rdi)
    447d:	aa                   	stos   %al,%es:(%rdi)
    447e:	aa                   	stos   %al,%es:(%rdi)
    447f:	aa                   	stos   %al,%es:(%rdi)
    4480:	aa                   	stos   %al,%es:(%rdi)
    4481:	aa                   	stos   %al,%es:(%rdi)
    4482:	aa                   	stos   %al,%es:(%rdi)
    4483:	aa                   	stos   %al,%es:(%rdi)
    4484:	aa                   	stos   %al,%es:(%rdi)
    4485:	aa                   	stos   %al,%es:(%rdi)
    4486:	aa                   	stos   %al,%es:(%rdi)
    4487:	aa                   	stos   %al,%es:(%rdi)
    4488:	aa                   	stos   %al,%es:(%rdi)
    4489:	aa                   	stos   %al,%es:(%rdi)
    448a:	aa                   	stos   %al,%es:(%rdi)
    448b:	aa                   	stos   %al,%es:(%rdi)
    448c:	aa                   	stos   %al,%es:(%rdi)
    448d:	aa                   	stos   %al,%es:(%rdi)
    448e:	aa                   	stos   %al,%es:(%rdi)
    448f:	aa                   	stos   %al,%es:(%rdi)
    4490:	aa                   	stos   %al,%es:(%rdi)
    4491:	aa                   	stos   %al,%es:(%rdi)
    4492:	aa                   	stos   %al,%es:(%rdi)
    4493:	aa                   	stos   %al,%es:(%rdi)
    4494:	aa                   	stos   %al,%es:(%rdi)
    4495:	aa                   	stos   %al,%es:(%rdi)
    4496:	aa                   	stos   %al,%es:(%rdi)
    4497:	aa                   	stos   %al,%es:(%rdi)
    4498:	aa                   	stos   %al,%es:(%rdi)
    4499:	aa                   	stos   %al,%es:(%rdi)
    449a:	aa                   	stos   %al,%es:(%rdi)
    449b:	aa                   	stos   %al,%es:(%rdi)
    449c:	aa                   	stos   %al,%es:(%rdi)
    449d:	aa                   	stos   %al,%es:(%rdi)
    449e:	aa                   	stos   %al,%es:(%rdi)
    449f:	aa                   	stos   %al,%es:(%rdi)
    44a0:	aa                   	stos   %al,%es:(%rdi)
    44a1:	aa                   	stos   %al,%es:(%rdi)
    44a2:	aa                   	stos   %al,%es:(%rdi)
    44a3:	aa                   	stos   %al,%es:(%rdi)
    44a4:	aa                   	stos   %al,%es:(%rdi)
    44a5:	aa                   	stos   %al,%es:(%rdi)
    44a6:	aa                   	stos   %al,%es:(%rdi)
    44a7:	aa                   	stos   %al,%es:(%rdi)
    44a8:	aa                   	stos   %al,%es:(%rdi)
    44a9:	aa                   	stos   %al,%es:(%rdi)
    44aa:	aa                   	stos   %al,%es:(%rdi)
    44ab:	aa                   	stos   %al,%es:(%rdi)
    44ac:	aa                   	stos   %al,%es:(%rdi)
    44ad:	aa                   	stos   %al,%es:(%rdi)
    44ae:	aa                   	stos   %al,%es:(%rdi)
    44af:	aa                   	stos   %al,%es:(%rdi)
    44b0:	aa                   	stos   %al,%es:(%rdi)
    44b1:	aa                   	stos   %al,%es:(%rdi)
    44b2:	aa                   	stos   %al,%es:(%rdi)
    44b3:	aa                   	stos   %al,%es:(%rdi)
    44b4:	aa                   	stos   %al,%es:(%rdi)
    44b5:	aa                   	stos   %al,%es:(%rdi)
    44b6:	aa                   	stos   %al,%es:(%rdi)
    44b7:	aa                   	stos   %al,%es:(%rdi)
    44b8:	aa                   	stos   %al,%es:(%rdi)
    44b9:	aa                   	stos   %al,%es:(%rdi)
    44ba:	aa                   	stos   %al,%es:(%rdi)
    44bb:	aa                   	stos   %al,%es:(%rdi)
    44bc:	aa                   	stos   %al,%es:(%rdi)
    44bd:	aa                   	stos   %al,%es:(%rdi)
    44be:	aa                   	stos   %al,%es:(%rdi)
    44bf:	aa                   	stos   %al,%es:(%rdi)
    44c0:	aa                   	stos   %al,%es:(%rdi)
    44c1:	aa                   	stos   %al,%es:(%rdi)
    44c2:	aa                   	stos   %al,%es:(%rdi)
    44c3:	aa                   	stos   %al,%es:(%rdi)
    44c4:	aa                   	stos   %al,%es:(%rdi)
    44c5:	aa                   	stos   %al,%es:(%rdi)
    44c6:	aa                   	stos   %al,%es:(%rdi)
    44c7:	aa                   	stos   %al,%es:(%rdi)
    44c8:	aa                   	stos   %al,%es:(%rdi)
    44c9:	aa                   	stos   %al,%es:(%rdi)
    44ca:	aa                   	stos   %al,%es:(%rdi)
    44cb:	aa                   	stos   %al,%es:(%rdi)
    44cc:	aa                   	stos   %al,%es:(%rdi)
    44cd:	aa                   	stos   %al,%es:(%rdi)
    44ce:	aa                   	stos   %al,%es:(%rdi)
    44cf:	aa                   	stos   %al,%es:(%rdi)
    44d0:	aa                   	stos   %al,%es:(%rdi)
    44d1:	aa                   	stos   %al,%es:(%rdi)
    44d2:	aa                   	stos   %al,%es:(%rdi)
    44d3:	aa                   	stos   %al,%es:(%rdi)
    44d4:	aa                   	stos   %al,%es:(%rdi)
    44d5:	aa                   	stos   %al,%es:(%rdi)
    44d6:	aa                   	stos   %al,%es:(%rdi)
    44d7:	aa                   	stos   %al,%es:(%rdi)
    44d8:	aa                   	stos   %al,%es:(%rdi)
    44d9:	aa                   	stos   %al,%es:(%rdi)
    44da:	aa                   	stos   %al,%es:(%rdi)
    44db:	aa                   	stos   %al,%es:(%rdi)
    44dc:	aa                   	stos   %al,%es:(%rdi)
    44dd:	aa                   	stos   %al,%es:(%rdi)
    44de:	aa                   	stos   %al,%es:(%rdi)
    44df:	aa                   	stos   %al,%es:(%rdi)
    44e0:	aa                   	stos   %al,%es:(%rdi)
    44e1:	aa                   	stos   %al,%es:(%rdi)
    44e2:	aa                   	stos   %al,%es:(%rdi)
    44e3:	aa                   	stos   %al,%es:(%rdi)
    44e4:	aa                   	stos   %al,%es:(%rdi)
    44e5:	aa                   	stos   %al,%es:(%rdi)
    44e6:	aa                   	stos   %al,%es:(%rdi)
    44e7:	aa                   	stos   %al,%es:(%rdi)
    44e8:	aa                   	stos   %al,%es:(%rdi)
    44e9:	aa                   	stos   %al,%es:(%rdi)
    44ea:	aa                   	stos   %al,%es:(%rdi)
    44eb:	aa                   	stos   %al,%es:(%rdi)
    44ec:	aa                   	stos   %al,%es:(%rdi)
    44ed:	aa                   	stos   %al,%es:(%rdi)
    44ee:	aa                   	stos   %al,%es:(%rdi)
    44ef:	aa                   	stos   %al,%es:(%rdi)
    44f0:	aa                   	stos   %al,%es:(%rdi)
    44f1:	aa                   	stos   %al,%es:(%rdi)
    44f2:	aa                   	stos   %al,%es:(%rdi)
    44f3:	aa                   	stos   %al,%es:(%rdi)
    44f4:	aa                   	stos   %al,%es:(%rdi)
    44f5:	aa                   	stos   %al,%es:(%rdi)
    44f6:	aa                   	stos   %al,%es:(%rdi)
    44f7:	aa                   	stos   %al,%es:(%rdi)
    44f8:	aa                   	stos   %al,%es:(%rdi)
    44f9:	aa                   	stos   %al,%es:(%rdi)
    44fa:	aa                   	stos   %al,%es:(%rdi)
    44fb:	aa                   	stos   %al,%es:(%rdi)
    44fc:	aa                   	stos   %al,%es:(%rdi)
    44fd:	aa                   	stos   %al,%es:(%rdi)
    44fe:	aa                   	stos   %al,%es:(%rdi)
    44ff:	aa                   	stos   %al,%es:(%rdi)
    4500:	aa                   	stos   %al,%es:(%rdi)
    4501:	aa                   	stos   %al,%es:(%rdi)
    4502:	aa                   	stos   %al,%es:(%rdi)
    4503:	aa                   	stos   %al,%es:(%rdi)
    4504:	aa                   	stos   %al,%es:(%rdi)
    4505:	aa                   	stos   %al,%es:(%rdi)
    4506:	aa                   	stos   %al,%es:(%rdi)
    4507:	aa                   	stos   %al,%es:(%rdi)
    4508:	aa                   	stos   %al,%es:(%rdi)
    4509:	aa                   	stos   %al,%es:(%rdi)
    450a:	aa                   	stos   %al,%es:(%rdi)
    450b:	aa                   	stos   %al,%es:(%rdi)
    450c:	aa                   	stos   %al,%es:(%rdi)
    450d:	aa                   	stos   %al,%es:(%rdi)
    450e:	aa                   	stos   %al,%es:(%rdi)
    450f:	aa                   	stos   %al,%es:(%rdi)
    4510:	aa                   	stos   %al,%es:(%rdi)
    4511:	aa                   	stos   %al,%es:(%rdi)
    4512:	aa                   	stos   %al,%es:(%rdi)
    4513:	aa                   	stos   %al,%es:(%rdi)
    4514:	aa                   	stos   %al,%es:(%rdi)
    4515:	aa                   	stos   %al,%es:(%rdi)
    4516:	aa                   	stos   %al,%es:(%rdi)
    4517:	aa                   	stos   %al,%es:(%rdi)
    4518:	aa                   	stos   %al,%es:(%rdi)
    4519:	aa                   	stos   %al,%es:(%rdi)
    451a:	aa                   	stos   %al,%es:(%rdi)
    451b:	aa                   	stos   %al,%es:(%rdi)
    451c:	aa                   	stos   %al,%es:(%rdi)
    451d:	aa                   	stos   %al,%es:(%rdi)
    451e:	aa                   	stos   %al,%es:(%rdi)
    451f:	aa                   	stos   %al,%es:(%rdi)
    4520:	aa                   	stos   %al,%es:(%rdi)
    4521:	aa                   	stos   %al,%es:(%rdi)
    4522:	aa                   	stos   %al,%es:(%rdi)
    4523:	aa                   	stos   %al,%es:(%rdi)
    4524:	aa                   	stos   %al,%es:(%rdi)
    4525:	aa                   	stos   %al,%es:(%rdi)
    4526:	aa                   	stos   %al,%es:(%rdi)
    4527:	aa                   	stos   %al,%es:(%rdi)
    4528:	aa                   	stos   %al,%es:(%rdi)
    4529:	aa                   	stos   %al,%es:(%rdi)
    452a:	aa                   	stos   %al,%es:(%rdi)
    452b:	aa                   	stos   %al,%es:(%rdi)
    452c:	aa                   	stos   %al,%es:(%rdi)
    452d:	aa                   	stos   %al,%es:(%rdi)
    452e:	aa                   	stos   %al,%es:(%rdi)
    452f:	aa                   	stos   %al,%es:(%rdi)
    4530:	aa                   	stos   %al,%es:(%rdi)
    4531:	aa                   	stos   %al,%es:(%rdi)
    4532:	aa                   	stos   %al,%es:(%rdi)
    4533:	aa                   	stos   %al,%es:(%rdi)
    4534:	aa                   	stos   %al,%es:(%rdi)
    4535:	aa                   	stos   %al,%es:(%rdi)
    4536:	aa                   	stos   %al,%es:(%rdi)
    4537:	aa                   	stos   %al,%es:(%rdi)
    4538:	aa                   	stos   %al,%es:(%rdi)
    4539:	aa                   	stos   %al,%es:(%rdi)
    453a:	aa                   	stos   %al,%es:(%rdi)
    453b:	aa                   	stos   %al,%es:(%rdi)
    453c:	aa                   	stos   %al,%es:(%rdi)
    453d:	aa                   	stos   %al,%es:(%rdi)
    453e:	aa                   	stos   %al,%es:(%rdi)
    453f:	aa                   	stos   %al,%es:(%rdi)
    4540:	aa                   	stos   %al,%es:(%rdi)
    4541:	aa                   	stos   %al,%es:(%rdi)
    4542:	aa                   	stos   %al,%es:(%rdi)
    4543:	aa                   	stos   %al,%es:(%rdi)
    4544:	aa                   	stos   %al,%es:(%rdi)
    4545:	aa                   	stos   %al,%es:(%rdi)
    4546:	aa                   	stos   %al,%es:(%rdi)
    4547:	aa                   	stos   %al,%es:(%rdi)
    4548:	aa                   	stos   %al,%es:(%rdi)
    4549:	aa                   	stos   %al,%es:(%rdi)
    454a:	aa                   	stos   %al,%es:(%rdi)
    454b:	aa                   	stos   %al,%es:(%rdi)
    454c:	aa                   	stos   %al,%es:(%rdi)
    454d:	aa                   	stos   %al,%es:(%rdi)
    454e:	aa                   	stos   %al,%es:(%rdi)
    454f:	aa                   	stos   %al,%es:(%rdi)
    4550:	aa                   	stos   %al,%es:(%rdi)
    4551:	aa                   	stos   %al,%es:(%rdi)
    4552:	aa                   	stos   %al,%es:(%rdi)
    4553:	aa                   	stos   %al,%es:(%rdi)
    4554:	aa                   	stos   %al,%es:(%rdi)
    4555:	aa                   	stos   %al,%es:(%rdi)
    4556:	aa                   	stos   %al,%es:(%rdi)
    4557:	aa                   	stos   %al,%es:(%rdi)
    4558:	aa                   	stos   %al,%es:(%rdi)
    4559:	aa                   	stos   %al,%es:(%rdi)
    455a:	aa                   	stos   %al,%es:(%rdi)
    455b:	aa                   	stos   %al,%es:(%rdi)
    455c:	aa                   	stos   %al,%es:(%rdi)
    455d:	aa                   	stos   %al,%es:(%rdi)
    455e:	aa                   	stos   %al,%es:(%rdi)
    455f:	aa                   	stos   %al,%es:(%rdi)
    4560:	aa                   	stos   %al,%es:(%rdi)
    4561:	aa                   	stos   %al,%es:(%rdi)
    4562:	aa                   	stos   %al,%es:(%rdi)
    4563:	aa                   	stos   %al,%es:(%rdi)
    4564:	aa                   	stos   %al,%es:(%rdi)
    4565:	aa                   	stos   %al,%es:(%rdi)
    4566:	aa                   	stos   %al,%es:(%rdi)
    4567:	aa                   	stos   %al,%es:(%rdi)
    4568:	aa                   	stos   %al,%es:(%rdi)
    4569:	aa                   	stos   %al,%es:(%rdi)
    456a:	aa                   	stos   %al,%es:(%rdi)
    456b:	aa                   	stos   %al,%es:(%rdi)
    456c:	aa                   	stos   %al,%es:(%rdi)
    456d:	aa                   	stos   %al,%es:(%rdi)
    456e:	aa                   	stos   %al,%es:(%rdi)
    456f:	aa                   	stos   %al,%es:(%rdi)
    4570:	aa                   	stos   %al,%es:(%rdi)
    4571:	aa                   	stos   %al,%es:(%rdi)
    4572:	aa                   	stos   %al,%es:(%rdi)
    4573:	aa                   	stos   %al,%es:(%rdi)
    4574:	aa                   	stos   %al,%es:(%rdi)
    4575:	aa                   	stos   %al,%es:(%rdi)
    4576:	aa                   	stos   %al,%es:(%rdi)
    4577:	aa                   	stos   %al,%es:(%rdi)
    4578:	aa                   	stos   %al,%es:(%rdi)
    4579:	aa                   	stos   %al,%es:(%rdi)
    457a:	aa                   	stos   %al,%es:(%rdi)
    457b:	aa                   	stos   %al,%es:(%rdi)
    457c:	aa                   	stos   %al,%es:(%rdi)
    457d:	aa                   	stos   %al,%es:(%rdi)
    457e:	aa                   	stos   %al,%es:(%rdi)
    457f:	aa                   	stos   %al,%es:(%rdi)
    4580:	aa                   	stos   %al,%es:(%rdi)
    4581:	aa                   	stos   %al,%es:(%rdi)
    4582:	aa                   	stos   %al,%es:(%rdi)
    4583:	aa                   	stos   %al,%es:(%rdi)
    4584:	aa                   	stos   %al,%es:(%rdi)
    4585:	aa                   	stos   %al,%es:(%rdi)
    4586:	aa                   	stos   %al,%es:(%rdi)
    4587:	aa                   	stos   %al,%es:(%rdi)
    4588:	aa                   	stos   %al,%es:(%rdi)
    4589:	aa                   	stos   %al,%es:(%rdi)
    458a:	aa                   	stos   %al,%es:(%rdi)
    458b:	aa                   	stos   %al,%es:(%rdi)
    458c:	aa                   	stos   %al,%es:(%rdi)
    458d:	aa                   	stos   %al,%es:(%rdi)
    458e:	aa                   	stos   %al,%es:(%rdi)
    458f:	aa                   	stos   %al,%es:(%rdi)
    4590:	aa                   	stos   %al,%es:(%rdi)
    4591:	aa                   	stos   %al,%es:(%rdi)
    4592:	aa                   	stos   %al,%es:(%rdi)
    4593:	aa                   	stos   %al,%es:(%rdi)
    4594:	aa                   	stos   %al,%es:(%rdi)
    4595:	aa                   	stos   %al,%es:(%rdi)
    4596:	aa                   	stos   %al,%es:(%rdi)
    4597:	aa                   	stos   %al,%es:(%rdi)
    4598:	aa                   	stos   %al,%es:(%rdi)
    4599:	aa                   	stos   %al,%es:(%rdi)
    459a:	aa                   	stos   %al,%es:(%rdi)
    459b:	aa                   	stos   %al,%es:(%rdi)
    459c:	aa                   	stos   %al,%es:(%rdi)
    459d:	aa                   	stos   %al,%es:(%rdi)
    459e:	aa                   	stos   %al,%es:(%rdi)
    459f:	aa                   	stos   %al,%es:(%rdi)
    45a0:	aa                   	stos   %al,%es:(%rdi)
    45a1:	aa                   	stos   %al,%es:(%rdi)
    45a2:	aa                   	stos   %al,%es:(%rdi)
    45a3:	aa                   	stos   %al,%es:(%rdi)
    45a4:	aa                   	stos   %al,%es:(%rdi)
    45a5:	aa                   	stos   %al,%es:(%rdi)
    45a6:	aa                   	stos   %al,%es:(%rdi)
    45a7:	aa                   	stos   %al,%es:(%rdi)
    45a8:	aa                   	stos   %al,%es:(%rdi)
    45a9:	aa                   	stos   %al,%es:(%rdi)
    45aa:	aa                   	stos   %al,%es:(%rdi)
    45ab:	aa                   	stos   %al,%es:(%rdi)
    45ac:	aa                   	stos   %al,%es:(%rdi)
    45ad:	aa                   	stos   %al,%es:(%rdi)
    45ae:	aa                   	stos   %al,%es:(%rdi)
    45af:	aa                   	stos   %al,%es:(%rdi)
    45b0:	aa                   	stos   %al,%es:(%rdi)
    45b1:	aa                   	stos   %al,%es:(%rdi)
    45b2:	aa                   	stos   %al,%es:(%rdi)
    45b3:	aa                   	stos   %al,%es:(%rdi)
    45b4:	aa                   	stos   %al,%es:(%rdi)
    45b5:	aa                   	stos   %al,%es:(%rdi)
    45b6:	aa                   	stos   %al,%es:(%rdi)
    45b7:	aa                   	stos   %al,%es:(%rdi)
    45b8:	aa                   	stos   %al,%es:(%rdi)
    45b9:	aa                   	stos   %al,%es:(%rdi)
    45ba:	aa                   	stos   %al,%es:(%rdi)
    45bb:	aa                   	stos   %al,%es:(%rdi)
    45bc:	aa                   	stos   %al,%es:(%rdi)
    45bd:	aa                   	stos   %al,%es:(%rdi)
    45be:	aa                   	stos   %al,%es:(%rdi)
    45bf:	aa                   	stos   %al,%es:(%rdi)
    45c0:	aa                   	stos   %al,%es:(%rdi)
    45c1:	aa                   	stos   %al,%es:(%rdi)
    45c2:	aa                   	stos   %al,%es:(%rdi)
    45c3:	aa                   	stos   %al,%es:(%rdi)
    45c4:	aa                   	stos   %al,%es:(%rdi)
    45c5:	aa                   	stos   %al,%es:(%rdi)
    45c6:	aa                   	stos   %al,%es:(%rdi)
    45c7:	aa                   	stos   %al,%es:(%rdi)
    45c8:	aa                   	stos   %al,%es:(%rdi)
    45c9:	aa                   	stos   %al,%es:(%rdi)
    45ca:	aa                   	stos   %al,%es:(%rdi)
    45cb:	aa                   	stos   %al,%es:(%rdi)
    45cc:	aa                   	stos   %al,%es:(%rdi)
    45cd:	aa                   	stos   %al,%es:(%rdi)
    45ce:	aa                   	stos   %al,%es:(%rdi)
    45cf:	aa                   	stos   %al,%es:(%rdi)
    45d0:	aa                   	stos   %al,%es:(%rdi)
    45d1:	aa                   	stos   %al,%es:(%rdi)
    45d2:	aa                   	stos   %al,%es:(%rdi)
    45d3:	aa                   	stos   %al,%es:(%rdi)
    45d4:	aa                   	stos   %al,%es:(%rdi)
    45d5:	aa                   	stos   %al,%es:(%rdi)
    45d6:	aa                   	stos   %al,%es:(%rdi)
    45d7:	aa                   	stos   %al,%es:(%rdi)
    45d8:	aa                   	stos   %al,%es:(%rdi)
    45d9:	aa                   	stos   %al,%es:(%rdi)
    45da:	aa                   	stos   %al,%es:(%rdi)
    45db:	aa                   	stos   %al,%es:(%rdi)
    45dc:	aa                   	stos   %al,%es:(%rdi)
    45dd:	aa                   	stos   %al,%es:(%rdi)
    45de:	aa                   	stos   %al,%es:(%rdi)
    45df:	aa                   	stos   %al,%es:(%rdi)
    45e0:	aa                   	stos   %al,%es:(%rdi)
    45e1:	aa                   	stos   %al,%es:(%rdi)
    45e2:	aa                   	stos   %al,%es:(%rdi)
    45e3:	aa                   	stos   %al,%es:(%rdi)
    45e4:	aa                   	stos   %al,%es:(%rdi)
    45e5:	aa                   	stos   %al,%es:(%rdi)
    45e6:	aa                   	stos   %al,%es:(%rdi)
    45e7:	aa                   	stos   %al,%es:(%rdi)
    45e8:	aa                   	stos   %al,%es:(%rdi)
    45e9:	aa                   	stos   %al,%es:(%rdi)
    45ea:	aa                   	stos   %al,%es:(%rdi)
    45eb:	aa                   	stos   %al,%es:(%rdi)
    45ec:	aa                   	stos   %al,%es:(%rdi)
    45ed:	aa                   	stos   %al,%es:(%rdi)
    45ee:	aa                   	stos   %al,%es:(%rdi)
    45ef:	aa                   	stos   %al,%es:(%rdi)
    45f0:	aa                   	stos   %al,%es:(%rdi)
    45f1:	aa                   	stos   %al,%es:(%rdi)
    45f2:	aa                   	stos   %al,%es:(%rdi)
    45f3:	aa                   	stos   %al,%es:(%rdi)
    45f4:	aa                   	stos   %al,%es:(%rdi)
    45f5:	aa                   	stos   %al,%es:(%rdi)
    45f6:	aa                   	stos   %al,%es:(%rdi)
    45f7:	aa                   	stos   %al,%es:(%rdi)
    45f8:	aa                   	stos   %al,%es:(%rdi)
    45f9:	aa                   	stos   %al,%es:(%rdi)
    45fa:	aa                   	stos   %al,%es:(%rdi)
    45fb:	aa                   	stos   %al,%es:(%rdi)
    45fc:	aa                   	stos   %al,%es:(%rdi)
    45fd:	aa                   	stos   %al,%es:(%rdi)
    45fe:	aa                   	stos   %al,%es:(%rdi)
    45ff:	aa                   	stos   %al,%es:(%rdi)
    4600:	aa                   	stos   %al,%es:(%rdi)
    4601:	aa                   	stos   %al,%es:(%rdi)
    4602:	aa                   	stos   %al,%es:(%rdi)
    4603:	aa                   	stos   %al,%es:(%rdi)
    4604:	aa                   	stos   %al,%es:(%rdi)
    4605:	aa                   	stos   %al,%es:(%rdi)
    4606:	aa                   	stos   %al,%es:(%rdi)
    4607:	aa                   	stos   %al,%es:(%rdi)
    4608:	aa                   	stos   %al,%es:(%rdi)
    4609:	aa                   	stos   %al,%es:(%rdi)
    460a:	aa                   	stos   %al,%es:(%rdi)
    460b:	aa                   	stos   %al,%es:(%rdi)
    460c:	aa                   	stos   %al,%es:(%rdi)
    460d:	aa                   	stos   %al,%es:(%rdi)
    460e:	aa                   	stos   %al,%es:(%rdi)
    460f:	aa                   	stos   %al,%es:(%rdi)
    4610:	aa                   	stos   %al,%es:(%rdi)
    4611:	aa                   	stos   %al,%es:(%rdi)
    4612:	aa                   	stos   %al,%es:(%rdi)
    4613:	aa                   	stos   %al,%es:(%rdi)
    4614:	aa                   	stos   %al,%es:(%rdi)
    4615:	aa                   	stos   %al,%es:(%rdi)
    4616:	aa                   	stos   %al,%es:(%rdi)
    4617:	aa                   	stos   %al,%es:(%rdi)
    4618:	aa                   	stos   %al,%es:(%rdi)
    4619:	aa                   	stos   %al,%es:(%rdi)
    461a:	aa                   	stos   %al,%es:(%rdi)
    461b:	aa                   	stos   %al,%es:(%rdi)
    461c:	aa                   	stos   %al,%es:(%rdi)
    461d:	aa                   	stos   %al,%es:(%rdi)
    461e:	aa                   	stos   %al,%es:(%rdi)
    461f:	aa                   	stos   %al,%es:(%rdi)
    4620:	aa                   	stos   %al,%es:(%rdi)
    4621:	aa                   	stos   %al,%es:(%rdi)
    4622:	aa                   	stos   %al,%es:(%rdi)
    4623:	aa                   	stos   %al,%es:(%rdi)
    4624:	aa                   	stos   %al,%es:(%rdi)
    4625:	aa                   	stos   %al,%es:(%rdi)
    4626:	aa                   	stos   %al,%es:(%rdi)
    4627:	aa                   	stos   %al,%es:(%rdi)
    4628:	aa                   	stos   %al,%es:(%rdi)
    4629:	aa                   	stos   %al,%es:(%rdi)
    462a:	aa                   	stos   %al,%es:(%rdi)
    462b:	aa                   	stos   %al,%es:(%rdi)
    462c:	aa                   	stos   %al,%es:(%rdi)
    462d:	aa                   	stos   %al,%es:(%rdi)
    462e:	aa                   	stos   %al,%es:(%rdi)
    462f:	aa                   	stos   %al,%es:(%rdi)
    4630:	aa                   	stos   %al,%es:(%rdi)
    4631:	aa                   	stos   %al,%es:(%rdi)
    4632:	aa                   	stos   %al,%es:(%rdi)
    4633:	aa                   	stos   %al,%es:(%rdi)
    4634:	aa                   	stos   %al,%es:(%rdi)
    4635:	aa                   	stos   %al,%es:(%rdi)
    4636:	aa                   	stos   %al,%es:(%rdi)
    4637:	aa                   	stos   %al,%es:(%rdi)
    4638:	aa                   	stos   %al,%es:(%rdi)
    4639:	aa                   	stos   %al,%es:(%rdi)
    463a:	aa                   	stos   %al,%es:(%rdi)
    463b:	aa                   	stos   %al,%es:(%rdi)
    463c:	aa                   	stos   %al,%es:(%rdi)
    463d:	aa                   	stos   %al,%es:(%rdi)
    463e:	aa                   	stos   %al,%es:(%rdi)
    463f:	aa                   	stos   %al,%es:(%rdi)
    4640:	aa                   	stos   %al,%es:(%rdi)
    4641:	aa                   	stos   %al,%es:(%rdi)
    4642:	aa                   	stos   %al,%es:(%rdi)
    4643:	aa                   	stos   %al,%es:(%rdi)
    4644:	aa                   	stos   %al,%es:(%rdi)
    4645:	aa                   	stos   %al,%es:(%rdi)
    4646:	aa                   	stos   %al,%es:(%rdi)
    4647:	aa                   	stos   %al,%es:(%rdi)
    4648:	aa                   	stos   %al,%es:(%rdi)
    4649:	aa                   	stos   %al,%es:(%rdi)
    464a:	aa                   	stos   %al,%es:(%rdi)
    464b:	aa                   	stos   %al,%es:(%rdi)
    464c:	aa                   	stos   %al,%es:(%rdi)
    464d:	aa                   	stos   %al,%es:(%rdi)
    464e:	aa                   	stos   %al,%es:(%rdi)
    464f:	aa                   	stos   %al,%es:(%rdi)
    4650:	aa                   	stos   %al,%es:(%rdi)
    4651:	aa                   	stos   %al,%es:(%rdi)
    4652:	aa                   	stos   %al,%es:(%rdi)
    4653:	aa                   	stos   %al,%es:(%rdi)
    4654:	aa                   	stos   %al,%es:(%rdi)
    4655:	aa                   	stos   %al,%es:(%rdi)
    4656:	aa                   	stos   %al,%es:(%rdi)
    4657:	aa                   	stos   %al,%es:(%rdi)
    4658:	aa                   	stos   %al,%es:(%rdi)
    4659:	aa                   	stos   %al,%es:(%rdi)
    465a:	aa                   	stos   %al,%es:(%rdi)
    465b:	aa                   	stos   %al,%es:(%rdi)
    465c:	aa                   	stos   %al,%es:(%rdi)
    465d:	aa                   	stos   %al,%es:(%rdi)
    465e:	aa                   	stos   %al,%es:(%rdi)
    465f:	aa                   	stos   %al,%es:(%rdi)
    4660:	aa                   	stos   %al,%es:(%rdi)
    4661:	aa                   	stos   %al,%es:(%rdi)
    4662:	aa                   	stos   %al,%es:(%rdi)
    4663:	aa                   	stos   %al,%es:(%rdi)
    4664:	aa                   	stos   %al,%es:(%rdi)
    4665:	aa                   	stos   %al,%es:(%rdi)
    4666:	aa                   	stos   %al,%es:(%rdi)
    4667:	aa                   	stos   %al,%es:(%rdi)
    4668:	aa                   	stos   %al,%es:(%rdi)
    4669:	aa                   	stos   %al,%es:(%rdi)
    466a:	aa                   	stos   %al,%es:(%rdi)
    466b:	aa                   	stos   %al,%es:(%rdi)
    466c:	aa                   	stos   %al,%es:(%rdi)
    466d:	aa                   	stos   %al,%es:(%rdi)
    466e:	aa                   	stos   %al,%es:(%rdi)
    466f:	aa                   	stos   %al,%es:(%rdi)
    4670:	aa                   	stos   %al,%es:(%rdi)
    4671:	aa                   	stos   %al,%es:(%rdi)
    4672:	aa                   	stos   %al,%es:(%rdi)
    4673:	aa                   	stos   %al,%es:(%rdi)
    4674:	aa                   	stos   %al,%es:(%rdi)
    4675:	aa                   	stos   %al,%es:(%rdi)
    4676:	aa                   	stos   %al,%es:(%rdi)
    4677:	aa                   	stos   %al,%es:(%rdi)
    4678:	aa                   	stos   %al,%es:(%rdi)
    4679:	aa                   	stos   %al,%es:(%rdi)
    467a:	aa                   	stos   %al,%es:(%rdi)
    467b:	aa                   	stos   %al,%es:(%rdi)
    467c:	aa                   	stos   %al,%es:(%rdi)
    467d:	aa                   	stos   %al,%es:(%rdi)
    467e:	aa                   	stos   %al,%es:(%rdi)
    467f:	aa                   	stos   %al,%es:(%rdi)
    4680:	aa                   	stos   %al,%es:(%rdi)
    4681:	aa                   	stos   %al,%es:(%rdi)
    4682:	aa                   	stos   %al,%es:(%rdi)
    4683:	aa                   	stos   %al,%es:(%rdi)
    4684:	aa                   	stos   %al,%es:(%rdi)
    4685:	aa                   	stos   %al,%es:(%rdi)
    4686:	aa                   	stos   %al,%es:(%rdi)
    4687:	aa                   	stos   %al,%es:(%rdi)
    4688:	aa                   	stos   %al,%es:(%rdi)
    4689:	aa                   	stos   %al,%es:(%rdi)
    468a:	aa                   	stos   %al,%es:(%rdi)
    468b:	aa                   	stos   %al,%es:(%rdi)
    468c:	aa                   	stos   %al,%es:(%rdi)
    468d:	aa                   	stos   %al,%es:(%rdi)
    468e:	aa                   	stos   %al,%es:(%rdi)
    468f:	aa                   	stos   %al,%es:(%rdi)
    4690:	aa                   	stos   %al,%es:(%rdi)
    4691:	aa                   	stos   %al,%es:(%rdi)
    4692:	aa                   	stos   %al,%es:(%rdi)
    4693:	aa                   	stos   %al,%es:(%rdi)
    4694:	aa                   	stos   %al,%es:(%rdi)
    4695:	aa                   	stos   %al,%es:(%rdi)
    4696:	aa                   	stos   %al,%es:(%rdi)
    4697:	aa                   	stos   %al,%es:(%rdi)
    4698:	aa                   	stos   %al,%es:(%rdi)
    4699:	aa                   	stos   %al,%es:(%rdi)
    469a:	aa                   	stos   %al,%es:(%rdi)
    469b:	aa                   	stos   %al,%es:(%rdi)
    469c:	aa                   	stos   %al,%es:(%rdi)
    469d:	aa                   	stos   %al,%es:(%rdi)
    469e:	aa                   	stos   %al,%es:(%rdi)
    469f:	aa                   	stos   %al,%es:(%rdi)
    46a0:	aa                   	stos   %al,%es:(%rdi)
    46a1:	aa                   	stos   %al,%es:(%rdi)
    46a2:	aa                   	stos   %al,%es:(%rdi)
    46a3:	aa                   	stos   %al,%es:(%rdi)
    46a4:	aa                   	stos   %al,%es:(%rdi)
    46a5:	aa                   	stos   %al,%es:(%rdi)
    46a6:	aa                   	stos   %al,%es:(%rdi)
    46a7:	aa                   	stos   %al,%es:(%rdi)
    46a8:	aa                   	stos   %al,%es:(%rdi)
    46a9:	aa                   	stos   %al,%es:(%rdi)
    46aa:	aa                   	stos   %al,%es:(%rdi)
    46ab:	aa                   	stos   %al,%es:(%rdi)
    46ac:	aa                   	stos   %al,%es:(%rdi)
    46ad:	aa                   	stos   %al,%es:(%rdi)
    46ae:	aa                   	stos   %al,%es:(%rdi)
    46af:	aa                   	stos   %al,%es:(%rdi)
    46b0:	aa                   	stos   %al,%es:(%rdi)
    46b1:	aa                   	stos   %al,%es:(%rdi)
    46b2:	aa                   	stos   %al,%es:(%rdi)
    46b3:	aa                   	stos   %al,%es:(%rdi)
    46b4:	aa                   	stos   %al,%es:(%rdi)
    46b5:	aa                   	stos   %al,%es:(%rdi)
    46b6:	aa                   	stos   %al,%es:(%rdi)
    46b7:	aa                   	stos   %al,%es:(%rdi)
    46b8:	aa                   	stos   %al,%es:(%rdi)
    46b9:	aa                   	stos   %al,%es:(%rdi)
    46ba:	aa                   	stos   %al,%es:(%rdi)
    46bb:	aa                   	stos   %al,%es:(%rdi)
    46bc:	aa                   	stos   %al,%es:(%rdi)
    46bd:	aa                   	stos   %al,%es:(%rdi)
    46be:	aa                   	stos   %al,%es:(%rdi)
    46bf:	aa                   	stos   %al,%es:(%rdi)
    46c0:	aa                   	stos   %al,%es:(%rdi)
    46c1:	aa                   	stos   %al,%es:(%rdi)
    46c2:	aa                   	stos   %al,%es:(%rdi)
    46c3:	aa                   	stos   %al,%es:(%rdi)
    46c4:	aa                   	stos   %al,%es:(%rdi)
    46c5:	aa                   	stos   %al,%es:(%rdi)
    46c6:	aa                   	stos   %al,%es:(%rdi)
    46c7:	aa                   	stos   %al,%es:(%rdi)
    46c8:	aa                   	stos   %al,%es:(%rdi)
    46c9:	aa                   	stos   %al,%es:(%rdi)
    46ca:	aa                   	stos   %al,%es:(%rdi)
    46cb:	aa                   	stos   %al,%es:(%rdi)
    46cc:	aa                   	stos   %al,%es:(%rdi)
    46cd:	aa                   	stos   %al,%es:(%rdi)
    46ce:	aa                   	stos   %al,%es:(%rdi)
    46cf:	aa                   	stos   %al,%es:(%rdi)
    46d0:	aa                   	stos   %al,%es:(%rdi)
    46d1:	aa                   	stos   %al,%es:(%rdi)
    46d2:	aa                   	stos   %al,%es:(%rdi)
    46d3:	aa                   	stos   %al,%es:(%rdi)
    46d4:	aa                   	stos   %al,%es:(%rdi)
    46d5:	aa                   	stos   %al,%es:(%rdi)
    46d6:	aa                   	stos   %al,%es:(%rdi)
    46d7:	aa                   	stos   %al,%es:(%rdi)
    46d8:	aa                   	stos   %al,%es:(%rdi)
    46d9:	aa                   	stos   %al,%es:(%rdi)
    46da:	aa                   	stos   %al,%es:(%rdi)
    46db:	aa                   	stos   %al,%es:(%rdi)
    46dc:	aa                   	stos   %al,%es:(%rdi)
    46dd:	aa                   	stos   %al,%es:(%rdi)
    46de:	aa                   	stos   %al,%es:(%rdi)
    46df:	aa                   	stos   %al,%es:(%rdi)
    46e0:	aa                   	stos   %al,%es:(%rdi)
    46e1:	aa                   	stos   %al,%es:(%rdi)
    46e2:	aa                   	stos   %al,%es:(%rdi)
    46e3:	aa                   	stos   %al,%es:(%rdi)
    46e4:	aa                   	stos   %al,%es:(%rdi)
    46e5:	aa                   	stos   %al,%es:(%rdi)
    46e6:	aa                   	stos   %al,%es:(%rdi)
    46e7:	aa                   	stos   %al,%es:(%rdi)
    46e8:	aa                   	stos   %al,%es:(%rdi)
    46e9:	aa                   	stos   %al,%es:(%rdi)
    46ea:	aa                   	stos   %al,%es:(%rdi)
    46eb:	aa                   	stos   %al,%es:(%rdi)
    46ec:	aa                   	stos   %al,%es:(%rdi)
    46ed:	aa                   	stos   %al,%es:(%rdi)
    46ee:	aa                   	stos   %al,%es:(%rdi)
    46ef:	aa                   	stos   %al,%es:(%rdi)
    46f0:	aa                   	stos   %al,%es:(%rdi)
    46f1:	aa                   	stos   %al,%es:(%rdi)
    46f2:	aa                   	stos   %al,%es:(%rdi)
    46f3:	aa                   	stos   %al,%es:(%rdi)
    46f4:	aa                   	stos   %al,%es:(%rdi)
    46f5:	aa                   	stos   %al,%es:(%rdi)
    46f6:	aa                   	stos   %al,%es:(%rdi)
    46f7:	aa                   	stos   %al,%es:(%rdi)
    46f8:	aa                   	stos   %al,%es:(%rdi)
    46f9:	aa                   	stos   %al,%es:(%rdi)
    46fa:	aa                   	stos   %al,%es:(%rdi)
    46fb:	aa                   	stos   %al,%es:(%rdi)
    46fc:	aa                   	stos   %al,%es:(%rdi)
    46fd:	aa                   	stos   %al,%es:(%rdi)
    46fe:	aa                   	stos   %al,%es:(%rdi)
    46ff:	aa                   	stos   %al,%es:(%rdi)
    4700:	aa                   	stos   %al,%es:(%rdi)
    4701:	aa                   	stos   %al,%es:(%rdi)
    4702:	aa                   	stos   %al,%es:(%rdi)
    4703:	aa                   	stos   %al,%es:(%rdi)
    4704:	aa                   	stos   %al,%es:(%rdi)
    4705:	aa                   	stos   %al,%es:(%rdi)
    4706:	aa                   	stos   %al,%es:(%rdi)
    4707:	aa                   	stos   %al,%es:(%rdi)
    4708:	aa                   	stos   %al,%es:(%rdi)
    4709:	aa                   	stos   %al,%es:(%rdi)
    470a:	aa                   	stos   %al,%es:(%rdi)
    470b:	aa                   	stos   %al,%es:(%rdi)
    470c:	aa                   	stos   %al,%es:(%rdi)
    470d:	aa                   	stos   %al,%es:(%rdi)
    470e:	aa                   	stos   %al,%es:(%rdi)
    470f:	aa                   	stos   %al,%es:(%rdi)
    4710:	aa                   	stos   %al,%es:(%rdi)
    4711:	aa                   	stos   %al,%es:(%rdi)
    4712:	aa                   	stos   %al,%es:(%rdi)
    4713:	aa                   	stos   %al,%es:(%rdi)
    4714:	aa                   	stos   %al,%es:(%rdi)
    4715:	aa                   	stos   %al,%es:(%rdi)
    4716:	aa                   	stos   %al,%es:(%rdi)
    4717:	aa                   	stos   %al,%es:(%rdi)
    4718:	aa                   	stos   %al,%es:(%rdi)
    4719:	aa                   	stos   %al,%es:(%rdi)
    471a:	aa                   	stos   %al,%es:(%rdi)
    471b:	aa                   	stos   %al,%es:(%rdi)
    471c:	aa                   	stos   %al,%es:(%rdi)
    471d:	aa                   	stos   %al,%es:(%rdi)
    471e:	aa                   	stos   %al,%es:(%rdi)
    471f:	aa                   	stos   %al,%es:(%rdi)
    4720:	aa                   	stos   %al,%es:(%rdi)
    4721:	aa                   	stos   %al,%es:(%rdi)
    4722:	aa                   	stos   %al,%es:(%rdi)
    4723:	aa                   	stos   %al,%es:(%rdi)
    4724:	aa                   	stos   %al,%es:(%rdi)
    4725:	aa                   	stos   %al,%es:(%rdi)
    4726:	aa                   	stos   %al,%es:(%rdi)
    4727:	aa                   	stos   %al,%es:(%rdi)
    4728:	aa                   	stos   %al,%es:(%rdi)
    4729:	aa                   	stos   %al,%es:(%rdi)
    472a:	aa                   	stos   %al,%es:(%rdi)
    472b:	aa                   	stos   %al,%es:(%rdi)
    472c:	aa                   	stos   %al,%es:(%rdi)
    472d:	aa                   	stos   %al,%es:(%rdi)
    472e:	aa                   	stos   %al,%es:(%rdi)
    472f:	aa                   	stos   %al,%es:(%rdi)
    4730:	aa                   	stos   %al,%es:(%rdi)
    4731:	aa                   	stos   %al,%es:(%rdi)
    4732:	aa                   	stos   %al,%es:(%rdi)
    4733:	aa                   	stos   %al,%es:(%rdi)
    4734:	aa                   	stos   %al,%es:(%rdi)
    4735:	aa                   	stos   %al,%es:(%rdi)
    4736:	aa                   	stos   %al,%es:(%rdi)
    4737:	aa                   	stos   %al,%es:(%rdi)
    4738:	aa                   	stos   %al,%es:(%rdi)
    4739:	aa                   	stos   %al,%es:(%rdi)
    473a:	aa                   	stos   %al,%es:(%rdi)
    473b:	aa                   	stos   %al,%es:(%rdi)
    473c:	aa                   	stos   %al,%es:(%rdi)
    473d:	aa                   	stos   %al,%es:(%rdi)
    473e:	aa                   	stos   %al,%es:(%rdi)
    473f:	aa                   	stos   %al,%es:(%rdi)
    4740:	aa                   	stos   %al,%es:(%rdi)
    4741:	aa                   	stos   %al,%es:(%rdi)
    4742:	aa                   	stos   %al,%es:(%rdi)
    4743:	aa                   	stos   %al,%es:(%rdi)
    4744:	aa                   	stos   %al,%es:(%rdi)
    4745:	aa                   	stos   %al,%es:(%rdi)
    4746:	aa                   	stos   %al,%es:(%rdi)
    4747:	aa                   	stos   %al,%es:(%rdi)
    4748:	aa                   	stos   %al,%es:(%rdi)
    4749:	aa                   	stos   %al,%es:(%rdi)
    474a:	aa                   	stos   %al,%es:(%rdi)
    474b:	aa                   	stos   %al,%es:(%rdi)
    474c:	aa                   	stos   %al,%es:(%rdi)
    474d:	aa                   	stos   %al,%es:(%rdi)
    474e:	aa                   	stos   %al,%es:(%rdi)
    474f:	aa                   	stos   %al,%es:(%rdi)
    4750:	aa                   	stos   %al,%es:(%rdi)
    4751:	aa                   	stos   %al,%es:(%rdi)
    4752:	aa                   	stos   %al,%es:(%rdi)
    4753:	aa                   	stos   %al,%es:(%rdi)
    4754:	aa                   	stos   %al,%es:(%rdi)
    4755:	aa                   	stos   %al,%es:(%rdi)
    4756:	aa                   	stos   %al,%es:(%rdi)
    4757:	aa                   	stos   %al,%es:(%rdi)
    4758:	aa                   	stos   %al,%es:(%rdi)
    4759:	aa                   	stos   %al,%es:(%rdi)
    475a:	aa                   	stos   %al,%es:(%rdi)
    475b:	aa                   	stos   %al,%es:(%rdi)
    475c:	aa                   	stos   %al,%es:(%rdi)
    475d:	aa                   	stos   %al,%es:(%rdi)
    475e:	aa                   	stos   %al,%es:(%rdi)
    475f:	aa                   	stos   %al,%es:(%rdi)
    4760:	aa                   	stos   %al,%es:(%rdi)
    4761:	aa                   	stos   %al,%es:(%rdi)
    4762:	aa                   	stos   %al,%es:(%rdi)
    4763:	aa                   	stos   %al,%es:(%rdi)
    4764:	aa                   	stos   %al,%es:(%rdi)
    4765:	aa                   	stos   %al,%es:(%rdi)
    4766:	aa                   	stos   %al,%es:(%rdi)
    4767:	aa                   	stos   %al,%es:(%rdi)
    4768:	aa                   	stos   %al,%es:(%rdi)
    4769:	aa                   	stos   %al,%es:(%rdi)
    476a:	aa                   	stos   %al,%es:(%rdi)
    476b:	aa                   	stos   %al,%es:(%rdi)
    476c:	aa                   	stos   %al,%es:(%rdi)
    476d:	aa                   	stos   %al,%es:(%rdi)
    476e:	aa                   	stos   %al,%es:(%rdi)
    476f:	aa                   	stos   %al,%es:(%rdi)
    4770:	aa                   	stos   %al,%es:(%rdi)
    4771:	aa                   	stos   %al,%es:(%rdi)
    4772:	aa                   	stos   %al,%es:(%rdi)
    4773:	aa                   	stos   %al,%es:(%rdi)
    4774:	aa                   	stos   %al,%es:(%rdi)
    4775:	aa                   	stos   %al,%es:(%rdi)
    4776:	aa                   	stos   %al,%es:(%rdi)
    4777:	aa                   	stos   %al,%es:(%rdi)
    4778:	aa                   	stos   %al,%es:(%rdi)
    4779:	aa                   	stos   %al,%es:(%rdi)
    477a:	aa                   	stos   %al,%es:(%rdi)
    477b:	aa                   	stos   %al,%es:(%rdi)
    477c:	aa                   	stos   %al,%es:(%rdi)
    477d:	aa                   	stos   %al,%es:(%rdi)
    477e:	aa                   	stos   %al,%es:(%rdi)
    477f:	aa                   	stos   %al,%es:(%rdi)
    4780:	aa                   	stos   %al,%es:(%rdi)
    4781:	aa                   	stos   %al,%es:(%rdi)
    4782:	aa                   	stos   %al,%es:(%rdi)
    4783:	aa                   	stos   %al,%es:(%rdi)
    4784:	aa                   	stos   %al,%es:(%rdi)
    4785:	aa                   	stos   %al,%es:(%rdi)
    4786:	aa                   	stos   %al,%es:(%rdi)
    4787:	aa                   	stos   %al,%es:(%rdi)
    4788:	aa                   	stos   %al,%es:(%rdi)
    4789:	aa                   	stos   %al,%es:(%rdi)
    478a:	aa                   	stos   %al,%es:(%rdi)
    478b:	aa                   	stos   %al,%es:(%rdi)
    478c:	aa                   	stos   %al,%es:(%rdi)
    478d:	aa                   	stos   %al,%es:(%rdi)
    478e:	aa                   	stos   %al,%es:(%rdi)
    478f:	aa                   	stos   %al,%es:(%rdi)
    4790:	aa                   	stos   %al,%es:(%rdi)
    4791:	aa                   	stos   %al,%es:(%rdi)
    4792:	aa                   	stos   %al,%es:(%rdi)
    4793:	aa                   	stos   %al,%es:(%rdi)
    4794:	aa                   	stos   %al,%es:(%rdi)
    4795:	aa                   	stos   %al,%es:(%rdi)
    4796:	aa                   	stos   %al,%es:(%rdi)
    4797:	aa                   	stos   %al,%es:(%rdi)
    4798:	aa                   	stos   %al,%es:(%rdi)
    4799:	aa                   	stos   %al,%es:(%rdi)
    479a:	aa                   	stos   %al,%es:(%rdi)
    479b:	aa                   	stos   %al,%es:(%rdi)
    479c:	aa                   	stos   %al,%es:(%rdi)
    479d:	aa                   	stos   %al,%es:(%rdi)
    479e:	aa                   	stos   %al,%es:(%rdi)
    479f:	aa                   	stos   %al,%es:(%rdi)
    47a0:	aa                   	stos   %al,%es:(%rdi)
    47a1:	aa                   	stos   %al,%es:(%rdi)
    47a2:	aa                   	stos   %al,%es:(%rdi)
    47a3:	aa                   	stos   %al,%es:(%rdi)
    47a4:	aa                   	stos   %al,%es:(%rdi)
    47a5:	aa                   	stos   %al,%es:(%rdi)
    47a6:	aa                   	stos   %al,%es:(%rdi)
    47a7:	aa                   	stos   %al,%es:(%rdi)
    47a8:	aa                   	stos   %al,%es:(%rdi)
    47a9:	aa                   	stos   %al,%es:(%rdi)
    47aa:	aa                   	stos   %al,%es:(%rdi)
    47ab:	aa                   	stos   %al,%es:(%rdi)
    47ac:	aa                   	stos   %al,%es:(%rdi)
    47ad:	aa                   	stos   %al,%es:(%rdi)
    47ae:	aa                   	stos   %al,%es:(%rdi)
    47af:	aa                   	stos   %al,%es:(%rdi)
    47b0:	aa                   	stos   %al,%es:(%rdi)
    47b1:	aa                   	stos   %al,%es:(%rdi)
    47b2:	aa                   	stos   %al,%es:(%rdi)
    47b3:	aa                   	stos   %al,%es:(%rdi)
    47b4:	aa                   	stos   %al,%es:(%rdi)
    47b5:	aa                   	stos   %al,%es:(%rdi)
    47b6:	aa                   	stos   %al,%es:(%rdi)
    47b7:	aa                   	stos   %al,%es:(%rdi)
    47b8:	aa                   	stos   %al,%es:(%rdi)
    47b9:	aa                   	stos   %al,%es:(%rdi)
    47ba:	aa                   	stos   %al,%es:(%rdi)
    47bb:	aa                   	stos   %al,%es:(%rdi)
    47bc:	aa                   	stos   %al,%es:(%rdi)
    47bd:	aa                   	stos   %al,%es:(%rdi)
    47be:	aa                   	stos   %al,%es:(%rdi)
    47bf:	aa                   	stos   %al,%es:(%rdi)
    47c0:	aa                   	stos   %al,%es:(%rdi)
    47c1:	aa                   	stos   %al,%es:(%rdi)
    47c2:	aa                   	stos   %al,%es:(%rdi)
    47c3:	aa                   	stos   %al,%es:(%rdi)
    47c4:	aa                   	stos   %al,%es:(%rdi)
    47c5:	aa                   	stos   %al,%es:(%rdi)
    47c6:	aa                   	stos   %al,%es:(%rdi)
    47c7:	aa                   	stos   %al,%es:(%rdi)
    47c8:	aa                   	stos   %al,%es:(%rdi)
    47c9:	aa                   	stos   %al,%es:(%rdi)
    47ca:	aa                   	stos   %al,%es:(%rdi)
    47cb:	aa                   	stos   %al,%es:(%rdi)
    47cc:	aa                   	stos   %al,%es:(%rdi)
    47cd:	aa                   	stos   %al,%es:(%rdi)
    47ce:	aa                   	stos   %al,%es:(%rdi)
    47cf:	aa                   	stos   %al,%es:(%rdi)
    47d0:	aa                   	stos   %al,%es:(%rdi)
    47d1:	aa                   	stos   %al,%es:(%rdi)
    47d2:	aa                   	stos   %al,%es:(%rdi)
    47d3:	aa                   	stos   %al,%es:(%rdi)
    47d4:	aa                   	stos   %al,%es:(%rdi)
    47d5:	aa                   	stos   %al,%es:(%rdi)
    47d6:	aa                   	stos   %al,%es:(%rdi)
    47d7:	aa                   	stos   %al,%es:(%rdi)
    47d8:	aa                   	stos   %al,%es:(%rdi)
    47d9:	aa                   	stos   %al,%es:(%rdi)
    47da:	aa                   	stos   %al,%es:(%rdi)
    47db:	aa                   	stos   %al,%es:(%rdi)
    47dc:	aa                   	stos   %al,%es:(%rdi)
    47dd:	aa                   	stos   %al,%es:(%rdi)
    47de:	aa                   	stos   %al,%es:(%rdi)
    47df:	aa                   	stos   %al,%es:(%rdi)
    47e0:	aa                   	stos   %al,%es:(%rdi)
    47e1:	aa                   	stos   %al,%es:(%rdi)
    47e2:	aa                   	stos   %al,%es:(%rdi)
    47e3:	aa                   	stos   %al,%es:(%rdi)
    47e4:	aa                   	stos   %al,%es:(%rdi)
    47e5:	aa                   	stos   %al,%es:(%rdi)
    47e6:	aa                   	stos   %al,%es:(%rdi)
    47e7:	aa                   	stos   %al,%es:(%rdi)
    47e8:	aa                   	stos   %al,%es:(%rdi)
    47e9:	aa                   	stos   %al,%es:(%rdi)
    47ea:	aa                   	stos   %al,%es:(%rdi)
    47eb:	aa                   	stos   %al,%es:(%rdi)
    47ec:	aa                   	stos   %al,%es:(%rdi)
    47ed:	aa                   	stos   %al,%es:(%rdi)
    47ee:	aa                   	stos   %al,%es:(%rdi)
    47ef:	aa                   	stos   %al,%es:(%rdi)
    47f0:	aa                   	stos   %al,%es:(%rdi)
    47f1:	aa                   	stos   %al,%es:(%rdi)
    47f2:	aa                   	stos   %al,%es:(%rdi)
    47f3:	aa                   	stos   %al,%es:(%rdi)
    47f4:	aa                   	stos   %al,%es:(%rdi)
    47f5:	aa                   	stos   %al,%es:(%rdi)
    47f6:	aa                   	stos   %al,%es:(%rdi)
    47f7:	aa                   	stos   %al,%es:(%rdi)
    47f8:	aa                   	stos   %al,%es:(%rdi)
    47f9:	aa                   	stos   %al,%es:(%rdi)
    47fa:	aa                   	stos   %al,%es:(%rdi)
    47fb:	aa                   	stos   %al,%es:(%rdi)
    47fc:	aa                   	stos   %al,%es:(%rdi)
    47fd:	aa                   	stos   %al,%es:(%rdi)
    47fe:	aa                   	stos   %al,%es:(%rdi)
    47ff:	aa                   	stos   %al,%es:(%rdi)
    4800:	aa                   	stos   %al,%es:(%rdi)
    4801:	aa                   	stos   %al,%es:(%rdi)
    4802:	aa                   	stos   %al,%es:(%rdi)
    4803:	aa                   	stos   %al,%es:(%rdi)
    4804:	aa                   	stos   %al,%es:(%rdi)
    4805:	aa                   	stos   %al,%es:(%rdi)
    4806:	aa                   	stos   %al,%es:(%rdi)
    4807:	aa                   	stos   %al,%es:(%rdi)
    4808:	aa                   	stos   %al,%es:(%rdi)
    4809:	aa                   	stos   %al,%es:(%rdi)
    480a:	aa                   	stos   %al,%es:(%rdi)
    480b:	aa                   	stos   %al,%es:(%rdi)
    480c:	aa                   	stos   %al,%es:(%rdi)
    480d:	aa                   	stos   %al,%es:(%rdi)
    480e:	aa                   	stos   %al,%es:(%rdi)
    480f:	aa                   	stos   %al,%es:(%rdi)
    4810:	aa                   	stos   %al,%es:(%rdi)
    4811:	aa                   	stos   %al,%es:(%rdi)
    4812:	aa                   	stos   %al,%es:(%rdi)
    4813:	aa                   	stos   %al,%es:(%rdi)
    4814:	aa                   	stos   %al,%es:(%rdi)
    4815:	aa                   	stos   %al,%es:(%rdi)
    4816:	aa                   	stos   %al,%es:(%rdi)
    4817:	aa                   	stos   %al,%es:(%rdi)
    4818:	aa                   	stos   %al,%es:(%rdi)
    4819:	aa                   	stos   %al,%es:(%rdi)
    481a:	aa                   	stos   %al,%es:(%rdi)
    481b:	aa                   	stos   %al,%es:(%rdi)
    481c:	aa                   	stos   %al,%es:(%rdi)
    481d:	aa                   	stos   %al,%es:(%rdi)
    481e:	aa                   	stos   %al,%es:(%rdi)
    481f:	aa                   	stos   %al,%es:(%rdi)
    4820:	aa                   	stos   %al,%es:(%rdi)
    4821:	aa                   	stos   %al,%es:(%rdi)
    4822:	aa                   	stos   %al,%es:(%rdi)
    4823:	aa                   	stos   %al,%es:(%rdi)
    4824:	aa                   	stos   %al,%es:(%rdi)
    4825:	aa                   	stos   %al,%es:(%rdi)
    4826:	aa                   	stos   %al,%es:(%rdi)
    4827:	aa                   	stos   %al,%es:(%rdi)
    4828:	aa                   	stos   %al,%es:(%rdi)
    4829:	aa                   	stos   %al,%es:(%rdi)
    482a:	aa                   	stos   %al,%es:(%rdi)
    482b:	aa                   	stos   %al,%es:(%rdi)
    482c:	aa                   	stos   %al,%es:(%rdi)
    482d:	aa                   	stos   %al,%es:(%rdi)
    482e:	aa                   	stos   %al,%es:(%rdi)
    482f:	aa                   	stos   %al,%es:(%rdi)
    4830:	aa                   	stos   %al,%es:(%rdi)
    4831:	aa                   	stos   %al,%es:(%rdi)
    4832:	aa                   	stos   %al,%es:(%rdi)
    4833:	aa                   	stos   %al,%es:(%rdi)
    4834:	aa                   	stos   %al,%es:(%rdi)
    4835:	aa                   	stos   %al,%es:(%rdi)
    4836:	aa                   	stos   %al,%es:(%rdi)
    4837:	aa                   	stos   %al,%es:(%rdi)
    4838:	aa                   	stos   %al,%es:(%rdi)
    4839:	aa                   	stos   %al,%es:(%rdi)
    483a:	aa                   	stos   %al,%es:(%rdi)
    483b:	aa                   	stos   %al,%es:(%rdi)
    483c:	aa                   	stos   %al,%es:(%rdi)
    483d:	aa                   	stos   %al,%es:(%rdi)
    483e:	aa                   	stos   %al,%es:(%rdi)
    483f:	aa                   	stos   %al,%es:(%rdi)
    4840:	aa                   	stos   %al,%es:(%rdi)
    4841:	aa                   	stos   %al,%es:(%rdi)
    4842:	aa                   	stos   %al,%es:(%rdi)
    4843:	aa                   	stos   %al,%es:(%rdi)
    4844:	aa                   	stos   %al,%es:(%rdi)
    4845:	aa                   	stos   %al,%es:(%rdi)
    4846:	aa                   	stos   %al,%es:(%rdi)
    4847:	aa                   	stos   %al,%es:(%rdi)
    4848:	aa                   	stos   %al,%es:(%rdi)
    4849:	aa                   	stos   %al,%es:(%rdi)
    484a:	aa                   	stos   %al,%es:(%rdi)
    484b:	aa                   	stos   %al,%es:(%rdi)
    484c:	aa                   	stos   %al,%es:(%rdi)
    484d:	aa                   	stos   %al,%es:(%rdi)
    484e:	aa                   	stos   %al,%es:(%rdi)
    484f:	aa                   	stos   %al,%es:(%rdi)
    4850:	aa                   	stos   %al,%es:(%rdi)
    4851:	aa                   	stos   %al,%es:(%rdi)
    4852:	aa                   	stos   %al,%es:(%rdi)
    4853:	aa                   	stos   %al,%es:(%rdi)
    4854:	aa                   	stos   %al,%es:(%rdi)
    4855:	aa                   	stos   %al,%es:(%rdi)
    4856:	aa                   	stos   %al,%es:(%rdi)
    4857:	aa                   	stos   %al,%es:(%rdi)
    4858:	aa                   	stos   %al,%es:(%rdi)
    4859:	aa                   	stos   %al,%es:(%rdi)
    485a:	aa                   	stos   %al,%es:(%rdi)
    485b:	aa                   	stos   %al,%es:(%rdi)
    485c:	aa                   	stos   %al,%es:(%rdi)
    485d:	aa                   	stos   %al,%es:(%rdi)
    485e:	aa                   	stos   %al,%es:(%rdi)
    485f:	aa                   	stos   %al,%es:(%rdi)
    4860:	aa                   	stos   %al,%es:(%rdi)
    4861:	aa                   	stos   %al,%es:(%rdi)
    4862:	aa                   	stos   %al,%es:(%rdi)
    4863:	aa                   	stos   %al,%es:(%rdi)
    4864:	aa                   	stos   %al,%es:(%rdi)
    4865:	aa                   	stos   %al,%es:(%rdi)
    4866:	aa                   	stos   %al,%es:(%rdi)
    4867:	aa                   	stos   %al,%es:(%rdi)
    4868:	aa                   	stos   %al,%es:(%rdi)
    4869:	aa                   	stos   %al,%es:(%rdi)
    486a:	aa                   	stos   %al,%es:(%rdi)
    486b:	aa                   	stos   %al,%es:(%rdi)
    486c:	aa                   	stos   %al,%es:(%rdi)
    486d:	aa                   	stos   %al,%es:(%rdi)
    486e:	aa                   	stos   %al,%es:(%rdi)
    486f:	aa                   	stos   %al,%es:(%rdi)
    4870:	aa                   	stos   %al,%es:(%rdi)
    4871:	aa                   	stos   %al,%es:(%rdi)
    4872:	aa                   	stos   %al,%es:(%rdi)
    4873:	aa                   	stos   %al,%es:(%rdi)
    4874:	aa                   	stos   %al,%es:(%rdi)
    4875:	aa                   	stos   %al,%es:(%rdi)
    4876:	aa                   	stos   %al,%es:(%rdi)
    4877:	aa                   	stos   %al,%es:(%rdi)
    4878:	aa                   	stos   %al,%es:(%rdi)
    4879:	aa                   	stos   %al,%es:(%rdi)
    487a:	aa                   	stos   %al,%es:(%rdi)
    487b:	aa                   	stos   %al,%es:(%rdi)
    487c:	aa                   	stos   %al,%es:(%rdi)
    487d:	aa                   	stos   %al,%es:(%rdi)
    487e:	aa                   	stos   %al,%es:(%rdi)
    487f:	aa                   	stos   %al,%es:(%rdi)
    4880:	aa                   	stos   %al,%es:(%rdi)
    4881:	aa                   	stos   %al,%es:(%rdi)
    4882:	aa                   	stos   %al,%es:(%rdi)
    4883:	aa                   	stos   %al,%es:(%rdi)
    4884:	aa                   	stos   %al,%es:(%rdi)
    4885:	aa                   	stos   %al,%es:(%rdi)
    4886:	aa                   	stos   %al,%es:(%rdi)
    4887:	aa                   	stos   %al,%es:(%rdi)
    4888:	aa                   	stos   %al,%es:(%rdi)
    4889:	aa                   	stos   %al,%es:(%rdi)
    488a:	aa                   	stos   %al,%es:(%rdi)
    488b:	aa                   	stos   %al,%es:(%rdi)
    488c:	aa                   	stos   %al,%es:(%rdi)
    488d:	aa                   	stos   %al,%es:(%rdi)
    488e:	aa                   	stos   %al,%es:(%rdi)
    488f:	aa                   	stos   %al,%es:(%rdi)
    4890:	aa                   	stos   %al,%es:(%rdi)
    4891:	aa                   	stos   %al,%es:(%rdi)
    4892:	aa                   	stos   %al,%es:(%rdi)
    4893:	aa                   	stos   %al,%es:(%rdi)
    4894:	aa                   	stos   %al,%es:(%rdi)
    4895:	aa                   	stos   %al,%es:(%rdi)
    4896:	aa                   	stos   %al,%es:(%rdi)
    4897:	aa                   	stos   %al,%es:(%rdi)
    4898:	aa                   	stos   %al,%es:(%rdi)
    4899:	aa                   	stos   %al,%es:(%rdi)
    489a:	aa                   	stos   %al,%es:(%rdi)
    489b:	aa                   	stos   %al,%es:(%rdi)
    489c:	aa                   	stos   %al,%es:(%rdi)
    489d:	aa                   	stos   %al,%es:(%rdi)
    489e:	aa                   	stos   %al,%es:(%rdi)
    489f:	aa                   	stos   %al,%es:(%rdi)
    48a0:	aa                   	stos   %al,%es:(%rdi)
    48a1:	aa                   	stos   %al,%es:(%rdi)
    48a2:	aa                   	stos   %al,%es:(%rdi)
    48a3:	aa                   	stos   %al,%es:(%rdi)
    48a4:	aa                   	stos   %al,%es:(%rdi)
    48a5:	aa                   	stos   %al,%es:(%rdi)
    48a6:	aa                   	stos   %al,%es:(%rdi)
    48a7:	aa                   	stos   %al,%es:(%rdi)
    48a8:	aa                   	stos   %al,%es:(%rdi)
    48a9:	aa                   	stos   %al,%es:(%rdi)
    48aa:	aa                   	stos   %al,%es:(%rdi)
    48ab:	aa                   	stos   %al,%es:(%rdi)
    48ac:	aa                   	stos   %al,%es:(%rdi)
    48ad:	aa                   	stos   %al,%es:(%rdi)
    48ae:	aa                   	stos   %al,%es:(%rdi)
    48af:	aa                   	stos   %al,%es:(%rdi)
    48b0:	aa                   	stos   %al,%es:(%rdi)
    48b1:	aa                   	stos   %al,%es:(%rdi)
    48b2:	aa                   	stos   %al,%es:(%rdi)
    48b3:	aa                   	stos   %al,%es:(%rdi)
    48b4:	aa                   	stos   %al,%es:(%rdi)
    48b5:	aa                   	stos   %al,%es:(%rdi)
    48b6:	aa                   	stos   %al,%es:(%rdi)
    48b7:	aa                   	stos   %al,%es:(%rdi)
    48b8:	aa                   	stos   %al,%es:(%rdi)
    48b9:	aa                   	stos   %al,%es:(%rdi)
    48ba:	aa                   	stos   %al,%es:(%rdi)
    48bb:	aa                   	stos   %al,%es:(%rdi)
    48bc:	aa                   	stos   %al,%es:(%rdi)
    48bd:	aa                   	stos   %al,%es:(%rdi)
    48be:	aa                   	stos   %al,%es:(%rdi)
    48bf:	aa                   	stos   %al,%es:(%rdi)
    48c0:	aa                   	stos   %al,%es:(%rdi)
    48c1:	aa                   	stos   %al,%es:(%rdi)
    48c2:	aa                   	stos   %al,%es:(%rdi)
    48c3:	aa                   	stos   %al,%es:(%rdi)
    48c4:	aa                   	stos   %al,%es:(%rdi)
    48c5:	aa                   	stos   %al,%es:(%rdi)
    48c6:	aa                   	stos   %al,%es:(%rdi)
    48c7:	aa                   	stos   %al,%es:(%rdi)
    48c8:	aa                   	stos   %al,%es:(%rdi)
    48c9:	aa                   	stos   %al,%es:(%rdi)
    48ca:	aa                   	stos   %al,%es:(%rdi)
    48cb:	aa                   	stos   %al,%es:(%rdi)
    48cc:	aa                   	stos   %al,%es:(%rdi)
    48cd:	aa                   	stos   %al,%es:(%rdi)
    48ce:	aa                   	stos   %al,%es:(%rdi)
    48cf:	aa                   	stos   %al,%es:(%rdi)
    48d0:	aa                   	stos   %al,%es:(%rdi)
    48d1:	aa                   	stos   %al,%es:(%rdi)
    48d2:	aa                   	stos   %al,%es:(%rdi)
    48d3:	aa                   	stos   %al,%es:(%rdi)
    48d4:	aa                   	stos   %al,%es:(%rdi)
    48d5:	aa                   	stos   %al,%es:(%rdi)
    48d6:	aa                   	stos   %al,%es:(%rdi)
    48d7:	aa                   	stos   %al,%es:(%rdi)
    48d8:	aa                   	stos   %al,%es:(%rdi)
    48d9:	aa                   	stos   %al,%es:(%rdi)
    48da:	aa                   	stos   %al,%es:(%rdi)
    48db:	aa                   	stos   %al,%es:(%rdi)
    48dc:	aa                   	stos   %al,%es:(%rdi)
    48dd:	aa                   	stos   %al,%es:(%rdi)
    48de:	aa                   	stos   %al,%es:(%rdi)
    48df:	aa                   	stos   %al,%es:(%rdi)
    48e0:	aa                   	stos   %al,%es:(%rdi)
    48e1:	aa                   	stos   %al,%es:(%rdi)
    48e2:	aa                   	stos   %al,%es:(%rdi)
    48e3:	aa                   	stos   %al,%es:(%rdi)
    48e4:	aa                   	stos   %al,%es:(%rdi)
    48e5:	aa                   	stos   %al,%es:(%rdi)
    48e6:	aa                   	stos   %al,%es:(%rdi)
    48e7:	aa                   	stos   %al,%es:(%rdi)
    48e8:	aa                   	stos   %al,%es:(%rdi)
    48e9:	aa                   	stos   %al,%es:(%rdi)
    48ea:	aa                   	stos   %al,%es:(%rdi)
    48eb:	aa                   	stos   %al,%es:(%rdi)
    48ec:	aa                   	stos   %al,%es:(%rdi)
    48ed:	aa                   	stos   %al,%es:(%rdi)
    48ee:	aa                   	stos   %al,%es:(%rdi)
    48ef:	aa                   	stos   %al,%es:(%rdi)
    48f0:	aa                   	stos   %al,%es:(%rdi)
    48f1:	aa                   	stos   %al,%es:(%rdi)
    48f2:	aa                   	stos   %al,%es:(%rdi)
    48f3:	aa                   	stos   %al,%es:(%rdi)
    48f4:	aa                   	stos   %al,%es:(%rdi)
    48f5:	aa                   	stos   %al,%es:(%rdi)
    48f6:	aa                   	stos   %al,%es:(%rdi)
    48f7:	aa                   	stos   %al,%es:(%rdi)
    48f8:	aa                   	stos   %al,%es:(%rdi)
    48f9:	aa                   	stos   %al,%es:(%rdi)
    48fa:	aa                   	stos   %al,%es:(%rdi)
    48fb:	aa                   	stos   %al,%es:(%rdi)
    48fc:	aa                   	stos   %al,%es:(%rdi)
    48fd:	aa                   	stos   %al,%es:(%rdi)
    48fe:	aa                   	stos   %al,%es:(%rdi)
    48ff:	aa                   	stos   %al,%es:(%rdi)
    4900:	aa                   	stos   %al,%es:(%rdi)
    4901:	aa                   	stos   %al,%es:(%rdi)
    4902:	aa                   	stos   %al,%es:(%rdi)
    4903:	aa                   	stos   %al,%es:(%rdi)
    4904:	aa                   	stos   %al,%es:(%rdi)
    4905:	aa                   	stos   %al,%es:(%rdi)
    4906:	aa                   	stos   %al,%es:(%rdi)
    4907:	aa                   	stos   %al,%es:(%rdi)
    4908:	aa                   	stos   %al,%es:(%rdi)
    4909:	aa                   	stos   %al,%es:(%rdi)
    490a:	aa                   	stos   %al,%es:(%rdi)
    490b:	aa                   	stos   %al,%es:(%rdi)
    490c:	aa                   	stos   %al,%es:(%rdi)
    490d:	aa                   	stos   %al,%es:(%rdi)
    490e:	aa                   	stos   %al,%es:(%rdi)
    490f:	aa                   	stos   %al,%es:(%rdi)
    4910:	aa                   	stos   %al,%es:(%rdi)
    4911:	aa                   	stos   %al,%es:(%rdi)
    4912:	aa                   	stos   %al,%es:(%rdi)
    4913:	aa                   	stos   %al,%es:(%rdi)
    4914:	aa                   	stos   %al,%es:(%rdi)
    4915:	aa                   	stos   %al,%es:(%rdi)
    4916:	aa                   	stos   %al,%es:(%rdi)
    4917:	aa                   	stos   %al,%es:(%rdi)
    4918:	aa                   	stos   %al,%es:(%rdi)
    4919:	aa                   	stos   %al,%es:(%rdi)
    491a:	aa                   	stos   %al,%es:(%rdi)
    491b:	aa                   	stos   %al,%es:(%rdi)
    491c:	aa                   	stos   %al,%es:(%rdi)
    491d:	aa                   	stos   %al,%es:(%rdi)
    491e:	aa                   	stos   %al,%es:(%rdi)
    491f:	aa                   	stos   %al,%es:(%rdi)
    4920:	aa                   	stos   %al,%es:(%rdi)
    4921:	aa                   	stos   %al,%es:(%rdi)
    4922:	aa                   	stos   %al,%es:(%rdi)
    4923:	aa                   	stos   %al,%es:(%rdi)
    4924:	aa                   	stos   %al,%es:(%rdi)
    4925:	aa                   	stos   %al,%es:(%rdi)
    4926:	aa                   	stos   %al,%es:(%rdi)
    4927:	aa                   	stos   %al,%es:(%rdi)
    4928:	aa                   	stos   %al,%es:(%rdi)
    4929:	aa                   	stos   %al,%es:(%rdi)
    492a:	aa                   	stos   %al,%es:(%rdi)
    492b:	aa                   	stos   %al,%es:(%rdi)
    492c:	aa                   	stos   %al,%es:(%rdi)
    492d:	aa                   	stos   %al,%es:(%rdi)
    492e:	aa                   	stos   %al,%es:(%rdi)
    492f:	aa                   	stos   %al,%es:(%rdi)
    4930:	aa                   	stos   %al,%es:(%rdi)
    4931:	aa                   	stos   %al,%es:(%rdi)
    4932:	aa                   	stos   %al,%es:(%rdi)
    4933:	aa                   	stos   %al,%es:(%rdi)
    4934:	aa                   	stos   %al,%es:(%rdi)
    4935:	aa                   	stos   %al,%es:(%rdi)
    4936:	aa                   	stos   %al,%es:(%rdi)
    4937:	aa                   	stos   %al,%es:(%rdi)
    4938:	aa                   	stos   %al,%es:(%rdi)
    4939:	aa                   	stos   %al,%es:(%rdi)
    493a:	aa                   	stos   %al,%es:(%rdi)
    493b:	aa                   	stos   %al,%es:(%rdi)
    493c:	aa                   	stos   %al,%es:(%rdi)
    493d:	aa                   	stos   %al,%es:(%rdi)
    493e:	aa                   	stos   %al,%es:(%rdi)
    493f:	aa                   	stos   %al,%es:(%rdi)
    4940:	aa                   	stos   %al,%es:(%rdi)
    4941:	aa                   	stos   %al,%es:(%rdi)
    4942:	aa                   	stos   %al,%es:(%rdi)
    4943:	aa                   	stos   %al,%es:(%rdi)
    4944:	aa                   	stos   %al,%es:(%rdi)
    4945:	aa                   	stos   %al,%es:(%rdi)
    4946:	aa                   	stos   %al,%es:(%rdi)
    4947:	aa                   	stos   %al,%es:(%rdi)
    4948:	aa                   	stos   %al,%es:(%rdi)
    4949:	aa                   	stos   %al,%es:(%rdi)
    494a:	aa                   	stos   %al,%es:(%rdi)
    494b:	aa                   	stos   %al,%es:(%rdi)
    494c:	aa                   	stos   %al,%es:(%rdi)
    494d:	aa                   	stos   %al,%es:(%rdi)
    494e:	aa                   	stos   %al,%es:(%rdi)
    494f:	aa                   	stos   %al,%es:(%rdi)
    4950:	aa                   	stos   %al,%es:(%rdi)
    4951:	aa                   	stos   %al,%es:(%rdi)
    4952:	aa                   	stos   %al,%es:(%rdi)
    4953:	aa                   	stos   %al,%es:(%rdi)
    4954:	aa                   	stos   %al,%es:(%rdi)
    4955:	aa                   	stos   %al,%es:(%rdi)
    4956:	aa                   	stos   %al,%es:(%rdi)
    4957:	aa                   	stos   %al,%es:(%rdi)
    4958:	aa                   	stos   %al,%es:(%rdi)
    4959:	aa                   	stos   %al,%es:(%rdi)
    495a:	aa                   	stos   %al,%es:(%rdi)
    495b:	aa                   	stos   %al,%es:(%rdi)
    495c:	aa                   	stos   %al,%es:(%rdi)
    495d:	aa                   	stos   %al,%es:(%rdi)
    495e:	aa                   	stos   %al,%es:(%rdi)
    495f:	aa                   	stos   %al,%es:(%rdi)
    4960:	aa                   	stos   %al,%es:(%rdi)
    4961:	aa                   	stos   %al,%es:(%rdi)
    4962:	aa                   	stos   %al,%es:(%rdi)
    4963:	aa                   	stos   %al,%es:(%rdi)
    4964:	aa                   	stos   %al,%es:(%rdi)
    4965:	aa                   	stos   %al,%es:(%rdi)
    4966:	aa                   	stos   %al,%es:(%rdi)
    4967:	aa                   	stos   %al,%es:(%rdi)
    4968:	aa                   	stos   %al,%es:(%rdi)
    4969:	aa                   	stos   %al,%es:(%rdi)
    496a:	aa                   	stos   %al,%es:(%rdi)
    496b:	aa                   	stos   %al,%es:(%rdi)
    496c:	aa                   	stos   %al,%es:(%rdi)
    496d:	aa                   	stos   %al,%es:(%rdi)
    496e:	aa                   	stos   %al,%es:(%rdi)
    496f:	aa                   	stos   %al,%es:(%rdi)
    4970:	aa                   	stos   %al,%es:(%rdi)
    4971:	aa                   	stos   %al,%es:(%rdi)
    4972:	aa                   	stos   %al,%es:(%rdi)
    4973:	aa                   	stos   %al,%es:(%rdi)
    4974:	aa                   	stos   %al,%es:(%rdi)
    4975:	aa                   	stos   %al,%es:(%rdi)
    4976:	aa                   	stos   %al,%es:(%rdi)
    4977:	aa                   	stos   %al,%es:(%rdi)
    4978:	aa                   	stos   %al,%es:(%rdi)
    4979:	aa                   	stos   %al,%es:(%rdi)
    497a:	aa                   	stos   %al,%es:(%rdi)
    497b:	aa                   	stos   %al,%es:(%rdi)
    497c:	aa                   	stos   %al,%es:(%rdi)
    497d:	aa                   	stos   %al,%es:(%rdi)
    497e:	aa                   	stos   %al,%es:(%rdi)
    497f:	aa                   	stos   %al,%es:(%rdi)
    4980:	aa                   	stos   %al,%es:(%rdi)
    4981:	aa                   	stos   %al,%es:(%rdi)
    4982:	aa                   	stos   %al,%es:(%rdi)
    4983:	aa                   	stos   %al,%es:(%rdi)
    4984:	aa                   	stos   %al,%es:(%rdi)
    4985:	aa                   	stos   %al,%es:(%rdi)
    4986:	aa                   	stos   %al,%es:(%rdi)
    4987:	aa                   	stos   %al,%es:(%rdi)
    4988:	aa                   	stos   %al,%es:(%rdi)
    4989:	aa                   	stos   %al,%es:(%rdi)
    498a:	aa                   	stos   %al,%es:(%rdi)
    498b:	aa                   	stos   %al,%es:(%rdi)
    498c:	aa                   	stos   %al,%es:(%rdi)
    498d:	aa                   	stos   %al,%es:(%rdi)
    498e:	aa                   	stos   %al,%es:(%rdi)
    498f:	aa                   	stos   %al,%es:(%rdi)
    4990:	aa                   	stos   %al,%es:(%rdi)
    4991:	aa                   	stos   %al,%es:(%rdi)
    4992:	aa                   	stos   %al,%es:(%rdi)
    4993:	aa                   	stos   %al,%es:(%rdi)
    4994:	aa                   	stos   %al,%es:(%rdi)
    4995:	aa                   	stos   %al,%es:(%rdi)
    4996:	aa                   	stos   %al,%es:(%rdi)
    4997:	aa                   	stos   %al,%es:(%rdi)
    4998:	aa                   	stos   %al,%es:(%rdi)
    4999:	aa                   	stos   %al,%es:(%rdi)
    499a:	aa                   	stos   %al,%es:(%rdi)
    499b:	aa                   	stos   %al,%es:(%rdi)
    499c:	aa                   	stos   %al,%es:(%rdi)
    499d:	aa                   	stos   %al,%es:(%rdi)
    499e:	aa                   	stos   %al,%es:(%rdi)
    499f:	aa                   	stos   %al,%es:(%rdi)
    49a0:	aa                   	stos   %al,%es:(%rdi)
    49a1:	aa                   	stos   %al,%es:(%rdi)
    49a2:	aa                   	stos   %al,%es:(%rdi)
    49a3:	aa                   	stos   %al,%es:(%rdi)
    49a4:	aa                   	stos   %al,%es:(%rdi)
    49a5:	aa                   	stos   %al,%es:(%rdi)
    49a6:	aa                   	stos   %al,%es:(%rdi)
    49a7:	aa                   	stos   %al,%es:(%rdi)
    49a8:	aa                   	stos   %al,%es:(%rdi)
    49a9:	aa                   	stos   %al,%es:(%rdi)
    49aa:	aa                   	stos   %al,%es:(%rdi)
    49ab:	aa                   	stos   %al,%es:(%rdi)
    49ac:	aa                   	stos   %al,%es:(%rdi)
    49ad:	aa                   	stos   %al,%es:(%rdi)
    49ae:	aa                   	stos   %al,%es:(%rdi)
    49af:	aa                   	stos   %al,%es:(%rdi)
    49b0:	aa                   	stos   %al,%es:(%rdi)
    49b1:	aa                   	stos   %al,%es:(%rdi)
    49b2:	aa                   	stos   %al,%es:(%rdi)
    49b3:	aa                   	stos   %al,%es:(%rdi)
    49b4:	aa                   	stos   %al,%es:(%rdi)
    49b5:	aa                   	stos   %al,%es:(%rdi)
    49b6:	aa                   	stos   %al,%es:(%rdi)
    49b7:	aa                   	stos   %al,%es:(%rdi)
    49b8:	aa                   	stos   %al,%es:(%rdi)
    49b9:	aa                   	stos   %al,%es:(%rdi)
    49ba:	aa                   	stos   %al,%es:(%rdi)
    49bb:	aa                   	stos   %al,%es:(%rdi)
    49bc:	aa                   	stos   %al,%es:(%rdi)
    49bd:	aa                   	stos   %al,%es:(%rdi)
    49be:	aa                   	stos   %al,%es:(%rdi)
    49bf:	aa                   	stos   %al,%es:(%rdi)
    49c0:	aa                   	stos   %al,%es:(%rdi)
    49c1:	aa                   	stos   %al,%es:(%rdi)
    49c2:	aa                   	stos   %al,%es:(%rdi)
    49c3:	aa                   	stos   %al,%es:(%rdi)
    49c4:	aa                   	stos   %al,%es:(%rdi)
    49c5:	aa                   	stos   %al,%es:(%rdi)
    49c6:	aa                   	stos   %al,%es:(%rdi)
    49c7:	aa                   	stos   %al,%es:(%rdi)
    49c8:	aa                   	stos   %al,%es:(%rdi)
    49c9:	aa                   	stos   %al,%es:(%rdi)
    49ca:	aa                   	stos   %al,%es:(%rdi)
    49cb:	aa                   	stos   %al,%es:(%rdi)
    49cc:	aa                   	stos   %al,%es:(%rdi)
    49cd:	aa                   	stos   %al,%es:(%rdi)
    49ce:	aa                   	stos   %al,%es:(%rdi)
    49cf:	aa                   	stos   %al,%es:(%rdi)
    49d0:	aa                   	stos   %al,%es:(%rdi)
    49d1:	aa                   	stos   %al,%es:(%rdi)
    49d2:	aa                   	stos   %al,%es:(%rdi)
    49d3:	aa                   	stos   %al,%es:(%rdi)
    49d4:	aa                   	stos   %al,%es:(%rdi)
    49d5:	aa                   	stos   %al,%es:(%rdi)
    49d6:	aa                   	stos   %al,%es:(%rdi)
    49d7:	aa                   	stos   %al,%es:(%rdi)
    49d8:	aa                   	stos   %al,%es:(%rdi)
    49d9:	aa                   	stos   %al,%es:(%rdi)
    49da:	aa                   	stos   %al,%es:(%rdi)
    49db:	aa                   	stos   %al,%es:(%rdi)
    49dc:	aa                   	stos   %al,%es:(%rdi)
    49dd:	aa                   	stos   %al,%es:(%rdi)
    49de:	aa                   	stos   %al,%es:(%rdi)
    49df:	aa                   	stos   %al,%es:(%rdi)
    49e0:	aa                   	stos   %al,%es:(%rdi)
    49e1:	aa                   	stos   %al,%es:(%rdi)
    49e2:	aa                   	stos   %al,%es:(%rdi)
    49e3:	aa                   	stos   %al,%es:(%rdi)
    49e4:	aa                   	stos   %al,%es:(%rdi)
    49e5:	aa                   	stos   %al,%es:(%rdi)
    49e6:	aa                   	stos   %al,%es:(%rdi)
    49e7:	aa                   	stos   %al,%es:(%rdi)
    49e8:	aa                   	stos   %al,%es:(%rdi)
    49e9:	aa                   	stos   %al,%es:(%rdi)
    49ea:	aa                   	stos   %al,%es:(%rdi)
    49eb:	aa                   	stos   %al,%es:(%rdi)
    49ec:	aa                   	stos   %al,%es:(%rdi)
    49ed:	aa                   	stos   %al,%es:(%rdi)
    49ee:	aa                   	stos   %al,%es:(%rdi)
    49ef:	aa                   	stos   %al,%es:(%rdi)
    49f0:	aa                   	stos   %al,%es:(%rdi)
    49f1:	aa                   	stos   %al,%es:(%rdi)
    49f2:	aa                   	stos   %al,%es:(%rdi)
    49f3:	aa                   	stos   %al,%es:(%rdi)
    49f4:	aa                   	stos   %al,%es:(%rdi)
    49f5:	aa                   	stos   %al,%es:(%rdi)
    49f6:	aa                   	stos   %al,%es:(%rdi)
    49f7:	aa                   	stos   %al,%es:(%rdi)
    49f8:	aa                   	stos   %al,%es:(%rdi)
    49f9:	aa                   	stos   %al,%es:(%rdi)
    49fa:	aa                   	stos   %al,%es:(%rdi)
    49fb:	aa                   	stos   %al,%es:(%rdi)
    49fc:	aa                   	stos   %al,%es:(%rdi)
    49fd:	aa                   	stos   %al,%es:(%rdi)
    49fe:	aa                   	stos   %al,%es:(%rdi)
    49ff:	aa                   	stos   %al,%es:(%rdi)
    4a00:	aa                   	stos   %al,%es:(%rdi)
    4a01:	aa                   	stos   %al,%es:(%rdi)
    4a02:	aa                   	stos   %al,%es:(%rdi)
    4a03:	aa                   	stos   %al,%es:(%rdi)
    4a04:	aa                   	stos   %al,%es:(%rdi)
    4a05:	aa                   	stos   %al,%es:(%rdi)
    4a06:	aa                   	stos   %al,%es:(%rdi)
    4a07:	aa                   	stos   %al,%es:(%rdi)
    4a08:	aa                   	stos   %al,%es:(%rdi)
    4a09:	aa                   	stos   %al,%es:(%rdi)
    4a0a:	aa                   	stos   %al,%es:(%rdi)
    4a0b:	aa                   	stos   %al,%es:(%rdi)
    4a0c:	aa                   	stos   %al,%es:(%rdi)
    4a0d:	aa                   	stos   %al,%es:(%rdi)
    4a0e:	aa                   	stos   %al,%es:(%rdi)
    4a0f:	aa                   	stos   %al,%es:(%rdi)
    4a10:	aa                   	stos   %al,%es:(%rdi)
    4a11:	aa                   	stos   %al,%es:(%rdi)
    4a12:	aa                   	stos   %al,%es:(%rdi)
    4a13:	aa                   	stos   %al,%es:(%rdi)
    4a14:	aa                   	stos   %al,%es:(%rdi)
    4a15:	aa                   	stos   %al,%es:(%rdi)
    4a16:	aa                   	stos   %al,%es:(%rdi)
    4a17:	aa                   	stos   %al,%es:(%rdi)
    4a18:	aa                   	stos   %al,%es:(%rdi)
    4a19:	aa                   	stos   %al,%es:(%rdi)
    4a1a:	aa                   	stos   %al,%es:(%rdi)
    4a1b:	aa                   	stos   %al,%es:(%rdi)
    4a1c:	aa                   	stos   %al,%es:(%rdi)
    4a1d:	aa                   	stos   %al,%es:(%rdi)
    4a1e:	aa                   	stos   %al,%es:(%rdi)
    4a1f:	aa                   	stos   %al,%es:(%rdi)
    4a20:	aa                   	stos   %al,%es:(%rdi)
    4a21:	aa                   	stos   %al,%es:(%rdi)
    4a22:	aa                   	stos   %al,%es:(%rdi)
    4a23:	aa                   	stos   %al,%es:(%rdi)
    4a24:	aa                   	stos   %al,%es:(%rdi)
    4a25:	aa                   	stos   %al,%es:(%rdi)
    4a26:	aa                   	stos   %al,%es:(%rdi)
    4a27:	aa                   	stos   %al,%es:(%rdi)
    4a28:	aa                   	stos   %al,%es:(%rdi)
    4a29:	aa                   	stos   %al,%es:(%rdi)
    4a2a:	aa                   	stos   %al,%es:(%rdi)
    4a2b:	aa                   	stos   %al,%es:(%rdi)
    4a2c:	aa                   	stos   %al,%es:(%rdi)
    4a2d:	aa                   	stos   %al,%es:(%rdi)
    4a2e:	aa                   	stos   %al,%es:(%rdi)
    4a2f:	aa                   	stos   %al,%es:(%rdi)
    4a30:	aa                   	stos   %al,%es:(%rdi)
    4a31:	aa                   	stos   %al,%es:(%rdi)
    4a32:	aa                   	stos   %al,%es:(%rdi)
    4a33:	aa                   	stos   %al,%es:(%rdi)
    4a34:	aa                   	stos   %al,%es:(%rdi)
    4a35:	aa                   	stos   %al,%es:(%rdi)
    4a36:	aa                   	stos   %al,%es:(%rdi)
    4a37:	aa                   	stos   %al,%es:(%rdi)
    4a38:	aa                   	stos   %al,%es:(%rdi)
    4a39:	aa                   	stos   %al,%es:(%rdi)
    4a3a:	aa                   	stos   %al,%es:(%rdi)
    4a3b:	aa                   	stos   %al,%es:(%rdi)
    4a3c:	aa                   	stos   %al,%es:(%rdi)
    4a3d:	aa                   	stos   %al,%es:(%rdi)
    4a3e:	aa                   	stos   %al,%es:(%rdi)
    4a3f:	aa                   	stos   %al,%es:(%rdi)
    4a40:	aa                   	stos   %al,%es:(%rdi)
    4a41:	aa                   	stos   %al,%es:(%rdi)
    4a42:	aa                   	stos   %al,%es:(%rdi)
    4a43:	aa                   	stos   %al,%es:(%rdi)
    4a44:	aa                   	stos   %al,%es:(%rdi)
    4a45:	aa                   	stos   %al,%es:(%rdi)
    4a46:	aa                   	stos   %al,%es:(%rdi)
    4a47:	aa                   	stos   %al,%es:(%rdi)
    4a48:	aa                   	stos   %al,%es:(%rdi)
    4a49:	aa                   	stos   %al,%es:(%rdi)
    4a4a:	aa                   	stos   %al,%es:(%rdi)
    4a4b:	aa                   	stos   %al,%es:(%rdi)
    4a4c:	aa                   	stos   %al,%es:(%rdi)
    4a4d:	aa                   	stos   %al,%es:(%rdi)
    4a4e:	aa                   	stos   %al,%es:(%rdi)
    4a4f:	aa                   	stos   %al,%es:(%rdi)
    4a50:	aa                   	stos   %al,%es:(%rdi)
    4a51:	aa                   	stos   %al,%es:(%rdi)
    4a52:	aa                   	stos   %al,%es:(%rdi)
    4a53:	aa                   	stos   %al,%es:(%rdi)
    4a54:	aa                   	stos   %al,%es:(%rdi)
    4a55:	aa                   	stos   %al,%es:(%rdi)
    4a56:	aa                   	stos   %al,%es:(%rdi)
    4a57:	aa                   	stos   %al,%es:(%rdi)
    4a58:	aa                   	stos   %al,%es:(%rdi)
    4a59:	aa                   	stos   %al,%es:(%rdi)
    4a5a:	aa                   	stos   %al,%es:(%rdi)
    4a5b:	aa                   	stos   %al,%es:(%rdi)
    4a5c:	aa                   	stos   %al,%es:(%rdi)
    4a5d:	aa                   	stos   %al,%es:(%rdi)
    4a5e:	aa                   	stos   %al,%es:(%rdi)
    4a5f:	aa                   	stos   %al,%es:(%rdi)
    4a60:	aa                   	stos   %al,%es:(%rdi)
    4a61:	aa                   	stos   %al,%es:(%rdi)
    4a62:	aa                   	stos   %al,%es:(%rdi)
    4a63:	aa                   	stos   %al,%es:(%rdi)
    4a64:	aa                   	stos   %al,%es:(%rdi)
    4a65:	aa                   	stos   %al,%es:(%rdi)
    4a66:	aa                   	stos   %al,%es:(%rdi)
    4a67:	aa                   	stos   %al,%es:(%rdi)
    4a68:	aa                   	stos   %al,%es:(%rdi)
    4a69:	aa                   	stos   %al,%es:(%rdi)
    4a6a:	aa                   	stos   %al,%es:(%rdi)
    4a6b:	aa                   	stos   %al,%es:(%rdi)
    4a6c:	aa                   	stos   %al,%es:(%rdi)
    4a6d:	aa                   	stos   %al,%es:(%rdi)
    4a6e:	aa                   	stos   %al,%es:(%rdi)
    4a6f:	aa                   	stos   %al,%es:(%rdi)
    4a70:	aa                   	stos   %al,%es:(%rdi)
    4a71:	aa                   	stos   %al,%es:(%rdi)
    4a72:	aa                   	stos   %al,%es:(%rdi)
    4a73:	aa                   	stos   %al,%es:(%rdi)
    4a74:	aa                   	stos   %al,%es:(%rdi)
    4a75:	aa                   	stos   %al,%es:(%rdi)
    4a76:	aa                   	stos   %al,%es:(%rdi)
    4a77:	aa                   	stos   %al,%es:(%rdi)
    4a78:	aa                   	stos   %al,%es:(%rdi)
    4a79:	aa                   	stos   %al,%es:(%rdi)
    4a7a:	aa                   	stos   %al,%es:(%rdi)
    4a7b:	aa                   	stos   %al,%es:(%rdi)
    4a7c:	aa                   	stos   %al,%es:(%rdi)
    4a7d:	aa                   	stos   %al,%es:(%rdi)
    4a7e:	aa                   	stos   %al,%es:(%rdi)
    4a7f:	aa                   	stos   %al,%es:(%rdi)
    4a80:	aa                   	stos   %al,%es:(%rdi)
    4a81:	aa                   	stos   %al,%es:(%rdi)
    4a82:	aa                   	stos   %al,%es:(%rdi)
    4a83:	aa                   	stos   %al,%es:(%rdi)
    4a84:	aa                   	stos   %al,%es:(%rdi)
    4a85:	aa                   	stos   %al,%es:(%rdi)
    4a86:	aa                   	stos   %al,%es:(%rdi)
    4a87:	aa                   	stos   %al,%es:(%rdi)
    4a88:	aa                   	stos   %al,%es:(%rdi)
    4a89:	aa                   	stos   %al,%es:(%rdi)
    4a8a:	aa                   	stos   %al,%es:(%rdi)
    4a8b:	aa                   	stos   %al,%es:(%rdi)
    4a8c:	aa                   	stos   %al,%es:(%rdi)
    4a8d:	aa                   	stos   %al,%es:(%rdi)
    4a8e:	aa                   	stos   %al,%es:(%rdi)
    4a8f:	aa                   	stos   %al,%es:(%rdi)
    4a90:	aa                   	stos   %al,%es:(%rdi)
    4a91:	aa                   	stos   %al,%es:(%rdi)
    4a92:	aa                   	stos   %al,%es:(%rdi)
    4a93:	aa                   	stos   %al,%es:(%rdi)
    4a94:	aa                   	stos   %al,%es:(%rdi)
    4a95:	aa                   	stos   %al,%es:(%rdi)
    4a96:	aa                   	stos   %al,%es:(%rdi)
    4a97:	aa                   	stos   %al,%es:(%rdi)
    4a98:	aa                   	stos   %al,%es:(%rdi)
    4a99:	aa                   	stos   %al,%es:(%rdi)
    4a9a:	aa                   	stos   %al,%es:(%rdi)
    4a9b:	aa                   	stos   %al,%es:(%rdi)
    4a9c:	aa                   	stos   %al,%es:(%rdi)
    4a9d:	aa                   	stos   %al,%es:(%rdi)
    4a9e:	aa                   	stos   %al,%es:(%rdi)
    4a9f:	aa                   	stos   %al,%es:(%rdi)
    4aa0:	aa                   	stos   %al,%es:(%rdi)
    4aa1:	aa                   	stos   %al,%es:(%rdi)
    4aa2:	aa                   	stos   %al,%es:(%rdi)
    4aa3:	aa                   	stos   %al,%es:(%rdi)
    4aa4:	aa                   	stos   %al,%es:(%rdi)
    4aa5:	aa                   	stos   %al,%es:(%rdi)
    4aa6:	aa                   	stos   %al,%es:(%rdi)
    4aa7:	aa                   	stos   %al,%es:(%rdi)
    4aa8:	aa                   	stos   %al,%es:(%rdi)
    4aa9:	aa                   	stos   %al,%es:(%rdi)
    4aaa:	aa                   	stos   %al,%es:(%rdi)
    4aab:	aa                   	stos   %al,%es:(%rdi)
    4aac:	aa                   	stos   %al,%es:(%rdi)
    4aad:	aa                   	stos   %al,%es:(%rdi)
    4aae:	aa                   	stos   %al,%es:(%rdi)
    4aaf:	aa                   	stos   %al,%es:(%rdi)
    4ab0:	aa                   	stos   %al,%es:(%rdi)
    4ab1:	aa                   	stos   %al,%es:(%rdi)
    4ab2:	aa                   	stos   %al,%es:(%rdi)
    4ab3:	aa                   	stos   %al,%es:(%rdi)
    4ab4:	aa                   	stos   %al,%es:(%rdi)
    4ab5:	aa                   	stos   %al,%es:(%rdi)
    4ab6:	aa                   	stos   %al,%es:(%rdi)
    4ab7:	aa                   	stos   %al,%es:(%rdi)
    4ab8:	aa                   	stos   %al,%es:(%rdi)
    4ab9:	aa                   	stos   %al,%es:(%rdi)
    4aba:	aa                   	stos   %al,%es:(%rdi)
    4abb:	aa                   	stos   %al,%es:(%rdi)
    4abc:	aa                   	stos   %al,%es:(%rdi)
    4abd:	aa                   	stos   %al,%es:(%rdi)
    4abe:	aa                   	stos   %al,%es:(%rdi)
    4abf:	aa                   	stos   %al,%es:(%rdi)
    4ac0:	aa                   	stos   %al,%es:(%rdi)
    4ac1:	aa                   	stos   %al,%es:(%rdi)
    4ac2:	aa                   	stos   %al,%es:(%rdi)
    4ac3:	aa                   	stos   %al,%es:(%rdi)
    4ac4:	aa                   	stos   %al,%es:(%rdi)
    4ac5:	aa                   	stos   %al,%es:(%rdi)
    4ac6:	aa                   	stos   %al,%es:(%rdi)
    4ac7:	aa                   	stos   %al,%es:(%rdi)
    4ac8:	aa                   	stos   %al,%es:(%rdi)
    4ac9:	aa                   	stos   %al,%es:(%rdi)
    4aca:	aa                   	stos   %al,%es:(%rdi)
    4acb:	aa                   	stos   %al,%es:(%rdi)
    4acc:	aa                   	stos   %al,%es:(%rdi)
    4acd:	aa                   	stos   %al,%es:(%rdi)
    4ace:	aa                   	stos   %al,%es:(%rdi)
    4acf:	aa                   	stos   %al,%es:(%rdi)
    4ad0:	aa                   	stos   %al,%es:(%rdi)
    4ad1:	aa                   	stos   %al,%es:(%rdi)
    4ad2:	aa                   	stos   %al,%es:(%rdi)
    4ad3:	aa                   	stos   %al,%es:(%rdi)
    4ad4:	aa                   	stos   %al,%es:(%rdi)
    4ad5:	aa                   	stos   %al,%es:(%rdi)
    4ad6:	aa                   	stos   %al,%es:(%rdi)
    4ad7:	aa                   	stos   %al,%es:(%rdi)
    4ad8:	aa                   	stos   %al,%es:(%rdi)
    4ad9:	aa                   	stos   %al,%es:(%rdi)
    4ada:	aa                   	stos   %al,%es:(%rdi)
    4adb:	aa                   	stos   %al,%es:(%rdi)
    4adc:	aa                   	stos   %al,%es:(%rdi)
    4add:	aa                   	stos   %al,%es:(%rdi)
    4ade:	aa                   	stos   %al,%es:(%rdi)
    4adf:	aa                   	stos   %al,%es:(%rdi)
    4ae0:	aa                   	stos   %al,%es:(%rdi)
    4ae1:	aa                   	stos   %al,%es:(%rdi)
    4ae2:	aa                   	stos   %al,%es:(%rdi)
    4ae3:	aa                   	stos   %al,%es:(%rdi)
    4ae4:	aa                   	stos   %al,%es:(%rdi)
    4ae5:	aa                   	stos   %al,%es:(%rdi)
    4ae6:	aa                   	stos   %al,%es:(%rdi)
    4ae7:	aa                   	stos   %al,%es:(%rdi)
    4ae8:	aa                   	stos   %al,%es:(%rdi)
    4ae9:	aa                   	stos   %al,%es:(%rdi)
    4aea:	aa                   	stos   %al,%es:(%rdi)
    4aeb:	aa                   	stos   %al,%es:(%rdi)
    4aec:	aa                   	stos   %al,%es:(%rdi)
    4aed:	aa                   	stos   %al,%es:(%rdi)
    4aee:	aa                   	stos   %al,%es:(%rdi)
    4aef:	aa                   	stos   %al,%es:(%rdi)
    4af0:	aa                   	stos   %al,%es:(%rdi)
    4af1:	aa                   	stos   %al,%es:(%rdi)
    4af2:	aa                   	stos   %al,%es:(%rdi)
    4af3:	aa                   	stos   %al,%es:(%rdi)
    4af4:	aa                   	stos   %al,%es:(%rdi)
    4af5:	aa                   	stos   %al,%es:(%rdi)
    4af6:	aa                   	stos   %al,%es:(%rdi)
    4af7:	aa                   	stos   %al,%es:(%rdi)
    4af8:	aa                   	stos   %al,%es:(%rdi)
    4af9:	aa                   	stos   %al,%es:(%rdi)
    4afa:	aa                   	stos   %al,%es:(%rdi)
    4afb:	aa                   	stos   %al,%es:(%rdi)
    4afc:	aa                   	stos   %al,%es:(%rdi)
    4afd:	aa                   	stos   %al,%es:(%rdi)
    4afe:	aa                   	stos   %al,%es:(%rdi)
    4aff:	aa                   	stos   %al,%es:(%rdi)
    4b00:	aa                   	stos   %al,%es:(%rdi)
    4b01:	aa                   	stos   %al,%es:(%rdi)
    4b02:	aa                   	stos   %al,%es:(%rdi)
    4b03:	aa                   	stos   %al,%es:(%rdi)
    4b04:	aa                   	stos   %al,%es:(%rdi)
    4b05:	aa                   	stos   %al,%es:(%rdi)
    4b06:	aa                   	stos   %al,%es:(%rdi)
    4b07:	aa                   	stos   %al,%es:(%rdi)
    4b08:	aa                   	stos   %al,%es:(%rdi)
    4b09:	aa                   	stos   %al,%es:(%rdi)
    4b0a:	aa                   	stos   %al,%es:(%rdi)
    4b0b:	aa                   	stos   %al,%es:(%rdi)
    4b0c:	aa                   	stos   %al,%es:(%rdi)
    4b0d:	aa                   	stos   %al,%es:(%rdi)
    4b0e:	aa                   	stos   %al,%es:(%rdi)
    4b0f:	aa                   	stos   %al,%es:(%rdi)
    4b10:	aa                   	stos   %al,%es:(%rdi)
    4b11:	aa                   	stos   %al,%es:(%rdi)
    4b12:	aa                   	stos   %al,%es:(%rdi)
    4b13:	aa                   	stos   %al,%es:(%rdi)
    4b14:	aa                   	stos   %al,%es:(%rdi)
    4b15:	aa                   	stos   %al,%es:(%rdi)
    4b16:	aa                   	stos   %al,%es:(%rdi)
    4b17:	aa                   	stos   %al,%es:(%rdi)
    4b18:	aa                   	stos   %al,%es:(%rdi)
    4b19:	aa                   	stos   %al,%es:(%rdi)
    4b1a:	aa                   	stos   %al,%es:(%rdi)
    4b1b:	aa                   	stos   %al,%es:(%rdi)
    4b1c:	aa                   	stos   %al,%es:(%rdi)
    4b1d:	aa                   	stos   %al,%es:(%rdi)
    4b1e:	aa                   	stos   %al,%es:(%rdi)
    4b1f:	aa                   	stos   %al,%es:(%rdi)
    4b20:	aa                   	stos   %al,%es:(%rdi)
    4b21:	aa                   	stos   %al,%es:(%rdi)
    4b22:	aa                   	stos   %al,%es:(%rdi)
    4b23:	aa                   	stos   %al,%es:(%rdi)
    4b24:	aa                   	stos   %al,%es:(%rdi)
    4b25:	aa                   	stos   %al,%es:(%rdi)
    4b26:	aa                   	stos   %al,%es:(%rdi)
    4b27:	aa                   	stos   %al,%es:(%rdi)
    4b28:	aa                   	stos   %al,%es:(%rdi)
    4b29:	aa                   	stos   %al,%es:(%rdi)
    4b2a:	aa                   	stos   %al,%es:(%rdi)
    4b2b:	aa                   	stos   %al,%es:(%rdi)
    4b2c:	aa                   	stos   %al,%es:(%rdi)
    4b2d:	aa                   	stos   %al,%es:(%rdi)
    4b2e:	aa                   	stos   %al,%es:(%rdi)
    4b2f:	aa                   	stos   %al,%es:(%rdi)
    4b30:	aa                   	stos   %al,%es:(%rdi)
    4b31:	aa                   	stos   %al,%es:(%rdi)
    4b32:	aa                   	stos   %al,%es:(%rdi)
    4b33:	aa                   	stos   %al,%es:(%rdi)
    4b34:	aa                   	stos   %al,%es:(%rdi)
    4b35:	aa                   	stos   %al,%es:(%rdi)
    4b36:	aa                   	stos   %al,%es:(%rdi)
    4b37:	aa                   	stos   %al,%es:(%rdi)
    4b38:	aa                   	stos   %al,%es:(%rdi)
    4b39:	aa                   	stos   %al,%es:(%rdi)
    4b3a:	aa                   	stos   %al,%es:(%rdi)
    4b3b:	aa                   	stos   %al,%es:(%rdi)
    4b3c:	aa                   	stos   %al,%es:(%rdi)
    4b3d:	aa                   	stos   %al,%es:(%rdi)
    4b3e:	aa                   	stos   %al,%es:(%rdi)
    4b3f:	aa                   	stos   %al,%es:(%rdi)
    4b40:	aa                   	stos   %al,%es:(%rdi)
    4b41:	aa                   	stos   %al,%es:(%rdi)
    4b42:	aa                   	stos   %al,%es:(%rdi)
    4b43:	aa                   	stos   %al,%es:(%rdi)
    4b44:	aa                   	stos   %al,%es:(%rdi)
    4b45:	aa                   	stos   %al,%es:(%rdi)
    4b46:	aa                   	stos   %al,%es:(%rdi)
    4b47:	aa                   	stos   %al,%es:(%rdi)
    4b48:	aa                   	stos   %al,%es:(%rdi)
    4b49:	aa                   	stos   %al,%es:(%rdi)
    4b4a:	aa                   	stos   %al,%es:(%rdi)
    4b4b:	aa                   	stos   %al,%es:(%rdi)
    4b4c:	aa                   	stos   %al,%es:(%rdi)
    4b4d:	aa                   	stos   %al,%es:(%rdi)
    4b4e:	aa                   	stos   %al,%es:(%rdi)
    4b4f:	aa                   	stos   %al,%es:(%rdi)
    4b50:	aa                   	stos   %al,%es:(%rdi)
    4b51:	aa                   	stos   %al,%es:(%rdi)
    4b52:	aa                   	stos   %al,%es:(%rdi)
    4b53:	aa                   	stos   %al,%es:(%rdi)
    4b54:	aa                   	stos   %al,%es:(%rdi)
    4b55:	aa                   	stos   %al,%es:(%rdi)
    4b56:	aa                   	stos   %al,%es:(%rdi)
    4b57:	aa                   	stos   %al,%es:(%rdi)
    4b58:	aa                   	stos   %al,%es:(%rdi)
    4b59:	aa                   	stos   %al,%es:(%rdi)
    4b5a:	aa                   	stos   %al,%es:(%rdi)
    4b5b:	aa                   	stos   %al,%es:(%rdi)
    4b5c:	aa                   	stos   %al,%es:(%rdi)
    4b5d:	aa                   	stos   %al,%es:(%rdi)
    4b5e:	aa                   	stos   %al,%es:(%rdi)
    4b5f:	aa                   	stos   %al,%es:(%rdi)
    4b60:	aa                   	stos   %al,%es:(%rdi)
    4b61:	aa                   	stos   %al,%es:(%rdi)
    4b62:	aa                   	stos   %al,%es:(%rdi)
    4b63:	aa                   	stos   %al,%es:(%rdi)
    4b64:	aa                   	stos   %al,%es:(%rdi)
    4b65:	aa                   	stos   %al,%es:(%rdi)
    4b66:	aa                   	stos   %al,%es:(%rdi)
    4b67:	aa                   	stos   %al,%es:(%rdi)
    4b68:	aa                   	stos   %al,%es:(%rdi)
    4b69:	aa                   	stos   %al,%es:(%rdi)
    4b6a:	aa                   	stos   %al,%es:(%rdi)
    4b6b:	aa                   	stos   %al,%es:(%rdi)
    4b6c:	aa                   	stos   %al,%es:(%rdi)
    4b6d:	aa                   	stos   %al,%es:(%rdi)
    4b6e:	aa                   	stos   %al,%es:(%rdi)
    4b6f:	aa                   	stos   %al,%es:(%rdi)
    4b70:	aa                   	stos   %al,%es:(%rdi)
    4b71:	aa                   	stos   %al,%es:(%rdi)
    4b72:	aa                   	stos   %al,%es:(%rdi)
    4b73:	aa                   	stos   %al,%es:(%rdi)
    4b74:	aa                   	stos   %al,%es:(%rdi)
    4b75:	aa                   	stos   %al,%es:(%rdi)
    4b76:	aa                   	stos   %al,%es:(%rdi)
    4b77:	aa                   	stos   %al,%es:(%rdi)
    4b78:	aa                   	stos   %al,%es:(%rdi)
    4b79:	aa                   	stos   %al,%es:(%rdi)
    4b7a:	aa                   	stos   %al,%es:(%rdi)
    4b7b:	aa                   	stos   %al,%es:(%rdi)
    4b7c:	aa                   	stos   %al,%es:(%rdi)
    4b7d:	aa                   	stos   %al,%es:(%rdi)
    4b7e:	aa                   	stos   %al,%es:(%rdi)
    4b7f:	aa                   	stos   %al,%es:(%rdi)
    4b80:	aa                   	stos   %al,%es:(%rdi)
    4b81:	aa                   	stos   %al,%es:(%rdi)
    4b82:	aa                   	stos   %al,%es:(%rdi)
    4b83:	aa                   	stos   %al,%es:(%rdi)
    4b84:	aa                   	stos   %al,%es:(%rdi)
    4b85:	aa                   	stos   %al,%es:(%rdi)
    4b86:	aa                   	stos   %al,%es:(%rdi)
    4b87:	aa                   	stos   %al,%es:(%rdi)
    4b88:	aa                   	stos   %al,%es:(%rdi)
    4b89:	aa                   	stos   %al,%es:(%rdi)
    4b8a:	aa                   	stos   %al,%es:(%rdi)
    4b8b:	aa                   	stos   %al,%es:(%rdi)
    4b8c:	aa                   	stos   %al,%es:(%rdi)
    4b8d:	aa                   	stos   %al,%es:(%rdi)
    4b8e:	aa                   	stos   %al,%es:(%rdi)
    4b8f:	aa                   	stos   %al,%es:(%rdi)
    4b90:	aa                   	stos   %al,%es:(%rdi)
    4b91:	aa                   	stos   %al,%es:(%rdi)
    4b92:	aa                   	stos   %al,%es:(%rdi)
    4b93:	aa                   	stos   %al,%es:(%rdi)
    4b94:	aa                   	stos   %al,%es:(%rdi)
    4b95:	aa                   	stos   %al,%es:(%rdi)
    4b96:	aa                   	stos   %al,%es:(%rdi)
    4b97:	aa                   	stos   %al,%es:(%rdi)
    4b98:	aa                   	stos   %al,%es:(%rdi)
    4b99:	aa                   	stos   %al,%es:(%rdi)
    4b9a:	aa                   	stos   %al,%es:(%rdi)
    4b9b:	aa                   	stos   %al,%es:(%rdi)
    4b9c:	aa                   	stos   %al,%es:(%rdi)
    4b9d:	aa                   	stos   %al,%es:(%rdi)
    4b9e:	aa                   	stos   %al,%es:(%rdi)
    4b9f:	aa                   	stos   %al,%es:(%rdi)
    4ba0:	aa                   	stos   %al,%es:(%rdi)
    4ba1:	aa                   	stos   %al,%es:(%rdi)
    4ba2:	aa                   	stos   %al,%es:(%rdi)
    4ba3:	aa                   	stos   %al,%es:(%rdi)
    4ba4:	aa                   	stos   %al,%es:(%rdi)
    4ba5:	aa                   	stos   %al,%es:(%rdi)
    4ba6:	aa                   	stos   %al,%es:(%rdi)
    4ba7:	aa                   	stos   %al,%es:(%rdi)
    4ba8:	aa                   	stos   %al,%es:(%rdi)
    4ba9:	aa                   	stos   %al,%es:(%rdi)
    4baa:	aa                   	stos   %al,%es:(%rdi)
    4bab:	aa                   	stos   %al,%es:(%rdi)
    4bac:	aa                   	stos   %al,%es:(%rdi)
    4bad:	aa                   	stos   %al,%es:(%rdi)
    4bae:	aa                   	stos   %al,%es:(%rdi)
    4baf:	aa                   	stos   %al,%es:(%rdi)
    4bb0:	aa                   	stos   %al,%es:(%rdi)
    4bb1:	aa                   	stos   %al,%es:(%rdi)
    4bb2:	aa                   	stos   %al,%es:(%rdi)
    4bb3:	aa                   	stos   %al,%es:(%rdi)
    4bb4:	aa                   	stos   %al,%es:(%rdi)
    4bb5:	aa                   	stos   %al,%es:(%rdi)
    4bb6:	aa                   	stos   %al,%es:(%rdi)
    4bb7:	aa                   	stos   %al,%es:(%rdi)
    4bb8:	aa                   	stos   %al,%es:(%rdi)
    4bb9:	aa                   	stos   %al,%es:(%rdi)
    4bba:	aa                   	stos   %al,%es:(%rdi)
    4bbb:	aa                   	stos   %al,%es:(%rdi)
    4bbc:	aa                   	stos   %al,%es:(%rdi)
    4bbd:	aa                   	stos   %al,%es:(%rdi)
    4bbe:	aa                   	stos   %al,%es:(%rdi)
    4bbf:	aa                   	stos   %al,%es:(%rdi)
    4bc0:	aa                   	stos   %al,%es:(%rdi)
    4bc1:	aa                   	stos   %al,%es:(%rdi)
    4bc2:	aa                   	stos   %al,%es:(%rdi)
    4bc3:	aa                   	stos   %al,%es:(%rdi)
    4bc4:	aa                   	stos   %al,%es:(%rdi)
    4bc5:	aa                   	stos   %al,%es:(%rdi)
    4bc6:	aa                   	stos   %al,%es:(%rdi)
    4bc7:	aa                   	stos   %al,%es:(%rdi)
    4bc8:	aa                   	stos   %al,%es:(%rdi)
    4bc9:	aa                   	stos   %al,%es:(%rdi)
    4bca:	aa                   	stos   %al,%es:(%rdi)
    4bcb:	aa                   	stos   %al,%es:(%rdi)
    4bcc:	aa                   	stos   %al,%es:(%rdi)
    4bcd:	aa                   	stos   %al,%es:(%rdi)
    4bce:	aa                   	stos   %al,%es:(%rdi)
    4bcf:	aa                   	stos   %al,%es:(%rdi)
    4bd0:	aa                   	stos   %al,%es:(%rdi)
    4bd1:	aa                   	stos   %al,%es:(%rdi)
    4bd2:	aa                   	stos   %al,%es:(%rdi)
    4bd3:	aa                   	stos   %al,%es:(%rdi)
    4bd4:	aa                   	stos   %al,%es:(%rdi)
    4bd5:	aa                   	stos   %al,%es:(%rdi)
    4bd6:	aa                   	stos   %al,%es:(%rdi)
    4bd7:	aa                   	stos   %al,%es:(%rdi)
    4bd8:	aa                   	stos   %al,%es:(%rdi)
    4bd9:	aa                   	stos   %al,%es:(%rdi)
    4bda:	aa                   	stos   %al,%es:(%rdi)
    4bdb:	aa                   	stos   %al,%es:(%rdi)
    4bdc:	aa                   	stos   %al,%es:(%rdi)
    4bdd:	aa                   	stos   %al,%es:(%rdi)
    4bde:	aa                   	stos   %al,%es:(%rdi)
    4bdf:	aa                   	stos   %al,%es:(%rdi)
    4be0:	aa                   	stos   %al,%es:(%rdi)
    4be1:	aa                   	stos   %al,%es:(%rdi)
    4be2:	aa                   	stos   %al,%es:(%rdi)
    4be3:	aa                   	stos   %al,%es:(%rdi)
    4be4:	aa                   	stos   %al,%es:(%rdi)
    4be5:	aa                   	stos   %al,%es:(%rdi)
    4be6:	aa                   	stos   %al,%es:(%rdi)
    4be7:	aa                   	stos   %al,%es:(%rdi)
    4be8:	aa                   	stos   %al,%es:(%rdi)
    4be9:	aa                   	stos   %al,%es:(%rdi)
    4bea:	aa                   	stos   %al,%es:(%rdi)
    4beb:	aa                   	stos   %al,%es:(%rdi)
    4bec:	aa                   	stos   %al,%es:(%rdi)
    4bed:	aa                   	stos   %al,%es:(%rdi)
    4bee:	aa                   	stos   %al,%es:(%rdi)
    4bef:	aa                   	stos   %al,%es:(%rdi)
    4bf0:	aa                   	stos   %al,%es:(%rdi)
    4bf1:	aa                   	stos   %al,%es:(%rdi)
    4bf2:	aa                   	stos   %al,%es:(%rdi)
    4bf3:	aa                   	stos   %al,%es:(%rdi)
    4bf4:	aa                   	stos   %al,%es:(%rdi)
    4bf5:	aa                   	stos   %al,%es:(%rdi)
    4bf6:	aa                   	stos   %al,%es:(%rdi)
    4bf7:	aa                   	stos   %al,%es:(%rdi)
    4bf8:	aa                   	stos   %al,%es:(%rdi)
    4bf9:	aa                   	stos   %al,%es:(%rdi)
    4bfa:	aa                   	stos   %al,%es:(%rdi)
    4bfb:	aa                   	stos   %al,%es:(%rdi)
    4bfc:	aa                   	stos   %al,%es:(%rdi)
    4bfd:	aa                   	stos   %al,%es:(%rdi)
    4bfe:	aa                   	stos   %al,%es:(%rdi)
    4bff:	aa                   	stos   %al,%es:(%rdi)
    4c00:	aa                   	stos   %al,%es:(%rdi)
    4c01:	aa                   	stos   %al,%es:(%rdi)
    4c02:	aa                   	stos   %al,%es:(%rdi)
    4c03:	aa                   	stos   %al,%es:(%rdi)
    4c04:	aa                   	stos   %al,%es:(%rdi)
    4c05:	aa                   	stos   %al,%es:(%rdi)
    4c06:	aa                   	stos   %al,%es:(%rdi)
    4c07:	aa                   	stos   %al,%es:(%rdi)
    4c08:	aa                   	stos   %al,%es:(%rdi)
    4c09:	aa                   	stos   %al,%es:(%rdi)
    4c0a:	aa                   	stos   %al,%es:(%rdi)
    4c0b:	aa                   	stos   %al,%es:(%rdi)
    4c0c:	aa                   	stos   %al,%es:(%rdi)
    4c0d:	aa                   	stos   %al,%es:(%rdi)
    4c0e:	aa                   	stos   %al,%es:(%rdi)
    4c0f:	aa                   	stos   %al,%es:(%rdi)
    4c10:	aa                   	stos   %al,%es:(%rdi)
    4c11:	aa                   	stos   %al,%es:(%rdi)
    4c12:	aa                   	stos   %al,%es:(%rdi)
    4c13:	aa                   	stos   %al,%es:(%rdi)
    4c14:	aa                   	stos   %al,%es:(%rdi)
    4c15:	aa                   	stos   %al,%es:(%rdi)
    4c16:	aa                   	stos   %al,%es:(%rdi)
    4c17:	aa                   	stos   %al,%es:(%rdi)
    4c18:	aa                   	stos   %al,%es:(%rdi)
    4c19:	aa                   	stos   %al,%es:(%rdi)
    4c1a:	aa                   	stos   %al,%es:(%rdi)
    4c1b:	aa                   	stos   %al,%es:(%rdi)
    4c1c:	aa                   	stos   %al,%es:(%rdi)
    4c1d:	aa                   	stos   %al,%es:(%rdi)
    4c1e:	aa                   	stos   %al,%es:(%rdi)
    4c1f:	aa                   	stos   %al,%es:(%rdi)
    4c20:	aa                   	stos   %al,%es:(%rdi)
    4c21:	aa                   	stos   %al,%es:(%rdi)
    4c22:	aa                   	stos   %al,%es:(%rdi)
    4c23:	aa                   	stos   %al,%es:(%rdi)
    4c24:	aa                   	stos   %al,%es:(%rdi)
    4c25:	aa                   	stos   %al,%es:(%rdi)
    4c26:	aa                   	stos   %al,%es:(%rdi)
    4c27:	aa                   	stos   %al,%es:(%rdi)
    4c28:	aa                   	stos   %al,%es:(%rdi)
    4c29:	aa                   	stos   %al,%es:(%rdi)
    4c2a:	aa                   	stos   %al,%es:(%rdi)
    4c2b:	aa                   	stos   %al,%es:(%rdi)
    4c2c:	aa                   	stos   %al,%es:(%rdi)
    4c2d:	aa                   	stos   %al,%es:(%rdi)
    4c2e:	aa                   	stos   %al,%es:(%rdi)
    4c2f:	aa                   	stos   %al,%es:(%rdi)
    4c30:	aa                   	stos   %al,%es:(%rdi)
    4c31:	aa                   	stos   %al,%es:(%rdi)
    4c32:	aa                   	stos   %al,%es:(%rdi)
    4c33:	aa                   	stos   %al,%es:(%rdi)
    4c34:	aa                   	stos   %al,%es:(%rdi)
    4c35:	aa                   	stos   %al,%es:(%rdi)
    4c36:	aa                   	stos   %al,%es:(%rdi)
    4c37:	aa                   	stos   %al,%es:(%rdi)
    4c38:	aa                   	stos   %al,%es:(%rdi)
    4c39:	aa                   	stos   %al,%es:(%rdi)
    4c3a:	aa                   	stos   %al,%es:(%rdi)
    4c3b:	aa                   	stos   %al,%es:(%rdi)
    4c3c:	aa                   	stos   %al,%es:(%rdi)
    4c3d:	aa                   	stos   %al,%es:(%rdi)
    4c3e:	aa                   	stos   %al,%es:(%rdi)
    4c3f:	aa                   	stos   %al,%es:(%rdi)
    4c40:	aa                   	stos   %al,%es:(%rdi)
    4c41:	aa                   	stos   %al,%es:(%rdi)
    4c42:	aa                   	stos   %al,%es:(%rdi)
    4c43:	aa                   	stos   %al,%es:(%rdi)
    4c44:	aa                   	stos   %al,%es:(%rdi)
    4c45:	aa                   	stos   %al,%es:(%rdi)
    4c46:	aa                   	stos   %al,%es:(%rdi)
    4c47:	aa                   	stos   %al,%es:(%rdi)
    4c48:	aa                   	stos   %al,%es:(%rdi)
    4c49:	aa                   	stos   %al,%es:(%rdi)
    4c4a:	aa                   	stos   %al,%es:(%rdi)
    4c4b:	aa                   	stos   %al,%es:(%rdi)
    4c4c:	aa                   	stos   %al,%es:(%rdi)
    4c4d:	aa                   	stos   %al,%es:(%rdi)
    4c4e:	aa                   	stos   %al,%es:(%rdi)
    4c4f:	aa                   	stos   %al,%es:(%rdi)
    4c50:	aa                   	stos   %al,%es:(%rdi)
    4c51:	aa                   	stos   %al,%es:(%rdi)
    4c52:	aa                   	stos   %al,%es:(%rdi)
    4c53:	aa                   	stos   %al,%es:(%rdi)
    4c54:	aa                   	stos   %al,%es:(%rdi)
    4c55:	aa                   	stos   %al,%es:(%rdi)
    4c56:	aa                   	stos   %al,%es:(%rdi)
    4c57:	aa                   	stos   %al,%es:(%rdi)
    4c58:	aa                   	stos   %al,%es:(%rdi)
    4c59:	aa                   	stos   %al,%es:(%rdi)
    4c5a:	aa                   	stos   %al,%es:(%rdi)
    4c5b:	aa                   	stos   %al,%es:(%rdi)
    4c5c:	aa                   	stos   %al,%es:(%rdi)
    4c5d:	aa                   	stos   %al,%es:(%rdi)
    4c5e:	aa                   	stos   %al,%es:(%rdi)
    4c5f:	aa                   	stos   %al,%es:(%rdi)
    4c60:	aa                   	stos   %al,%es:(%rdi)
    4c61:	aa                   	stos   %al,%es:(%rdi)
    4c62:	aa                   	stos   %al,%es:(%rdi)
    4c63:	aa                   	stos   %al,%es:(%rdi)
    4c64:	aa                   	stos   %al,%es:(%rdi)
    4c65:	aa                   	stos   %al,%es:(%rdi)
    4c66:	aa                   	stos   %al,%es:(%rdi)
    4c67:	aa                   	stos   %al,%es:(%rdi)
    4c68:	aa                   	stos   %al,%es:(%rdi)
    4c69:	aa                   	stos   %al,%es:(%rdi)
    4c6a:	aa                   	stos   %al,%es:(%rdi)
    4c6b:	aa                   	stos   %al,%es:(%rdi)
    4c6c:	aa                   	stos   %al,%es:(%rdi)
    4c6d:	aa                   	stos   %al,%es:(%rdi)
    4c6e:	aa                   	stos   %al,%es:(%rdi)
    4c6f:	aa                   	stos   %al,%es:(%rdi)
    4c70:	aa                   	stos   %al,%es:(%rdi)
    4c71:	aa                   	stos   %al,%es:(%rdi)
    4c72:	aa                   	stos   %al,%es:(%rdi)
    4c73:	aa                   	stos   %al,%es:(%rdi)
    4c74:	aa                   	stos   %al,%es:(%rdi)
    4c75:	aa                   	stos   %al,%es:(%rdi)
    4c76:	aa                   	stos   %al,%es:(%rdi)
    4c77:	aa                   	stos   %al,%es:(%rdi)
    4c78:	aa                   	stos   %al,%es:(%rdi)
    4c79:	aa                   	stos   %al,%es:(%rdi)
    4c7a:	aa                   	stos   %al,%es:(%rdi)
    4c7b:	aa                   	stos   %al,%es:(%rdi)
    4c7c:	aa                   	stos   %al,%es:(%rdi)
    4c7d:	aa                   	stos   %al,%es:(%rdi)
    4c7e:	aa                   	stos   %al,%es:(%rdi)
    4c7f:	aa                   	stos   %al,%es:(%rdi)
    4c80:	aa                   	stos   %al,%es:(%rdi)
    4c81:	aa                   	stos   %al,%es:(%rdi)
    4c82:	aa                   	stos   %al,%es:(%rdi)
    4c83:	aa                   	stos   %al,%es:(%rdi)
    4c84:	aa                   	stos   %al,%es:(%rdi)
    4c85:	aa                   	stos   %al,%es:(%rdi)
    4c86:	aa                   	stos   %al,%es:(%rdi)
    4c87:	aa                   	stos   %al,%es:(%rdi)
    4c88:	aa                   	stos   %al,%es:(%rdi)
    4c89:	aa                   	stos   %al,%es:(%rdi)
    4c8a:	aa                   	stos   %al,%es:(%rdi)
    4c8b:	aa                   	stos   %al,%es:(%rdi)
    4c8c:	aa                   	stos   %al,%es:(%rdi)
    4c8d:	aa                   	stos   %al,%es:(%rdi)
    4c8e:	aa                   	stos   %al,%es:(%rdi)
    4c8f:	aa                   	stos   %al,%es:(%rdi)
    4c90:	aa                   	stos   %al,%es:(%rdi)
    4c91:	aa                   	stos   %al,%es:(%rdi)
    4c92:	aa                   	stos   %al,%es:(%rdi)
    4c93:	aa                   	stos   %al,%es:(%rdi)
    4c94:	aa                   	stos   %al,%es:(%rdi)
    4c95:	aa                   	stos   %al,%es:(%rdi)
    4c96:	aa                   	stos   %al,%es:(%rdi)
    4c97:	aa                   	stos   %al,%es:(%rdi)
    4c98:	aa                   	stos   %al,%es:(%rdi)
    4c99:	aa                   	stos   %al,%es:(%rdi)
    4c9a:	aa                   	stos   %al,%es:(%rdi)
    4c9b:	aa                   	stos   %al,%es:(%rdi)
    4c9c:	aa                   	stos   %al,%es:(%rdi)
    4c9d:	aa                   	stos   %al,%es:(%rdi)
    4c9e:	aa                   	stos   %al,%es:(%rdi)
    4c9f:	aa                   	stos   %al,%es:(%rdi)
    4ca0:	aa                   	stos   %al,%es:(%rdi)
    4ca1:	aa                   	stos   %al,%es:(%rdi)
    4ca2:	aa                   	stos   %al,%es:(%rdi)
    4ca3:	aa                   	stos   %al,%es:(%rdi)
    4ca4:	aa                   	stos   %al,%es:(%rdi)
    4ca5:	aa                   	stos   %al,%es:(%rdi)
    4ca6:	aa                   	stos   %al,%es:(%rdi)
    4ca7:	aa                   	stos   %al,%es:(%rdi)
    4ca8:	aa                   	stos   %al,%es:(%rdi)
    4ca9:	aa                   	stos   %al,%es:(%rdi)
    4caa:	aa                   	stos   %al,%es:(%rdi)
    4cab:	aa                   	stos   %al,%es:(%rdi)
    4cac:	aa                   	stos   %al,%es:(%rdi)
    4cad:	aa                   	stos   %al,%es:(%rdi)
    4cae:	aa                   	stos   %al,%es:(%rdi)
    4caf:	aa                   	stos   %al,%es:(%rdi)
    4cb0:	aa                   	stos   %al,%es:(%rdi)
    4cb1:	aa                   	stos   %al,%es:(%rdi)
    4cb2:	aa                   	stos   %al,%es:(%rdi)
    4cb3:	aa                   	stos   %al,%es:(%rdi)
    4cb4:	aa                   	stos   %al,%es:(%rdi)
    4cb5:	aa                   	stos   %al,%es:(%rdi)
    4cb6:	aa                   	stos   %al,%es:(%rdi)
    4cb7:	aa                   	stos   %al,%es:(%rdi)
    4cb8:	aa                   	stos   %al,%es:(%rdi)
    4cb9:	aa                   	stos   %al,%es:(%rdi)
    4cba:	aa                   	stos   %al,%es:(%rdi)
    4cbb:	aa                   	stos   %al,%es:(%rdi)
    4cbc:	aa                   	stos   %al,%es:(%rdi)
    4cbd:	aa                   	stos   %al,%es:(%rdi)
    4cbe:	aa                   	stos   %al,%es:(%rdi)
    4cbf:	aa                   	stos   %al,%es:(%rdi)
    4cc0:	aa                   	stos   %al,%es:(%rdi)
    4cc1:	aa                   	stos   %al,%es:(%rdi)
    4cc2:	aa                   	stos   %al,%es:(%rdi)
    4cc3:	aa                   	stos   %al,%es:(%rdi)
    4cc4:	aa                   	stos   %al,%es:(%rdi)
    4cc5:	aa                   	stos   %al,%es:(%rdi)
    4cc6:	aa                   	stos   %al,%es:(%rdi)
    4cc7:	aa                   	stos   %al,%es:(%rdi)
    4cc8:	aa                   	stos   %al,%es:(%rdi)
    4cc9:	aa                   	stos   %al,%es:(%rdi)
    4cca:	aa                   	stos   %al,%es:(%rdi)
    4ccb:	aa                   	stos   %al,%es:(%rdi)
    4ccc:	aa                   	stos   %al,%es:(%rdi)
    4ccd:	aa                   	stos   %al,%es:(%rdi)
    4cce:	aa                   	stos   %al,%es:(%rdi)
    4ccf:	aa                   	stos   %al,%es:(%rdi)
    4cd0:	aa                   	stos   %al,%es:(%rdi)
    4cd1:	aa                   	stos   %al,%es:(%rdi)
    4cd2:	aa                   	stos   %al,%es:(%rdi)
    4cd3:	aa                   	stos   %al,%es:(%rdi)
    4cd4:	aa                   	stos   %al,%es:(%rdi)
    4cd5:	aa                   	stos   %al,%es:(%rdi)
    4cd6:	aa                   	stos   %al,%es:(%rdi)
    4cd7:	aa                   	stos   %al,%es:(%rdi)
    4cd8:	aa                   	stos   %al,%es:(%rdi)
    4cd9:	aa                   	stos   %al,%es:(%rdi)
    4cda:	aa                   	stos   %al,%es:(%rdi)
    4cdb:	aa                   	stos   %al,%es:(%rdi)
    4cdc:	aa                   	stos   %al,%es:(%rdi)
    4cdd:	aa                   	stos   %al,%es:(%rdi)
    4cde:	aa                   	stos   %al,%es:(%rdi)
    4cdf:	aa                   	stos   %al,%es:(%rdi)
    4ce0:	aa                   	stos   %al,%es:(%rdi)
    4ce1:	aa                   	stos   %al,%es:(%rdi)
    4ce2:	aa                   	stos   %al,%es:(%rdi)
    4ce3:	aa                   	stos   %al,%es:(%rdi)
    4ce4:	aa                   	stos   %al,%es:(%rdi)
    4ce5:	aa                   	stos   %al,%es:(%rdi)
    4ce6:	aa                   	stos   %al,%es:(%rdi)
    4ce7:	aa                   	stos   %al,%es:(%rdi)
    4ce8:	aa                   	stos   %al,%es:(%rdi)
    4ce9:	aa                   	stos   %al,%es:(%rdi)
    4cea:	aa                   	stos   %al,%es:(%rdi)
    4ceb:	aa                   	stos   %al,%es:(%rdi)
    4cec:	aa                   	stos   %al,%es:(%rdi)
    4ced:	aa                   	stos   %al,%es:(%rdi)
    4cee:	aa                   	stos   %al,%es:(%rdi)
    4cef:	aa                   	stos   %al,%es:(%rdi)
    4cf0:	aa                   	stos   %al,%es:(%rdi)
    4cf1:	aa                   	stos   %al,%es:(%rdi)
    4cf2:	aa                   	stos   %al,%es:(%rdi)
    4cf3:	aa                   	stos   %al,%es:(%rdi)
    4cf4:	aa                   	stos   %al,%es:(%rdi)
    4cf5:	aa                   	stos   %al,%es:(%rdi)
    4cf6:	aa                   	stos   %al,%es:(%rdi)
    4cf7:	aa                   	stos   %al,%es:(%rdi)
    4cf8:	aa                   	stos   %al,%es:(%rdi)
    4cf9:	aa                   	stos   %al,%es:(%rdi)
    4cfa:	aa                   	stos   %al,%es:(%rdi)
    4cfb:	aa                   	stos   %al,%es:(%rdi)
    4cfc:	aa                   	stos   %al,%es:(%rdi)
    4cfd:	aa                   	stos   %al,%es:(%rdi)
    4cfe:	aa                   	stos   %al,%es:(%rdi)
    4cff:	aa                   	stos   %al,%es:(%rdi)
    4d00:	aa                   	stos   %al,%es:(%rdi)
    4d01:	aa                   	stos   %al,%es:(%rdi)
    4d02:	aa                   	stos   %al,%es:(%rdi)
    4d03:	aa                   	stos   %al,%es:(%rdi)
    4d04:	aa                   	stos   %al,%es:(%rdi)
    4d05:	aa                   	stos   %al,%es:(%rdi)
    4d06:	aa                   	stos   %al,%es:(%rdi)
    4d07:	aa                   	stos   %al,%es:(%rdi)
    4d08:	aa                   	stos   %al,%es:(%rdi)
    4d09:	aa                   	stos   %al,%es:(%rdi)
    4d0a:	aa                   	stos   %al,%es:(%rdi)
    4d0b:	aa                   	stos   %al,%es:(%rdi)
    4d0c:	aa                   	stos   %al,%es:(%rdi)
    4d0d:	aa                   	stos   %al,%es:(%rdi)
    4d0e:	aa                   	stos   %al,%es:(%rdi)
    4d0f:	aa                   	stos   %al,%es:(%rdi)
    4d10:	aa                   	stos   %al,%es:(%rdi)
    4d11:	aa                   	stos   %al,%es:(%rdi)
    4d12:	aa                   	stos   %al,%es:(%rdi)
    4d13:	aa                   	stos   %al,%es:(%rdi)
    4d14:	aa                   	stos   %al,%es:(%rdi)
    4d15:	aa                   	stos   %al,%es:(%rdi)
    4d16:	aa                   	stos   %al,%es:(%rdi)
    4d17:	aa                   	stos   %al,%es:(%rdi)
    4d18:	aa                   	stos   %al,%es:(%rdi)
    4d19:	aa                   	stos   %al,%es:(%rdi)
    4d1a:	aa                   	stos   %al,%es:(%rdi)
    4d1b:	aa                   	stos   %al,%es:(%rdi)
    4d1c:	aa                   	stos   %al,%es:(%rdi)
    4d1d:	aa                   	stos   %al,%es:(%rdi)
    4d1e:	aa                   	stos   %al,%es:(%rdi)
    4d1f:	aa                   	stos   %al,%es:(%rdi)
    4d20:	aa                   	stos   %al,%es:(%rdi)
    4d21:	aa                   	stos   %al,%es:(%rdi)
    4d22:	aa                   	stos   %al,%es:(%rdi)
    4d23:	aa                   	stos   %al,%es:(%rdi)
    4d24:	aa                   	stos   %al,%es:(%rdi)
    4d25:	aa                   	stos   %al,%es:(%rdi)
    4d26:	aa                   	stos   %al,%es:(%rdi)
    4d27:	aa                   	stos   %al,%es:(%rdi)
    4d28:	aa                   	stos   %al,%es:(%rdi)
    4d29:	aa                   	stos   %al,%es:(%rdi)
    4d2a:	aa                   	stos   %al,%es:(%rdi)
    4d2b:	aa                   	stos   %al,%es:(%rdi)
    4d2c:	aa                   	stos   %al,%es:(%rdi)
    4d2d:	aa                   	stos   %al,%es:(%rdi)
    4d2e:	aa                   	stos   %al,%es:(%rdi)
    4d2f:	aa                   	stos   %al,%es:(%rdi)
    4d30:	aa                   	stos   %al,%es:(%rdi)
    4d31:	aa                   	stos   %al,%es:(%rdi)
    4d32:	aa                   	stos   %al,%es:(%rdi)
    4d33:	aa                   	stos   %al,%es:(%rdi)
    4d34:	aa                   	stos   %al,%es:(%rdi)
    4d35:	aa                   	stos   %al,%es:(%rdi)
    4d36:	aa                   	stos   %al,%es:(%rdi)
    4d37:	aa                   	stos   %al,%es:(%rdi)
    4d38:	aa                   	stos   %al,%es:(%rdi)
    4d39:	aa                   	stos   %al,%es:(%rdi)
    4d3a:	aa                   	stos   %al,%es:(%rdi)
    4d3b:	aa                   	stos   %al,%es:(%rdi)
    4d3c:	aa                   	stos   %al,%es:(%rdi)
    4d3d:	aa                   	stos   %al,%es:(%rdi)
    4d3e:	aa                   	stos   %al,%es:(%rdi)
    4d3f:	aa                   	stos   %al,%es:(%rdi)
    4d40:	aa                   	stos   %al,%es:(%rdi)
    4d41:	aa                   	stos   %al,%es:(%rdi)
    4d42:	aa                   	stos   %al,%es:(%rdi)
    4d43:	aa                   	stos   %al,%es:(%rdi)
    4d44:	aa                   	stos   %al,%es:(%rdi)
    4d45:	aa                   	stos   %al,%es:(%rdi)
    4d46:	aa                   	stos   %al,%es:(%rdi)
    4d47:	aa                   	stos   %al,%es:(%rdi)
    4d48:	aa                   	stos   %al,%es:(%rdi)
    4d49:	aa                   	stos   %al,%es:(%rdi)
    4d4a:	aa                   	stos   %al,%es:(%rdi)
    4d4b:	aa                   	stos   %al,%es:(%rdi)
    4d4c:	aa                   	stos   %al,%es:(%rdi)
    4d4d:	aa                   	stos   %al,%es:(%rdi)
    4d4e:	aa                   	stos   %al,%es:(%rdi)
    4d4f:	aa                   	stos   %al,%es:(%rdi)
    4d50:	aa                   	stos   %al,%es:(%rdi)
    4d51:	aa                   	stos   %al,%es:(%rdi)
    4d52:	aa                   	stos   %al,%es:(%rdi)
    4d53:	aa                   	stos   %al,%es:(%rdi)
    4d54:	aa                   	stos   %al,%es:(%rdi)
    4d55:	aa                   	stos   %al,%es:(%rdi)
    4d56:	aa                   	stos   %al,%es:(%rdi)
    4d57:	aa                   	stos   %al,%es:(%rdi)
    4d58:	aa                   	stos   %al,%es:(%rdi)
    4d59:	aa                   	stos   %al,%es:(%rdi)
    4d5a:	aa                   	stos   %al,%es:(%rdi)
    4d5b:	aa                   	stos   %al,%es:(%rdi)
    4d5c:	aa                   	stos   %al,%es:(%rdi)
    4d5d:	aa                   	stos   %al,%es:(%rdi)
    4d5e:	aa                   	stos   %al,%es:(%rdi)
    4d5f:	aa                   	stos   %al,%es:(%rdi)
    4d60:	aa                   	stos   %al,%es:(%rdi)
    4d61:	aa                   	stos   %al,%es:(%rdi)
    4d62:	aa                   	stos   %al,%es:(%rdi)
    4d63:	aa                   	stos   %al,%es:(%rdi)
    4d64:	aa                   	stos   %al,%es:(%rdi)
    4d65:	aa                   	stos   %al,%es:(%rdi)
    4d66:	aa                   	stos   %al,%es:(%rdi)
    4d67:	aa                   	stos   %al,%es:(%rdi)
    4d68:	aa                   	stos   %al,%es:(%rdi)
    4d69:	aa                   	stos   %al,%es:(%rdi)
    4d6a:	aa                   	stos   %al,%es:(%rdi)
    4d6b:	aa                   	stos   %al,%es:(%rdi)
    4d6c:	aa                   	stos   %al,%es:(%rdi)
    4d6d:	aa                   	stos   %al,%es:(%rdi)
    4d6e:	aa                   	stos   %al,%es:(%rdi)
    4d6f:	aa                   	stos   %al,%es:(%rdi)
    4d70:	aa                   	stos   %al,%es:(%rdi)
    4d71:	aa                   	stos   %al,%es:(%rdi)
    4d72:	aa                   	stos   %al,%es:(%rdi)
    4d73:	aa                   	stos   %al,%es:(%rdi)
    4d74:	aa                   	stos   %al,%es:(%rdi)
    4d75:	aa                   	stos   %al,%es:(%rdi)
    4d76:	aa                   	stos   %al,%es:(%rdi)
    4d77:	aa                   	stos   %al,%es:(%rdi)
    4d78:	aa                   	stos   %al,%es:(%rdi)
    4d79:	aa                   	stos   %al,%es:(%rdi)
    4d7a:	aa                   	stos   %al,%es:(%rdi)
    4d7b:	aa                   	stos   %al,%es:(%rdi)
    4d7c:	aa                   	stos   %al,%es:(%rdi)
    4d7d:	aa                   	stos   %al,%es:(%rdi)
    4d7e:	aa                   	stos   %al,%es:(%rdi)
    4d7f:	aa                   	stos   %al,%es:(%rdi)
    4d80:	aa                   	stos   %al,%es:(%rdi)
    4d81:	aa                   	stos   %al,%es:(%rdi)
    4d82:	aa                   	stos   %al,%es:(%rdi)
    4d83:	aa                   	stos   %al,%es:(%rdi)
    4d84:	aa                   	stos   %al,%es:(%rdi)
    4d85:	aa                   	stos   %al,%es:(%rdi)
    4d86:	aa                   	stos   %al,%es:(%rdi)
    4d87:	aa                   	stos   %al,%es:(%rdi)
    4d88:	aa                   	stos   %al,%es:(%rdi)
    4d89:	aa                   	stos   %al,%es:(%rdi)
    4d8a:	aa                   	stos   %al,%es:(%rdi)
    4d8b:	aa                   	stos   %al,%es:(%rdi)
    4d8c:	aa                   	stos   %al,%es:(%rdi)
    4d8d:	aa                   	stos   %al,%es:(%rdi)
    4d8e:	aa                   	stos   %al,%es:(%rdi)
    4d8f:	aa                   	stos   %al,%es:(%rdi)
    4d90:	aa                   	stos   %al,%es:(%rdi)
    4d91:	aa                   	stos   %al,%es:(%rdi)
    4d92:	aa                   	stos   %al,%es:(%rdi)
    4d93:	aa                   	stos   %al,%es:(%rdi)
    4d94:	aa                   	stos   %al,%es:(%rdi)
    4d95:	aa                   	stos   %al,%es:(%rdi)
    4d96:	aa                   	stos   %al,%es:(%rdi)
    4d97:	aa                   	stos   %al,%es:(%rdi)
    4d98:	aa                   	stos   %al,%es:(%rdi)
    4d99:	aa                   	stos   %al,%es:(%rdi)
    4d9a:	aa                   	stos   %al,%es:(%rdi)
    4d9b:	aa                   	stos   %al,%es:(%rdi)
    4d9c:	aa                   	stos   %al,%es:(%rdi)
    4d9d:	aa                   	stos   %al,%es:(%rdi)
    4d9e:	aa                   	stos   %al,%es:(%rdi)
    4d9f:	aa                   	stos   %al,%es:(%rdi)
    4da0:	aa                   	stos   %al,%es:(%rdi)
    4da1:	aa                   	stos   %al,%es:(%rdi)
    4da2:	aa                   	stos   %al,%es:(%rdi)
    4da3:	aa                   	stos   %al,%es:(%rdi)
    4da4:	aa                   	stos   %al,%es:(%rdi)
    4da5:	aa                   	stos   %al,%es:(%rdi)
    4da6:	aa                   	stos   %al,%es:(%rdi)
    4da7:	aa                   	stos   %al,%es:(%rdi)
    4da8:	aa                   	stos   %al,%es:(%rdi)
    4da9:	aa                   	stos   %al,%es:(%rdi)
    4daa:	aa                   	stos   %al,%es:(%rdi)
    4dab:	aa                   	stos   %al,%es:(%rdi)
    4dac:	aa                   	stos   %al,%es:(%rdi)
    4dad:	aa                   	stos   %al,%es:(%rdi)
    4dae:	aa                   	stos   %al,%es:(%rdi)
    4daf:	aa                   	stos   %al,%es:(%rdi)
    4db0:	aa                   	stos   %al,%es:(%rdi)
    4db1:	aa                   	stos   %al,%es:(%rdi)
    4db2:	aa                   	stos   %al,%es:(%rdi)
    4db3:	aa                   	stos   %al,%es:(%rdi)
    4db4:	aa                   	stos   %al,%es:(%rdi)
    4db5:	aa                   	stos   %al,%es:(%rdi)
    4db6:	aa                   	stos   %al,%es:(%rdi)
    4db7:	aa                   	stos   %al,%es:(%rdi)
    4db8:	aa                   	stos   %al,%es:(%rdi)
    4db9:	aa                   	stos   %al,%es:(%rdi)
    4dba:	aa                   	stos   %al,%es:(%rdi)
    4dbb:	aa                   	stos   %al,%es:(%rdi)
    4dbc:	aa                   	stos   %al,%es:(%rdi)
    4dbd:	aa                   	stos   %al,%es:(%rdi)
    4dbe:	aa                   	stos   %al,%es:(%rdi)
    4dbf:	aa                   	stos   %al,%es:(%rdi)
    4dc0:	aa                   	stos   %al,%es:(%rdi)
    4dc1:	aa                   	stos   %al,%es:(%rdi)
    4dc2:	aa                   	stos   %al,%es:(%rdi)
    4dc3:	aa                   	stos   %al,%es:(%rdi)
    4dc4:	aa                   	stos   %al,%es:(%rdi)
    4dc5:	aa                   	stos   %al,%es:(%rdi)
    4dc6:	aa                   	stos   %al,%es:(%rdi)
    4dc7:	aa                   	stos   %al,%es:(%rdi)
    4dc8:	aa                   	stos   %al,%es:(%rdi)
    4dc9:	aa                   	stos   %al,%es:(%rdi)
    4dca:	aa                   	stos   %al,%es:(%rdi)
    4dcb:	aa                   	stos   %al,%es:(%rdi)
    4dcc:	aa                   	stos   %al,%es:(%rdi)
    4dcd:	aa                   	stos   %al,%es:(%rdi)
    4dce:	aa                   	stos   %al,%es:(%rdi)
    4dcf:	aa                   	stos   %al,%es:(%rdi)
    4dd0:	aa                   	stos   %al,%es:(%rdi)
    4dd1:	aa                   	stos   %al,%es:(%rdi)
    4dd2:	aa                   	stos   %al,%es:(%rdi)
    4dd3:	aa                   	stos   %al,%es:(%rdi)
    4dd4:	aa                   	stos   %al,%es:(%rdi)
    4dd5:	aa                   	stos   %al,%es:(%rdi)
    4dd6:	aa                   	stos   %al,%es:(%rdi)
    4dd7:	aa                   	stos   %al,%es:(%rdi)
    4dd8:	aa                   	stos   %al,%es:(%rdi)
    4dd9:	aa                   	stos   %al,%es:(%rdi)
    4dda:	aa                   	stos   %al,%es:(%rdi)
    4ddb:	aa                   	stos   %al,%es:(%rdi)
    4ddc:	aa                   	stos   %al,%es:(%rdi)
    4ddd:	aa                   	stos   %al,%es:(%rdi)
    4dde:	aa                   	stos   %al,%es:(%rdi)
    4ddf:	aa                   	stos   %al,%es:(%rdi)
    4de0:	aa                   	stos   %al,%es:(%rdi)
    4de1:	aa                   	stos   %al,%es:(%rdi)
    4de2:	aa                   	stos   %al,%es:(%rdi)
    4de3:	aa                   	stos   %al,%es:(%rdi)
    4de4:	aa                   	stos   %al,%es:(%rdi)
    4de5:	aa                   	stos   %al,%es:(%rdi)
    4de6:	aa                   	stos   %al,%es:(%rdi)
    4de7:	aa                   	stos   %al,%es:(%rdi)
    4de8:	aa                   	stos   %al,%es:(%rdi)
    4de9:	aa                   	stos   %al,%es:(%rdi)
    4dea:	aa                   	stos   %al,%es:(%rdi)
    4deb:	aa                   	stos   %al,%es:(%rdi)
    4dec:	aa                   	stos   %al,%es:(%rdi)
    4ded:	aa                   	stos   %al,%es:(%rdi)
    4dee:	aa                   	stos   %al,%es:(%rdi)
    4def:	aa                   	stos   %al,%es:(%rdi)
    4df0:	aa                   	stos   %al,%es:(%rdi)
    4df1:	aa                   	stos   %al,%es:(%rdi)
    4df2:	aa                   	stos   %al,%es:(%rdi)
    4df3:	aa                   	stos   %al,%es:(%rdi)
    4df4:	aa                   	stos   %al,%es:(%rdi)
    4df5:	aa                   	stos   %al,%es:(%rdi)
    4df6:	aa                   	stos   %al,%es:(%rdi)
    4df7:	aa                   	stos   %al,%es:(%rdi)
    4df8:	aa                   	stos   %al,%es:(%rdi)
    4df9:	aa                   	stos   %al,%es:(%rdi)
    4dfa:	aa                   	stos   %al,%es:(%rdi)
    4dfb:	aa                   	stos   %al,%es:(%rdi)
    4dfc:	aa                   	stos   %al,%es:(%rdi)
    4dfd:	aa                   	stos   %al,%es:(%rdi)
    4dfe:	aa                   	stos   %al,%es:(%rdi)
    4dff:	aa                   	stos   %al,%es:(%rdi)
    4e00:	aa                   	stos   %al,%es:(%rdi)
    4e01:	aa                   	stos   %al,%es:(%rdi)
    4e02:	aa                   	stos   %al,%es:(%rdi)
    4e03:	aa                   	stos   %al,%es:(%rdi)
    4e04:	aa                   	stos   %al,%es:(%rdi)
    4e05:	aa                   	stos   %al,%es:(%rdi)
    4e06:	aa                   	stos   %al,%es:(%rdi)
    4e07:	aa                   	stos   %al,%es:(%rdi)
    4e08:	aa                   	stos   %al,%es:(%rdi)
    4e09:	aa                   	stos   %al,%es:(%rdi)
    4e0a:	aa                   	stos   %al,%es:(%rdi)
    4e0b:	aa                   	stos   %al,%es:(%rdi)
    4e0c:	aa                   	stos   %al,%es:(%rdi)
    4e0d:	aa                   	stos   %al,%es:(%rdi)
    4e0e:	aa                   	stos   %al,%es:(%rdi)
    4e0f:	aa                   	stos   %al,%es:(%rdi)
    4e10:	aa                   	stos   %al,%es:(%rdi)
    4e11:	aa                   	stos   %al,%es:(%rdi)
    4e12:	aa                   	stos   %al,%es:(%rdi)
    4e13:	aa                   	stos   %al,%es:(%rdi)
    4e14:	aa                   	stos   %al,%es:(%rdi)
    4e15:	aa                   	stos   %al,%es:(%rdi)
    4e16:	aa                   	stos   %al,%es:(%rdi)
    4e17:	aa                   	stos   %al,%es:(%rdi)
    4e18:	aa                   	stos   %al,%es:(%rdi)
    4e19:	aa                   	stos   %al,%es:(%rdi)
    4e1a:	aa                   	stos   %al,%es:(%rdi)
    4e1b:	aa                   	stos   %al,%es:(%rdi)
    4e1c:	aa                   	stos   %al,%es:(%rdi)
    4e1d:	aa                   	stos   %al,%es:(%rdi)
    4e1e:	aa                   	stos   %al,%es:(%rdi)
    4e1f:	aa                   	stos   %al,%es:(%rdi)
    4e20:	aa                   	stos   %al,%es:(%rdi)
    4e21:	aa                   	stos   %al,%es:(%rdi)
    4e22:	aa                   	stos   %al,%es:(%rdi)
    4e23:	aa                   	stos   %al,%es:(%rdi)
    4e24:	aa                   	stos   %al,%es:(%rdi)
    4e25:	aa                   	stos   %al,%es:(%rdi)
    4e26:	aa                   	stos   %al,%es:(%rdi)
    4e27:	aa                   	stos   %al,%es:(%rdi)
    4e28:	aa                   	stos   %al,%es:(%rdi)
    4e29:	aa                   	stos   %al,%es:(%rdi)
    4e2a:	aa                   	stos   %al,%es:(%rdi)
    4e2b:	aa                   	stos   %al,%es:(%rdi)
    4e2c:	aa                   	stos   %al,%es:(%rdi)
    4e2d:	aa                   	stos   %al,%es:(%rdi)
    4e2e:	aa                   	stos   %al,%es:(%rdi)
    4e2f:	aa                   	stos   %al,%es:(%rdi)
    4e30:	aa                   	stos   %al,%es:(%rdi)
    4e31:	aa                   	stos   %al,%es:(%rdi)
    4e32:	aa                   	stos   %al,%es:(%rdi)
    4e33:	aa                   	stos   %al,%es:(%rdi)
    4e34:	aa                   	stos   %al,%es:(%rdi)
    4e35:	aa                   	stos   %al,%es:(%rdi)
    4e36:	aa                   	stos   %al,%es:(%rdi)
    4e37:	aa                   	stos   %al,%es:(%rdi)
    4e38:	aa                   	stos   %al,%es:(%rdi)
    4e39:	aa                   	stos   %al,%es:(%rdi)
    4e3a:	aa                   	stos   %al,%es:(%rdi)
    4e3b:	aa                   	stos   %al,%es:(%rdi)
    4e3c:	aa                   	stos   %al,%es:(%rdi)
    4e3d:	aa                   	stos   %al,%es:(%rdi)
    4e3e:	aa                   	stos   %al,%es:(%rdi)
    4e3f:	aa                   	stos   %al,%es:(%rdi)
    4e40:	aa                   	stos   %al,%es:(%rdi)
    4e41:	aa                   	stos   %al,%es:(%rdi)
    4e42:	aa                   	stos   %al,%es:(%rdi)
    4e43:	aa                   	stos   %al,%es:(%rdi)
    4e44:	aa                   	stos   %al,%es:(%rdi)
    4e45:	aa                   	stos   %al,%es:(%rdi)
    4e46:	aa                   	stos   %al,%es:(%rdi)
    4e47:	aa                   	stos   %al,%es:(%rdi)
    4e48:	aa                   	stos   %al,%es:(%rdi)
    4e49:	aa                   	stos   %al,%es:(%rdi)
    4e4a:	aa                   	stos   %al,%es:(%rdi)
    4e4b:	aa                   	stos   %al,%es:(%rdi)
    4e4c:	aa                   	stos   %al,%es:(%rdi)
    4e4d:	aa                   	stos   %al,%es:(%rdi)
    4e4e:	aa                   	stos   %al,%es:(%rdi)
    4e4f:	aa                   	stos   %al,%es:(%rdi)
    4e50:	aa                   	stos   %al,%es:(%rdi)
    4e51:	aa                   	stos   %al,%es:(%rdi)
    4e52:	aa                   	stos   %al,%es:(%rdi)
    4e53:	aa                   	stos   %al,%es:(%rdi)
    4e54:	aa                   	stos   %al,%es:(%rdi)
    4e55:	aa                   	stos   %al,%es:(%rdi)
    4e56:	aa                   	stos   %al,%es:(%rdi)
    4e57:	aa                   	stos   %al,%es:(%rdi)
    4e58:	aa                   	stos   %al,%es:(%rdi)
    4e59:	aa                   	stos   %al,%es:(%rdi)
    4e5a:	aa                   	stos   %al,%es:(%rdi)
    4e5b:	aa                   	stos   %al,%es:(%rdi)
    4e5c:	aa                   	stos   %al,%es:(%rdi)
    4e5d:	aa                   	stos   %al,%es:(%rdi)
    4e5e:	aa                   	stos   %al,%es:(%rdi)
    4e5f:	aa                   	stos   %al,%es:(%rdi)
    4e60:	aa                   	stos   %al,%es:(%rdi)
    4e61:	aa                   	stos   %al,%es:(%rdi)
    4e62:	aa                   	stos   %al,%es:(%rdi)
    4e63:	aa                   	stos   %al,%es:(%rdi)
    4e64:	aa                   	stos   %al,%es:(%rdi)
    4e65:	aa                   	stos   %al,%es:(%rdi)
    4e66:	aa                   	stos   %al,%es:(%rdi)
    4e67:	aa                   	stos   %al,%es:(%rdi)
    4e68:	aa                   	stos   %al,%es:(%rdi)
    4e69:	aa                   	stos   %al,%es:(%rdi)
    4e6a:	aa                   	stos   %al,%es:(%rdi)
    4e6b:	aa                   	stos   %al,%es:(%rdi)
    4e6c:	aa                   	stos   %al,%es:(%rdi)
    4e6d:	aa                   	stos   %al,%es:(%rdi)
    4e6e:	aa                   	stos   %al,%es:(%rdi)
    4e6f:	aa                   	stos   %al,%es:(%rdi)
    4e70:	aa                   	stos   %al,%es:(%rdi)
    4e71:	aa                   	stos   %al,%es:(%rdi)
    4e72:	aa                   	stos   %al,%es:(%rdi)
    4e73:	aa                   	stos   %al,%es:(%rdi)
    4e74:	aa                   	stos   %al,%es:(%rdi)
    4e75:	aa                   	stos   %al,%es:(%rdi)
    4e76:	aa                   	stos   %al,%es:(%rdi)
    4e77:	aa                   	stos   %al,%es:(%rdi)
    4e78:	aa                   	stos   %al,%es:(%rdi)
    4e79:	aa                   	stos   %al,%es:(%rdi)
    4e7a:	aa                   	stos   %al,%es:(%rdi)
    4e7b:	aa                   	stos   %al,%es:(%rdi)
    4e7c:	aa                   	stos   %al,%es:(%rdi)
    4e7d:	aa                   	stos   %al,%es:(%rdi)
    4e7e:	aa                   	stos   %al,%es:(%rdi)
    4e7f:	aa                   	stos   %al,%es:(%rdi)
    4e80:	aa                   	stos   %al,%es:(%rdi)
    4e81:	aa                   	stos   %al,%es:(%rdi)
    4e82:	aa                   	stos   %al,%es:(%rdi)
    4e83:	aa                   	stos   %al,%es:(%rdi)
    4e84:	aa                   	stos   %al,%es:(%rdi)
    4e85:	aa                   	stos   %al,%es:(%rdi)
    4e86:	aa                   	stos   %al,%es:(%rdi)
    4e87:	aa                   	stos   %al,%es:(%rdi)
    4e88:	aa                   	stos   %al,%es:(%rdi)
    4e89:	aa                   	stos   %al,%es:(%rdi)
    4e8a:	aa                   	stos   %al,%es:(%rdi)
    4e8b:	aa                   	stos   %al,%es:(%rdi)
    4e8c:	aa                   	stos   %al,%es:(%rdi)
    4e8d:	aa                   	stos   %al,%es:(%rdi)
    4e8e:	aa                   	stos   %al,%es:(%rdi)
    4e8f:	aa                   	stos   %al,%es:(%rdi)
    4e90:	aa                   	stos   %al,%es:(%rdi)
    4e91:	aa                   	stos   %al,%es:(%rdi)
    4e92:	aa                   	stos   %al,%es:(%rdi)
    4e93:	aa                   	stos   %al,%es:(%rdi)
    4e94:	aa                   	stos   %al,%es:(%rdi)
    4e95:	aa                   	stos   %al,%es:(%rdi)
    4e96:	aa                   	stos   %al,%es:(%rdi)
    4e97:	aa                   	stos   %al,%es:(%rdi)
    4e98:	aa                   	stos   %al,%es:(%rdi)
    4e99:	aa                   	stos   %al,%es:(%rdi)
    4e9a:	aa                   	stos   %al,%es:(%rdi)
    4e9b:	aa                   	stos   %al,%es:(%rdi)
    4e9c:	aa                   	stos   %al,%es:(%rdi)
    4e9d:	aa                   	stos   %al,%es:(%rdi)
    4e9e:	aa                   	stos   %al,%es:(%rdi)
    4e9f:	aa                   	stos   %al,%es:(%rdi)
    4ea0:	aa                   	stos   %al,%es:(%rdi)
    4ea1:	aa                   	stos   %al,%es:(%rdi)
    4ea2:	aa                   	stos   %al,%es:(%rdi)
    4ea3:	aa                   	stos   %al,%es:(%rdi)
    4ea4:	aa                   	stos   %al,%es:(%rdi)
    4ea5:	aa                   	stos   %al,%es:(%rdi)
    4ea6:	aa                   	stos   %al,%es:(%rdi)
    4ea7:	aa                   	stos   %al,%es:(%rdi)
    4ea8:	aa                   	stos   %al,%es:(%rdi)
    4ea9:	aa                   	stos   %al,%es:(%rdi)
    4eaa:	aa                   	stos   %al,%es:(%rdi)
    4eab:	aa                   	stos   %al,%es:(%rdi)
    4eac:	aa                   	stos   %al,%es:(%rdi)
    4ead:	aa                   	stos   %al,%es:(%rdi)
    4eae:	aa                   	stos   %al,%es:(%rdi)
    4eaf:	aa                   	stos   %al,%es:(%rdi)
    4eb0:	aa                   	stos   %al,%es:(%rdi)
    4eb1:	aa                   	stos   %al,%es:(%rdi)
    4eb2:	aa                   	stos   %al,%es:(%rdi)
    4eb3:	aa                   	stos   %al,%es:(%rdi)
    4eb4:	aa                   	stos   %al,%es:(%rdi)
    4eb5:	aa                   	stos   %al,%es:(%rdi)
    4eb6:	aa                   	stos   %al,%es:(%rdi)
    4eb7:	aa                   	stos   %al,%es:(%rdi)
    4eb8:	aa                   	stos   %al,%es:(%rdi)
    4eb9:	aa                   	stos   %al,%es:(%rdi)
    4eba:	aa                   	stos   %al,%es:(%rdi)
    4ebb:	aa                   	stos   %al,%es:(%rdi)
    4ebc:	aa                   	stos   %al,%es:(%rdi)
    4ebd:	aa                   	stos   %al,%es:(%rdi)
    4ebe:	aa                   	stos   %al,%es:(%rdi)
    4ebf:	aa                   	stos   %al,%es:(%rdi)
    4ec0:	aa                   	stos   %al,%es:(%rdi)
    4ec1:	aa                   	stos   %al,%es:(%rdi)
    4ec2:	aa                   	stos   %al,%es:(%rdi)
    4ec3:	aa                   	stos   %al,%es:(%rdi)
    4ec4:	aa                   	stos   %al,%es:(%rdi)
    4ec5:	aa                   	stos   %al,%es:(%rdi)
    4ec6:	aa                   	stos   %al,%es:(%rdi)
    4ec7:	aa                   	stos   %al,%es:(%rdi)
    4ec8:	aa                   	stos   %al,%es:(%rdi)
    4ec9:	aa                   	stos   %al,%es:(%rdi)
    4eca:	aa                   	stos   %al,%es:(%rdi)
    4ecb:	aa                   	stos   %al,%es:(%rdi)
    4ecc:	aa                   	stos   %al,%es:(%rdi)
    4ecd:	aa                   	stos   %al,%es:(%rdi)
    4ece:	aa                   	stos   %al,%es:(%rdi)
    4ecf:	aa                   	stos   %al,%es:(%rdi)
    4ed0:	aa                   	stos   %al,%es:(%rdi)
    4ed1:	aa                   	stos   %al,%es:(%rdi)
    4ed2:	aa                   	stos   %al,%es:(%rdi)
    4ed3:	aa                   	stos   %al,%es:(%rdi)
    4ed4:	aa                   	stos   %al,%es:(%rdi)
    4ed5:	aa                   	stos   %al,%es:(%rdi)
    4ed6:	aa                   	stos   %al,%es:(%rdi)
    4ed7:	aa                   	stos   %al,%es:(%rdi)
    4ed8:	aa                   	stos   %al,%es:(%rdi)
    4ed9:	aa                   	stos   %al,%es:(%rdi)
    4eda:	aa                   	stos   %al,%es:(%rdi)
    4edb:	aa                   	stos   %al,%es:(%rdi)
    4edc:	aa                   	stos   %al,%es:(%rdi)
    4edd:	aa                   	stos   %al,%es:(%rdi)
    4ede:	aa                   	stos   %al,%es:(%rdi)
    4edf:	aa                   	stos   %al,%es:(%rdi)
    4ee0:	aa                   	stos   %al,%es:(%rdi)
    4ee1:	aa                   	stos   %al,%es:(%rdi)
    4ee2:	aa                   	stos   %al,%es:(%rdi)
    4ee3:	aa                   	stos   %al,%es:(%rdi)
    4ee4:	aa                   	stos   %al,%es:(%rdi)
    4ee5:	aa                   	stos   %al,%es:(%rdi)
    4ee6:	aa                   	stos   %al,%es:(%rdi)
    4ee7:	aa                   	stos   %al,%es:(%rdi)
    4ee8:	aa                   	stos   %al,%es:(%rdi)
    4ee9:	aa                   	stos   %al,%es:(%rdi)
    4eea:	aa                   	stos   %al,%es:(%rdi)
    4eeb:	aa                   	stos   %al,%es:(%rdi)
    4eec:	aa                   	stos   %al,%es:(%rdi)
    4eed:	aa                   	stos   %al,%es:(%rdi)
    4eee:	aa                   	stos   %al,%es:(%rdi)
    4eef:	aa                   	stos   %al,%es:(%rdi)
    4ef0:	aa                   	stos   %al,%es:(%rdi)
    4ef1:	aa                   	stos   %al,%es:(%rdi)
    4ef2:	aa                   	stos   %al,%es:(%rdi)
    4ef3:	aa                   	stos   %al,%es:(%rdi)
    4ef4:	aa                   	stos   %al,%es:(%rdi)
    4ef5:	aa                   	stos   %al,%es:(%rdi)
    4ef6:	aa                   	stos   %al,%es:(%rdi)
    4ef7:	aa                   	stos   %al,%es:(%rdi)
    4ef8:	aa                   	stos   %al,%es:(%rdi)
    4ef9:	aa                   	stos   %al,%es:(%rdi)
    4efa:	aa                   	stos   %al,%es:(%rdi)
    4efb:	aa                   	stos   %al,%es:(%rdi)
    4efc:	aa                   	stos   %al,%es:(%rdi)
    4efd:	aa                   	stos   %al,%es:(%rdi)
    4efe:	aa                   	stos   %al,%es:(%rdi)
    4eff:	aa                   	stos   %al,%es:(%rdi)
    4f00:	aa                   	stos   %al,%es:(%rdi)
    4f01:	aa                   	stos   %al,%es:(%rdi)
    4f02:	aa                   	stos   %al,%es:(%rdi)
    4f03:	aa                   	stos   %al,%es:(%rdi)
    4f04:	aa                   	stos   %al,%es:(%rdi)
    4f05:	aa                   	stos   %al,%es:(%rdi)
    4f06:	aa                   	stos   %al,%es:(%rdi)
    4f07:	aa                   	stos   %al,%es:(%rdi)
    4f08:	aa                   	stos   %al,%es:(%rdi)
    4f09:	aa                   	stos   %al,%es:(%rdi)
    4f0a:	aa                   	stos   %al,%es:(%rdi)
    4f0b:	aa                   	stos   %al,%es:(%rdi)
    4f0c:	aa                   	stos   %al,%es:(%rdi)
    4f0d:	aa                   	stos   %al,%es:(%rdi)
    4f0e:	aa                   	stos   %al,%es:(%rdi)
    4f0f:	aa                   	stos   %al,%es:(%rdi)
    4f10:	aa                   	stos   %al,%es:(%rdi)
    4f11:	aa                   	stos   %al,%es:(%rdi)
    4f12:	aa                   	stos   %al,%es:(%rdi)
    4f13:	aa                   	stos   %al,%es:(%rdi)
    4f14:	aa                   	stos   %al,%es:(%rdi)
    4f15:	aa                   	stos   %al,%es:(%rdi)
    4f16:	aa                   	stos   %al,%es:(%rdi)
    4f17:	aa                   	stos   %al,%es:(%rdi)
    4f18:	aa                   	stos   %al,%es:(%rdi)
    4f19:	aa                   	stos   %al,%es:(%rdi)
    4f1a:	aa                   	stos   %al,%es:(%rdi)
    4f1b:	aa                   	stos   %al,%es:(%rdi)
    4f1c:	aa                   	stos   %al,%es:(%rdi)
    4f1d:	aa                   	stos   %al,%es:(%rdi)
    4f1e:	aa                   	stos   %al,%es:(%rdi)
    4f1f:	aa                   	stos   %al,%es:(%rdi)
    4f20:	aa                   	stos   %al,%es:(%rdi)
    4f21:	aa                   	stos   %al,%es:(%rdi)
    4f22:	aa                   	stos   %al,%es:(%rdi)
    4f23:	aa                   	stos   %al,%es:(%rdi)
    4f24:	aa                   	stos   %al,%es:(%rdi)
    4f25:	aa                   	stos   %al,%es:(%rdi)
    4f26:	aa                   	stos   %al,%es:(%rdi)
    4f27:	aa                   	stos   %al,%es:(%rdi)
    4f28:	aa                   	stos   %al,%es:(%rdi)
    4f29:	aa                   	stos   %al,%es:(%rdi)
    4f2a:	aa                   	stos   %al,%es:(%rdi)
    4f2b:	aa                   	stos   %al,%es:(%rdi)
    4f2c:	aa                   	stos   %al,%es:(%rdi)
    4f2d:	aa                   	stos   %al,%es:(%rdi)
    4f2e:	aa                   	stos   %al,%es:(%rdi)
    4f2f:	aa                   	stos   %al,%es:(%rdi)
    4f30:	aa                   	stos   %al,%es:(%rdi)
    4f31:	aa                   	stos   %al,%es:(%rdi)
    4f32:	aa                   	stos   %al,%es:(%rdi)
    4f33:	aa                   	stos   %al,%es:(%rdi)
    4f34:	aa                   	stos   %al,%es:(%rdi)
    4f35:	aa                   	stos   %al,%es:(%rdi)
    4f36:	aa                   	stos   %al,%es:(%rdi)
    4f37:	aa                   	stos   %al,%es:(%rdi)
    4f38:	aa                   	stos   %al,%es:(%rdi)
    4f39:	aa                   	stos   %al,%es:(%rdi)
    4f3a:	aa                   	stos   %al,%es:(%rdi)
    4f3b:	aa                   	stos   %al,%es:(%rdi)
    4f3c:	aa                   	stos   %al,%es:(%rdi)
    4f3d:	aa                   	stos   %al,%es:(%rdi)
    4f3e:	aa                   	stos   %al,%es:(%rdi)
    4f3f:	aa                   	stos   %al,%es:(%rdi)
    4f40:	aa                   	stos   %al,%es:(%rdi)
    4f41:	aa                   	stos   %al,%es:(%rdi)
    4f42:	aa                   	stos   %al,%es:(%rdi)
    4f43:	aa                   	stos   %al,%es:(%rdi)
    4f44:	aa                   	stos   %al,%es:(%rdi)
    4f45:	aa                   	stos   %al,%es:(%rdi)
    4f46:	aa                   	stos   %al,%es:(%rdi)
    4f47:	aa                   	stos   %al,%es:(%rdi)
    4f48:	aa                   	stos   %al,%es:(%rdi)
    4f49:	aa                   	stos   %al,%es:(%rdi)
    4f4a:	aa                   	stos   %al,%es:(%rdi)
    4f4b:	aa                   	stos   %al,%es:(%rdi)
    4f4c:	aa                   	stos   %al,%es:(%rdi)
    4f4d:	aa                   	stos   %al,%es:(%rdi)
    4f4e:	aa                   	stos   %al,%es:(%rdi)
    4f4f:	aa                   	stos   %al,%es:(%rdi)
    4f50:	aa                   	stos   %al,%es:(%rdi)
    4f51:	aa                   	stos   %al,%es:(%rdi)
    4f52:	aa                   	stos   %al,%es:(%rdi)
    4f53:	aa                   	stos   %al,%es:(%rdi)
    4f54:	aa                   	stos   %al,%es:(%rdi)
    4f55:	aa                   	stos   %al,%es:(%rdi)
    4f56:	aa                   	stos   %al,%es:(%rdi)
    4f57:	aa                   	stos   %al,%es:(%rdi)
    4f58:	aa                   	stos   %al,%es:(%rdi)
    4f59:	aa                   	stos   %al,%es:(%rdi)
    4f5a:	aa                   	stos   %al,%es:(%rdi)
    4f5b:	aa                   	stos   %al,%es:(%rdi)
    4f5c:	aa                   	stos   %al,%es:(%rdi)
    4f5d:	aa                   	stos   %al,%es:(%rdi)
    4f5e:	aa                   	stos   %al,%es:(%rdi)
    4f5f:	aa                   	stos   %al,%es:(%rdi)
    4f60:	aa                   	stos   %al,%es:(%rdi)
    4f61:	aa                   	stos   %al,%es:(%rdi)
    4f62:	aa                   	stos   %al,%es:(%rdi)
    4f63:	aa                   	stos   %al,%es:(%rdi)
    4f64:	aa                   	stos   %al,%es:(%rdi)
    4f65:	aa                   	stos   %al,%es:(%rdi)
    4f66:	aa                   	stos   %al,%es:(%rdi)
    4f67:	aa                   	stos   %al,%es:(%rdi)
    4f68:	aa                   	stos   %al,%es:(%rdi)
    4f69:	aa                   	stos   %al,%es:(%rdi)
    4f6a:	aa                   	stos   %al,%es:(%rdi)
    4f6b:	aa                   	stos   %al,%es:(%rdi)
    4f6c:	aa                   	stos   %al,%es:(%rdi)
    4f6d:	aa                   	stos   %al,%es:(%rdi)
    4f6e:	aa                   	stos   %al,%es:(%rdi)
    4f6f:	aa                   	stos   %al,%es:(%rdi)
    4f70:	aa                   	stos   %al,%es:(%rdi)
    4f71:	aa                   	stos   %al,%es:(%rdi)
    4f72:	aa                   	stos   %al,%es:(%rdi)
    4f73:	aa                   	stos   %al,%es:(%rdi)
    4f74:	aa                   	stos   %al,%es:(%rdi)
    4f75:	aa                   	stos   %al,%es:(%rdi)
    4f76:	aa                   	stos   %al,%es:(%rdi)
    4f77:	aa                   	stos   %al,%es:(%rdi)
    4f78:	aa                   	stos   %al,%es:(%rdi)
    4f79:	aa                   	stos   %al,%es:(%rdi)
    4f7a:	aa                   	stos   %al,%es:(%rdi)
    4f7b:	aa                   	stos   %al,%es:(%rdi)
    4f7c:	aa                   	stos   %al,%es:(%rdi)
    4f7d:	aa                   	stos   %al,%es:(%rdi)
    4f7e:	aa                   	stos   %al,%es:(%rdi)
    4f7f:	aa                   	stos   %al,%es:(%rdi)
    4f80:	aa                   	stos   %al,%es:(%rdi)
    4f81:	aa                   	stos   %al,%es:(%rdi)
    4f82:	aa                   	stos   %al,%es:(%rdi)
    4f83:	aa                   	stos   %al,%es:(%rdi)
    4f84:	aa                   	stos   %al,%es:(%rdi)
    4f85:	aa                   	stos   %al,%es:(%rdi)
    4f86:	aa                   	stos   %al,%es:(%rdi)
    4f87:	aa                   	stos   %al,%es:(%rdi)
    4f88:	aa                   	stos   %al,%es:(%rdi)
    4f89:	aa                   	stos   %al,%es:(%rdi)
    4f8a:	aa                   	stos   %al,%es:(%rdi)
    4f8b:	aa                   	stos   %al,%es:(%rdi)
    4f8c:	aa                   	stos   %al,%es:(%rdi)
    4f8d:	aa                   	stos   %al,%es:(%rdi)
    4f8e:	aa                   	stos   %al,%es:(%rdi)
    4f8f:	aa                   	stos   %al,%es:(%rdi)
    4f90:	aa                   	stos   %al,%es:(%rdi)
    4f91:	aa                   	stos   %al,%es:(%rdi)
    4f92:	aa                   	stos   %al,%es:(%rdi)
    4f93:	aa                   	stos   %al,%es:(%rdi)
    4f94:	aa                   	stos   %al,%es:(%rdi)
    4f95:	aa                   	stos   %al,%es:(%rdi)
    4f96:	aa                   	stos   %al,%es:(%rdi)
    4f97:	aa                   	stos   %al,%es:(%rdi)
    4f98:	aa                   	stos   %al,%es:(%rdi)
    4f99:	aa                   	stos   %al,%es:(%rdi)
    4f9a:	aa                   	stos   %al,%es:(%rdi)
    4f9b:	aa                   	stos   %al,%es:(%rdi)
    4f9c:	aa                   	stos   %al,%es:(%rdi)
    4f9d:	aa                   	stos   %al,%es:(%rdi)
    4f9e:	aa                   	stos   %al,%es:(%rdi)
    4f9f:	aa                   	stos   %al,%es:(%rdi)
    4fa0:	aa                   	stos   %al,%es:(%rdi)
    4fa1:	aa                   	stos   %al,%es:(%rdi)
    4fa2:	aa                   	stos   %al,%es:(%rdi)
    4fa3:	aa                   	stos   %al,%es:(%rdi)
    4fa4:	aa                   	stos   %al,%es:(%rdi)
    4fa5:	aa                   	stos   %al,%es:(%rdi)
    4fa6:	aa                   	stos   %al,%es:(%rdi)
    4fa7:	aa                   	stos   %al,%es:(%rdi)
    4fa8:	aa                   	stos   %al,%es:(%rdi)
    4fa9:	aa                   	stos   %al,%es:(%rdi)
    4faa:	aa                   	stos   %al,%es:(%rdi)
    4fab:	aa                   	stos   %al,%es:(%rdi)
    4fac:	aa                   	stos   %al,%es:(%rdi)
    4fad:	aa                   	stos   %al,%es:(%rdi)
    4fae:	aa                   	stos   %al,%es:(%rdi)
    4faf:	aa                   	stos   %al,%es:(%rdi)
    4fb0:	aa                   	stos   %al,%es:(%rdi)
    4fb1:	aa                   	stos   %al,%es:(%rdi)
    4fb2:	aa                   	stos   %al,%es:(%rdi)
    4fb3:	aa                   	stos   %al,%es:(%rdi)
    4fb4:	aa                   	stos   %al,%es:(%rdi)
    4fb5:	aa                   	stos   %al,%es:(%rdi)
    4fb6:	aa                   	stos   %al,%es:(%rdi)
    4fb7:	aa                   	stos   %al,%es:(%rdi)
    4fb8:	aa                   	stos   %al,%es:(%rdi)
    4fb9:	aa                   	stos   %al,%es:(%rdi)
    4fba:	aa                   	stos   %al,%es:(%rdi)
    4fbb:	aa                   	stos   %al,%es:(%rdi)
    4fbc:	aa                   	stos   %al,%es:(%rdi)
    4fbd:	aa                   	stos   %al,%es:(%rdi)
    4fbe:	aa                   	stos   %al,%es:(%rdi)
    4fbf:	aa                   	stos   %al,%es:(%rdi)
    4fc0:	aa                   	stos   %al,%es:(%rdi)
    4fc1:	aa                   	stos   %al,%es:(%rdi)
    4fc2:	aa                   	stos   %al,%es:(%rdi)
    4fc3:	aa                   	stos   %al,%es:(%rdi)
    4fc4:	aa                   	stos   %al,%es:(%rdi)
    4fc5:	aa                   	stos   %al,%es:(%rdi)
    4fc6:	aa                   	stos   %al,%es:(%rdi)
    4fc7:	aa                   	stos   %al,%es:(%rdi)
    4fc8:	aa                   	stos   %al,%es:(%rdi)
    4fc9:	aa                   	stos   %al,%es:(%rdi)
    4fca:	aa                   	stos   %al,%es:(%rdi)
    4fcb:	aa                   	stos   %al,%es:(%rdi)
    4fcc:	aa                   	stos   %al,%es:(%rdi)
    4fcd:	aa                   	stos   %al,%es:(%rdi)
    4fce:	aa                   	stos   %al,%es:(%rdi)
    4fcf:	aa                   	stos   %al,%es:(%rdi)
    4fd0:	aa                   	stos   %al,%es:(%rdi)
    4fd1:	aa                   	stos   %al,%es:(%rdi)
    4fd2:	aa                   	stos   %al,%es:(%rdi)
    4fd3:	aa                   	stos   %al,%es:(%rdi)
    4fd4:	aa                   	stos   %al,%es:(%rdi)
    4fd5:	aa                   	stos   %al,%es:(%rdi)
    4fd6:	aa                   	stos   %al,%es:(%rdi)
    4fd7:	aa                   	stos   %al,%es:(%rdi)
    4fd8:	aa                   	stos   %al,%es:(%rdi)
    4fd9:	aa                   	stos   %al,%es:(%rdi)
    4fda:	aa                   	stos   %al,%es:(%rdi)
    4fdb:	aa                   	stos   %al,%es:(%rdi)
    4fdc:	aa                   	stos   %al,%es:(%rdi)
    4fdd:	aa                   	stos   %al,%es:(%rdi)
    4fde:	aa                   	stos   %al,%es:(%rdi)
    4fdf:	aa                   	stos   %al,%es:(%rdi)
    4fe0:	aa                   	stos   %al,%es:(%rdi)
    4fe1:	aa                   	stos   %al,%es:(%rdi)
    4fe2:	aa                   	stos   %al,%es:(%rdi)
    4fe3:	aa                   	stos   %al,%es:(%rdi)
    4fe4:	aa                   	stos   %al,%es:(%rdi)
    4fe5:	aa                   	stos   %al,%es:(%rdi)
    4fe6:	aa                   	stos   %al,%es:(%rdi)
    4fe7:	aa                   	stos   %al,%es:(%rdi)
    4fe8:	aa                   	stos   %al,%es:(%rdi)
    4fe9:	aa                   	stos   %al,%es:(%rdi)
    4fea:	aa                   	stos   %al,%es:(%rdi)
    4feb:	aa                   	stos   %al,%es:(%rdi)
    4fec:	aa                   	stos   %al,%es:(%rdi)
    4fed:	aa                   	stos   %al,%es:(%rdi)
    4fee:	aa                   	stos   %al,%es:(%rdi)
    4fef:	aa                   	stos   %al,%es:(%rdi)
    4ff0:	aa                   	stos   %al,%es:(%rdi)
    4ff1:	aa                   	stos   %al,%es:(%rdi)
    4ff2:	aa                   	stos   %al,%es:(%rdi)
    4ff3:	aa                   	stos   %al,%es:(%rdi)
    4ff4:	aa                   	stos   %al,%es:(%rdi)
    4ff5:	aa                   	stos   %al,%es:(%rdi)
    4ff6:	aa                   	stos   %al,%es:(%rdi)
    4ff7:	aa                   	stos   %al,%es:(%rdi)
    4ff8:	aa                   	stos   %al,%es:(%rdi)
    4ff9:	aa                   	stos   %al,%es:(%rdi)
    4ffa:	aa                   	stos   %al,%es:(%rdi)
    4ffb:	aa                   	stos   %al,%es:(%rdi)
    4ffc:	aa                   	stos   %al,%es:(%rdi)
    4ffd:	aa                   	stos   %al,%es:(%rdi)
    4ffe:	aa                   	stos   %al,%es:(%rdi)
    4fff:	aa                   	stos   %al,%es:(%rdi)

0000000000005000 <z_x86_nmi_stack>:
    5000:	aa                   	stos   %al,%es:(%rdi)
    5001:	aa                   	stos   %al,%es:(%rdi)
    5002:	aa                   	stos   %al,%es:(%rdi)
    5003:	aa                   	stos   %al,%es:(%rdi)
    5004:	aa                   	stos   %al,%es:(%rdi)
    5005:	aa                   	stos   %al,%es:(%rdi)
    5006:	aa                   	stos   %al,%es:(%rdi)
    5007:	aa                   	stos   %al,%es:(%rdi)
    5008:	aa                   	stos   %al,%es:(%rdi)
    5009:	aa                   	stos   %al,%es:(%rdi)
    500a:	aa                   	stos   %al,%es:(%rdi)
    500b:	aa                   	stos   %al,%es:(%rdi)
    500c:	aa                   	stos   %al,%es:(%rdi)
    500d:	aa                   	stos   %al,%es:(%rdi)
    500e:	aa                   	stos   %al,%es:(%rdi)
    500f:	aa                   	stos   %al,%es:(%rdi)
    5010:	aa                   	stos   %al,%es:(%rdi)
    5011:	aa                   	stos   %al,%es:(%rdi)
    5012:	aa                   	stos   %al,%es:(%rdi)
    5013:	aa                   	stos   %al,%es:(%rdi)
    5014:	aa                   	stos   %al,%es:(%rdi)
    5015:	aa                   	stos   %al,%es:(%rdi)
    5016:	aa                   	stos   %al,%es:(%rdi)
    5017:	aa                   	stos   %al,%es:(%rdi)
    5018:	aa                   	stos   %al,%es:(%rdi)
    5019:	aa                   	stos   %al,%es:(%rdi)
    501a:	aa                   	stos   %al,%es:(%rdi)
    501b:	aa                   	stos   %al,%es:(%rdi)
    501c:	aa                   	stos   %al,%es:(%rdi)
    501d:	aa                   	stos   %al,%es:(%rdi)
    501e:	aa                   	stos   %al,%es:(%rdi)
    501f:	aa                   	stos   %al,%es:(%rdi)
    5020:	aa                   	stos   %al,%es:(%rdi)
    5021:	aa                   	stos   %al,%es:(%rdi)
    5022:	aa                   	stos   %al,%es:(%rdi)
    5023:	aa                   	stos   %al,%es:(%rdi)
    5024:	aa                   	stos   %al,%es:(%rdi)
    5025:	aa                   	stos   %al,%es:(%rdi)
    5026:	aa                   	stos   %al,%es:(%rdi)
    5027:	aa                   	stos   %al,%es:(%rdi)
    5028:	aa                   	stos   %al,%es:(%rdi)
    5029:	aa                   	stos   %al,%es:(%rdi)
    502a:	aa                   	stos   %al,%es:(%rdi)
    502b:	aa                   	stos   %al,%es:(%rdi)
    502c:	aa                   	stos   %al,%es:(%rdi)
    502d:	aa                   	stos   %al,%es:(%rdi)
    502e:	aa                   	stos   %al,%es:(%rdi)
    502f:	aa                   	stos   %al,%es:(%rdi)
    5030:	aa                   	stos   %al,%es:(%rdi)
    5031:	aa                   	stos   %al,%es:(%rdi)
    5032:	aa                   	stos   %al,%es:(%rdi)
    5033:	aa                   	stos   %al,%es:(%rdi)
    5034:	aa                   	stos   %al,%es:(%rdi)
    5035:	aa                   	stos   %al,%es:(%rdi)
    5036:	aa                   	stos   %al,%es:(%rdi)
    5037:	aa                   	stos   %al,%es:(%rdi)
    5038:	aa                   	stos   %al,%es:(%rdi)
    5039:	aa                   	stos   %al,%es:(%rdi)
    503a:	aa                   	stos   %al,%es:(%rdi)
    503b:	aa                   	stos   %al,%es:(%rdi)
    503c:	aa                   	stos   %al,%es:(%rdi)
    503d:	aa                   	stos   %al,%es:(%rdi)
    503e:	aa                   	stos   %al,%es:(%rdi)
    503f:	aa                   	stos   %al,%es:(%rdi)
    5040:	aa                   	stos   %al,%es:(%rdi)
    5041:	aa                   	stos   %al,%es:(%rdi)
    5042:	aa                   	stos   %al,%es:(%rdi)
    5043:	aa                   	stos   %al,%es:(%rdi)
    5044:	aa                   	stos   %al,%es:(%rdi)
    5045:	aa                   	stos   %al,%es:(%rdi)
    5046:	aa                   	stos   %al,%es:(%rdi)
    5047:	aa                   	stos   %al,%es:(%rdi)
    5048:	aa                   	stos   %al,%es:(%rdi)
    5049:	aa                   	stos   %al,%es:(%rdi)
    504a:	aa                   	stos   %al,%es:(%rdi)
    504b:	aa                   	stos   %al,%es:(%rdi)
    504c:	aa                   	stos   %al,%es:(%rdi)
    504d:	aa                   	stos   %al,%es:(%rdi)
    504e:	aa                   	stos   %al,%es:(%rdi)
    504f:	aa                   	stos   %al,%es:(%rdi)
    5050:	aa                   	stos   %al,%es:(%rdi)
    5051:	aa                   	stos   %al,%es:(%rdi)
    5052:	aa                   	stos   %al,%es:(%rdi)
    5053:	aa                   	stos   %al,%es:(%rdi)
    5054:	aa                   	stos   %al,%es:(%rdi)
    5055:	aa                   	stos   %al,%es:(%rdi)
    5056:	aa                   	stos   %al,%es:(%rdi)
    5057:	aa                   	stos   %al,%es:(%rdi)
    5058:	aa                   	stos   %al,%es:(%rdi)
    5059:	aa                   	stos   %al,%es:(%rdi)
    505a:	aa                   	stos   %al,%es:(%rdi)
    505b:	aa                   	stos   %al,%es:(%rdi)
    505c:	aa                   	stos   %al,%es:(%rdi)
    505d:	aa                   	stos   %al,%es:(%rdi)
    505e:	aa                   	stos   %al,%es:(%rdi)
    505f:	aa                   	stos   %al,%es:(%rdi)
    5060:	aa                   	stos   %al,%es:(%rdi)
    5061:	aa                   	stos   %al,%es:(%rdi)
    5062:	aa                   	stos   %al,%es:(%rdi)
    5063:	aa                   	stos   %al,%es:(%rdi)
    5064:	aa                   	stos   %al,%es:(%rdi)
    5065:	aa                   	stos   %al,%es:(%rdi)
    5066:	aa                   	stos   %al,%es:(%rdi)
    5067:	aa                   	stos   %al,%es:(%rdi)
    5068:	aa                   	stos   %al,%es:(%rdi)
    5069:	aa                   	stos   %al,%es:(%rdi)
    506a:	aa                   	stos   %al,%es:(%rdi)
    506b:	aa                   	stos   %al,%es:(%rdi)
    506c:	aa                   	stos   %al,%es:(%rdi)
    506d:	aa                   	stos   %al,%es:(%rdi)
    506e:	aa                   	stos   %al,%es:(%rdi)
    506f:	aa                   	stos   %al,%es:(%rdi)
    5070:	aa                   	stos   %al,%es:(%rdi)
    5071:	aa                   	stos   %al,%es:(%rdi)
    5072:	aa                   	stos   %al,%es:(%rdi)
    5073:	aa                   	stos   %al,%es:(%rdi)
    5074:	aa                   	stos   %al,%es:(%rdi)
    5075:	aa                   	stos   %al,%es:(%rdi)
    5076:	aa                   	stos   %al,%es:(%rdi)
    5077:	aa                   	stos   %al,%es:(%rdi)
    5078:	aa                   	stos   %al,%es:(%rdi)
    5079:	aa                   	stos   %al,%es:(%rdi)
    507a:	aa                   	stos   %al,%es:(%rdi)
    507b:	aa                   	stos   %al,%es:(%rdi)
    507c:	aa                   	stos   %al,%es:(%rdi)
    507d:	aa                   	stos   %al,%es:(%rdi)
    507e:	aa                   	stos   %al,%es:(%rdi)
    507f:	aa                   	stos   %al,%es:(%rdi)
    5080:	aa                   	stos   %al,%es:(%rdi)
    5081:	aa                   	stos   %al,%es:(%rdi)
    5082:	aa                   	stos   %al,%es:(%rdi)
    5083:	aa                   	stos   %al,%es:(%rdi)
    5084:	aa                   	stos   %al,%es:(%rdi)
    5085:	aa                   	stos   %al,%es:(%rdi)
    5086:	aa                   	stos   %al,%es:(%rdi)
    5087:	aa                   	stos   %al,%es:(%rdi)
    5088:	aa                   	stos   %al,%es:(%rdi)
    5089:	aa                   	stos   %al,%es:(%rdi)
    508a:	aa                   	stos   %al,%es:(%rdi)
    508b:	aa                   	stos   %al,%es:(%rdi)
    508c:	aa                   	stos   %al,%es:(%rdi)
    508d:	aa                   	stos   %al,%es:(%rdi)
    508e:	aa                   	stos   %al,%es:(%rdi)
    508f:	aa                   	stos   %al,%es:(%rdi)
    5090:	aa                   	stos   %al,%es:(%rdi)
    5091:	aa                   	stos   %al,%es:(%rdi)
    5092:	aa                   	stos   %al,%es:(%rdi)
    5093:	aa                   	stos   %al,%es:(%rdi)
    5094:	aa                   	stos   %al,%es:(%rdi)
    5095:	aa                   	stos   %al,%es:(%rdi)
    5096:	aa                   	stos   %al,%es:(%rdi)
    5097:	aa                   	stos   %al,%es:(%rdi)
    5098:	aa                   	stos   %al,%es:(%rdi)
    5099:	aa                   	stos   %al,%es:(%rdi)
    509a:	aa                   	stos   %al,%es:(%rdi)
    509b:	aa                   	stos   %al,%es:(%rdi)
    509c:	aa                   	stos   %al,%es:(%rdi)
    509d:	aa                   	stos   %al,%es:(%rdi)
    509e:	aa                   	stos   %al,%es:(%rdi)
    509f:	aa                   	stos   %al,%es:(%rdi)
    50a0:	aa                   	stos   %al,%es:(%rdi)
    50a1:	aa                   	stos   %al,%es:(%rdi)
    50a2:	aa                   	stos   %al,%es:(%rdi)
    50a3:	aa                   	stos   %al,%es:(%rdi)
    50a4:	aa                   	stos   %al,%es:(%rdi)
    50a5:	aa                   	stos   %al,%es:(%rdi)
    50a6:	aa                   	stos   %al,%es:(%rdi)
    50a7:	aa                   	stos   %al,%es:(%rdi)
    50a8:	aa                   	stos   %al,%es:(%rdi)
    50a9:	aa                   	stos   %al,%es:(%rdi)
    50aa:	aa                   	stos   %al,%es:(%rdi)
    50ab:	aa                   	stos   %al,%es:(%rdi)
    50ac:	aa                   	stos   %al,%es:(%rdi)
    50ad:	aa                   	stos   %al,%es:(%rdi)
    50ae:	aa                   	stos   %al,%es:(%rdi)
    50af:	aa                   	stos   %al,%es:(%rdi)
    50b0:	aa                   	stos   %al,%es:(%rdi)
    50b1:	aa                   	stos   %al,%es:(%rdi)
    50b2:	aa                   	stos   %al,%es:(%rdi)
    50b3:	aa                   	stos   %al,%es:(%rdi)
    50b4:	aa                   	stos   %al,%es:(%rdi)
    50b5:	aa                   	stos   %al,%es:(%rdi)
    50b6:	aa                   	stos   %al,%es:(%rdi)
    50b7:	aa                   	stos   %al,%es:(%rdi)
    50b8:	aa                   	stos   %al,%es:(%rdi)
    50b9:	aa                   	stos   %al,%es:(%rdi)
    50ba:	aa                   	stos   %al,%es:(%rdi)
    50bb:	aa                   	stos   %al,%es:(%rdi)
    50bc:	aa                   	stos   %al,%es:(%rdi)
    50bd:	aa                   	stos   %al,%es:(%rdi)
    50be:	aa                   	stos   %al,%es:(%rdi)
    50bf:	aa                   	stos   %al,%es:(%rdi)
    50c0:	aa                   	stos   %al,%es:(%rdi)
    50c1:	aa                   	stos   %al,%es:(%rdi)
    50c2:	aa                   	stos   %al,%es:(%rdi)
    50c3:	aa                   	stos   %al,%es:(%rdi)
    50c4:	aa                   	stos   %al,%es:(%rdi)
    50c5:	aa                   	stos   %al,%es:(%rdi)
    50c6:	aa                   	stos   %al,%es:(%rdi)
    50c7:	aa                   	stos   %al,%es:(%rdi)
    50c8:	aa                   	stos   %al,%es:(%rdi)
    50c9:	aa                   	stos   %al,%es:(%rdi)
    50ca:	aa                   	stos   %al,%es:(%rdi)
    50cb:	aa                   	stos   %al,%es:(%rdi)
    50cc:	aa                   	stos   %al,%es:(%rdi)
    50cd:	aa                   	stos   %al,%es:(%rdi)
    50ce:	aa                   	stos   %al,%es:(%rdi)
    50cf:	aa                   	stos   %al,%es:(%rdi)
    50d0:	aa                   	stos   %al,%es:(%rdi)
    50d1:	aa                   	stos   %al,%es:(%rdi)
    50d2:	aa                   	stos   %al,%es:(%rdi)
    50d3:	aa                   	stos   %al,%es:(%rdi)
    50d4:	aa                   	stos   %al,%es:(%rdi)
    50d5:	aa                   	stos   %al,%es:(%rdi)
    50d6:	aa                   	stos   %al,%es:(%rdi)
    50d7:	aa                   	stos   %al,%es:(%rdi)
    50d8:	aa                   	stos   %al,%es:(%rdi)
    50d9:	aa                   	stos   %al,%es:(%rdi)
    50da:	aa                   	stos   %al,%es:(%rdi)
    50db:	aa                   	stos   %al,%es:(%rdi)
    50dc:	aa                   	stos   %al,%es:(%rdi)
    50dd:	aa                   	stos   %al,%es:(%rdi)
    50de:	aa                   	stos   %al,%es:(%rdi)
    50df:	aa                   	stos   %al,%es:(%rdi)
    50e0:	aa                   	stos   %al,%es:(%rdi)
    50e1:	aa                   	stos   %al,%es:(%rdi)
    50e2:	aa                   	stos   %al,%es:(%rdi)
    50e3:	aa                   	stos   %al,%es:(%rdi)
    50e4:	aa                   	stos   %al,%es:(%rdi)
    50e5:	aa                   	stos   %al,%es:(%rdi)
    50e6:	aa                   	stos   %al,%es:(%rdi)
    50e7:	aa                   	stos   %al,%es:(%rdi)
    50e8:	aa                   	stos   %al,%es:(%rdi)
    50e9:	aa                   	stos   %al,%es:(%rdi)
    50ea:	aa                   	stos   %al,%es:(%rdi)
    50eb:	aa                   	stos   %al,%es:(%rdi)
    50ec:	aa                   	stos   %al,%es:(%rdi)
    50ed:	aa                   	stos   %al,%es:(%rdi)
    50ee:	aa                   	stos   %al,%es:(%rdi)
    50ef:	aa                   	stos   %al,%es:(%rdi)
    50f0:	aa                   	stos   %al,%es:(%rdi)
    50f1:	aa                   	stos   %al,%es:(%rdi)
    50f2:	aa                   	stos   %al,%es:(%rdi)
    50f3:	aa                   	stos   %al,%es:(%rdi)
    50f4:	aa                   	stos   %al,%es:(%rdi)
    50f5:	aa                   	stos   %al,%es:(%rdi)
    50f6:	aa                   	stos   %al,%es:(%rdi)
    50f7:	aa                   	stos   %al,%es:(%rdi)
    50f8:	aa                   	stos   %al,%es:(%rdi)
    50f9:	aa                   	stos   %al,%es:(%rdi)
    50fa:	aa                   	stos   %al,%es:(%rdi)
    50fb:	aa                   	stos   %al,%es:(%rdi)
    50fc:	aa                   	stos   %al,%es:(%rdi)
    50fd:	aa                   	stos   %al,%es:(%rdi)
    50fe:	aa                   	stos   %al,%es:(%rdi)
    50ff:	aa                   	stos   %al,%es:(%rdi)
    5100:	aa                   	stos   %al,%es:(%rdi)
    5101:	aa                   	stos   %al,%es:(%rdi)
    5102:	aa                   	stos   %al,%es:(%rdi)
    5103:	aa                   	stos   %al,%es:(%rdi)
    5104:	aa                   	stos   %al,%es:(%rdi)
    5105:	aa                   	stos   %al,%es:(%rdi)
    5106:	aa                   	stos   %al,%es:(%rdi)
    5107:	aa                   	stos   %al,%es:(%rdi)
    5108:	aa                   	stos   %al,%es:(%rdi)
    5109:	aa                   	stos   %al,%es:(%rdi)
    510a:	aa                   	stos   %al,%es:(%rdi)
    510b:	aa                   	stos   %al,%es:(%rdi)
    510c:	aa                   	stos   %al,%es:(%rdi)
    510d:	aa                   	stos   %al,%es:(%rdi)
    510e:	aa                   	stos   %al,%es:(%rdi)
    510f:	aa                   	stos   %al,%es:(%rdi)
    5110:	aa                   	stos   %al,%es:(%rdi)
    5111:	aa                   	stos   %al,%es:(%rdi)
    5112:	aa                   	stos   %al,%es:(%rdi)
    5113:	aa                   	stos   %al,%es:(%rdi)
    5114:	aa                   	stos   %al,%es:(%rdi)
    5115:	aa                   	stos   %al,%es:(%rdi)
    5116:	aa                   	stos   %al,%es:(%rdi)
    5117:	aa                   	stos   %al,%es:(%rdi)
    5118:	aa                   	stos   %al,%es:(%rdi)
    5119:	aa                   	stos   %al,%es:(%rdi)
    511a:	aa                   	stos   %al,%es:(%rdi)
    511b:	aa                   	stos   %al,%es:(%rdi)
    511c:	aa                   	stos   %al,%es:(%rdi)
    511d:	aa                   	stos   %al,%es:(%rdi)
    511e:	aa                   	stos   %al,%es:(%rdi)
    511f:	aa                   	stos   %al,%es:(%rdi)
    5120:	aa                   	stos   %al,%es:(%rdi)
    5121:	aa                   	stos   %al,%es:(%rdi)
    5122:	aa                   	stos   %al,%es:(%rdi)
    5123:	aa                   	stos   %al,%es:(%rdi)
    5124:	aa                   	stos   %al,%es:(%rdi)
    5125:	aa                   	stos   %al,%es:(%rdi)
    5126:	aa                   	stos   %al,%es:(%rdi)
    5127:	aa                   	stos   %al,%es:(%rdi)
    5128:	aa                   	stos   %al,%es:(%rdi)
    5129:	aa                   	stos   %al,%es:(%rdi)
    512a:	aa                   	stos   %al,%es:(%rdi)
    512b:	aa                   	stos   %al,%es:(%rdi)
    512c:	aa                   	stos   %al,%es:(%rdi)
    512d:	aa                   	stos   %al,%es:(%rdi)
    512e:	aa                   	stos   %al,%es:(%rdi)
    512f:	aa                   	stos   %al,%es:(%rdi)
    5130:	aa                   	stos   %al,%es:(%rdi)
    5131:	aa                   	stos   %al,%es:(%rdi)
    5132:	aa                   	stos   %al,%es:(%rdi)
    5133:	aa                   	stos   %al,%es:(%rdi)
    5134:	aa                   	stos   %al,%es:(%rdi)
    5135:	aa                   	stos   %al,%es:(%rdi)
    5136:	aa                   	stos   %al,%es:(%rdi)
    5137:	aa                   	stos   %al,%es:(%rdi)
    5138:	aa                   	stos   %al,%es:(%rdi)
    5139:	aa                   	stos   %al,%es:(%rdi)
    513a:	aa                   	stos   %al,%es:(%rdi)
    513b:	aa                   	stos   %al,%es:(%rdi)
    513c:	aa                   	stos   %al,%es:(%rdi)
    513d:	aa                   	stos   %al,%es:(%rdi)
    513e:	aa                   	stos   %al,%es:(%rdi)
    513f:	aa                   	stos   %al,%es:(%rdi)
    5140:	aa                   	stos   %al,%es:(%rdi)
    5141:	aa                   	stos   %al,%es:(%rdi)
    5142:	aa                   	stos   %al,%es:(%rdi)
    5143:	aa                   	stos   %al,%es:(%rdi)
    5144:	aa                   	stos   %al,%es:(%rdi)
    5145:	aa                   	stos   %al,%es:(%rdi)
    5146:	aa                   	stos   %al,%es:(%rdi)
    5147:	aa                   	stos   %al,%es:(%rdi)
    5148:	aa                   	stos   %al,%es:(%rdi)
    5149:	aa                   	stos   %al,%es:(%rdi)
    514a:	aa                   	stos   %al,%es:(%rdi)
    514b:	aa                   	stos   %al,%es:(%rdi)
    514c:	aa                   	stos   %al,%es:(%rdi)
    514d:	aa                   	stos   %al,%es:(%rdi)
    514e:	aa                   	stos   %al,%es:(%rdi)
    514f:	aa                   	stos   %al,%es:(%rdi)
    5150:	aa                   	stos   %al,%es:(%rdi)
    5151:	aa                   	stos   %al,%es:(%rdi)
    5152:	aa                   	stos   %al,%es:(%rdi)
    5153:	aa                   	stos   %al,%es:(%rdi)
    5154:	aa                   	stos   %al,%es:(%rdi)
    5155:	aa                   	stos   %al,%es:(%rdi)
    5156:	aa                   	stos   %al,%es:(%rdi)
    5157:	aa                   	stos   %al,%es:(%rdi)
    5158:	aa                   	stos   %al,%es:(%rdi)
    5159:	aa                   	stos   %al,%es:(%rdi)
    515a:	aa                   	stos   %al,%es:(%rdi)
    515b:	aa                   	stos   %al,%es:(%rdi)
    515c:	aa                   	stos   %al,%es:(%rdi)
    515d:	aa                   	stos   %al,%es:(%rdi)
    515e:	aa                   	stos   %al,%es:(%rdi)
    515f:	aa                   	stos   %al,%es:(%rdi)
    5160:	aa                   	stos   %al,%es:(%rdi)
    5161:	aa                   	stos   %al,%es:(%rdi)
    5162:	aa                   	stos   %al,%es:(%rdi)
    5163:	aa                   	stos   %al,%es:(%rdi)
    5164:	aa                   	stos   %al,%es:(%rdi)
    5165:	aa                   	stos   %al,%es:(%rdi)
    5166:	aa                   	stos   %al,%es:(%rdi)
    5167:	aa                   	stos   %al,%es:(%rdi)
    5168:	aa                   	stos   %al,%es:(%rdi)
    5169:	aa                   	stos   %al,%es:(%rdi)
    516a:	aa                   	stos   %al,%es:(%rdi)
    516b:	aa                   	stos   %al,%es:(%rdi)
    516c:	aa                   	stos   %al,%es:(%rdi)
    516d:	aa                   	stos   %al,%es:(%rdi)
    516e:	aa                   	stos   %al,%es:(%rdi)
    516f:	aa                   	stos   %al,%es:(%rdi)
    5170:	aa                   	stos   %al,%es:(%rdi)
    5171:	aa                   	stos   %al,%es:(%rdi)
    5172:	aa                   	stos   %al,%es:(%rdi)
    5173:	aa                   	stos   %al,%es:(%rdi)
    5174:	aa                   	stos   %al,%es:(%rdi)
    5175:	aa                   	stos   %al,%es:(%rdi)
    5176:	aa                   	stos   %al,%es:(%rdi)
    5177:	aa                   	stos   %al,%es:(%rdi)
    5178:	aa                   	stos   %al,%es:(%rdi)
    5179:	aa                   	stos   %al,%es:(%rdi)
    517a:	aa                   	stos   %al,%es:(%rdi)
    517b:	aa                   	stos   %al,%es:(%rdi)
    517c:	aa                   	stos   %al,%es:(%rdi)
    517d:	aa                   	stos   %al,%es:(%rdi)
    517e:	aa                   	stos   %al,%es:(%rdi)
    517f:	aa                   	stos   %al,%es:(%rdi)
    5180:	aa                   	stos   %al,%es:(%rdi)
    5181:	aa                   	stos   %al,%es:(%rdi)
    5182:	aa                   	stos   %al,%es:(%rdi)
    5183:	aa                   	stos   %al,%es:(%rdi)
    5184:	aa                   	stos   %al,%es:(%rdi)
    5185:	aa                   	stos   %al,%es:(%rdi)
    5186:	aa                   	stos   %al,%es:(%rdi)
    5187:	aa                   	stos   %al,%es:(%rdi)
    5188:	aa                   	stos   %al,%es:(%rdi)
    5189:	aa                   	stos   %al,%es:(%rdi)
    518a:	aa                   	stos   %al,%es:(%rdi)
    518b:	aa                   	stos   %al,%es:(%rdi)
    518c:	aa                   	stos   %al,%es:(%rdi)
    518d:	aa                   	stos   %al,%es:(%rdi)
    518e:	aa                   	stos   %al,%es:(%rdi)
    518f:	aa                   	stos   %al,%es:(%rdi)
    5190:	aa                   	stos   %al,%es:(%rdi)
    5191:	aa                   	stos   %al,%es:(%rdi)
    5192:	aa                   	stos   %al,%es:(%rdi)
    5193:	aa                   	stos   %al,%es:(%rdi)
    5194:	aa                   	stos   %al,%es:(%rdi)
    5195:	aa                   	stos   %al,%es:(%rdi)
    5196:	aa                   	stos   %al,%es:(%rdi)
    5197:	aa                   	stos   %al,%es:(%rdi)
    5198:	aa                   	stos   %al,%es:(%rdi)
    5199:	aa                   	stos   %al,%es:(%rdi)
    519a:	aa                   	stos   %al,%es:(%rdi)
    519b:	aa                   	stos   %al,%es:(%rdi)
    519c:	aa                   	stos   %al,%es:(%rdi)
    519d:	aa                   	stos   %al,%es:(%rdi)
    519e:	aa                   	stos   %al,%es:(%rdi)
    519f:	aa                   	stos   %al,%es:(%rdi)
    51a0:	aa                   	stos   %al,%es:(%rdi)
    51a1:	aa                   	stos   %al,%es:(%rdi)
    51a2:	aa                   	stos   %al,%es:(%rdi)
    51a3:	aa                   	stos   %al,%es:(%rdi)
    51a4:	aa                   	stos   %al,%es:(%rdi)
    51a5:	aa                   	stos   %al,%es:(%rdi)
    51a6:	aa                   	stos   %al,%es:(%rdi)
    51a7:	aa                   	stos   %al,%es:(%rdi)
    51a8:	aa                   	stos   %al,%es:(%rdi)
    51a9:	aa                   	stos   %al,%es:(%rdi)
    51aa:	aa                   	stos   %al,%es:(%rdi)
    51ab:	aa                   	stos   %al,%es:(%rdi)
    51ac:	aa                   	stos   %al,%es:(%rdi)
    51ad:	aa                   	stos   %al,%es:(%rdi)
    51ae:	aa                   	stos   %al,%es:(%rdi)
    51af:	aa                   	stos   %al,%es:(%rdi)
    51b0:	aa                   	stos   %al,%es:(%rdi)
    51b1:	aa                   	stos   %al,%es:(%rdi)
    51b2:	aa                   	stos   %al,%es:(%rdi)
    51b3:	aa                   	stos   %al,%es:(%rdi)
    51b4:	aa                   	stos   %al,%es:(%rdi)
    51b5:	aa                   	stos   %al,%es:(%rdi)
    51b6:	aa                   	stos   %al,%es:(%rdi)
    51b7:	aa                   	stos   %al,%es:(%rdi)
    51b8:	aa                   	stos   %al,%es:(%rdi)
    51b9:	aa                   	stos   %al,%es:(%rdi)
    51ba:	aa                   	stos   %al,%es:(%rdi)
    51bb:	aa                   	stos   %al,%es:(%rdi)
    51bc:	aa                   	stos   %al,%es:(%rdi)
    51bd:	aa                   	stos   %al,%es:(%rdi)
    51be:	aa                   	stos   %al,%es:(%rdi)
    51bf:	aa                   	stos   %al,%es:(%rdi)
    51c0:	aa                   	stos   %al,%es:(%rdi)
    51c1:	aa                   	stos   %al,%es:(%rdi)
    51c2:	aa                   	stos   %al,%es:(%rdi)
    51c3:	aa                   	stos   %al,%es:(%rdi)
    51c4:	aa                   	stos   %al,%es:(%rdi)
    51c5:	aa                   	stos   %al,%es:(%rdi)
    51c6:	aa                   	stos   %al,%es:(%rdi)
    51c7:	aa                   	stos   %al,%es:(%rdi)
    51c8:	aa                   	stos   %al,%es:(%rdi)
    51c9:	aa                   	stos   %al,%es:(%rdi)
    51ca:	aa                   	stos   %al,%es:(%rdi)
    51cb:	aa                   	stos   %al,%es:(%rdi)
    51cc:	aa                   	stos   %al,%es:(%rdi)
    51cd:	aa                   	stos   %al,%es:(%rdi)
    51ce:	aa                   	stos   %al,%es:(%rdi)
    51cf:	aa                   	stos   %al,%es:(%rdi)
    51d0:	aa                   	stos   %al,%es:(%rdi)
    51d1:	aa                   	stos   %al,%es:(%rdi)
    51d2:	aa                   	stos   %al,%es:(%rdi)
    51d3:	aa                   	stos   %al,%es:(%rdi)
    51d4:	aa                   	stos   %al,%es:(%rdi)
    51d5:	aa                   	stos   %al,%es:(%rdi)
    51d6:	aa                   	stos   %al,%es:(%rdi)
    51d7:	aa                   	stos   %al,%es:(%rdi)
    51d8:	aa                   	stos   %al,%es:(%rdi)
    51d9:	aa                   	stos   %al,%es:(%rdi)
    51da:	aa                   	stos   %al,%es:(%rdi)
    51db:	aa                   	stos   %al,%es:(%rdi)
    51dc:	aa                   	stos   %al,%es:(%rdi)
    51dd:	aa                   	stos   %al,%es:(%rdi)
    51de:	aa                   	stos   %al,%es:(%rdi)
    51df:	aa                   	stos   %al,%es:(%rdi)
    51e0:	aa                   	stos   %al,%es:(%rdi)
    51e1:	aa                   	stos   %al,%es:(%rdi)
    51e2:	aa                   	stos   %al,%es:(%rdi)
    51e3:	aa                   	stos   %al,%es:(%rdi)
    51e4:	aa                   	stos   %al,%es:(%rdi)
    51e5:	aa                   	stos   %al,%es:(%rdi)
    51e6:	aa                   	stos   %al,%es:(%rdi)
    51e7:	aa                   	stos   %al,%es:(%rdi)
    51e8:	aa                   	stos   %al,%es:(%rdi)
    51e9:	aa                   	stos   %al,%es:(%rdi)
    51ea:	aa                   	stos   %al,%es:(%rdi)
    51eb:	aa                   	stos   %al,%es:(%rdi)
    51ec:	aa                   	stos   %al,%es:(%rdi)
    51ed:	aa                   	stos   %al,%es:(%rdi)
    51ee:	aa                   	stos   %al,%es:(%rdi)
    51ef:	aa                   	stos   %al,%es:(%rdi)
    51f0:	aa                   	stos   %al,%es:(%rdi)
    51f1:	aa                   	stos   %al,%es:(%rdi)
    51f2:	aa                   	stos   %al,%es:(%rdi)
    51f3:	aa                   	stos   %al,%es:(%rdi)
    51f4:	aa                   	stos   %al,%es:(%rdi)
    51f5:	aa                   	stos   %al,%es:(%rdi)
    51f6:	aa                   	stos   %al,%es:(%rdi)
    51f7:	aa                   	stos   %al,%es:(%rdi)
    51f8:	aa                   	stos   %al,%es:(%rdi)
    51f9:	aa                   	stos   %al,%es:(%rdi)
    51fa:	aa                   	stos   %al,%es:(%rdi)
    51fb:	aa                   	stos   %al,%es:(%rdi)
    51fc:	aa                   	stos   %al,%es:(%rdi)
    51fd:	aa                   	stos   %al,%es:(%rdi)
    51fe:	aa                   	stos   %al,%es:(%rdi)
    51ff:	aa                   	stos   %al,%es:(%rdi)
    5200:	aa                   	stos   %al,%es:(%rdi)
    5201:	aa                   	stos   %al,%es:(%rdi)
    5202:	aa                   	stos   %al,%es:(%rdi)
    5203:	aa                   	stos   %al,%es:(%rdi)
    5204:	aa                   	stos   %al,%es:(%rdi)
    5205:	aa                   	stos   %al,%es:(%rdi)
    5206:	aa                   	stos   %al,%es:(%rdi)
    5207:	aa                   	stos   %al,%es:(%rdi)
    5208:	aa                   	stos   %al,%es:(%rdi)
    5209:	aa                   	stos   %al,%es:(%rdi)
    520a:	aa                   	stos   %al,%es:(%rdi)
    520b:	aa                   	stos   %al,%es:(%rdi)
    520c:	aa                   	stos   %al,%es:(%rdi)
    520d:	aa                   	stos   %al,%es:(%rdi)
    520e:	aa                   	stos   %al,%es:(%rdi)
    520f:	aa                   	stos   %al,%es:(%rdi)
    5210:	aa                   	stos   %al,%es:(%rdi)
    5211:	aa                   	stos   %al,%es:(%rdi)
    5212:	aa                   	stos   %al,%es:(%rdi)
    5213:	aa                   	stos   %al,%es:(%rdi)
    5214:	aa                   	stos   %al,%es:(%rdi)
    5215:	aa                   	stos   %al,%es:(%rdi)
    5216:	aa                   	stos   %al,%es:(%rdi)
    5217:	aa                   	stos   %al,%es:(%rdi)
    5218:	aa                   	stos   %al,%es:(%rdi)
    5219:	aa                   	stos   %al,%es:(%rdi)
    521a:	aa                   	stos   %al,%es:(%rdi)
    521b:	aa                   	stos   %al,%es:(%rdi)
    521c:	aa                   	stos   %al,%es:(%rdi)
    521d:	aa                   	stos   %al,%es:(%rdi)
    521e:	aa                   	stos   %al,%es:(%rdi)
    521f:	aa                   	stos   %al,%es:(%rdi)
    5220:	aa                   	stos   %al,%es:(%rdi)
    5221:	aa                   	stos   %al,%es:(%rdi)
    5222:	aa                   	stos   %al,%es:(%rdi)
    5223:	aa                   	stos   %al,%es:(%rdi)
    5224:	aa                   	stos   %al,%es:(%rdi)
    5225:	aa                   	stos   %al,%es:(%rdi)
    5226:	aa                   	stos   %al,%es:(%rdi)
    5227:	aa                   	stos   %al,%es:(%rdi)
    5228:	aa                   	stos   %al,%es:(%rdi)
    5229:	aa                   	stos   %al,%es:(%rdi)
    522a:	aa                   	stos   %al,%es:(%rdi)
    522b:	aa                   	stos   %al,%es:(%rdi)
    522c:	aa                   	stos   %al,%es:(%rdi)
    522d:	aa                   	stos   %al,%es:(%rdi)
    522e:	aa                   	stos   %al,%es:(%rdi)
    522f:	aa                   	stos   %al,%es:(%rdi)
    5230:	aa                   	stos   %al,%es:(%rdi)
    5231:	aa                   	stos   %al,%es:(%rdi)
    5232:	aa                   	stos   %al,%es:(%rdi)
    5233:	aa                   	stos   %al,%es:(%rdi)
    5234:	aa                   	stos   %al,%es:(%rdi)
    5235:	aa                   	stos   %al,%es:(%rdi)
    5236:	aa                   	stos   %al,%es:(%rdi)
    5237:	aa                   	stos   %al,%es:(%rdi)
    5238:	aa                   	stos   %al,%es:(%rdi)
    5239:	aa                   	stos   %al,%es:(%rdi)
    523a:	aa                   	stos   %al,%es:(%rdi)
    523b:	aa                   	stos   %al,%es:(%rdi)
    523c:	aa                   	stos   %al,%es:(%rdi)
    523d:	aa                   	stos   %al,%es:(%rdi)
    523e:	aa                   	stos   %al,%es:(%rdi)
    523f:	aa                   	stos   %al,%es:(%rdi)
    5240:	aa                   	stos   %al,%es:(%rdi)
    5241:	aa                   	stos   %al,%es:(%rdi)
    5242:	aa                   	stos   %al,%es:(%rdi)
    5243:	aa                   	stos   %al,%es:(%rdi)
    5244:	aa                   	stos   %al,%es:(%rdi)
    5245:	aa                   	stos   %al,%es:(%rdi)
    5246:	aa                   	stos   %al,%es:(%rdi)
    5247:	aa                   	stos   %al,%es:(%rdi)
    5248:	aa                   	stos   %al,%es:(%rdi)
    5249:	aa                   	stos   %al,%es:(%rdi)
    524a:	aa                   	stos   %al,%es:(%rdi)
    524b:	aa                   	stos   %al,%es:(%rdi)
    524c:	aa                   	stos   %al,%es:(%rdi)
    524d:	aa                   	stos   %al,%es:(%rdi)
    524e:	aa                   	stos   %al,%es:(%rdi)
    524f:	aa                   	stos   %al,%es:(%rdi)
    5250:	aa                   	stos   %al,%es:(%rdi)
    5251:	aa                   	stos   %al,%es:(%rdi)
    5252:	aa                   	stos   %al,%es:(%rdi)
    5253:	aa                   	stos   %al,%es:(%rdi)
    5254:	aa                   	stos   %al,%es:(%rdi)
    5255:	aa                   	stos   %al,%es:(%rdi)
    5256:	aa                   	stos   %al,%es:(%rdi)
    5257:	aa                   	stos   %al,%es:(%rdi)
    5258:	aa                   	stos   %al,%es:(%rdi)
    5259:	aa                   	stos   %al,%es:(%rdi)
    525a:	aa                   	stos   %al,%es:(%rdi)
    525b:	aa                   	stos   %al,%es:(%rdi)
    525c:	aa                   	stos   %al,%es:(%rdi)
    525d:	aa                   	stos   %al,%es:(%rdi)
    525e:	aa                   	stos   %al,%es:(%rdi)
    525f:	aa                   	stos   %al,%es:(%rdi)
    5260:	aa                   	stos   %al,%es:(%rdi)
    5261:	aa                   	stos   %al,%es:(%rdi)
    5262:	aa                   	stos   %al,%es:(%rdi)
    5263:	aa                   	stos   %al,%es:(%rdi)
    5264:	aa                   	stos   %al,%es:(%rdi)
    5265:	aa                   	stos   %al,%es:(%rdi)
    5266:	aa                   	stos   %al,%es:(%rdi)
    5267:	aa                   	stos   %al,%es:(%rdi)
    5268:	aa                   	stos   %al,%es:(%rdi)
    5269:	aa                   	stos   %al,%es:(%rdi)
    526a:	aa                   	stos   %al,%es:(%rdi)
    526b:	aa                   	stos   %al,%es:(%rdi)
    526c:	aa                   	stos   %al,%es:(%rdi)
    526d:	aa                   	stos   %al,%es:(%rdi)
    526e:	aa                   	stos   %al,%es:(%rdi)
    526f:	aa                   	stos   %al,%es:(%rdi)
    5270:	aa                   	stos   %al,%es:(%rdi)
    5271:	aa                   	stos   %al,%es:(%rdi)
    5272:	aa                   	stos   %al,%es:(%rdi)
    5273:	aa                   	stos   %al,%es:(%rdi)
    5274:	aa                   	stos   %al,%es:(%rdi)
    5275:	aa                   	stos   %al,%es:(%rdi)
    5276:	aa                   	stos   %al,%es:(%rdi)
    5277:	aa                   	stos   %al,%es:(%rdi)
    5278:	aa                   	stos   %al,%es:(%rdi)
    5279:	aa                   	stos   %al,%es:(%rdi)
    527a:	aa                   	stos   %al,%es:(%rdi)
    527b:	aa                   	stos   %al,%es:(%rdi)
    527c:	aa                   	stos   %al,%es:(%rdi)
    527d:	aa                   	stos   %al,%es:(%rdi)
    527e:	aa                   	stos   %al,%es:(%rdi)
    527f:	aa                   	stos   %al,%es:(%rdi)
    5280:	aa                   	stos   %al,%es:(%rdi)
    5281:	aa                   	stos   %al,%es:(%rdi)
    5282:	aa                   	stos   %al,%es:(%rdi)
    5283:	aa                   	stos   %al,%es:(%rdi)
    5284:	aa                   	stos   %al,%es:(%rdi)
    5285:	aa                   	stos   %al,%es:(%rdi)
    5286:	aa                   	stos   %al,%es:(%rdi)
    5287:	aa                   	stos   %al,%es:(%rdi)
    5288:	aa                   	stos   %al,%es:(%rdi)
    5289:	aa                   	stos   %al,%es:(%rdi)
    528a:	aa                   	stos   %al,%es:(%rdi)
    528b:	aa                   	stos   %al,%es:(%rdi)
    528c:	aa                   	stos   %al,%es:(%rdi)
    528d:	aa                   	stos   %al,%es:(%rdi)
    528e:	aa                   	stos   %al,%es:(%rdi)
    528f:	aa                   	stos   %al,%es:(%rdi)
    5290:	aa                   	stos   %al,%es:(%rdi)
    5291:	aa                   	stos   %al,%es:(%rdi)
    5292:	aa                   	stos   %al,%es:(%rdi)
    5293:	aa                   	stos   %al,%es:(%rdi)
    5294:	aa                   	stos   %al,%es:(%rdi)
    5295:	aa                   	stos   %al,%es:(%rdi)
    5296:	aa                   	stos   %al,%es:(%rdi)
    5297:	aa                   	stos   %al,%es:(%rdi)
    5298:	aa                   	stos   %al,%es:(%rdi)
    5299:	aa                   	stos   %al,%es:(%rdi)
    529a:	aa                   	stos   %al,%es:(%rdi)
    529b:	aa                   	stos   %al,%es:(%rdi)
    529c:	aa                   	stos   %al,%es:(%rdi)
    529d:	aa                   	stos   %al,%es:(%rdi)
    529e:	aa                   	stos   %al,%es:(%rdi)
    529f:	aa                   	stos   %al,%es:(%rdi)
    52a0:	aa                   	stos   %al,%es:(%rdi)
    52a1:	aa                   	stos   %al,%es:(%rdi)
    52a2:	aa                   	stos   %al,%es:(%rdi)
    52a3:	aa                   	stos   %al,%es:(%rdi)
    52a4:	aa                   	stos   %al,%es:(%rdi)
    52a5:	aa                   	stos   %al,%es:(%rdi)
    52a6:	aa                   	stos   %al,%es:(%rdi)
    52a7:	aa                   	stos   %al,%es:(%rdi)
    52a8:	aa                   	stos   %al,%es:(%rdi)
    52a9:	aa                   	stos   %al,%es:(%rdi)
    52aa:	aa                   	stos   %al,%es:(%rdi)
    52ab:	aa                   	stos   %al,%es:(%rdi)
    52ac:	aa                   	stos   %al,%es:(%rdi)
    52ad:	aa                   	stos   %al,%es:(%rdi)
    52ae:	aa                   	stos   %al,%es:(%rdi)
    52af:	aa                   	stos   %al,%es:(%rdi)
    52b0:	aa                   	stos   %al,%es:(%rdi)
    52b1:	aa                   	stos   %al,%es:(%rdi)
    52b2:	aa                   	stos   %al,%es:(%rdi)
    52b3:	aa                   	stos   %al,%es:(%rdi)
    52b4:	aa                   	stos   %al,%es:(%rdi)
    52b5:	aa                   	stos   %al,%es:(%rdi)
    52b6:	aa                   	stos   %al,%es:(%rdi)
    52b7:	aa                   	stos   %al,%es:(%rdi)
    52b8:	aa                   	stos   %al,%es:(%rdi)
    52b9:	aa                   	stos   %al,%es:(%rdi)
    52ba:	aa                   	stos   %al,%es:(%rdi)
    52bb:	aa                   	stos   %al,%es:(%rdi)
    52bc:	aa                   	stos   %al,%es:(%rdi)
    52bd:	aa                   	stos   %al,%es:(%rdi)
    52be:	aa                   	stos   %al,%es:(%rdi)
    52bf:	aa                   	stos   %al,%es:(%rdi)
    52c0:	aa                   	stos   %al,%es:(%rdi)
    52c1:	aa                   	stos   %al,%es:(%rdi)
    52c2:	aa                   	stos   %al,%es:(%rdi)
    52c3:	aa                   	stos   %al,%es:(%rdi)
    52c4:	aa                   	stos   %al,%es:(%rdi)
    52c5:	aa                   	stos   %al,%es:(%rdi)
    52c6:	aa                   	stos   %al,%es:(%rdi)
    52c7:	aa                   	stos   %al,%es:(%rdi)
    52c8:	aa                   	stos   %al,%es:(%rdi)
    52c9:	aa                   	stos   %al,%es:(%rdi)
    52ca:	aa                   	stos   %al,%es:(%rdi)
    52cb:	aa                   	stos   %al,%es:(%rdi)
    52cc:	aa                   	stos   %al,%es:(%rdi)
    52cd:	aa                   	stos   %al,%es:(%rdi)
    52ce:	aa                   	stos   %al,%es:(%rdi)
    52cf:	aa                   	stos   %al,%es:(%rdi)
    52d0:	aa                   	stos   %al,%es:(%rdi)
    52d1:	aa                   	stos   %al,%es:(%rdi)
    52d2:	aa                   	stos   %al,%es:(%rdi)
    52d3:	aa                   	stos   %al,%es:(%rdi)
    52d4:	aa                   	stos   %al,%es:(%rdi)
    52d5:	aa                   	stos   %al,%es:(%rdi)
    52d6:	aa                   	stos   %al,%es:(%rdi)
    52d7:	aa                   	stos   %al,%es:(%rdi)
    52d8:	aa                   	stos   %al,%es:(%rdi)
    52d9:	aa                   	stos   %al,%es:(%rdi)
    52da:	aa                   	stos   %al,%es:(%rdi)
    52db:	aa                   	stos   %al,%es:(%rdi)
    52dc:	aa                   	stos   %al,%es:(%rdi)
    52dd:	aa                   	stos   %al,%es:(%rdi)
    52de:	aa                   	stos   %al,%es:(%rdi)
    52df:	aa                   	stos   %al,%es:(%rdi)
    52e0:	aa                   	stos   %al,%es:(%rdi)
    52e1:	aa                   	stos   %al,%es:(%rdi)
    52e2:	aa                   	stos   %al,%es:(%rdi)
    52e3:	aa                   	stos   %al,%es:(%rdi)
    52e4:	aa                   	stos   %al,%es:(%rdi)
    52e5:	aa                   	stos   %al,%es:(%rdi)
    52e6:	aa                   	stos   %al,%es:(%rdi)
    52e7:	aa                   	stos   %al,%es:(%rdi)
    52e8:	aa                   	stos   %al,%es:(%rdi)
    52e9:	aa                   	stos   %al,%es:(%rdi)
    52ea:	aa                   	stos   %al,%es:(%rdi)
    52eb:	aa                   	stos   %al,%es:(%rdi)
    52ec:	aa                   	stos   %al,%es:(%rdi)
    52ed:	aa                   	stos   %al,%es:(%rdi)
    52ee:	aa                   	stos   %al,%es:(%rdi)
    52ef:	aa                   	stos   %al,%es:(%rdi)
    52f0:	aa                   	stos   %al,%es:(%rdi)
    52f1:	aa                   	stos   %al,%es:(%rdi)
    52f2:	aa                   	stos   %al,%es:(%rdi)
    52f3:	aa                   	stos   %al,%es:(%rdi)
    52f4:	aa                   	stos   %al,%es:(%rdi)
    52f5:	aa                   	stos   %al,%es:(%rdi)
    52f6:	aa                   	stos   %al,%es:(%rdi)
    52f7:	aa                   	stos   %al,%es:(%rdi)
    52f8:	aa                   	stos   %al,%es:(%rdi)
    52f9:	aa                   	stos   %al,%es:(%rdi)
    52fa:	aa                   	stos   %al,%es:(%rdi)
    52fb:	aa                   	stos   %al,%es:(%rdi)
    52fc:	aa                   	stos   %al,%es:(%rdi)
    52fd:	aa                   	stos   %al,%es:(%rdi)
    52fe:	aa                   	stos   %al,%es:(%rdi)
    52ff:	aa                   	stos   %al,%es:(%rdi)
    5300:	aa                   	stos   %al,%es:(%rdi)
    5301:	aa                   	stos   %al,%es:(%rdi)
    5302:	aa                   	stos   %al,%es:(%rdi)
    5303:	aa                   	stos   %al,%es:(%rdi)
    5304:	aa                   	stos   %al,%es:(%rdi)
    5305:	aa                   	stos   %al,%es:(%rdi)
    5306:	aa                   	stos   %al,%es:(%rdi)
    5307:	aa                   	stos   %al,%es:(%rdi)
    5308:	aa                   	stos   %al,%es:(%rdi)
    5309:	aa                   	stos   %al,%es:(%rdi)
    530a:	aa                   	stos   %al,%es:(%rdi)
    530b:	aa                   	stos   %al,%es:(%rdi)
    530c:	aa                   	stos   %al,%es:(%rdi)
    530d:	aa                   	stos   %al,%es:(%rdi)
    530e:	aa                   	stos   %al,%es:(%rdi)
    530f:	aa                   	stos   %al,%es:(%rdi)
    5310:	aa                   	stos   %al,%es:(%rdi)
    5311:	aa                   	stos   %al,%es:(%rdi)
    5312:	aa                   	stos   %al,%es:(%rdi)
    5313:	aa                   	stos   %al,%es:(%rdi)
    5314:	aa                   	stos   %al,%es:(%rdi)
    5315:	aa                   	stos   %al,%es:(%rdi)
    5316:	aa                   	stos   %al,%es:(%rdi)
    5317:	aa                   	stos   %al,%es:(%rdi)
    5318:	aa                   	stos   %al,%es:(%rdi)
    5319:	aa                   	stos   %al,%es:(%rdi)
    531a:	aa                   	stos   %al,%es:(%rdi)
    531b:	aa                   	stos   %al,%es:(%rdi)
    531c:	aa                   	stos   %al,%es:(%rdi)
    531d:	aa                   	stos   %al,%es:(%rdi)
    531e:	aa                   	stos   %al,%es:(%rdi)
    531f:	aa                   	stos   %al,%es:(%rdi)
    5320:	aa                   	stos   %al,%es:(%rdi)
    5321:	aa                   	stos   %al,%es:(%rdi)
    5322:	aa                   	stos   %al,%es:(%rdi)
    5323:	aa                   	stos   %al,%es:(%rdi)
    5324:	aa                   	stos   %al,%es:(%rdi)
    5325:	aa                   	stos   %al,%es:(%rdi)
    5326:	aa                   	stos   %al,%es:(%rdi)
    5327:	aa                   	stos   %al,%es:(%rdi)
    5328:	aa                   	stos   %al,%es:(%rdi)
    5329:	aa                   	stos   %al,%es:(%rdi)
    532a:	aa                   	stos   %al,%es:(%rdi)
    532b:	aa                   	stos   %al,%es:(%rdi)
    532c:	aa                   	stos   %al,%es:(%rdi)
    532d:	aa                   	stos   %al,%es:(%rdi)
    532e:	aa                   	stos   %al,%es:(%rdi)
    532f:	aa                   	stos   %al,%es:(%rdi)
    5330:	aa                   	stos   %al,%es:(%rdi)
    5331:	aa                   	stos   %al,%es:(%rdi)
    5332:	aa                   	stos   %al,%es:(%rdi)
    5333:	aa                   	stos   %al,%es:(%rdi)
    5334:	aa                   	stos   %al,%es:(%rdi)
    5335:	aa                   	stos   %al,%es:(%rdi)
    5336:	aa                   	stos   %al,%es:(%rdi)
    5337:	aa                   	stos   %al,%es:(%rdi)
    5338:	aa                   	stos   %al,%es:(%rdi)
    5339:	aa                   	stos   %al,%es:(%rdi)
    533a:	aa                   	stos   %al,%es:(%rdi)
    533b:	aa                   	stos   %al,%es:(%rdi)
    533c:	aa                   	stos   %al,%es:(%rdi)
    533d:	aa                   	stos   %al,%es:(%rdi)
    533e:	aa                   	stos   %al,%es:(%rdi)
    533f:	aa                   	stos   %al,%es:(%rdi)
    5340:	aa                   	stos   %al,%es:(%rdi)
    5341:	aa                   	stos   %al,%es:(%rdi)
    5342:	aa                   	stos   %al,%es:(%rdi)
    5343:	aa                   	stos   %al,%es:(%rdi)
    5344:	aa                   	stos   %al,%es:(%rdi)
    5345:	aa                   	stos   %al,%es:(%rdi)
    5346:	aa                   	stos   %al,%es:(%rdi)
    5347:	aa                   	stos   %al,%es:(%rdi)
    5348:	aa                   	stos   %al,%es:(%rdi)
    5349:	aa                   	stos   %al,%es:(%rdi)
    534a:	aa                   	stos   %al,%es:(%rdi)
    534b:	aa                   	stos   %al,%es:(%rdi)
    534c:	aa                   	stos   %al,%es:(%rdi)
    534d:	aa                   	stos   %al,%es:(%rdi)
    534e:	aa                   	stos   %al,%es:(%rdi)
    534f:	aa                   	stos   %al,%es:(%rdi)
    5350:	aa                   	stos   %al,%es:(%rdi)
    5351:	aa                   	stos   %al,%es:(%rdi)
    5352:	aa                   	stos   %al,%es:(%rdi)
    5353:	aa                   	stos   %al,%es:(%rdi)
    5354:	aa                   	stos   %al,%es:(%rdi)
    5355:	aa                   	stos   %al,%es:(%rdi)
    5356:	aa                   	stos   %al,%es:(%rdi)
    5357:	aa                   	stos   %al,%es:(%rdi)
    5358:	aa                   	stos   %al,%es:(%rdi)
    5359:	aa                   	stos   %al,%es:(%rdi)
    535a:	aa                   	stos   %al,%es:(%rdi)
    535b:	aa                   	stos   %al,%es:(%rdi)
    535c:	aa                   	stos   %al,%es:(%rdi)
    535d:	aa                   	stos   %al,%es:(%rdi)
    535e:	aa                   	stos   %al,%es:(%rdi)
    535f:	aa                   	stos   %al,%es:(%rdi)
    5360:	aa                   	stos   %al,%es:(%rdi)
    5361:	aa                   	stos   %al,%es:(%rdi)
    5362:	aa                   	stos   %al,%es:(%rdi)
    5363:	aa                   	stos   %al,%es:(%rdi)
    5364:	aa                   	stos   %al,%es:(%rdi)
    5365:	aa                   	stos   %al,%es:(%rdi)
    5366:	aa                   	stos   %al,%es:(%rdi)
    5367:	aa                   	stos   %al,%es:(%rdi)
    5368:	aa                   	stos   %al,%es:(%rdi)
    5369:	aa                   	stos   %al,%es:(%rdi)
    536a:	aa                   	stos   %al,%es:(%rdi)
    536b:	aa                   	stos   %al,%es:(%rdi)
    536c:	aa                   	stos   %al,%es:(%rdi)
    536d:	aa                   	stos   %al,%es:(%rdi)
    536e:	aa                   	stos   %al,%es:(%rdi)
    536f:	aa                   	stos   %al,%es:(%rdi)
    5370:	aa                   	stos   %al,%es:(%rdi)
    5371:	aa                   	stos   %al,%es:(%rdi)
    5372:	aa                   	stos   %al,%es:(%rdi)
    5373:	aa                   	stos   %al,%es:(%rdi)
    5374:	aa                   	stos   %al,%es:(%rdi)
    5375:	aa                   	stos   %al,%es:(%rdi)
    5376:	aa                   	stos   %al,%es:(%rdi)
    5377:	aa                   	stos   %al,%es:(%rdi)
    5378:	aa                   	stos   %al,%es:(%rdi)
    5379:	aa                   	stos   %al,%es:(%rdi)
    537a:	aa                   	stos   %al,%es:(%rdi)
    537b:	aa                   	stos   %al,%es:(%rdi)
    537c:	aa                   	stos   %al,%es:(%rdi)
    537d:	aa                   	stos   %al,%es:(%rdi)
    537e:	aa                   	stos   %al,%es:(%rdi)
    537f:	aa                   	stos   %al,%es:(%rdi)
    5380:	aa                   	stos   %al,%es:(%rdi)
    5381:	aa                   	stos   %al,%es:(%rdi)
    5382:	aa                   	stos   %al,%es:(%rdi)
    5383:	aa                   	stos   %al,%es:(%rdi)
    5384:	aa                   	stos   %al,%es:(%rdi)
    5385:	aa                   	stos   %al,%es:(%rdi)
    5386:	aa                   	stos   %al,%es:(%rdi)
    5387:	aa                   	stos   %al,%es:(%rdi)
    5388:	aa                   	stos   %al,%es:(%rdi)
    5389:	aa                   	stos   %al,%es:(%rdi)
    538a:	aa                   	stos   %al,%es:(%rdi)
    538b:	aa                   	stos   %al,%es:(%rdi)
    538c:	aa                   	stos   %al,%es:(%rdi)
    538d:	aa                   	stos   %al,%es:(%rdi)
    538e:	aa                   	stos   %al,%es:(%rdi)
    538f:	aa                   	stos   %al,%es:(%rdi)
    5390:	aa                   	stos   %al,%es:(%rdi)
    5391:	aa                   	stos   %al,%es:(%rdi)
    5392:	aa                   	stos   %al,%es:(%rdi)
    5393:	aa                   	stos   %al,%es:(%rdi)
    5394:	aa                   	stos   %al,%es:(%rdi)
    5395:	aa                   	stos   %al,%es:(%rdi)
    5396:	aa                   	stos   %al,%es:(%rdi)
    5397:	aa                   	stos   %al,%es:(%rdi)
    5398:	aa                   	stos   %al,%es:(%rdi)
    5399:	aa                   	stos   %al,%es:(%rdi)
    539a:	aa                   	stos   %al,%es:(%rdi)
    539b:	aa                   	stos   %al,%es:(%rdi)
    539c:	aa                   	stos   %al,%es:(%rdi)
    539d:	aa                   	stos   %al,%es:(%rdi)
    539e:	aa                   	stos   %al,%es:(%rdi)
    539f:	aa                   	stos   %al,%es:(%rdi)
    53a0:	aa                   	stos   %al,%es:(%rdi)
    53a1:	aa                   	stos   %al,%es:(%rdi)
    53a2:	aa                   	stos   %al,%es:(%rdi)
    53a3:	aa                   	stos   %al,%es:(%rdi)
    53a4:	aa                   	stos   %al,%es:(%rdi)
    53a5:	aa                   	stos   %al,%es:(%rdi)
    53a6:	aa                   	stos   %al,%es:(%rdi)
    53a7:	aa                   	stos   %al,%es:(%rdi)
    53a8:	aa                   	stos   %al,%es:(%rdi)
    53a9:	aa                   	stos   %al,%es:(%rdi)
    53aa:	aa                   	stos   %al,%es:(%rdi)
    53ab:	aa                   	stos   %al,%es:(%rdi)
    53ac:	aa                   	stos   %al,%es:(%rdi)
    53ad:	aa                   	stos   %al,%es:(%rdi)
    53ae:	aa                   	stos   %al,%es:(%rdi)
    53af:	aa                   	stos   %al,%es:(%rdi)
    53b0:	aa                   	stos   %al,%es:(%rdi)
    53b1:	aa                   	stos   %al,%es:(%rdi)
    53b2:	aa                   	stos   %al,%es:(%rdi)
    53b3:	aa                   	stos   %al,%es:(%rdi)
    53b4:	aa                   	stos   %al,%es:(%rdi)
    53b5:	aa                   	stos   %al,%es:(%rdi)
    53b6:	aa                   	stos   %al,%es:(%rdi)
    53b7:	aa                   	stos   %al,%es:(%rdi)
    53b8:	aa                   	stos   %al,%es:(%rdi)
    53b9:	aa                   	stos   %al,%es:(%rdi)
    53ba:	aa                   	stos   %al,%es:(%rdi)
    53bb:	aa                   	stos   %al,%es:(%rdi)
    53bc:	aa                   	stos   %al,%es:(%rdi)
    53bd:	aa                   	stos   %al,%es:(%rdi)
    53be:	aa                   	stos   %al,%es:(%rdi)
    53bf:	aa                   	stos   %al,%es:(%rdi)
    53c0:	aa                   	stos   %al,%es:(%rdi)
    53c1:	aa                   	stos   %al,%es:(%rdi)
    53c2:	aa                   	stos   %al,%es:(%rdi)
    53c3:	aa                   	stos   %al,%es:(%rdi)
    53c4:	aa                   	stos   %al,%es:(%rdi)
    53c5:	aa                   	stos   %al,%es:(%rdi)
    53c6:	aa                   	stos   %al,%es:(%rdi)
    53c7:	aa                   	stos   %al,%es:(%rdi)
    53c8:	aa                   	stos   %al,%es:(%rdi)
    53c9:	aa                   	stos   %al,%es:(%rdi)
    53ca:	aa                   	stos   %al,%es:(%rdi)
    53cb:	aa                   	stos   %al,%es:(%rdi)
    53cc:	aa                   	stos   %al,%es:(%rdi)
    53cd:	aa                   	stos   %al,%es:(%rdi)
    53ce:	aa                   	stos   %al,%es:(%rdi)
    53cf:	aa                   	stos   %al,%es:(%rdi)
    53d0:	aa                   	stos   %al,%es:(%rdi)
    53d1:	aa                   	stos   %al,%es:(%rdi)
    53d2:	aa                   	stos   %al,%es:(%rdi)
    53d3:	aa                   	stos   %al,%es:(%rdi)
    53d4:	aa                   	stos   %al,%es:(%rdi)
    53d5:	aa                   	stos   %al,%es:(%rdi)
    53d6:	aa                   	stos   %al,%es:(%rdi)
    53d7:	aa                   	stos   %al,%es:(%rdi)
    53d8:	aa                   	stos   %al,%es:(%rdi)
    53d9:	aa                   	stos   %al,%es:(%rdi)
    53da:	aa                   	stos   %al,%es:(%rdi)
    53db:	aa                   	stos   %al,%es:(%rdi)
    53dc:	aa                   	stos   %al,%es:(%rdi)
    53dd:	aa                   	stos   %al,%es:(%rdi)
    53de:	aa                   	stos   %al,%es:(%rdi)
    53df:	aa                   	stos   %al,%es:(%rdi)
    53e0:	aa                   	stos   %al,%es:(%rdi)
    53e1:	aa                   	stos   %al,%es:(%rdi)
    53e2:	aa                   	stos   %al,%es:(%rdi)
    53e3:	aa                   	stos   %al,%es:(%rdi)
    53e4:	aa                   	stos   %al,%es:(%rdi)
    53e5:	aa                   	stos   %al,%es:(%rdi)
    53e6:	aa                   	stos   %al,%es:(%rdi)
    53e7:	aa                   	stos   %al,%es:(%rdi)
    53e8:	aa                   	stos   %al,%es:(%rdi)
    53e9:	aa                   	stos   %al,%es:(%rdi)
    53ea:	aa                   	stos   %al,%es:(%rdi)
    53eb:	aa                   	stos   %al,%es:(%rdi)
    53ec:	aa                   	stos   %al,%es:(%rdi)
    53ed:	aa                   	stos   %al,%es:(%rdi)
    53ee:	aa                   	stos   %al,%es:(%rdi)
    53ef:	aa                   	stos   %al,%es:(%rdi)
    53f0:	aa                   	stos   %al,%es:(%rdi)
    53f1:	aa                   	stos   %al,%es:(%rdi)
    53f2:	aa                   	stos   %al,%es:(%rdi)
    53f3:	aa                   	stos   %al,%es:(%rdi)
    53f4:	aa                   	stos   %al,%es:(%rdi)
    53f5:	aa                   	stos   %al,%es:(%rdi)
    53f6:	aa                   	stos   %al,%es:(%rdi)
    53f7:	aa                   	stos   %al,%es:(%rdi)
    53f8:	aa                   	stos   %al,%es:(%rdi)
    53f9:	aa                   	stos   %al,%es:(%rdi)
    53fa:	aa                   	stos   %al,%es:(%rdi)
    53fb:	aa                   	stos   %al,%es:(%rdi)
    53fc:	aa                   	stos   %al,%es:(%rdi)
    53fd:	aa                   	stos   %al,%es:(%rdi)
    53fe:	aa                   	stos   %al,%es:(%rdi)
    53ff:	aa                   	stos   %al,%es:(%rdi)
    5400:	aa                   	stos   %al,%es:(%rdi)
    5401:	aa                   	stos   %al,%es:(%rdi)
    5402:	aa                   	stos   %al,%es:(%rdi)
    5403:	aa                   	stos   %al,%es:(%rdi)
    5404:	aa                   	stos   %al,%es:(%rdi)
    5405:	aa                   	stos   %al,%es:(%rdi)
    5406:	aa                   	stos   %al,%es:(%rdi)
    5407:	aa                   	stos   %al,%es:(%rdi)
    5408:	aa                   	stos   %al,%es:(%rdi)
    5409:	aa                   	stos   %al,%es:(%rdi)
    540a:	aa                   	stos   %al,%es:(%rdi)
    540b:	aa                   	stos   %al,%es:(%rdi)
    540c:	aa                   	stos   %al,%es:(%rdi)
    540d:	aa                   	stos   %al,%es:(%rdi)
    540e:	aa                   	stos   %al,%es:(%rdi)
    540f:	aa                   	stos   %al,%es:(%rdi)
    5410:	aa                   	stos   %al,%es:(%rdi)
    5411:	aa                   	stos   %al,%es:(%rdi)
    5412:	aa                   	stos   %al,%es:(%rdi)
    5413:	aa                   	stos   %al,%es:(%rdi)
    5414:	aa                   	stos   %al,%es:(%rdi)
    5415:	aa                   	stos   %al,%es:(%rdi)
    5416:	aa                   	stos   %al,%es:(%rdi)
    5417:	aa                   	stos   %al,%es:(%rdi)
    5418:	aa                   	stos   %al,%es:(%rdi)
    5419:	aa                   	stos   %al,%es:(%rdi)
    541a:	aa                   	stos   %al,%es:(%rdi)
    541b:	aa                   	stos   %al,%es:(%rdi)
    541c:	aa                   	stos   %al,%es:(%rdi)
    541d:	aa                   	stos   %al,%es:(%rdi)
    541e:	aa                   	stos   %al,%es:(%rdi)
    541f:	aa                   	stos   %al,%es:(%rdi)
    5420:	aa                   	stos   %al,%es:(%rdi)
    5421:	aa                   	stos   %al,%es:(%rdi)
    5422:	aa                   	stos   %al,%es:(%rdi)
    5423:	aa                   	stos   %al,%es:(%rdi)
    5424:	aa                   	stos   %al,%es:(%rdi)
    5425:	aa                   	stos   %al,%es:(%rdi)
    5426:	aa                   	stos   %al,%es:(%rdi)
    5427:	aa                   	stos   %al,%es:(%rdi)
    5428:	aa                   	stos   %al,%es:(%rdi)
    5429:	aa                   	stos   %al,%es:(%rdi)
    542a:	aa                   	stos   %al,%es:(%rdi)
    542b:	aa                   	stos   %al,%es:(%rdi)
    542c:	aa                   	stos   %al,%es:(%rdi)
    542d:	aa                   	stos   %al,%es:(%rdi)
    542e:	aa                   	stos   %al,%es:(%rdi)
    542f:	aa                   	stos   %al,%es:(%rdi)
    5430:	aa                   	stos   %al,%es:(%rdi)
    5431:	aa                   	stos   %al,%es:(%rdi)
    5432:	aa                   	stos   %al,%es:(%rdi)
    5433:	aa                   	stos   %al,%es:(%rdi)
    5434:	aa                   	stos   %al,%es:(%rdi)
    5435:	aa                   	stos   %al,%es:(%rdi)
    5436:	aa                   	stos   %al,%es:(%rdi)
    5437:	aa                   	stos   %al,%es:(%rdi)
    5438:	aa                   	stos   %al,%es:(%rdi)
    5439:	aa                   	stos   %al,%es:(%rdi)
    543a:	aa                   	stos   %al,%es:(%rdi)
    543b:	aa                   	stos   %al,%es:(%rdi)
    543c:	aa                   	stos   %al,%es:(%rdi)
    543d:	aa                   	stos   %al,%es:(%rdi)
    543e:	aa                   	stos   %al,%es:(%rdi)
    543f:	aa                   	stos   %al,%es:(%rdi)
    5440:	aa                   	stos   %al,%es:(%rdi)
    5441:	aa                   	stos   %al,%es:(%rdi)
    5442:	aa                   	stos   %al,%es:(%rdi)
    5443:	aa                   	stos   %al,%es:(%rdi)
    5444:	aa                   	stos   %al,%es:(%rdi)
    5445:	aa                   	stos   %al,%es:(%rdi)
    5446:	aa                   	stos   %al,%es:(%rdi)
    5447:	aa                   	stos   %al,%es:(%rdi)
    5448:	aa                   	stos   %al,%es:(%rdi)
    5449:	aa                   	stos   %al,%es:(%rdi)
    544a:	aa                   	stos   %al,%es:(%rdi)
    544b:	aa                   	stos   %al,%es:(%rdi)
    544c:	aa                   	stos   %al,%es:(%rdi)
    544d:	aa                   	stos   %al,%es:(%rdi)
    544e:	aa                   	stos   %al,%es:(%rdi)
    544f:	aa                   	stos   %al,%es:(%rdi)
    5450:	aa                   	stos   %al,%es:(%rdi)
    5451:	aa                   	stos   %al,%es:(%rdi)
    5452:	aa                   	stos   %al,%es:(%rdi)
    5453:	aa                   	stos   %al,%es:(%rdi)
    5454:	aa                   	stos   %al,%es:(%rdi)
    5455:	aa                   	stos   %al,%es:(%rdi)
    5456:	aa                   	stos   %al,%es:(%rdi)
    5457:	aa                   	stos   %al,%es:(%rdi)
    5458:	aa                   	stos   %al,%es:(%rdi)
    5459:	aa                   	stos   %al,%es:(%rdi)
    545a:	aa                   	stos   %al,%es:(%rdi)
    545b:	aa                   	stos   %al,%es:(%rdi)
    545c:	aa                   	stos   %al,%es:(%rdi)
    545d:	aa                   	stos   %al,%es:(%rdi)
    545e:	aa                   	stos   %al,%es:(%rdi)
    545f:	aa                   	stos   %al,%es:(%rdi)
    5460:	aa                   	stos   %al,%es:(%rdi)
    5461:	aa                   	stos   %al,%es:(%rdi)
    5462:	aa                   	stos   %al,%es:(%rdi)
    5463:	aa                   	stos   %al,%es:(%rdi)
    5464:	aa                   	stos   %al,%es:(%rdi)
    5465:	aa                   	stos   %al,%es:(%rdi)
    5466:	aa                   	stos   %al,%es:(%rdi)
    5467:	aa                   	stos   %al,%es:(%rdi)
    5468:	aa                   	stos   %al,%es:(%rdi)
    5469:	aa                   	stos   %al,%es:(%rdi)
    546a:	aa                   	stos   %al,%es:(%rdi)
    546b:	aa                   	stos   %al,%es:(%rdi)
    546c:	aa                   	stos   %al,%es:(%rdi)
    546d:	aa                   	stos   %al,%es:(%rdi)
    546e:	aa                   	stos   %al,%es:(%rdi)
    546f:	aa                   	stos   %al,%es:(%rdi)
    5470:	aa                   	stos   %al,%es:(%rdi)
    5471:	aa                   	stos   %al,%es:(%rdi)
    5472:	aa                   	stos   %al,%es:(%rdi)
    5473:	aa                   	stos   %al,%es:(%rdi)
    5474:	aa                   	stos   %al,%es:(%rdi)
    5475:	aa                   	stos   %al,%es:(%rdi)
    5476:	aa                   	stos   %al,%es:(%rdi)
    5477:	aa                   	stos   %al,%es:(%rdi)
    5478:	aa                   	stos   %al,%es:(%rdi)
    5479:	aa                   	stos   %al,%es:(%rdi)
    547a:	aa                   	stos   %al,%es:(%rdi)
    547b:	aa                   	stos   %al,%es:(%rdi)
    547c:	aa                   	stos   %al,%es:(%rdi)
    547d:	aa                   	stos   %al,%es:(%rdi)
    547e:	aa                   	stos   %al,%es:(%rdi)
    547f:	aa                   	stos   %al,%es:(%rdi)
    5480:	aa                   	stos   %al,%es:(%rdi)
    5481:	aa                   	stos   %al,%es:(%rdi)
    5482:	aa                   	stos   %al,%es:(%rdi)
    5483:	aa                   	stos   %al,%es:(%rdi)
    5484:	aa                   	stos   %al,%es:(%rdi)
    5485:	aa                   	stos   %al,%es:(%rdi)
    5486:	aa                   	stos   %al,%es:(%rdi)
    5487:	aa                   	stos   %al,%es:(%rdi)
    5488:	aa                   	stos   %al,%es:(%rdi)
    5489:	aa                   	stos   %al,%es:(%rdi)
    548a:	aa                   	stos   %al,%es:(%rdi)
    548b:	aa                   	stos   %al,%es:(%rdi)
    548c:	aa                   	stos   %al,%es:(%rdi)
    548d:	aa                   	stos   %al,%es:(%rdi)
    548e:	aa                   	stos   %al,%es:(%rdi)
    548f:	aa                   	stos   %al,%es:(%rdi)
    5490:	aa                   	stos   %al,%es:(%rdi)
    5491:	aa                   	stos   %al,%es:(%rdi)
    5492:	aa                   	stos   %al,%es:(%rdi)
    5493:	aa                   	stos   %al,%es:(%rdi)
    5494:	aa                   	stos   %al,%es:(%rdi)
    5495:	aa                   	stos   %al,%es:(%rdi)
    5496:	aa                   	stos   %al,%es:(%rdi)
    5497:	aa                   	stos   %al,%es:(%rdi)
    5498:	aa                   	stos   %al,%es:(%rdi)
    5499:	aa                   	stos   %al,%es:(%rdi)
    549a:	aa                   	stos   %al,%es:(%rdi)
    549b:	aa                   	stos   %al,%es:(%rdi)
    549c:	aa                   	stos   %al,%es:(%rdi)
    549d:	aa                   	stos   %al,%es:(%rdi)
    549e:	aa                   	stos   %al,%es:(%rdi)
    549f:	aa                   	stos   %al,%es:(%rdi)
    54a0:	aa                   	stos   %al,%es:(%rdi)
    54a1:	aa                   	stos   %al,%es:(%rdi)
    54a2:	aa                   	stos   %al,%es:(%rdi)
    54a3:	aa                   	stos   %al,%es:(%rdi)
    54a4:	aa                   	stos   %al,%es:(%rdi)
    54a5:	aa                   	stos   %al,%es:(%rdi)
    54a6:	aa                   	stos   %al,%es:(%rdi)
    54a7:	aa                   	stos   %al,%es:(%rdi)
    54a8:	aa                   	stos   %al,%es:(%rdi)
    54a9:	aa                   	stos   %al,%es:(%rdi)
    54aa:	aa                   	stos   %al,%es:(%rdi)
    54ab:	aa                   	stos   %al,%es:(%rdi)
    54ac:	aa                   	stos   %al,%es:(%rdi)
    54ad:	aa                   	stos   %al,%es:(%rdi)
    54ae:	aa                   	stos   %al,%es:(%rdi)
    54af:	aa                   	stos   %al,%es:(%rdi)
    54b0:	aa                   	stos   %al,%es:(%rdi)
    54b1:	aa                   	stos   %al,%es:(%rdi)
    54b2:	aa                   	stos   %al,%es:(%rdi)
    54b3:	aa                   	stos   %al,%es:(%rdi)
    54b4:	aa                   	stos   %al,%es:(%rdi)
    54b5:	aa                   	stos   %al,%es:(%rdi)
    54b6:	aa                   	stos   %al,%es:(%rdi)
    54b7:	aa                   	stos   %al,%es:(%rdi)
    54b8:	aa                   	stos   %al,%es:(%rdi)
    54b9:	aa                   	stos   %al,%es:(%rdi)
    54ba:	aa                   	stos   %al,%es:(%rdi)
    54bb:	aa                   	stos   %al,%es:(%rdi)
    54bc:	aa                   	stos   %al,%es:(%rdi)
    54bd:	aa                   	stos   %al,%es:(%rdi)
    54be:	aa                   	stos   %al,%es:(%rdi)
    54bf:	aa                   	stos   %al,%es:(%rdi)
    54c0:	aa                   	stos   %al,%es:(%rdi)
    54c1:	aa                   	stos   %al,%es:(%rdi)
    54c2:	aa                   	stos   %al,%es:(%rdi)
    54c3:	aa                   	stos   %al,%es:(%rdi)
    54c4:	aa                   	stos   %al,%es:(%rdi)
    54c5:	aa                   	stos   %al,%es:(%rdi)
    54c6:	aa                   	stos   %al,%es:(%rdi)
    54c7:	aa                   	stos   %al,%es:(%rdi)
    54c8:	aa                   	stos   %al,%es:(%rdi)
    54c9:	aa                   	stos   %al,%es:(%rdi)
    54ca:	aa                   	stos   %al,%es:(%rdi)
    54cb:	aa                   	stos   %al,%es:(%rdi)
    54cc:	aa                   	stos   %al,%es:(%rdi)
    54cd:	aa                   	stos   %al,%es:(%rdi)
    54ce:	aa                   	stos   %al,%es:(%rdi)
    54cf:	aa                   	stos   %al,%es:(%rdi)
    54d0:	aa                   	stos   %al,%es:(%rdi)
    54d1:	aa                   	stos   %al,%es:(%rdi)
    54d2:	aa                   	stos   %al,%es:(%rdi)
    54d3:	aa                   	stos   %al,%es:(%rdi)
    54d4:	aa                   	stos   %al,%es:(%rdi)
    54d5:	aa                   	stos   %al,%es:(%rdi)
    54d6:	aa                   	stos   %al,%es:(%rdi)
    54d7:	aa                   	stos   %al,%es:(%rdi)
    54d8:	aa                   	stos   %al,%es:(%rdi)
    54d9:	aa                   	stos   %al,%es:(%rdi)
    54da:	aa                   	stos   %al,%es:(%rdi)
    54db:	aa                   	stos   %al,%es:(%rdi)
    54dc:	aa                   	stos   %al,%es:(%rdi)
    54dd:	aa                   	stos   %al,%es:(%rdi)
    54de:	aa                   	stos   %al,%es:(%rdi)
    54df:	aa                   	stos   %al,%es:(%rdi)
    54e0:	aa                   	stos   %al,%es:(%rdi)
    54e1:	aa                   	stos   %al,%es:(%rdi)
    54e2:	aa                   	stos   %al,%es:(%rdi)
    54e3:	aa                   	stos   %al,%es:(%rdi)
    54e4:	aa                   	stos   %al,%es:(%rdi)
    54e5:	aa                   	stos   %al,%es:(%rdi)
    54e6:	aa                   	stos   %al,%es:(%rdi)
    54e7:	aa                   	stos   %al,%es:(%rdi)
    54e8:	aa                   	stos   %al,%es:(%rdi)
    54e9:	aa                   	stos   %al,%es:(%rdi)
    54ea:	aa                   	stos   %al,%es:(%rdi)
    54eb:	aa                   	stos   %al,%es:(%rdi)
    54ec:	aa                   	stos   %al,%es:(%rdi)
    54ed:	aa                   	stos   %al,%es:(%rdi)
    54ee:	aa                   	stos   %al,%es:(%rdi)
    54ef:	aa                   	stos   %al,%es:(%rdi)
    54f0:	aa                   	stos   %al,%es:(%rdi)
    54f1:	aa                   	stos   %al,%es:(%rdi)
    54f2:	aa                   	stos   %al,%es:(%rdi)
    54f3:	aa                   	stos   %al,%es:(%rdi)
    54f4:	aa                   	stos   %al,%es:(%rdi)
    54f5:	aa                   	stos   %al,%es:(%rdi)
    54f6:	aa                   	stos   %al,%es:(%rdi)
    54f7:	aa                   	stos   %al,%es:(%rdi)
    54f8:	aa                   	stos   %al,%es:(%rdi)
    54f9:	aa                   	stos   %al,%es:(%rdi)
    54fa:	aa                   	stos   %al,%es:(%rdi)
    54fb:	aa                   	stos   %al,%es:(%rdi)
    54fc:	aa                   	stos   %al,%es:(%rdi)
    54fd:	aa                   	stos   %al,%es:(%rdi)
    54fe:	aa                   	stos   %al,%es:(%rdi)
    54ff:	aa                   	stos   %al,%es:(%rdi)
    5500:	aa                   	stos   %al,%es:(%rdi)
    5501:	aa                   	stos   %al,%es:(%rdi)
    5502:	aa                   	stos   %al,%es:(%rdi)
    5503:	aa                   	stos   %al,%es:(%rdi)
    5504:	aa                   	stos   %al,%es:(%rdi)
    5505:	aa                   	stos   %al,%es:(%rdi)
    5506:	aa                   	stos   %al,%es:(%rdi)
    5507:	aa                   	stos   %al,%es:(%rdi)
    5508:	aa                   	stos   %al,%es:(%rdi)
    5509:	aa                   	stos   %al,%es:(%rdi)
    550a:	aa                   	stos   %al,%es:(%rdi)
    550b:	aa                   	stos   %al,%es:(%rdi)
    550c:	aa                   	stos   %al,%es:(%rdi)
    550d:	aa                   	stos   %al,%es:(%rdi)
    550e:	aa                   	stos   %al,%es:(%rdi)
    550f:	aa                   	stos   %al,%es:(%rdi)
    5510:	aa                   	stos   %al,%es:(%rdi)
    5511:	aa                   	stos   %al,%es:(%rdi)
    5512:	aa                   	stos   %al,%es:(%rdi)
    5513:	aa                   	stos   %al,%es:(%rdi)
    5514:	aa                   	stos   %al,%es:(%rdi)
    5515:	aa                   	stos   %al,%es:(%rdi)
    5516:	aa                   	stos   %al,%es:(%rdi)
    5517:	aa                   	stos   %al,%es:(%rdi)
    5518:	aa                   	stos   %al,%es:(%rdi)
    5519:	aa                   	stos   %al,%es:(%rdi)
    551a:	aa                   	stos   %al,%es:(%rdi)
    551b:	aa                   	stos   %al,%es:(%rdi)
    551c:	aa                   	stos   %al,%es:(%rdi)
    551d:	aa                   	stos   %al,%es:(%rdi)
    551e:	aa                   	stos   %al,%es:(%rdi)
    551f:	aa                   	stos   %al,%es:(%rdi)
    5520:	aa                   	stos   %al,%es:(%rdi)
    5521:	aa                   	stos   %al,%es:(%rdi)
    5522:	aa                   	stos   %al,%es:(%rdi)
    5523:	aa                   	stos   %al,%es:(%rdi)
    5524:	aa                   	stos   %al,%es:(%rdi)
    5525:	aa                   	stos   %al,%es:(%rdi)
    5526:	aa                   	stos   %al,%es:(%rdi)
    5527:	aa                   	stos   %al,%es:(%rdi)
    5528:	aa                   	stos   %al,%es:(%rdi)
    5529:	aa                   	stos   %al,%es:(%rdi)
    552a:	aa                   	stos   %al,%es:(%rdi)
    552b:	aa                   	stos   %al,%es:(%rdi)
    552c:	aa                   	stos   %al,%es:(%rdi)
    552d:	aa                   	stos   %al,%es:(%rdi)
    552e:	aa                   	stos   %al,%es:(%rdi)
    552f:	aa                   	stos   %al,%es:(%rdi)
    5530:	aa                   	stos   %al,%es:(%rdi)
    5531:	aa                   	stos   %al,%es:(%rdi)
    5532:	aa                   	stos   %al,%es:(%rdi)
    5533:	aa                   	stos   %al,%es:(%rdi)
    5534:	aa                   	stos   %al,%es:(%rdi)
    5535:	aa                   	stos   %al,%es:(%rdi)
    5536:	aa                   	stos   %al,%es:(%rdi)
    5537:	aa                   	stos   %al,%es:(%rdi)
    5538:	aa                   	stos   %al,%es:(%rdi)
    5539:	aa                   	stos   %al,%es:(%rdi)
    553a:	aa                   	stos   %al,%es:(%rdi)
    553b:	aa                   	stos   %al,%es:(%rdi)
    553c:	aa                   	stos   %al,%es:(%rdi)
    553d:	aa                   	stos   %al,%es:(%rdi)
    553e:	aa                   	stos   %al,%es:(%rdi)
    553f:	aa                   	stos   %al,%es:(%rdi)
    5540:	aa                   	stos   %al,%es:(%rdi)
    5541:	aa                   	stos   %al,%es:(%rdi)
    5542:	aa                   	stos   %al,%es:(%rdi)
    5543:	aa                   	stos   %al,%es:(%rdi)
    5544:	aa                   	stos   %al,%es:(%rdi)
    5545:	aa                   	stos   %al,%es:(%rdi)
    5546:	aa                   	stos   %al,%es:(%rdi)
    5547:	aa                   	stos   %al,%es:(%rdi)
    5548:	aa                   	stos   %al,%es:(%rdi)
    5549:	aa                   	stos   %al,%es:(%rdi)
    554a:	aa                   	stos   %al,%es:(%rdi)
    554b:	aa                   	stos   %al,%es:(%rdi)
    554c:	aa                   	stos   %al,%es:(%rdi)
    554d:	aa                   	stos   %al,%es:(%rdi)
    554e:	aa                   	stos   %al,%es:(%rdi)
    554f:	aa                   	stos   %al,%es:(%rdi)
    5550:	aa                   	stos   %al,%es:(%rdi)
    5551:	aa                   	stos   %al,%es:(%rdi)
    5552:	aa                   	stos   %al,%es:(%rdi)
    5553:	aa                   	stos   %al,%es:(%rdi)
    5554:	aa                   	stos   %al,%es:(%rdi)
    5555:	aa                   	stos   %al,%es:(%rdi)
    5556:	aa                   	stos   %al,%es:(%rdi)
    5557:	aa                   	stos   %al,%es:(%rdi)
    5558:	aa                   	stos   %al,%es:(%rdi)
    5559:	aa                   	stos   %al,%es:(%rdi)
    555a:	aa                   	stos   %al,%es:(%rdi)
    555b:	aa                   	stos   %al,%es:(%rdi)
    555c:	aa                   	stos   %al,%es:(%rdi)
    555d:	aa                   	stos   %al,%es:(%rdi)
    555e:	aa                   	stos   %al,%es:(%rdi)
    555f:	aa                   	stos   %al,%es:(%rdi)
    5560:	aa                   	stos   %al,%es:(%rdi)
    5561:	aa                   	stos   %al,%es:(%rdi)
    5562:	aa                   	stos   %al,%es:(%rdi)
    5563:	aa                   	stos   %al,%es:(%rdi)
    5564:	aa                   	stos   %al,%es:(%rdi)
    5565:	aa                   	stos   %al,%es:(%rdi)
    5566:	aa                   	stos   %al,%es:(%rdi)
    5567:	aa                   	stos   %al,%es:(%rdi)
    5568:	aa                   	stos   %al,%es:(%rdi)
    5569:	aa                   	stos   %al,%es:(%rdi)
    556a:	aa                   	stos   %al,%es:(%rdi)
    556b:	aa                   	stos   %al,%es:(%rdi)
    556c:	aa                   	stos   %al,%es:(%rdi)
    556d:	aa                   	stos   %al,%es:(%rdi)
    556e:	aa                   	stos   %al,%es:(%rdi)
    556f:	aa                   	stos   %al,%es:(%rdi)
    5570:	aa                   	stos   %al,%es:(%rdi)
    5571:	aa                   	stos   %al,%es:(%rdi)
    5572:	aa                   	stos   %al,%es:(%rdi)
    5573:	aa                   	stos   %al,%es:(%rdi)
    5574:	aa                   	stos   %al,%es:(%rdi)
    5575:	aa                   	stos   %al,%es:(%rdi)
    5576:	aa                   	stos   %al,%es:(%rdi)
    5577:	aa                   	stos   %al,%es:(%rdi)
    5578:	aa                   	stos   %al,%es:(%rdi)
    5579:	aa                   	stos   %al,%es:(%rdi)
    557a:	aa                   	stos   %al,%es:(%rdi)
    557b:	aa                   	stos   %al,%es:(%rdi)
    557c:	aa                   	stos   %al,%es:(%rdi)
    557d:	aa                   	stos   %al,%es:(%rdi)
    557e:	aa                   	stos   %al,%es:(%rdi)
    557f:	aa                   	stos   %al,%es:(%rdi)
    5580:	aa                   	stos   %al,%es:(%rdi)
    5581:	aa                   	stos   %al,%es:(%rdi)
    5582:	aa                   	stos   %al,%es:(%rdi)
    5583:	aa                   	stos   %al,%es:(%rdi)
    5584:	aa                   	stos   %al,%es:(%rdi)
    5585:	aa                   	stos   %al,%es:(%rdi)
    5586:	aa                   	stos   %al,%es:(%rdi)
    5587:	aa                   	stos   %al,%es:(%rdi)
    5588:	aa                   	stos   %al,%es:(%rdi)
    5589:	aa                   	stos   %al,%es:(%rdi)
    558a:	aa                   	stos   %al,%es:(%rdi)
    558b:	aa                   	stos   %al,%es:(%rdi)
    558c:	aa                   	stos   %al,%es:(%rdi)
    558d:	aa                   	stos   %al,%es:(%rdi)
    558e:	aa                   	stos   %al,%es:(%rdi)
    558f:	aa                   	stos   %al,%es:(%rdi)
    5590:	aa                   	stos   %al,%es:(%rdi)
    5591:	aa                   	stos   %al,%es:(%rdi)
    5592:	aa                   	stos   %al,%es:(%rdi)
    5593:	aa                   	stos   %al,%es:(%rdi)
    5594:	aa                   	stos   %al,%es:(%rdi)
    5595:	aa                   	stos   %al,%es:(%rdi)
    5596:	aa                   	stos   %al,%es:(%rdi)
    5597:	aa                   	stos   %al,%es:(%rdi)
    5598:	aa                   	stos   %al,%es:(%rdi)
    5599:	aa                   	stos   %al,%es:(%rdi)
    559a:	aa                   	stos   %al,%es:(%rdi)
    559b:	aa                   	stos   %al,%es:(%rdi)
    559c:	aa                   	stos   %al,%es:(%rdi)
    559d:	aa                   	stos   %al,%es:(%rdi)
    559e:	aa                   	stos   %al,%es:(%rdi)
    559f:	aa                   	stos   %al,%es:(%rdi)
    55a0:	aa                   	stos   %al,%es:(%rdi)
    55a1:	aa                   	stos   %al,%es:(%rdi)
    55a2:	aa                   	stos   %al,%es:(%rdi)
    55a3:	aa                   	stos   %al,%es:(%rdi)
    55a4:	aa                   	stos   %al,%es:(%rdi)
    55a5:	aa                   	stos   %al,%es:(%rdi)
    55a6:	aa                   	stos   %al,%es:(%rdi)
    55a7:	aa                   	stos   %al,%es:(%rdi)
    55a8:	aa                   	stos   %al,%es:(%rdi)
    55a9:	aa                   	stos   %al,%es:(%rdi)
    55aa:	aa                   	stos   %al,%es:(%rdi)
    55ab:	aa                   	stos   %al,%es:(%rdi)
    55ac:	aa                   	stos   %al,%es:(%rdi)
    55ad:	aa                   	stos   %al,%es:(%rdi)
    55ae:	aa                   	stos   %al,%es:(%rdi)
    55af:	aa                   	stos   %al,%es:(%rdi)
    55b0:	aa                   	stos   %al,%es:(%rdi)
    55b1:	aa                   	stos   %al,%es:(%rdi)
    55b2:	aa                   	stos   %al,%es:(%rdi)
    55b3:	aa                   	stos   %al,%es:(%rdi)
    55b4:	aa                   	stos   %al,%es:(%rdi)
    55b5:	aa                   	stos   %al,%es:(%rdi)
    55b6:	aa                   	stos   %al,%es:(%rdi)
    55b7:	aa                   	stos   %al,%es:(%rdi)
    55b8:	aa                   	stos   %al,%es:(%rdi)
    55b9:	aa                   	stos   %al,%es:(%rdi)
    55ba:	aa                   	stos   %al,%es:(%rdi)
    55bb:	aa                   	stos   %al,%es:(%rdi)
    55bc:	aa                   	stos   %al,%es:(%rdi)
    55bd:	aa                   	stos   %al,%es:(%rdi)
    55be:	aa                   	stos   %al,%es:(%rdi)
    55bf:	aa                   	stos   %al,%es:(%rdi)
    55c0:	aa                   	stos   %al,%es:(%rdi)
    55c1:	aa                   	stos   %al,%es:(%rdi)
    55c2:	aa                   	stos   %al,%es:(%rdi)
    55c3:	aa                   	stos   %al,%es:(%rdi)
    55c4:	aa                   	stos   %al,%es:(%rdi)
    55c5:	aa                   	stos   %al,%es:(%rdi)
    55c6:	aa                   	stos   %al,%es:(%rdi)
    55c7:	aa                   	stos   %al,%es:(%rdi)
    55c8:	aa                   	stos   %al,%es:(%rdi)
    55c9:	aa                   	stos   %al,%es:(%rdi)
    55ca:	aa                   	stos   %al,%es:(%rdi)
    55cb:	aa                   	stos   %al,%es:(%rdi)
    55cc:	aa                   	stos   %al,%es:(%rdi)
    55cd:	aa                   	stos   %al,%es:(%rdi)
    55ce:	aa                   	stos   %al,%es:(%rdi)
    55cf:	aa                   	stos   %al,%es:(%rdi)
    55d0:	aa                   	stos   %al,%es:(%rdi)
    55d1:	aa                   	stos   %al,%es:(%rdi)
    55d2:	aa                   	stos   %al,%es:(%rdi)
    55d3:	aa                   	stos   %al,%es:(%rdi)
    55d4:	aa                   	stos   %al,%es:(%rdi)
    55d5:	aa                   	stos   %al,%es:(%rdi)
    55d6:	aa                   	stos   %al,%es:(%rdi)
    55d7:	aa                   	stos   %al,%es:(%rdi)
    55d8:	aa                   	stos   %al,%es:(%rdi)
    55d9:	aa                   	stos   %al,%es:(%rdi)
    55da:	aa                   	stos   %al,%es:(%rdi)
    55db:	aa                   	stos   %al,%es:(%rdi)
    55dc:	aa                   	stos   %al,%es:(%rdi)
    55dd:	aa                   	stos   %al,%es:(%rdi)
    55de:	aa                   	stos   %al,%es:(%rdi)
    55df:	aa                   	stos   %al,%es:(%rdi)
    55e0:	aa                   	stos   %al,%es:(%rdi)
    55e1:	aa                   	stos   %al,%es:(%rdi)
    55e2:	aa                   	stos   %al,%es:(%rdi)
    55e3:	aa                   	stos   %al,%es:(%rdi)
    55e4:	aa                   	stos   %al,%es:(%rdi)
    55e5:	aa                   	stos   %al,%es:(%rdi)
    55e6:	aa                   	stos   %al,%es:(%rdi)
    55e7:	aa                   	stos   %al,%es:(%rdi)
    55e8:	aa                   	stos   %al,%es:(%rdi)
    55e9:	aa                   	stos   %al,%es:(%rdi)
    55ea:	aa                   	stos   %al,%es:(%rdi)
    55eb:	aa                   	stos   %al,%es:(%rdi)
    55ec:	aa                   	stos   %al,%es:(%rdi)
    55ed:	aa                   	stos   %al,%es:(%rdi)
    55ee:	aa                   	stos   %al,%es:(%rdi)
    55ef:	aa                   	stos   %al,%es:(%rdi)
    55f0:	aa                   	stos   %al,%es:(%rdi)
    55f1:	aa                   	stos   %al,%es:(%rdi)
    55f2:	aa                   	stos   %al,%es:(%rdi)
    55f3:	aa                   	stos   %al,%es:(%rdi)
    55f4:	aa                   	stos   %al,%es:(%rdi)
    55f5:	aa                   	stos   %al,%es:(%rdi)
    55f6:	aa                   	stos   %al,%es:(%rdi)
    55f7:	aa                   	stos   %al,%es:(%rdi)
    55f8:	aa                   	stos   %al,%es:(%rdi)
    55f9:	aa                   	stos   %al,%es:(%rdi)
    55fa:	aa                   	stos   %al,%es:(%rdi)
    55fb:	aa                   	stos   %al,%es:(%rdi)
    55fc:	aa                   	stos   %al,%es:(%rdi)
    55fd:	aa                   	stos   %al,%es:(%rdi)
    55fe:	aa                   	stos   %al,%es:(%rdi)
    55ff:	aa                   	stos   %al,%es:(%rdi)
    5600:	aa                   	stos   %al,%es:(%rdi)
    5601:	aa                   	stos   %al,%es:(%rdi)
    5602:	aa                   	stos   %al,%es:(%rdi)
    5603:	aa                   	stos   %al,%es:(%rdi)
    5604:	aa                   	stos   %al,%es:(%rdi)
    5605:	aa                   	stos   %al,%es:(%rdi)
    5606:	aa                   	stos   %al,%es:(%rdi)
    5607:	aa                   	stos   %al,%es:(%rdi)
    5608:	aa                   	stos   %al,%es:(%rdi)
    5609:	aa                   	stos   %al,%es:(%rdi)
    560a:	aa                   	stos   %al,%es:(%rdi)
    560b:	aa                   	stos   %al,%es:(%rdi)
    560c:	aa                   	stos   %al,%es:(%rdi)
    560d:	aa                   	stos   %al,%es:(%rdi)
    560e:	aa                   	stos   %al,%es:(%rdi)
    560f:	aa                   	stos   %al,%es:(%rdi)
    5610:	aa                   	stos   %al,%es:(%rdi)
    5611:	aa                   	stos   %al,%es:(%rdi)
    5612:	aa                   	stos   %al,%es:(%rdi)
    5613:	aa                   	stos   %al,%es:(%rdi)
    5614:	aa                   	stos   %al,%es:(%rdi)
    5615:	aa                   	stos   %al,%es:(%rdi)
    5616:	aa                   	stos   %al,%es:(%rdi)
    5617:	aa                   	stos   %al,%es:(%rdi)
    5618:	aa                   	stos   %al,%es:(%rdi)
    5619:	aa                   	stos   %al,%es:(%rdi)
    561a:	aa                   	stos   %al,%es:(%rdi)
    561b:	aa                   	stos   %al,%es:(%rdi)
    561c:	aa                   	stos   %al,%es:(%rdi)
    561d:	aa                   	stos   %al,%es:(%rdi)
    561e:	aa                   	stos   %al,%es:(%rdi)
    561f:	aa                   	stos   %al,%es:(%rdi)
    5620:	aa                   	stos   %al,%es:(%rdi)
    5621:	aa                   	stos   %al,%es:(%rdi)
    5622:	aa                   	stos   %al,%es:(%rdi)
    5623:	aa                   	stos   %al,%es:(%rdi)
    5624:	aa                   	stos   %al,%es:(%rdi)
    5625:	aa                   	stos   %al,%es:(%rdi)
    5626:	aa                   	stos   %al,%es:(%rdi)
    5627:	aa                   	stos   %al,%es:(%rdi)
    5628:	aa                   	stos   %al,%es:(%rdi)
    5629:	aa                   	stos   %al,%es:(%rdi)
    562a:	aa                   	stos   %al,%es:(%rdi)
    562b:	aa                   	stos   %al,%es:(%rdi)
    562c:	aa                   	stos   %al,%es:(%rdi)
    562d:	aa                   	stos   %al,%es:(%rdi)
    562e:	aa                   	stos   %al,%es:(%rdi)
    562f:	aa                   	stos   %al,%es:(%rdi)
    5630:	aa                   	stos   %al,%es:(%rdi)
    5631:	aa                   	stos   %al,%es:(%rdi)
    5632:	aa                   	stos   %al,%es:(%rdi)
    5633:	aa                   	stos   %al,%es:(%rdi)
    5634:	aa                   	stos   %al,%es:(%rdi)
    5635:	aa                   	stos   %al,%es:(%rdi)
    5636:	aa                   	stos   %al,%es:(%rdi)
    5637:	aa                   	stos   %al,%es:(%rdi)
    5638:	aa                   	stos   %al,%es:(%rdi)
    5639:	aa                   	stos   %al,%es:(%rdi)
    563a:	aa                   	stos   %al,%es:(%rdi)
    563b:	aa                   	stos   %al,%es:(%rdi)
    563c:	aa                   	stos   %al,%es:(%rdi)
    563d:	aa                   	stos   %al,%es:(%rdi)
    563e:	aa                   	stos   %al,%es:(%rdi)
    563f:	aa                   	stos   %al,%es:(%rdi)
    5640:	aa                   	stos   %al,%es:(%rdi)
    5641:	aa                   	stos   %al,%es:(%rdi)
    5642:	aa                   	stos   %al,%es:(%rdi)
    5643:	aa                   	stos   %al,%es:(%rdi)
    5644:	aa                   	stos   %al,%es:(%rdi)
    5645:	aa                   	stos   %al,%es:(%rdi)
    5646:	aa                   	stos   %al,%es:(%rdi)
    5647:	aa                   	stos   %al,%es:(%rdi)
    5648:	aa                   	stos   %al,%es:(%rdi)
    5649:	aa                   	stos   %al,%es:(%rdi)
    564a:	aa                   	stos   %al,%es:(%rdi)
    564b:	aa                   	stos   %al,%es:(%rdi)
    564c:	aa                   	stos   %al,%es:(%rdi)
    564d:	aa                   	stos   %al,%es:(%rdi)
    564e:	aa                   	stos   %al,%es:(%rdi)
    564f:	aa                   	stos   %al,%es:(%rdi)
    5650:	aa                   	stos   %al,%es:(%rdi)
    5651:	aa                   	stos   %al,%es:(%rdi)
    5652:	aa                   	stos   %al,%es:(%rdi)
    5653:	aa                   	stos   %al,%es:(%rdi)
    5654:	aa                   	stos   %al,%es:(%rdi)
    5655:	aa                   	stos   %al,%es:(%rdi)
    5656:	aa                   	stos   %al,%es:(%rdi)
    5657:	aa                   	stos   %al,%es:(%rdi)
    5658:	aa                   	stos   %al,%es:(%rdi)
    5659:	aa                   	stos   %al,%es:(%rdi)
    565a:	aa                   	stos   %al,%es:(%rdi)
    565b:	aa                   	stos   %al,%es:(%rdi)
    565c:	aa                   	stos   %al,%es:(%rdi)
    565d:	aa                   	stos   %al,%es:(%rdi)
    565e:	aa                   	stos   %al,%es:(%rdi)
    565f:	aa                   	stos   %al,%es:(%rdi)
    5660:	aa                   	stos   %al,%es:(%rdi)
    5661:	aa                   	stos   %al,%es:(%rdi)
    5662:	aa                   	stos   %al,%es:(%rdi)
    5663:	aa                   	stos   %al,%es:(%rdi)
    5664:	aa                   	stos   %al,%es:(%rdi)
    5665:	aa                   	stos   %al,%es:(%rdi)
    5666:	aa                   	stos   %al,%es:(%rdi)
    5667:	aa                   	stos   %al,%es:(%rdi)
    5668:	aa                   	stos   %al,%es:(%rdi)
    5669:	aa                   	stos   %al,%es:(%rdi)
    566a:	aa                   	stos   %al,%es:(%rdi)
    566b:	aa                   	stos   %al,%es:(%rdi)
    566c:	aa                   	stos   %al,%es:(%rdi)
    566d:	aa                   	stos   %al,%es:(%rdi)
    566e:	aa                   	stos   %al,%es:(%rdi)
    566f:	aa                   	stos   %al,%es:(%rdi)
    5670:	aa                   	stos   %al,%es:(%rdi)
    5671:	aa                   	stos   %al,%es:(%rdi)
    5672:	aa                   	stos   %al,%es:(%rdi)
    5673:	aa                   	stos   %al,%es:(%rdi)
    5674:	aa                   	stos   %al,%es:(%rdi)
    5675:	aa                   	stos   %al,%es:(%rdi)
    5676:	aa                   	stos   %al,%es:(%rdi)
    5677:	aa                   	stos   %al,%es:(%rdi)
    5678:	aa                   	stos   %al,%es:(%rdi)
    5679:	aa                   	stos   %al,%es:(%rdi)
    567a:	aa                   	stos   %al,%es:(%rdi)
    567b:	aa                   	stos   %al,%es:(%rdi)
    567c:	aa                   	stos   %al,%es:(%rdi)
    567d:	aa                   	stos   %al,%es:(%rdi)
    567e:	aa                   	stos   %al,%es:(%rdi)
    567f:	aa                   	stos   %al,%es:(%rdi)
    5680:	aa                   	stos   %al,%es:(%rdi)
    5681:	aa                   	stos   %al,%es:(%rdi)
    5682:	aa                   	stos   %al,%es:(%rdi)
    5683:	aa                   	stos   %al,%es:(%rdi)
    5684:	aa                   	stos   %al,%es:(%rdi)
    5685:	aa                   	stos   %al,%es:(%rdi)
    5686:	aa                   	stos   %al,%es:(%rdi)
    5687:	aa                   	stos   %al,%es:(%rdi)
    5688:	aa                   	stos   %al,%es:(%rdi)
    5689:	aa                   	stos   %al,%es:(%rdi)
    568a:	aa                   	stos   %al,%es:(%rdi)
    568b:	aa                   	stos   %al,%es:(%rdi)
    568c:	aa                   	stos   %al,%es:(%rdi)
    568d:	aa                   	stos   %al,%es:(%rdi)
    568e:	aa                   	stos   %al,%es:(%rdi)
    568f:	aa                   	stos   %al,%es:(%rdi)
    5690:	aa                   	stos   %al,%es:(%rdi)
    5691:	aa                   	stos   %al,%es:(%rdi)
    5692:	aa                   	stos   %al,%es:(%rdi)
    5693:	aa                   	stos   %al,%es:(%rdi)
    5694:	aa                   	stos   %al,%es:(%rdi)
    5695:	aa                   	stos   %al,%es:(%rdi)
    5696:	aa                   	stos   %al,%es:(%rdi)
    5697:	aa                   	stos   %al,%es:(%rdi)
    5698:	aa                   	stos   %al,%es:(%rdi)
    5699:	aa                   	stos   %al,%es:(%rdi)
    569a:	aa                   	stos   %al,%es:(%rdi)
    569b:	aa                   	stos   %al,%es:(%rdi)
    569c:	aa                   	stos   %al,%es:(%rdi)
    569d:	aa                   	stos   %al,%es:(%rdi)
    569e:	aa                   	stos   %al,%es:(%rdi)
    569f:	aa                   	stos   %al,%es:(%rdi)
    56a0:	aa                   	stos   %al,%es:(%rdi)
    56a1:	aa                   	stos   %al,%es:(%rdi)
    56a2:	aa                   	stos   %al,%es:(%rdi)
    56a3:	aa                   	stos   %al,%es:(%rdi)
    56a4:	aa                   	stos   %al,%es:(%rdi)
    56a5:	aa                   	stos   %al,%es:(%rdi)
    56a6:	aa                   	stos   %al,%es:(%rdi)
    56a7:	aa                   	stos   %al,%es:(%rdi)
    56a8:	aa                   	stos   %al,%es:(%rdi)
    56a9:	aa                   	stos   %al,%es:(%rdi)
    56aa:	aa                   	stos   %al,%es:(%rdi)
    56ab:	aa                   	stos   %al,%es:(%rdi)
    56ac:	aa                   	stos   %al,%es:(%rdi)
    56ad:	aa                   	stos   %al,%es:(%rdi)
    56ae:	aa                   	stos   %al,%es:(%rdi)
    56af:	aa                   	stos   %al,%es:(%rdi)
    56b0:	aa                   	stos   %al,%es:(%rdi)
    56b1:	aa                   	stos   %al,%es:(%rdi)
    56b2:	aa                   	stos   %al,%es:(%rdi)
    56b3:	aa                   	stos   %al,%es:(%rdi)
    56b4:	aa                   	stos   %al,%es:(%rdi)
    56b5:	aa                   	stos   %al,%es:(%rdi)
    56b6:	aa                   	stos   %al,%es:(%rdi)
    56b7:	aa                   	stos   %al,%es:(%rdi)
    56b8:	aa                   	stos   %al,%es:(%rdi)
    56b9:	aa                   	stos   %al,%es:(%rdi)
    56ba:	aa                   	stos   %al,%es:(%rdi)
    56bb:	aa                   	stos   %al,%es:(%rdi)
    56bc:	aa                   	stos   %al,%es:(%rdi)
    56bd:	aa                   	stos   %al,%es:(%rdi)
    56be:	aa                   	stos   %al,%es:(%rdi)
    56bf:	aa                   	stos   %al,%es:(%rdi)
    56c0:	aa                   	stos   %al,%es:(%rdi)
    56c1:	aa                   	stos   %al,%es:(%rdi)
    56c2:	aa                   	stos   %al,%es:(%rdi)
    56c3:	aa                   	stos   %al,%es:(%rdi)
    56c4:	aa                   	stos   %al,%es:(%rdi)
    56c5:	aa                   	stos   %al,%es:(%rdi)
    56c6:	aa                   	stos   %al,%es:(%rdi)
    56c7:	aa                   	stos   %al,%es:(%rdi)
    56c8:	aa                   	stos   %al,%es:(%rdi)
    56c9:	aa                   	stos   %al,%es:(%rdi)
    56ca:	aa                   	stos   %al,%es:(%rdi)
    56cb:	aa                   	stos   %al,%es:(%rdi)
    56cc:	aa                   	stos   %al,%es:(%rdi)
    56cd:	aa                   	stos   %al,%es:(%rdi)
    56ce:	aa                   	stos   %al,%es:(%rdi)
    56cf:	aa                   	stos   %al,%es:(%rdi)
    56d0:	aa                   	stos   %al,%es:(%rdi)
    56d1:	aa                   	stos   %al,%es:(%rdi)
    56d2:	aa                   	stos   %al,%es:(%rdi)
    56d3:	aa                   	stos   %al,%es:(%rdi)
    56d4:	aa                   	stos   %al,%es:(%rdi)
    56d5:	aa                   	stos   %al,%es:(%rdi)
    56d6:	aa                   	stos   %al,%es:(%rdi)
    56d7:	aa                   	stos   %al,%es:(%rdi)
    56d8:	aa                   	stos   %al,%es:(%rdi)
    56d9:	aa                   	stos   %al,%es:(%rdi)
    56da:	aa                   	stos   %al,%es:(%rdi)
    56db:	aa                   	stos   %al,%es:(%rdi)
    56dc:	aa                   	stos   %al,%es:(%rdi)
    56dd:	aa                   	stos   %al,%es:(%rdi)
    56de:	aa                   	stos   %al,%es:(%rdi)
    56df:	aa                   	stos   %al,%es:(%rdi)
    56e0:	aa                   	stos   %al,%es:(%rdi)
    56e1:	aa                   	stos   %al,%es:(%rdi)
    56e2:	aa                   	stos   %al,%es:(%rdi)
    56e3:	aa                   	stos   %al,%es:(%rdi)
    56e4:	aa                   	stos   %al,%es:(%rdi)
    56e5:	aa                   	stos   %al,%es:(%rdi)
    56e6:	aa                   	stos   %al,%es:(%rdi)
    56e7:	aa                   	stos   %al,%es:(%rdi)
    56e8:	aa                   	stos   %al,%es:(%rdi)
    56e9:	aa                   	stos   %al,%es:(%rdi)
    56ea:	aa                   	stos   %al,%es:(%rdi)
    56eb:	aa                   	stos   %al,%es:(%rdi)
    56ec:	aa                   	stos   %al,%es:(%rdi)
    56ed:	aa                   	stos   %al,%es:(%rdi)
    56ee:	aa                   	stos   %al,%es:(%rdi)
    56ef:	aa                   	stos   %al,%es:(%rdi)
    56f0:	aa                   	stos   %al,%es:(%rdi)
    56f1:	aa                   	stos   %al,%es:(%rdi)
    56f2:	aa                   	stos   %al,%es:(%rdi)
    56f3:	aa                   	stos   %al,%es:(%rdi)
    56f4:	aa                   	stos   %al,%es:(%rdi)
    56f5:	aa                   	stos   %al,%es:(%rdi)
    56f6:	aa                   	stos   %al,%es:(%rdi)
    56f7:	aa                   	stos   %al,%es:(%rdi)
    56f8:	aa                   	stos   %al,%es:(%rdi)
    56f9:	aa                   	stos   %al,%es:(%rdi)
    56fa:	aa                   	stos   %al,%es:(%rdi)
    56fb:	aa                   	stos   %al,%es:(%rdi)
    56fc:	aa                   	stos   %al,%es:(%rdi)
    56fd:	aa                   	stos   %al,%es:(%rdi)
    56fe:	aa                   	stos   %al,%es:(%rdi)
    56ff:	aa                   	stos   %al,%es:(%rdi)
    5700:	aa                   	stos   %al,%es:(%rdi)
    5701:	aa                   	stos   %al,%es:(%rdi)
    5702:	aa                   	stos   %al,%es:(%rdi)
    5703:	aa                   	stos   %al,%es:(%rdi)
    5704:	aa                   	stos   %al,%es:(%rdi)
    5705:	aa                   	stos   %al,%es:(%rdi)
    5706:	aa                   	stos   %al,%es:(%rdi)
    5707:	aa                   	stos   %al,%es:(%rdi)
    5708:	aa                   	stos   %al,%es:(%rdi)
    5709:	aa                   	stos   %al,%es:(%rdi)
    570a:	aa                   	stos   %al,%es:(%rdi)
    570b:	aa                   	stos   %al,%es:(%rdi)
    570c:	aa                   	stos   %al,%es:(%rdi)
    570d:	aa                   	stos   %al,%es:(%rdi)
    570e:	aa                   	stos   %al,%es:(%rdi)
    570f:	aa                   	stos   %al,%es:(%rdi)
    5710:	aa                   	stos   %al,%es:(%rdi)
    5711:	aa                   	stos   %al,%es:(%rdi)
    5712:	aa                   	stos   %al,%es:(%rdi)
    5713:	aa                   	stos   %al,%es:(%rdi)
    5714:	aa                   	stos   %al,%es:(%rdi)
    5715:	aa                   	stos   %al,%es:(%rdi)
    5716:	aa                   	stos   %al,%es:(%rdi)
    5717:	aa                   	stos   %al,%es:(%rdi)
    5718:	aa                   	stos   %al,%es:(%rdi)
    5719:	aa                   	stos   %al,%es:(%rdi)
    571a:	aa                   	stos   %al,%es:(%rdi)
    571b:	aa                   	stos   %al,%es:(%rdi)
    571c:	aa                   	stos   %al,%es:(%rdi)
    571d:	aa                   	stos   %al,%es:(%rdi)
    571e:	aa                   	stos   %al,%es:(%rdi)
    571f:	aa                   	stos   %al,%es:(%rdi)
    5720:	aa                   	stos   %al,%es:(%rdi)
    5721:	aa                   	stos   %al,%es:(%rdi)
    5722:	aa                   	stos   %al,%es:(%rdi)
    5723:	aa                   	stos   %al,%es:(%rdi)
    5724:	aa                   	stos   %al,%es:(%rdi)
    5725:	aa                   	stos   %al,%es:(%rdi)
    5726:	aa                   	stos   %al,%es:(%rdi)
    5727:	aa                   	stos   %al,%es:(%rdi)
    5728:	aa                   	stos   %al,%es:(%rdi)
    5729:	aa                   	stos   %al,%es:(%rdi)
    572a:	aa                   	stos   %al,%es:(%rdi)
    572b:	aa                   	stos   %al,%es:(%rdi)
    572c:	aa                   	stos   %al,%es:(%rdi)
    572d:	aa                   	stos   %al,%es:(%rdi)
    572e:	aa                   	stos   %al,%es:(%rdi)
    572f:	aa                   	stos   %al,%es:(%rdi)
    5730:	aa                   	stos   %al,%es:(%rdi)
    5731:	aa                   	stos   %al,%es:(%rdi)
    5732:	aa                   	stos   %al,%es:(%rdi)
    5733:	aa                   	stos   %al,%es:(%rdi)
    5734:	aa                   	stos   %al,%es:(%rdi)
    5735:	aa                   	stos   %al,%es:(%rdi)
    5736:	aa                   	stos   %al,%es:(%rdi)
    5737:	aa                   	stos   %al,%es:(%rdi)
    5738:	aa                   	stos   %al,%es:(%rdi)
    5739:	aa                   	stos   %al,%es:(%rdi)
    573a:	aa                   	stos   %al,%es:(%rdi)
    573b:	aa                   	stos   %al,%es:(%rdi)
    573c:	aa                   	stos   %al,%es:(%rdi)
    573d:	aa                   	stos   %al,%es:(%rdi)
    573e:	aa                   	stos   %al,%es:(%rdi)
    573f:	aa                   	stos   %al,%es:(%rdi)
    5740:	aa                   	stos   %al,%es:(%rdi)
    5741:	aa                   	stos   %al,%es:(%rdi)
    5742:	aa                   	stos   %al,%es:(%rdi)
    5743:	aa                   	stos   %al,%es:(%rdi)
    5744:	aa                   	stos   %al,%es:(%rdi)
    5745:	aa                   	stos   %al,%es:(%rdi)
    5746:	aa                   	stos   %al,%es:(%rdi)
    5747:	aa                   	stos   %al,%es:(%rdi)
    5748:	aa                   	stos   %al,%es:(%rdi)
    5749:	aa                   	stos   %al,%es:(%rdi)
    574a:	aa                   	stos   %al,%es:(%rdi)
    574b:	aa                   	stos   %al,%es:(%rdi)
    574c:	aa                   	stos   %al,%es:(%rdi)
    574d:	aa                   	stos   %al,%es:(%rdi)
    574e:	aa                   	stos   %al,%es:(%rdi)
    574f:	aa                   	stos   %al,%es:(%rdi)
    5750:	aa                   	stos   %al,%es:(%rdi)
    5751:	aa                   	stos   %al,%es:(%rdi)
    5752:	aa                   	stos   %al,%es:(%rdi)
    5753:	aa                   	stos   %al,%es:(%rdi)
    5754:	aa                   	stos   %al,%es:(%rdi)
    5755:	aa                   	stos   %al,%es:(%rdi)
    5756:	aa                   	stos   %al,%es:(%rdi)
    5757:	aa                   	stos   %al,%es:(%rdi)
    5758:	aa                   	stos   %al,%es:(%rdi)
    5759:	aa                   	stos   %al,%es:(%rdi)
    575a:	aa                   	stos   %al,%es:(%rdi)
    575b:	aa                   	stos   %al,%es:(%rdi)
    575c:	aa                   	stos   %al,%es:(%rdi)
    575d:	aa                   	stos   %al,%es:(%rdi)
    575e:	aa                   	stos   %al,%es:(%rdi)
    575f:	aa                   	stos   %al,%es:(%rdi)
    5760:	aa                   	stos   %al,%es:(%rdi)
    5761:	aa                   	stos   %al,%es:(%rdi)
    5762:	aa                   	stos   %al,%es:(%rdi)
    5763:	aa                   	stos   %al,%es:(%rdi)
    5764:	aa                   	stos   %al,%es:(%rdi)
    5765:	aa                   	stos   %al,%es:(%rdi)
    5766:	aa                   	stos   %al,%es:(%rdi)
    5767:	aa                   	stos   %al,%es:(%rdi)
    5768:	aa                   	stos   %al,%es:(%rdi)
    5769:	aa                   	stos   %al,%es:(%rdi)
    576a:	aa                   	stos   %al,%es:(%rdi)
    576b:	aa                   	stos   %al,%es:(%rdi)
    576c:	aa                   	stos   %al,%es:(%rdi)
    576d:	aa                   	stos   %al,%es:(%rdi)
    576e:	aa                   	stos   %al,%es:(%rdi)
    576f:	aa                   	stos   %al,%es:(%rdi)
    5770:	aa                   	stos   %al,%es:(%rdi)
    5771:	aa                   	stos   %al,%es:(%rdi)
    5772:	aa                   	stos   %al,%es:(%rdi)
    5773:	aa                   	stos   %al,%es:(%rdi)
    5774:	aa                   	stos   %al,%es:(%rdi)
    5775:	aa                   	stos   %al,%es:(%rdi)
    5776:	aa                   	stos   %al,%es:(%rdi)
    5777:	aa                   	stos   %al,%es:(%rdi)
    5778:	aa                   	stos   %al,%es:(%rdi)
    5779:	aa                   	stos   %al,%es:(%rdi)
    577a:	aa                   	stos   %al,%es:(%rdi)
    577b:	aa                   	stos   %al,%es:(%rdi)
    577c:	aa                   	stos   %al,%es:(%rdi)
    577d:	aa                   	stos   %al,%es:(%rdi)
    577e:	aa                   	stos   %al,%es:(%rdi)
    577f:	aa                   	stos   %al,%es:(%rdi)
    5780:	aa                   	stos   %al,%es:(%rdi)
    5781:	aa                   	stos   %al,%es:(%rdi)
    5782:	aa                   	stos   %al,%es:(%rdi)
    5783:	aa                   	stos   %al,%es:(%rdi)
    5784:	aa                   	stos   %al,%es:(%rdi)
    5785:	aa                   	stos   %al,%es:(%rdi)
    5786:	aa                   	stos   %al,%es:(%rdi)
    5787:	aa                   	stos   %al,%es:(%rdi)
    5788:	aa                   	stos   %al,%es:(%rdi)
    5789:	aa                   	stos   %al,%es:(%rdi)
    578a:	aa                   	stos   %al,%es:(%rdi)
    578b:	aa                   	stos   %al,%es:(%rdi)
    578c:	aa                   	stos   %al,%es:(%rdi)
    578d:	aa                   	stos   %al,%es:(%rdi)
    578e:	aa                   	stos   %al,%es:(%rdi)
    578f:	aa                   	stos   %al,%es:(%rdi)
    5790:	aa                   	stos   %al,%es:(%rdi)
    5791:	aa                   	stos   %al,%es:(%rdi)
    5792:	aa                   	stos   %al,%es:(%rdi)
    5793:	aa                   	stos   %al,%es:(%rdi)
    5794:	aa                   	stos   %al,%es:(%rdi)
    5795:	aa                   	stos   %al,%es:(%rdi)
    5796:	aa                   	stos   %al,%es:(%rdi)
    5797:	aa                   	stos   %al,%es:(%rdi)
    5798:	aa                   	stos   %al,%es:(%rdi)
    5799:	aa                   	stos   %al,%es:(%rdi)
    579a:	aa                   	stos   %al,%es:(%rdi)
    579b:	aa                   	stos   %al,%es:(%rdi)
    579c:	aa                   	stos   %al,%es:(%rdi)
    579d:	aa                   	stos   %al,%es:(%rdi)
    579e:	aa                   	stos   %al,%es:(%rdi)
    579f:	aa                   	stos   %al,%es:(%rdi)
    57a0:	aa                   	stos   %al,%es:(%rdi)
    57a1:	aa                   	stos   %al,%es:(%rdi)
    57a2:	aa                   	stos   %al,%es:(%rdi)
    57a3:	aa                   	stos   %al,%es:(%rdi)
    57a4:	aa                   	stos   %al,%es:(%rdi)
    57a5:	aa                   	stos   %al,%es:(%rdi)
    57a6:	aa                   	stos   %al,%es:(%rdi)
    57a7:	aa                   	stos   %al,%es:(%rdi)
    57a8:	aa                   	stos   %al,%es:(%rdi)
    57a9:	aa                   	stos   %al,%es:(%rdi)
    57aa:	aa                   	stos   %al,%es:(%rdi)
    57ab:	aa                   	stos   %al,%es:(%rdi)
    57ac:	aa                   	stos   %al,%es:(%rdi)
    57ad:	aa                   	stos   %al,%es:(%rdi)
    57ae:	aa                   	stos   %al,%es:(%rdi)
    57af:	aa                   	stos   %al,%es:(%rdi)
    57b0:	aa                   	stos   %al,%es:(%rdi)
    57b1:	aa                   	stos   %al,%es:(%rdi)
    57b2:	aa                   	stos   %al,%es:(%rdi)
    57b3:	aa                   	stos   %al,%es:(%rdi)
    57b4:	aa                   	stos   %al,%es:(%rdi)
    57b5:	aa                   	stos   %al,%es:(%rdi)
    57b6:	aa                   	stos   %al,%es:(%rdi)
    57b7:	aa                   	stos   %al,%es:(%rdi)
    57b8:	aa                   	stos   %al,%es:(%rdi)
    57b9:	aa                   	stos   %al,%es:(%rdi)
    57ba:	aa                   	stos   %al,%es:(%rdi)
    57bb:	aa                   	stos   %al,%es:(%rdi)
    57bc:	aa                   	stos   %al,%es:(%rdi)
    57bd:	aa                   	stos   %al,%es:(%rdi)
    57be:	aa                   	stos   %al,%es:(%rdi)
    57bf:	aa                   	stos   %al,%es:(%rdi)
    57c0:	aa                   	stos   %al,%es:(%rdi)
    57c1:	aa                   	stos   %al,%es:(%rdi)
    57c2:	aa                   	stos   %al,%es:(%rdi)
    57c3:	aa                   	stos   %al,%es:(%rdi)
    57c4:	aa                   	stos   %al,%es:(%rdi)
    57c5:	aa                   	stos   %al,%es:(%rdi)
    57c6:	aa                   	stos   %al,%es:(%rdi)
    57c7:	aa                   	stos   %al,%es:(%rdi)
    57c8:	aa                   	stos   %al,%es:(%rdi)
    57c9:	aa                   	stos   %al,%es:(%rdi)
    57ca:	aa                   	stos   %al,%es:(%rdi)
    57cb:	aa                   	stos   %al,%es:(%rdi)
    57cc:	aa                   	stos   %al,%es:(%rdi)
    57cd:	aa                   	stos   %al,%es:(%rdi)
    57ce:	aa                   	stos   %al,%es:(%rdi)
    57cf:	aa                   	stos   %al,%es:(%rdi)
    57d0:	aa                   	stos   %al,%es:(%rdi)
    57d1:	aa                   	stos   %al,%es:(%rdi)
    57d2:	aa                   	stos   %al,%es:(%rdi)
    57d3:	aa                   	stos   %al,%es:(%rdi)
    57d4:	aa                   	stos   %al,%es:(%rdi)
    57d5:	aa                   	stos   %al,%es:(%rdi)
    57d6:	aa                   	stos   %al,%es:(%rdi)
    57d7:	aa                   	stos   %al,%es:(%rdi)
    57d8:	aa                   	stos   %al,%es:(%rdi)
    57d9:	aa                   	stos   %al,%es:(%rdi)
    57da:	aa                   	stos   %al,%es:(%rdi)
    57db:	aa                   	stos   %al,%es:(%rdi)
    57dc:	aa                   	stos   %al,%es:(%rdi)
    57dd:	aa                   	stos   %al,%es:(%rdi)
    57de:	aa                   	stos   %al,%es:(%rdi)
    57df:	aa                   	stos   %al,%es:(%rdi)
    57e0:	aa                   	stos   %al,%es:(%rdi)
    57e1:	aa                   	stos   %al,%es:(%rdi)
    57e2:	aa                   	stos   %al,%es:(%rdi)
    57e3:	aa                   	stos   %al,%es:(%rdi)
    57e4:	aa                   	stos   %al,%es:(%rdi)
    57e5:	aa                   	stos   %al,%es:(%rdi)
    57e6:	aa                   	stos   %al,%es:(%rdi)
    57e7:	aa                   	stos   %al,%es:(%rdi)
    57e8:	aa                   	stos   %al,%es:(%rdi)
    57e9:	aa                   	stos   %al,%es:(%rdi)
    57ea:	aa                   	stos   %al,%es:(%rdi)
    57eb:	aa                   	stos   %al,%es:(%rdi)
    57ec:	aa                   	stos   %al,%es:(%rdi)
    57ed:	aa                   	stos   %al,%es:(%rdi)
    57ee:	aa                   	stos   %al,%es:(%rdi)
    57ef:	aa                   	stos   %al,%es:(%rdi)
    57f0:	aa                   	stos   %al,%es:(%rdi)
    57f1:	aa                   	stos   %al,%es:(%rdi)
    57f2:	aa                   	stos   %al,%es:(%rdi)
    57f3:	aa                   	stos   %al,%es:(%rdi)
    57f4:	aa                   	stos   %al,%es:(%rdi)
    57f5:	aa                   	stos   %al,%es:(%rdi)
    57f6:	aa                   	stos   %al,%es:(%rdi)
    57f7:	aa                   	stos   %al,%es:(%rdi)
    57f8:	aa                   	stos   %al,%es:(%rdi)
    57f9:	aa                   	stos   %al,%es:(%rdi)
    57fa:	aa                   	stos   %al,%es:(%rdi)
    57fb:	aa                   	stos   %al,%es:(%rdi)
    57fc:	aa                   	stos   %al,%es:(%rdi)
    57fd:	aa                   	stos   %al,%es:(%rdi)
    57fe:	aa                   	stos   %al,%es:(%rdi)
    57ff:	aa                   	stos   %al,%es:(%rdi)
    5800:	aa                   	stos   %al,%es:(%rdi)
    5801:	aa                   	stos   %al,%es:(%rdi)
    5802:	aa                   	stos   %al,%es:(%rdi)
    5803:	aa                   	stos   %al,%es:(%rdi)
    5804:	aa                   	stos   %al,%es:(%rdi)
    5805:	aa                   	stos   %al,%es:(%rdi)
    5806:	aa                   	stos   %al,%es:(%rdi)
    5807:	aa                   	stos   %al,%es:(%rdi)
    5808:	aa                   	stos   %al,%es:(%rdi)
    5809:	aa                   	stos   %al,%es:(%rdi)
    580a:	aa                   	stos   %al,%es:(%rdi)
    580b:	aa                   	stos   %al,%es:(%rdi)
    580c:	aa                   	stos   %al,%es:(%rdi)
    580d:	aa                   	stos   %al,%es:(%rdi)
    580e:	aa                   	stos   %al,%es:(%rdi)
    580f:	aa                   	stos   %al,%es:(%rdi)
    5810:	aa                   	stos   %al,%es:(%rdi)
    5811:	aa                   	stos   %al,%es:(%rdi)
    5812:	aa                   	stos   %al,%es:(%rdi)
    5813:	aa                   	stos   %al,%es:(%rdi)
    5814:	aa                   	stos   %al,%es:(%rdi)
    5815:	aa                   	stos   %al,%es:(%rdi)
    5816:	aa                   	stos   %al,%es:(%rdi)
    5817:	aa                   	stos   %al,%es:(%rdi)
    5818:	aa                   	stos   %al,%es:(%rdi)
    5819:	aa                   	stos   %al,%es:(%rdi)
    581a:	aa                   	stos   %al,%es:(%rdi)
    581b:	aa                   	stos   %al,%es:(%rdi)
    581c:	aa                   	stos   %al,%es:(%rdi)
    581d:	aa                   	stos   %al,%es:(%rdi)
    581e:	aa                   	stos   %al,%es:(%rdi)
    581f:	aa                   	stos   %al,%es:(%rdi)
    5820:	aa                   	stos   %al,%es:(%rdi)
    5821:	aa                   	stos   %al,%es:(%rdi)
    5822:	aa                   	stos   %al,%es:(%rdi)
    5823:	aa                   	stos   %al,%es:(%rdi)
    5824:	aa                   	stos   %al,%es:(%rdi)
    5825:	aa                   	stos   %al,%es:(%rdi)
    5826:	aa                   	stos   %al,%es:(%rdi)
    5827:	aa                   	stos   %al,%es:(%rdi)
    5828:	aa                   	stos   %al,%es:(%rdi)
    5829:	aa                   	stos   %al,%es:(%rdi)
    582a:	aa                   	stos   %al,%es:(%rdi)
    582b:	aa                   	stos   %al,%es:(%rdi)
    582c:	aa                   	stos   %al,%es:(%rdi)
    582d:	aa                   	stos   %al,%es:(%rdi)
    582e:	aa                   	stos   %al,%es:(%rdi)
    582f:	aa                   	stos   %al,%es:(%rdi)
    5830:	aa                   	stos   %al,%es:(%rdi)
    5831:	aa                   	stos   %al,%es:(%rdi)
    5832:	aa                   	stos   %al,%es:(%rdi)
    5833:	aa                   	stos   %al,%es:(%rdi)
    5834:	aa                   	stos   %al,%es:(%rdi)
    5835:	aa                   	stos   %al,%es:(%rdi)
    5836:	aa                   	stos   %al,%es:(%rdi)
    5837:	aa                   	stos   %al,%es:(%rdi)
    5838:	aa                   	stos   %al,%es:(%rdi)
    5839:	aa                   	stos   %al,%es:(%rdi)
    583a:	aa                   	stos   %al,%es:(%rdi)
    583b:	aa                   	stos   %al,%es:(%rdi)
    583c:	aa                   	stos   %al,%es:(%rdi)
    583d:	aa                   	stos   %al,%es:(%rdi)
    583e:	aa                   	stos   %al,%es:(%rdi)
    583f:	aa                   	stos   %al,%es:(%rdi)
    5840:	aa                   	stos   %al,%es:(%rdi)
    5841:	aa                   	stos   %al,%es:(%rdi)
    5842:	aa                   	stos   %al,%es:(%rdi)
    5843:	aa                   	stos   %al,%es:(%rdi)
    5844:	aa                   	stos   %al,%es:(%rdi)
    5845:	aa                   	stos   %al,%es:(%rdi)
    5846:	aa                   	stos   %al,%es:(%rdi)
    5847:	aa                   	stos   %al,%es:(%rdi)
    5848:	aa                   	stos   %al,%es:(%rdi)
    5849:	aa                   	stos   %al,%es:(%rdi)
    584a:	aa                   	stos   %al,%es:(%rdi)
    584b:	aa                   	stos   %al,%es:(%rdi)
    584c:	aa                   	stos   %al,%es:(%rdi)
    584d:	aa                   	stos   %al,%es:(%rdi)
    584e:	aa                   	stos   %al,%es:(%rdi)
    584f:	aa                   	stos   %al,%es:(%rdi)
    5850:	aa                   	stos   %al,%es:(%rdi)
    5851:	aa                   	stos   %al,%es:(%rdi)
    5852:	aa                   	stos   %al,%es:(%rdi)
    5853:	aa                   	stos   %al,%es:(%rdi)
    5854:	aa                   	stos   %al,%es:(%rdi)
    5855:	aa                   	stos   %al,%es:(%rdi)
    5856:	aa                   	stos   %al,%es:(%rdi)
    5857:	aa                   	stos   %al,%es:(%rdi)
    5858:	aa                   	stos   %al,%es:(%rdi)
    5859:	aa                   	stos   %al,%es:(%rdi)
    585a:	aa                   	stos   %al,%es:(%rdi)
    585b:	aa                   	stos   %al,%es:(%rdi)
    585c:	aa                   	stos   %al,%es:(%rdi)
    585d:	aa                   	stos   %al,%es:(%rdi)
    585e:	aa                   	stos   %al,%es:(%rdi)
    585f:	aa                   	stos   %al,%es:(%rdi)
    5860:	aa                   	stos   %al,%es:(%rdi)
    5861:	aa                   	stos   %al,%es:(%rdi)
    5862:	aa                   	stos   %al,%es:(%rdi)
    5863:	aa                   	stos   %al,%es:(%rdi)
    5864:	aa                   	stos   %al,%es:(%rdi)
    5865:	aa                   	stos   %al,%es:(%rdi)
    5866:	aa                   	stos   %al,%es:(%rdi)
    5867:	aa                   	stos   %al,%es:(%rdi)
    5868:	aa                   	stos   %al,%es:(%rdi)
    5869:	aa                   	stos   %al,%es:(%rdi)
    586a:	aa                   	stos   %al,%es:(%rdi)
    586b:	aa                   	stos   %al,%es:(%rdi)
    586c:	aa                   	stos   %al,%es:(%rdi)
    586d:	aa                   	stos   %al,%es:(%rdi)
    586e:	aa                   	stos   %al,%es:(%rdi)
    586f:	aa                   	stos   %al,%es:(%rdi)
    5870:	aa                   	stos   %al,%es:(%rdi)
    5871:	aa                   	stos   %al,%es:(%rdi)
    5872:	aa                   	stos   %al,%es:(%rdi)
    5873:	aa                   	stos   %al,%es:(%rdi)
    5874:	aa                   	stos   %al,%es:(%rdi)
    5875:	aa                   	stos   %al,%es:(%rdi)
    5876:	aa                   	stos   %al,%es:(%rdi)
    5877:	aa                   	stos   %al,%es:(%rdi)
    5878:	aa                   	stos   %al,%es:(%rdi)
    5879:	aa                   	stos   %al,%es:(%rdi)
    587a:	aa                   	stos   %al,%es:(%rdi)
    587b:	aa                   	stos   %al,%es:(%rdi)
    587c:	aa                   	stos   %al,%es:(%rdi)
    587d:	aa                   	stos   %al,%es:(%rdi)
    587e:	aa                   	stos   %al,%es:(%rdi)
    587f:	aa                   	stos   %al,%es:(%rdi)
    5880:	aa                   	stos   %al,%es:(%rdi)
    5881:	aa                   	stos   %al,%es:(%rdi)
    5882:	aa                   	stos   %al,%es:(%rdi)
    5883:	aa                   	stos   %al,%es:(%rdi)
    5884:	aa                   	stos   %al,%es:(%rdi)
    5885:	aa                   	stos   %al,%es:(%rdi)
    5886:	aa                   	stos   %al,%es:(%rdi)
    5887:	aa                   	stos   %al,%es:(%rdi)
    5888:	aa                   	stos   %al,%es:(%rdi)
    5889:	aa                   	stos   %al,%es:(%rdi)
    588a:	aa                   	stos   %al,%es:(%rdi)
    588b:	aa                   	stos   %al,%es:(%rdi)
    588c:	aa                   	stos   %al,%es:(%rdi)
    588d:	aa                   	stos   %al,%es:(%rdi)
    588e:	aa                   	stos   %al,%es:(%rdi)
    588f:	aa                   	stos   %al,%es:(%rdi)
    5890:	aa                   	stos   %al,%es:(%rdi)
    5891:	aa                   	stos   %al,%es:(%rdi)
    5892:	aa                   	stos   %al,%es:(%rdi)
    5893:	aa                   	stos   %al,%es:(%rdi)
    5894:	aa                   	stos   %al,%es:(%rdi)
    5895:	aa                   	stos   %al,%es:(%rdi)
    5896:	aa                   	stos   %al,%es:(%rdi)
    5897:	aa                   	stos   %al,%es:(%rdi)
    5898:	aa                   	stos   %al,%es:(%rdi)
    5899:	aa                   	stos   %al,%es:(%rdi)
    589a:	aa                   	stos   %al,%es:(%rdi)
    589b:	aa                   	stos   %al,%es:(%rdi)
    589c:	aa                   	stos   %al,%es:(%rdi)
    589d:	aa                   	stos   %al,%es:(%rdi)
    589e:	aa                   	stos   %al,%es:(%rdi)
    589f:	aa                   	stos   %al,%es:(%rdi)
    58a0:	aa                   	stos   %al,%es:(%rdi)
    58a1:	aa                   	stos   %al,%es:(%rdi)
    58a2:	aa                   	stos   %al,%es:(%rdi)
    58a3:	aa                   	stos   %al,%es:(%rdi)
    58a4:	aa                   	stos   %al,%es:(%rdi)
    58a5:	aa                   	stos   %al,%es:(%rdi)
    58a6:	aa                   	stos   %al,%es:(%rdi)
    58a7:	aa                   	stos   %al,%es:(%rdi)
    58a8:	aa                   	stos   %al,%es:(%rdi)
    58a9:	aa                   	stos   %al,%es:(%rdi)
    58aa:	aa                   	stos   %al,%es:(%rdi)
    58ab:	aa                   	stos   %al,%es:(%rdi)
    58ac:	aa                   	stos   %al,%es:(%rdi)
    58ad:	aa                   	stos   %al,%es:(%rdi)
    58ae:	aa                   	stos   %al,%es:(%rdi)
    58af:	aa                   	stos   %al,%es:(%rdi)
    58b0:	aa                   	stos   %al,%es:(%rdi)
    58b1:	aa                   	stos   %al,%es:(%rdi)
    58b2:	aa                   	stos   %al,%es:(%rdi)
    58b3:	aa                   	stos   %al,%es:(%rdi)
    58b4:	aa                   	stos   %al,%es:(%rdi)
    58b5:	aa                   	stos   %al,%es:(%rdi)
    58b6:	aa                   	stos   %al,%es:(%rdi)
    58b7:	aa                   	stos   %al,%es:(%rdi)
    58b8:	aa                   	stos   %al,%es:(%rdi)
    58b9:	aa                   	stos   %al,%es:(%rdi)
    58ba:	aa                   	stos   %al,%es:(%rdi)
    58bb:	aa                   	stos   %al,%es:(%rdi)
    58bc:	aa                   	stos   %al,%es:(%rdi)
    58bd:	aa                   	stos   %al,%es:(%rdi)
    58be:	aa                   	stos   %al,%es:(%rdi)
    58bf:	aa                   	stos   %al,%es:(%rdi)
    58c0:	aa                   	stos   %al,%es:(%rdi)
    58c1:	aa                   	stos   %al,%es:(%rdi)
    58c2:	aa                   	stos   %al,%es:(%rdi)
    58c3:	aa                   	stos   %al,%es:(%rdi)
    58c4:	aa                   	stos   %al,%es:(%rdi)
    58c5:	aa                   	stos   %al,%es:(%rdi)
    58c6:	aa                   	stos   %al,%es:(%rdi)
    58c7:	aa                   	stos   %al,%es:(%rdi)
    58c8:	aa                   	stos   %al,%es:(%rdi)
    58c9:	aa                   	stos   %al,%es:(%rdi)
    58ca:	aa                   	stos   %al,%es:(%rdi)
    58cb:	aa                   	stos   %al,%es:(%rdi)
    58cc:	aa                   	stos   %al,%es:(%rdi)
    58cd:	aa                   	stos   %al,%es:(%rdi)
    58ce:	aa                   	stos   %al,%es:(%rdi)
    58cf:	aa                   	stos   %al,%es:(%rdi)
    58d0:	aa                   	stos   %al,%es:(%rdi)
    58d1:	aa                   	stos   %al,%es:(%rdi)
    58d2:	aa                   	stos   %al,%es:(%rdi)
    58d3:	aa                   	stos   %al,%es:(%rdi)
    58d4:	aa                   	stos   %al,%es:(%rdi)
    58d5:	aa                   	stos   %al,%es:(%rdi)
    58d6:	aa                   	stos   %al,%es:(%rdi)
    58d7:	aa                   	stos   %al,%es:(%rdi)
    58d8:	aa                   	stos   %al,%es:(%rdi)
    58d9:	aa                   	stos   %al,%es:(%rdi)
    58da:	aa                   	stos   %al,%es:(%rdi)
    58db:	aa                   	stos   %al,%es:(%rdi)
    58dc:	aa                   	stos   %al,%es:(%rdi)
    58dd:	aa                   	stos   %al,%es:(%rdi)
    58de:	aa                   	stos   %al,%es:(%rdi)
    58df:	aa                   	stos   %al,%es:(%rdi)
    58e0:	aa                   	stos   %al,%es:(%rdi)
    58e1:	aa                   	stos   %al,%es:(%rdi)
    58e2:	aa                   	stos   %al,%es:(%rdi)
    58e3:	aa                   	stos   %al,%es:(%rdi)
    58e4:	aa                   	stos   %al,%es:(%rdi)
    58e5:	aa                   	stos   %al,%es:(%rdi)
    58e6:	aa                   	stos   %al,%es:(%rdi)
    58e7:	aa                   	stos   %al,%es:(%rdi)
    58e8:	aa                   	stos   %al,%es:(%rdi)
    58e9:	aa                   	stos   %al,%es:(%rdi)
    58ea:	aa                   	stos   %al,%es:(%rdi)
    58eb:	aa                   	stos   %al,%es:(%rdi)
    58ec:	aa                   	stos   %al,%es:(%rdi)
    58ed:	aa                   	stos   %al,%es:(%rdi)
    58ee:	aa                   	stos   %al,%es:(%rdi)
    58ef:	aa                   	stos   %al,%es:(%rdi)
    58f0:	aa                   	stos   %al,%es:(%rdi)
    58f1:	aa                   	stos   %al,%es:(%rdi)
    58f2:	aa                   	stos   %al,%es:(%rdi)
    58f3:	aa                   	stos   %al,%es:(%rdi)
    58f4:	aa                   	stos   %al,%es:(%rdi)
    58f5:	aa                   	stos   %al,%es:(%rdi)
    58f6:	aa                   	stos   %al,%es:(%rdi)
    58f7:	aa                   	stos   %al,%es:(%rdi)
    58f8:	aa                   	stos   %al,%es:(%rdi)
    58f9:	aa                   	stos   %al,%es:(%rdi)
    58fa:	aa                   	stos   %al,%es:(%rdi)
    58fb:	aa                   	stos   %al,%es:(%rdi)
    58fc:	aa                   	stos   %al,%es:(%rdi)
    58fd:	aa                   	stos   %al,%es:(%rdi)
    58fe:	aa                   	stos   %al,%es:(%rdi)
    58ff:	aa                   	stos   %al,%es:(%rdi)
    5900:	aa                   	stos   %al,%es:(%rdi)
    5901:	aa                   	stos   %al,%es:(%rdi)
    5902:	aa                   	stos   %al,%es:(%rdi)
    5903:	aa                   	stos   %al,%es:(%rdi)
    5904:	aa                   	stos   %al,%es:(%rdi)
    5905:	aa                   	stos   %al,%es:(%rdi)
    5906:	aa                   	stos   %al,%es:(%rdi)
    5907:	aa                   	stos   %al,%es:(%rdi)
    5908:	aa                   	stos   %al,%es:(%rdi)
    5909:	aa                   	stos   %al,%es:(%rdi)
    590a:	aa                   	stos   %al,%es:(%rdi)
    590b:	aa                   	stos   %al,%es:(%rdi)
    590c:	aa                   	stos   %al,%es:(%rdi)
    590d:	aa                   	stos   %al,%es:(%rdi)
    590e:	aa                   	stos   %al,%es:(%rdi)
    590f:	aa                   	stos   %al,%es:(%rdi)
    5910:	aa                   	stos   %al,%es:(%rdi)
    5911:	aa                   	stos   %al,%es:(%rdi)
    5912:	aa                   	stos   %al,%es:(%rdi)
    5913:	aa                   	stos   %al,%es:(%rdi)
    5914:	aa                   	stos   %al,%es:(%rdi)
    5915:	aa                   	stos   %al,%es:(%rdi)
    5916:	aa                   	stos   %al,%es:(%rdi)
    5917:	aa                   	stos   %al,%es:(%rdi)
    5918:	aa                   	stos   %al,%es:(%rdi)
    5919:	aa                   	stos   %al,%es:(%rdi)
    591a:	aa                   	stos   %al,%es:(%rdi)
    591b:	aa                   	stos   %al,%es:(%rdi)
    591c:	aa                   	stos   %al,%es:(%rdi)
    591d:	aa                   	stos   %al,%es:(%rdi)
    591e:	aa                   	stos   %al,%es:(%rdi)
    591f:	aa                   	stos   %al,%es:(%rdi)
    5920:	aa                   	stos   %al,%es:(%rdi)
    5921:	aa                   	stos   %al,%es:(%rdi)
    5922:	aa                   	stos   %al,%es:(%rdi)
    5923:	aa                   	stos   %al,%es:(%rdi)
    5924:	aa                   	stos   %al,%es:(%rdi)
    5925:	aa                   	stos   %al,%es:(%rdi)
    5926:	aa                   	stos   %al,%es:(%rdi)
    5927:	aa                   	stos   %al,%es:(%rdi)
    5928:	aa                   	stos   %al,%es:(%rdi)
    5929:	aa                   	stos   %al,%es:(%rdi)
    592a:	aa                   	stos   %al,%es:(%rdi)
    592b:	aa                   	stos   %al,%es:(%rdi)
    592c:	aa                   	stos   %al,%es:(%rdi)
    592d:	aa                   	stos   %al,%es:(%rdi)
    592e:	aa                   	stos   %al,%es:(%rdi)
    592f:	aa                   	stos   %al,%es:(%rdi)
    5930:	aa                   	stos   %al,%es:(%rdi)
    5931:	aa                   	stos   %al,%es:(%rdi)
    5932:	aa                   	stos   %al,%es:(%rdi)
    5933:	aa                   	stos   %al,%es:(%rdi)
    5934:	aa                   	stos   %al,%es:(%rdi)
    5935:	aa                   	stos   %al,%es:(%rdi)
    5936:	aa                   	stos   %al,%es:(%rdi)
    5937:	aa                   	stos   %al,%es:(%rdi)
    5938:	aa                   	stos   %al,%es:(%rdi)
    5939:	aa                   	stos   %al,%es:(%rdi)
    593a:	aa                   	stos   %al,%es:(%rdi)
    593b:	aa                   	stos   %al,%es:(%rdi)
    593c:	aa                   	stos   %al,%es:(%rdi)
    593d:	aa                   	stos   %al,%es:(%rdi)
    593e:	aa                   	stos   %al,%es:(%rdi)
    593f:	aa                   	stos   %al,%es:(%rdi)
    5940:	aa                   	stos   %al,%es:(%rdi)
    5941:	aa                   	stos   %al,%es:(%rdi)
    5942:	aa                   	stos   %al,%es:(%rdi)
    5943:	aa                   	stos   %al,%es:(%rdi)
    5944:	aa                   	stos   %al,%es:(%rdi)
    5945:	aa                   	stos   %al,%es:(%rdi)
    5946:	aa                   	stos   %al,%es:(%rdi)
    5947:	aa                   	stos   %al,%es:(%rdi)
    5948:	aa                   	stos   %al,%es:(%rdi)
    5949:	aa                   	stos   %al,%es:(%rdi)
    594a:	aa                   	stos   %al,%es:(%rdi)
    594b:	aa                   	stos   %al,%es:(%rdi)
    594c:	aa                   	stos   %al,%es:(%rdi)
    594d:	aa                   	stos   %al,%es:(%rdi)
    594e:	aa                   	stos   %al,%es:(%rdi)
    594f:	aa                   	stos   %al,%es:(%rdi)
    5950:	aa                   	stos   %al,%es:(%rdi)
    5951:	aa                   	stos   %al,%es:(%rdi)
    5952:	aa                   	stos   %al,%es:(%rdi)
    5953:	aa                   	stos   %al,%es:(%rdi)
    5954:	aa                   	stos   %al,%es:(%rdi)
    5955:	aa                   	stos   %al,%es:(%rdi)
    5956:	aa                   	stos   %al,%es:(%rdi)
    5957:	aa                   	stos   %al,%es:(%rdi)
    5958:	aa                   	stos   %al,%es:(%rdi)
    5959:	aa                   	stos   %al,%es:(%rdi)
    595a:	aa                   	stos   %al,%es:(%rdi)
    595b:	aa                   	stos   %al,%es:(%rdi)
    595c:	aa                   	stos   %al,%es:(%rdi)
    595d:	aa                   	stos   %al,%es:(%rdi)
    595e:	aa                   	stos   %al,%es:(%rdi)
    595f:	aa                   	stos   %al,%es:(%rdi)
    5960:	aa                   	stos   %al,%es:(%rdi)
    5961:	aa                   	stos   %al,%es:(%rdi)
    5962:	aa                   	stos   %al,%es:(%rdi)
    5963:	aa                   	stos   %al,%es:(%rdi)
    5964:	aa                   	stos   %al,%es:(%rdi)
    5965:	aa                   	stos   %al,%es:(%rdi)
    5966:	aa                   	stos   %al,%es:(%rdi)
    5967:	aa                   	stos   %al,%es:(%rdi)
    5968:	aa                   	stos   %al,%es:(%rdi)
    5969:	aa                   	stos   %al,%es:(%rdi)
    596a:	aa                   	stos   %al,%es:(%rdi)
    596b:	aa                   	stos   %al,%es:(%rdi)
    596c:	aa                   	stos   %al,%es:(%rdi)
    596d:	aa                   	stos   %al,%es:(%rdi)
    596e:	aa                   	stos   %al,%es:(%rdi)
    596f:	aa                   	stos   %al,%es:(%rdi)
    5970:	aa                   	stos   %al,%es:(%rdi)
    5971:	aa                   	stos   %al,%es:(%rdi)
    5972:	aa                   	stos   %al,%es:(%rdi)
    5973:	aa                   	stos   %al,%es:(%rdi)
    5974:	aa                   	stos   %al,%es:(%rdi)
    5975:	aa                   	stos   %al,%es:(%rdi)
    5976:	aa                   	stos   %al,%es:(%rdi)
    5977:	aa                   	stos   %al,%es:(%rdi)
    5978:	aa                   	stos   %al,%es:(%rdi)
    5979:	aa                   	stos   %al,%es:(%rdi)
    597a:	aa                   	stos   %al,%es:(%rdi)
    597b:	aa                   	stos   %al,%es:(%rdi)
    597c:	aa                   	stos   %al,%es:(%rdi)
    597d:	aa                   	stos   %al,%es:(%rdi)
    597e:	aa                   	stos   %al,%es:(%rdi)
    597f:	aa                   	stos   %al,%es:(%rdi)
    5980:	aa                   	stos   %al,%es:(%rdi)
    5981:	aa                   	stos   %al,%es:(%rdi)
    5982:	aa                   	stos   %al,%es:(%rdi)
    5983:	aa                   	stos   %al,%es:(%rdi)
    5984:	aa                   	stos   %al,%es:(%rdi)
    5985:	aa                   	stos   %al,%es:(%rdi)
    5986:	aa                   	stos   %al,%es:(%rdi)
    5987:	aa                   	stos   %al,%es:(%rdi)
    5988:	aa                   	stos   %al,%es:(%rdi)
    5989:	aa                   	stos   %al,%es:(%rdi)
    598a:	aa                   	stos   %al,%es:(%rdi)
    598b:	aa                   	stos   %al,%es:(%rdi)
    598c:	aa                   	stos   %al,%es:(%rdi)
    598d:	aa                   	stos   %al,%es:(%rdi)
    598e:	aa                   	stos   %al,%es:(%rdi)
    598f:	aa                   	stos   %al,%es:(%rdi)
    5990:	aa                   	stos   %al,%es:(%rdi)
    5991:	aa                   	stos   %al,%es:(%rdi)
    5992:	aa                   	stos   %al,%es:(%rdi)
    5993:	aa                   	stos   %al,%es:(%rdi)
    5994:	aa                   	stos   %al,%es:(%rdi)
    5995:	aa                   	stos   %al,%es:(%rdi)
    5996:	aa                   	stos   %al,%es:(%rdi)
    5997:	aa                   	stos   %al,%es:(%rdi)
    5998:	aa                   	stos   %al,%es:(%rdi)
    5999:	aa                   	stos   %al,%es:(%rdi)
    599a:	aa                   	stos   %al,%es:(%rdi)
    599b:	aa                   	stos   %al,%es:(%rdi)
    599c:	aa                   	stos   %al,%es:(%rdi)
    599d:	aa                   	stos   %al,%es:(%rdi)
    599e:	aa                   	stos   %al,%es:(%rdi)
    599f:	aa                   	stos   %al,%es:(%rdi)
    59a0:	aa                   	stos   %al,%es:(%rdi)
    59a1:	aa                   	stos   %al,%es:(%rdi)
    59a2:	aa                   	stos   %al,%es:(%rdi)
    59a3:	aa                   	stos   %al,%es:(%rdi)
    59a4:	aa                   	stos   %al,%es:(%rdi)
    59a5:	aa                   	stos   %al,%es:(%rdi)
    59a6:	aa                   	stos   %al,%es:(%rdi)
    59a7:	aa                   	stos   %al,%es:(%rdi)
    59a8:	aa                   	stos   %al,%es:(%rdi)
    59a9:	aa                   	stos   %al,%es:(%rdi)
    59aa:	aa                   	stos   %al,%es:(%rdi)
    59ab:	aa                   	stos   %al,%es:(%rdi)
    59ac:	aa                   	stos   %al,%es:(%rdi)
    59ad:	aa                   	stos   %al,%es:(%rdi)
    59ae:	aa                   	stos   %al,%es:(%rdi)
    59af:	aa                   	stos   %al,%es:(%rdi)
    59b0:	aa                   	stos   %al,%es:(%rdi)
    59b1:	aa                   	stos   %al,%es:(%rdi)
    59b2:	aa                   	stos   %al,%es:(%rdi)
    59b3:	aa                   	stos   %al,%es:(%rdi)
    59b4:	aa                   	stos   %al,%es:(%rdi)
    59b5:	aa                   	stos   %al,%es:(%rdi)
    59b6:	aa                   	stos   %al,%es:(%rdi)
    59b7:	aa                   	stos   %al,%es:(%rdi)
    59b8:	aa                   	stos   %al,%es:(%rdi)
    59b9:	aa                   	stos   %al,%es:(%rdi)
    59ba:	aa                   	stos   %al,%es:(%rdi)
    59bb:	aa                   	stos   %al,%es:(%rdi)
    59bc:	aa                   	stos   %al,%es:(%rdi)
    59bd:	aa                   	stos   %al,%es:(%rdi)
    59be:	aa                   	stos   %al,%es:(%rdi)
    59bf:	aa                   	stos   %al,%es:(%rdi)
    59c0:	aa                   	stos   %al,%es:(%rdi)
    59c1:	aa                   	stos   %al,%es:(%rdi)
    59c2:	aa                   	stos   %al,%es:(%rdi)
    59c3:	aa                   	stos   %al,%es:(%rdi)
    59c4:	aa                   	stos   %al,%es:(%rdi)
    59c5:	aa                   	stos   %al,%es:(%rdi)
    59c6:	aa                   	stos   %al,%es:(%rdi)
    59c7:	aa                   	stos   %al,%es:(%rdi)
    59c8:	aa                   	stos   %al,%es:(%rdi)
    59c9:	aa                   	stos   %al,%es:(%rdi)
    59ca:	aa                   	stos   %al,%es:(%rdi)
    59cb:	aa                   	stos   %al,%es:(%rdi)
    59cc:	aa                   	stos   %al,%es:(%rdi)
    59cd:	aa                   	stos   %al,%es:(%rdi)
    59ce:	aa                   	stos   %al,%es:(%rdi)
    59cf:	aa                   	stos   %al,%es:(%rdi)
    59d0:	aa                   	stos   %al,%es:(%rdi)
    59d1:	aa                   	stos   %al,%es:(%rdi)
    59d2:	aa                   	stos   %al,%es:(%rdi)
    59d3:	aa                   	stos   %al,%es:(%rdi)
    59d4:	aa                   	stos   %al,%es:(%rdi)
    59d5:	aa                   	stos   %al,%es:(%rdi)
    59d6:	aa                   	stos   %al,%es:(%rdi)
    59d7:	aa                   	stos   %al,%es:(%rdi)
    59d8:	aa                   	stos   %al,%es:(%rdi)
    59d9:	aa                   	stos   %al,%es:(%rdi)
    59da:	aa                   	stos   %al,%es:(%rdi)
    59db:	aa                   	stos   %al,%es:(%rdi)
    59dc:	aa                   	stos   %al,%es:(%rdi)
    59dd:	aa                   	stos   %al,%es:(%rdi)
    59de:	aa                   	stos   %al,%es:(%rdi)
    59df:	aa                   	stos   %al,%es:(%rdi)
    59e0:	aa                   	stos   %al,%es:(%rdi)
    59e1:	aa                   	stos   %al,%es:(%rdi)
    59e2:	aa                   	stos   %al,%es:(%rdi)
    59e3:	aa                   	stos   %al,%es:(%rdi)
    59e4:	aa                   	stos   %al,%es:(%rdi)
    59e5:	aa                   	stos   %al,%es:(%rdi)
    59e6:	aa                   	stos   %al,%es:(%rdi)
    59e7:	aa                   	stos   %al,%es:(%rdi)
    59e8:	aa                   	stos   %al,%es:(%rdi)
    59e9:	aa                   	stos   %al,%es:(%rdi)
    59ea:	aa                   	stos   %al,%es:(%rdi)
    59eb:	aa                   	stos   %al,%es:(%rdi)
    59ec:	aa                   	stos   %al,%es:(%rdi)
    59ed:	aa                   	stos   %al,%es:(%rdi)
    59ee:	aa                   	stos   %al,%es:(%rdi)
    59ef:	aa                   	stos   %al,%es:(%rdi)
    59f0:	aa                   	stos   %al,%es:(%rdi)
    59f1:	aa                   	stos   %al,%es:(%rdi)
    59f2:	aa                   	stos   %al,%es:(%rdi)
    59f3:	aa                   	stos   %al,%es:(%rdi)
    59f4:	aa                   	stos   %al,%es:(%rdi)
    59f5:	aa                   	stos   %al,%es:(%rdi)
    59f6:	aa                   	stos   %al,%es:(%rdi)
    59f7:	aa                   	stos   %al,%es:(%rdi)
    59f8:	aa                   	stos   %al,%es:(%rdi)
    59f9:	aa                   	stos   %al,%es:(%rdi)
    59fa:	aa                   	stos   %al,%es:(%rdi)
    59fb:	aa                   	stos   %al,%es:(%rdi)
    59fc:	aa                   	stos   %al,%es:(%rdi)
    59fd:	aa                   	stos   %al,%es:(%rdi)
    59fe:	aa                   	stos   %al,%es:(%rdi)
    59ff:	aa                   	stos   %al,%es:(%rdi)
    5a00:	aa                   	stos   %al,%es:(%rdi)
    5a01:	aa                   	stos   %al,%es:(%rdi)
    5a02:	aa                   	stos   %al,%es:(%rdi)
    5a03:	aa                   	stos   %al,%es:(%rdi)
    5a04:	aa                   	stos   %al,%es:(%rdi)
    5a05:	aa                   	stos   %al,%es:(%rdi)
    5a06:	aa                   	stos   %al,%es:(%rdi)
    5a07:	aa                   	stos   %al,%es:(%rdi)
    5a08:	aa                   	stos   %al,%es:(%rdi)
    5a09:	aa                   	stos   %al,%es:(%rdi)
    5a0a:	aa                   	stos   %al,%es:(%rdi)
    5a0b:	aa                   	stos   %al,%es:(%rdi)
    5a0c:	aa                   	stos   %al,%es:(%rdi)
    5a0d:	aa                   	stos   %al,%es:(%rdi)
    5a0e:	aa                   	stos   %al,%es:(%rdi)
    5a0f:	aa                   	stos   %al,%es:(%rdi)
    5a10:	aa                   	stos   %al,%es:(%rdi)
    5a11:	aa                   	stos   %al,%es:(%rdi)
    5a12:	aa                   	stos   %al,%es:(%rdi)
    5a13:	aa                   	stos   %al,%es:(%rdi)
    5a14:	aa                   	stos   %al,%es:(%rdi)
    5a15:	aa                   	stos   %al,%es:(%rdi)
    5a16:	aa                   	stos   %al,%es:(%rdi)
    5a17:	aa                   	stos   %al,%es:(%rdi)
    5a18:	aa                   	stos   %al,%es:(%rdi)
    5a19:	aa                   	stos   %al,%es:(%rdi)
    5a1a:	aa                   	stos   %al,%es:(%rdi)
    5a1b:	aa                   	stos   %al,%es:(%rdi)
    5a1c:	aa                   	stos   %al,%es:(%rdi)
    5a1d:	aa                   	stos   %al,%es:(%rdi)
    5a1e:	aa                   	stos   %al,%es:(%rdi)
    5a1f:	aa                   	stos   %al,%es:(%rdi)
    5a20:	aa                   	stos   %al,%es:(%rdi)
    5a21:	aa                   	stos   %al,%es:(%rdi)
    5a22:	aa                   	stos   %al,%es:(%rdi)
    5a23:	aa                   	stos   %al,%es:(%rdi)
    5a24:	aa                   	stos   %al,%es:(%rdi)
    5a25:	aa                   	stos   %al,%es:(%rdi)
    5a26:	aa                   	stos   %al,%es:(%rdi)
    5a27:	aa                   	stos   %al,%es:(%rdi)
    5a28:	aa                   	stos   %al,%es:(%rdi)
    5a29:	aa                   	stos   %al,%es:(%rdi)
    5a2a:	aa                   	stos   %al,%es:(%rdi)
    5a2b:	aa                   	stos   %al,%es:(%rdi)
    5a2c:	aa                   	stos   %al,%es:(%rdi)
    5a2d:	aa                   	stos   %al,%es:(%rdi)
    5a2e:	aa                   	stos   %al,%es:(%rdi)
    5a2f:	aa                   	stos   %al,%es:(%rdi)
    5a30:	aa                   	stos   %al,%es:(%rdi)
    5a31:	aa                   	stos   %al,%es:(%rdi)
    5a32:	aa                   	stos   %al,%es:(%rdi)
    5a33:	aa                   	stos   %al,%es:(%rdi)
    5a34:	aa                   	stos   %al,%es:(%rdi)
    5a35:	aa                   	stos   %al,%es:(%rdi)
    5a36:	aa                   	stos   %al,%es:(%rdi)
    5a37:	aa                   	stos   %al,%es:(%rdi)
    5a38:	aa                   	stos   %al,%es:(%rdi)
    5a39:	aa                   	stos   %al,%es:(%rdi)
    5a3a:	aa                   	stos   %al,%es:(%rdi)
    5a3b:	aa                   	stos   %al,%es:(%rdi)
    5a3c:	aa                   	stos   %al,%es:(%rdi)
    5a3d:	aa                   	stos   %al,%es:(%rdi)
    5a3e:	aa                   	stos   %al,%es:(%rdi)
    5a3f:	aa                   	stos   %al,%es:(%rdi)
    5a40:	aa                   	stos   %al,%es:(%rdi)
    5a41:	aa                   	stos   %al,%es:(%rdi)
    5a42:	aa                   	stos   %al,%es:(%rdi)
    5a43:	aa                   	stos   %al,%es:(%rdi)
    5a44:	aa                   	stos   %al,%es:(%rdi)
    5a45:	aa                   	stos   %al,%es:(%rdi)
    5a46:	aa                   	stos   %al,%es:(%rdi)
    5a47:	aa                   	stos   %al,%es:(%rdi)
    5a48:	aa                   	stos   %al,%es:(%rdi)
    5a49:	aa                   	stos   %al,%es:(%rdi)
    5a4a:	aa                   	stos   %al,%es:(%rdi)
    5a4b:	aa                   	stos   %al,%es:(%rdi)
    5a4c:	aa                   	stos   %al,%es:(%rdi)
    5a4d:	aa                   	stos   %al,%es:(%rdi)
    5a4e:	aa                   	stos   %al,%es:(%rdi)
    5a4f:	aa                   	stos   %al,%es:(%rdi)
    5a50:	aa                   	stos   %al,%es:(%rdi)
    5a51:	aa                   	stos   %al,%es:(%rdi)
    5a52:	aa                   	stos   %al,%es:(%rdi)
    5a53:	aa                   	stos   %al,%es:(%rdi)
    5a54:	aa                   	stos   %al,%es:(%rdi)
    5a55:	aa                   	stos   %al,%es:(%rdi)
    5a56:	aa                   	stos   %al,%es:(%rdi)
    5a57:	aa                   	stos   %al,%es:(%rdi)
    5a58:	aa                   	stos   %al,%es:(%rdi)
    5a59:	aa                   	stos   %al,%es:(%rdi)
    5a5a:	aa                   	stos   %al,%es:(%rdi)
    5a5b:	aa                   	stos   %al,%es:(%rdi)
    5a5c:	aa                   	stos   %al,%es:(%rdi)
    5a5d:	aa                   	stos   %al,%es:(%rdi)
    5a5e:	aa                   	stos   %al,%es:(%rdi)
    5a5f:	aa                   	stos   %al,%es:(%rdi)
    5a60:	aa                   	stos   %al,%es:(%rdi)
    5a61:	aa                   	stos   %al,%es:(%rdi)
    5a62:	aa                   	stos   %al,%es:(%rdi)
    5a63:	aa                   	stos   %al,%es:(%rdi)
    5a64:	aa                   	stos   %al,%es:(%rdi)
    5a65:	aa                   	stos   %al,%es:(%rdi)
    5a66:	aa                   	stos   %al,%es:(%rdi)
    5a67:	aa                   	stos   %al,%es:(%rdi)
    5a68:	aa                   	stos   %al,%es:(%rdi)
    5a69:	aa                   	stos   %al,%es:(%rdi)
    5a6a:	aa                   	stos   %al,%es:(%rdi)
    5a6b:	aa                   	stos   %al,%es:(%rdi)
    5a6c:	aa                   	stos   %al,%es:(%rdi)
    5a6d:	aa                   	stos   %al,%es:(%rdi)
    5a6e:	aa                   	stos   %al,%es:(%rdi)
    5a6f:	aa                   	stos   %al,%es:(%rdi)
    5a70:	aa                   	stos   %al,%es:(%rdi)
    5a71:	aa                   	stos   %al,%es:(%rdi)
    5a72:	aa                   	stos   %al,%es:(%rdi)
    5a73:	aa                   	stos   %al,%es:(%rdi)
    5a74:	aa                   	stos   %al,%es:(%rdi)
    5a75:	aa                   	stos   %al,%es:(%rdi)
    5a76:	aa                   	stos   %al,%es:(%rdi)
    5a77:	aa                   	stos   %al,%es:(%rdi)
    5a78:	aa                   	stos   %al,%es:(%rdi)
    5a79:	aa                   	stos   %al,%es:(%rdi)
    5a7a:	aa                   	stos   %al,%es:(%rdi)
    5a7b:	aa                   	stos   %al,%es:(%rdi)
    5a7c:	aa                   	stos   %al,%es:(%rdi)
    5a7d:	aa                   	stos   %al,%es:(%rdi)
    5a7e:	aa                   	stos   %al,%es:(%rdi)
    5a7f:	aa                   	stos   %al,%es:(%rdi)
    5a80:	aa                   	stos   %al,%es:(%rdi)
    5a81:	aa                   	stos   %al,%es:(%rdi)
    5a82:	aa                   	stos   %al,%es:(%rdi)
    5a83:	aa                   	stos   %al,%es:(%rdi)
    5a84:	aa                   	stos   %al,%es:(%rdi)
    5a85:	aa                   	stos   %al,%es:(%rdi)
    5a86:	aa                   	stos   %al,%es:(%rdi)
    5a87:	aa                   	stos   %al,%es:(%rdi)
    5a88:	aa                   	stos   %al,%es:(%rdi)
    5a89:	aa                   	stos   %al,%es:(%rdi)
    5a8a:	aa                   	stos   %al,%es:(%rdi)
    5a8b:	aa                   	stos   %al,%es:(%rdi)
    5a8c:	aa                   	stos   %al,%es:(%rdi)
    5a8d:	aa                   	stos   %al,%es:(%rdi)
    5a8e:	aa                   	stos   %al,%es:(%rdi)
    5a8f:	aa                   	stos   %al,%es:(%rdi)
    5a90:	aa                   	stos   %al,%es:(%rdi)
    5a91:	aa                   	stos   %al,%es:(%rdi)
    5a92:	aa                   	stos   %al,%es:(%rdi)
    5a93:	aa                   	stos   %al,%es:(%rdi)
    5a94:	aa                   	stos   %al,%es:(%rdi)
    5a95:	aa                   	stos   %al,%es:(%rdi)
    5a96:	aa                   	stos   %al,%es:(%rdi)
    5a97:	aa                   	stos   %al,%es:(%rdi)
    5a98:	aa                   	stos   %al,%es:(%rdi)
    5a99:	aa                   	stos   %al,%es:(%rdi)
    5a9a:	aa                   	stos   %al,%es:(%rdi)
    5a9b:	aa                   	stos   %al,%es:(%rdi)
    5a9c:	aa                   	stos   %al,%es:(%rdi)
    5a9d:	aa                   	stos   %al,%es:(%rdi)
    5a9e:	aa                   	stos   %al,%es:(%rdi)
    5a9f:	aa                   	stos   %al,%es:(%rdi)
    5aa0:	aa                   	stos   %al,%es:(%rdi)
    5aa1:	aa                   	stos   %al,%es:(%rdi)
    5aa2:	aa                   	stos   %al,%es:(%rdi)
    5aa3:	aa                   	stos   %al,%es:(%rdi)
    5aa4:	aa                   	stos   %al,%es:(%rdi)
    5aa5:	aa                   	stos   %al,%es:(%rdi)
    5aa6:	aa                   	stos   %al,%es:(%rdi)
    5aa7:	aa                   	stos   %al,%es:(%rdi)
    5aa8:	aa                   	stos   %al,%es:(%rdi)
    5aa9:	aa                   	stos   %al,%es:(%rdi)
    5aaa:	aa                   	stos   %al,%es:(%rdi)
    5aab:	aa                   	stos   %al,%es:(%rdi)
    5aac:	aa                   	stos   %al,%es:(%rdi)
    5aad:	aa                   	stos   %al,%es:(%rdi)
    5aae:	aa                   	stos   %al,%es:(%rdi)
    5aaf:	aa                   	stos   %al,%es:(%rdi)
    5ab0:	aa                   	stos   %al,%es:(%rdi)
    5ab1:	aa                   	stos   %al,%es:(%rdi)
    5ab2:	aa                   	stos   %al,%es:(%rdi)
    5ab3:	aa                   	stos   %al,%es:(%rdi)
    5ab4:	aa                   	stos   %al,%es:(%rdi)
    5ab5:	aa                   	stos   %al,%es:(%rdi)
    5ab6:	aa                   	stos   %al,%es:(%rdi)
    5ab7:	aa                   	stos   %al,%es:(%rdi)
    5ab8:	aa                   	stos   %al,%es:(%rdi)
    5ab9:	aa                   	stos   %al,%es:(%rdi)
    5aba:	aa                   	stos   %al,%es:(%rdi)
    5abb:	aa                   	stos   %al,%es:(%rdi)
    5abc:	aa                   	stos   %al,%es:(%rdi)
    5abd:	aa                   	stos   %al,%es:(%rdi)
    5abe:	aa                   	stos   %al,%es:(%rdi)
    5abf:	aa                   	stos   %al,%es:(%rdi)
    5ac0:	aa                   	stos   %al,%es:(%rdi)
    5ac1:	aa                   	stos   %al,%es:(%rdi)
    5ac2:	aa                   	stos   %al,%es:(%rdi)
    5ac3:	aa                   	stos   %al,%es:(%rdi)
    5ac4:	aa                   	stos   %al,%es:(%rdi)
    5ac5:	aa                   	stos   %al,%es:(%rdi)
    5ac6:	aa                   	stos   %al,%es:(%rdi)
    5ac7:	aa                   	stos   %al,%es:(%rdi)
    5ac8:	aa                   	stos   %al,%es:(%rdi)
    5ac9:	aa                   	stos   %al,%es:(%rdi)
    5aca:	aa                   	stos   %al,%es:(%rdi)
    5acb:	aa                   	stos   %al,%es:(%rdi)
    5acc:	aa                   	stos   %al,%es:(%rdi)
    5acd:	aa                   	stos   %al,%es:(%rdi)
    5ace:	aa                   	stos   %al,%es:(%rdi)
    5acf:	aa                   	stos   %al,%es:(%rdi)
    5ad0:	aa                   	stos   %al,%es:(%rdi)
    5ad1:	aa                   	stos   %al,%es:(%rdi)
    5ad2:	aa                   	stos   %al,%es:(%rdi)
    5ad3:	aa                   	stos   %al,%es:(%rdi)
    5ad4:	aa                   	stos   %al,%es:(%rdi)
    5ad5:	aa                   	stos   %al,%es:(%rdi)
    5ad6:	aa                   	stos   %al,%es:(%rdi)
    5ad7:	aa                   	stos   %al,%es:(%rdi)
    5ad8:	aa                   	stos   %al,%es:(%rdi)
    5ad9:	aa                   	stos   %al,%es:(%rdi)
    5ada:	aa                   	stos   %al,%es:(%rdi)
    5adb:	aa                   	stos   %al,%es:(%rdi)
    5adc:	aa                   	stos   %al,%es:(%rdi)
    5add:	aa                   	stos   %al,%es:(%rdi)
    5ade:	aa                   	stos   %al,%es:(%rdi)
    5adf:	aa                   	stos   %al,%es:(%rdi)
    5ae0:	aa                   	stos   %al,%es:(%rdi)
    5ae1:	aa                   	stos   %al,%es:(%rdi)
    5ae2:	aa                   	stos   %al,%es:(%rdi)
    5ae3:	aa                   	stos   %al,%es:(%rdi)
    5ae4:	aa                   	stos   %al,%es:(%rdi)
    5ae5:	aa                   	stos   %al,%es:(%rdi)
    5ae6:	aa                   	stos   %al,%es:(%rdi)
    5ae7:	aa                   	stos   %al,%es:(%rdi)
    5ae8:	aa                   	stos   %al,%es:(%rdi)
    5ae9:	aa                   	stos   %al,%es:(%rdi)
    5aea:	aa                   	stos   %al,%es:(%rdi)
    5aeb:	aa                   	stos   %al,%es:(%rdi)
    5aec:	aa                   	stos   %al,%es:(%rdi)
    5aed:	aa                   	stos   %al,%es:(%rdi)
    5aee:	aa                   	stos   %al,%es:(%rdi)
    5aef:	aa                   	stos   %al,%es:(%rdi)
    5af0:	aa                   	stos   %al,%es:(%rdi)
    5af1:	aa                   	stos   %al,%es:(%rdi)
    5af2:	aa                   	stos   %al,%es:(%rdi)
    5af3:	aa                   	stos   %al,%es:(%rdi)
    5af4:	aa                   	stos   %al,%es:(%rdi)
    5af5:	aa                   	stos   %al,%es:(%rdi)
    5af6:	aa                   	stos   %al,%es:(%rdi)
    5af7:	aa                   	stos   %al,%es:(%rdi)
    5af8:	aa                   	stos   %al,%es:(%rdi)
    5af9:	aa                   	stos   %al,%es:(%rdi)
    5afa:	aa                   	stos   %al,%es:(%rdi)
    5afb:	aa                   	stos   %al,%es:(%rdi)
    5afc:	aa                   	stos   %al,%es:(%rdi)
    5afd:	aa                   	stos   %al,%es:(%rdi)
    5afe:	aa                   	stos   %al,%es:(%rdi)
    5aff:	aa                   	stos   %al,%es:(%rdi)
    5b00:	aa                   	stos   %al,%es:(%rdi)
    5b01:	aa                   	stos   %al,%es:(%rdi)
    5b02:	aa                   	stos   %al,%es:(%rdi)
    5b03:	aa                   	stos   %al,%es:(%rdi)
    5b04:	aa                   	stos   %al,%es:(%rdi)
    5b05:	aa                   	stos   %al,%es:(%rdi)
    5b06:	aa                   	stos   %al,%es:(%rdi)
    5b07:	aa                   	stos   %al,%es:(%rdi)
    5b08:	aa                   	stos   %al,%es:(%rdi)
    5b09:	aa                   	stos   %al,%es:(%rdi)
    5b0a:	aa                   	stos   %al,%es:(%rdi)
    5b0b:	aa                   	stos   %al,%es:(%rdi)
    5b0c:	aa                   	stos   %al,%es:(%rdi)
    5b0d:	aa                   	stos   %al,%es:(%rdi)
    5b0e:	aa                   	stos   %al,%es:(%rdi)
    5b0f:	aa                   	stos   %al,%es:(%rdi)
    5b10:	aa                   	stos   %al,%es:(%rdi)
    5b11:	aa                   	stos   %al,%es:(%rdi)
    5b12:	aa                   	stos   %al,%es:(%rdi)
    5b13:	aa                   	stos   %al,%es:(%rdi)
    5b14:	aa                   	stos   %al,%es:(%rdi)
    5b15:	aa                   	stos   %al,%es:(%rdi)
    5b16:	aa                   	stos   %al,%es:(%rdi)
    5b17:	aa                   	stos   %al,%es:(%rdi)
    5b18:	aa                   	stos   %al,%es:(%rdi)
    5b19:	aa                   	stos   %al,%es:(%rdi)
    5b1a:	aa                   	stos   %al,%es:(%rdi)
    5b1b:	aa                   	stos   %al,%es:(%rdi)
    5b1c:	aa                   	stos   %al,%es:(%rdi)
    5b1d:	aa                   	stos   %al,%es:(%rdi)
    5b1e:	aa                   	stos   %al,%es:(%rdi)
    5b1f:	aa                   	stos   %al,%es:(%rdi)
    5b20:	aa                   	stos   %al,%es:(%rdi)
    5b21:	aa                   	stos   %al,%es:(%rdi)
    5b22:	aa                   	stos   %al,%es:(%rdi)
    5b23:	aa                   	stos   %al,%es:(%rdi)
    5b24:	aa                   	stos   %al,%es:(%rdi)
    5b25:	aa                   	stos   %al,%es:(%rdi)
    5b26:	aa                   	stos   %al,%es:(%rdi)
    5b27:	aa                   	stos   %al,%es:(%rdi)
    5b28:	aa                   	stos   %al,%es:(%rdi)
    5b29:	aa                   	stos   %al,%es:(%rdi)
    5b2a:	aa                   	stos   %al,%es:(%rdi)
    5b2b:	aa                   	stos   %al,%es:(%rdi)
    5b2c:	aa                   	stos   %al,%es:(%rdi)
    5b2d:	aa                   	stos   %al,%es:(%rdi)
    5b2e:	aa                   	stos   %al,%es:(%rdi)
    5b2f:	aa                   	stos   %al,%es:(%rdi)
    5b30:	aa                   	stos   %al,%es:(%rdi)
    5b31:	aa                   	stos   %al,%es:(%rdi)
    5b32:	aa                   	stos   %al,%es:(%rdi)
    5b33:	aa                   	stos   %al,%es:(%rdi)
    5b34:	aa                   	stos   %al,%es:(%rdi)
    5b35:	aa                   	stos   %al,%es:(%rdi)
    5b36:	aa                   	stos   %al,%es:(%rdi)
    5b37:	aa                   	stos   %al,%es:(%rdi)
    5b38:	aa                   	stos   %al,%es:(%rdi)
    5b39:	aa                   	stos   %al,%es:(%rdi)
    5b3a:	aa                   	stos   %al,%es:(%rdi)
    5b3b:	aa                   	stos   %al,%es:(%rdi)
    5b3c:	aa                   	stos   %al,%es:(%rdi)
    5b3d:	aa                   	stos   %al,%es:(%rdi)
    5b3e:	aa                   	stos   %al,%es:(%rdi)
    5b3f:	aa                   	stos   %al,%es:(%rdi)
    5b40:	aa                   	stos   %al,%es:(%rdi)
    5b41:	aa                   	stos   %al,%es:(%rdi)
    5b42:	aa                   	stos   %al,%es:(%rdi)
    5b43:	aa                   	stos   %al,%es:(%rdi)
    5b44:	aa                   	stos   %al,%es:(%rdi)
    5b45:	aa                   	stos   %al,%es:(%rdi)
    5b46:	aa                   	stos   %al,%es:(%rdi)
    5b47:	aa                   	stos   %al,%es:(%rdi)
    5b48:	aa                   	stos   %al,%es:(%rdi)
    5b49:	aa                   	stos   %al,%es:(%rdi)
    5b4a:	aa                   	stos   %al,%es:(%rdi)
    5b4b:	aa                   	stos   %al,%es:(%rdi)
    5b4c:	aa                   	stos   %al,%es:(%rdi)
    5b4d:	aa                   	stos   %al,%es:(%rdi)
    5b4e:	aa                   	stos   %al,%es:(%rdi)
    5b4f:	aa                   	stos   %al,%es:(%rdi)
    5b50:	aa                   	stos   %al,%es:(%rdi)
    5b51:	aa                   	stos   %al,%es:(%rdi)
    5b52:	aa                   	stos   %al,%es:(%rdi)
    5b53:	aa                   	stos   %al,%es:(%rdi)
    5b54:	aa                   	stos   %al,%es:(%rdi)
    5b55:	aa                   	stos   %al,%es:(%rdi)
    5b56:	aa                   	stos   %al,%es:(%rdi)
    5b57:	aa                   	stos   %al,%es:(%rdi)
    5b58:	aa                   	stos   %al,%es:(%rdi)
    5b59:	aa                   	stos   %al,%es:(%rdi)
    5b5a:	aa                   	stos   %al,%es:(%rdi)
    5b5b:	aa                   	stos   %al,%es:(%rdi)
    5b5c:	aa                   	stos   %al,%es:(%rdi)
    5b5d:	aa                   	stos   %al,%es:(%rdi)
    5b5e:	aa                   	stos   %al,%es:(%rdi)
    5b5f:	aa                   	stos   %al,%es:(%rdi)
    5b60:	aa                   	stos   %al,%es:(%rdi)
    5b61:	aa                   	stos   %al,%es:(%rdi)
    5b62:	aa                   	stos   %al,%es:(%rdi)
    5b63:	aa                   	stos   %al,%es:(%rdi)
    5b64:	aa                   	stos   %al,%es:(%rdi)
    5b65:	aa                   	stos   %al,%es:(%rdi)
    5b66:	aa                   	stos   %al,%es:(%rdi)
    5b67:	aa                   	stos   %al,%es:(%rdi)
    5b68:	aa                   	stos   %al,%es:(%rdi)
    5b69:	aa                   	stos   %al,%es:(%rdi)
    5b6a:	aa                   	stos   %al,%es:(%rdi)
    5b6b:	aa                   	stos   %al,%es:(%rdi)
    5b6c:	aa                   	stos   %al,%es:(%rdi)
    5b6d:	aa                   	stos   %al,%es:(%rdi)
    5b6e:	aa                   	stos   %al,%es:(%rdi)
    5b6f:	aa                   	stos   %al,%es:(%rdi)
    5b70:	aa                   	stos   %al,%es:(%rdi)
    5b71:	aa                   	stos   %al,%es:(%rdi)
    5b72:	aa                   	stos   %al,%es:(%rdi)
    5b73:	aa                   	stos   %al,%es:(%rdi)
    5b74:	aa                   	stos   %al,%es:(%rdi)
    5b75:	aa                   	stos   %al,%es:(%rdi)
    5b76:	aa                   	stos   %al,%es:(%rdi)
    5b77:	aa                   	stos   %al,%es:(%rdi)
    5b78:	aa                   	stos   %al,%es:(%rdi)
    5b79:	aa                   	stos   %al,%es:(%rdi)
    5b7a:	aa                   	stos   %al,%es:(%rdi)
    5b7b:	aa                   	stos   %al,%es:(%rdi)
    5b7c:	aa                   	stos   %al,%es:(%rdi)
    5b7d:	aa                   	stos   %al,%es:(%rdi)
    5b7e:	aa                   	stos   %al,%es:(%rdi)
    5b7f:	aa                   	stos   %al,%es:(%rdi)
    5b80:	aa                   	stos   %al,%es:(%rdi)
    5b81:	aa                   	stos   %al,%es:(%rdi)
    5b82:	aa                   	stos   %al,%es:(%rdi)
    5b83:	aa                   	stos   %al,%es:(%rdi)
    5b84:	aa                   	stos   %al,%es:(%rdi)
    5b85:	aa                   	stos   %al,%es:(%rdi)
    5b86:	aa                   	stos   %al,%es:(%rdi)
    5b87:	aa                   	stos   %al,%es:(%rdi)
    5b88:	aa                   	stos   %al,%es:(%rdi)
    5b89:	aa                   	stos   %al,%es:(%rdi)
    5b8a:	aa                   	stos   %al,%es:(%rdi)
    5b8b:	aa                   	stos   %al,%es:(%rdi)
    5b8c:	aa                   	stos   %al,%es:(%rdi)
    5b8d:	aa                   	stos   %al,%es:(%rdi)
    5b8e:	aa                   	stos   %al,%es:(%rdi)
    5b8f:	aa                   	stos   %al,%es:(%rdi)
    5b90:	aa                   	stos   %al,%es:(%rdi)
    5b91:	aa                   	stos   %al,%es:(%rdi)
    5b92:	aa                   	stos   %al,%es:(%rdi)
    5b93:	aa                   	stos   %al,%es:(%rdi)
    5b94:	aa                   	stos   %al,%es:(%rdi)
    5b95:	aa                   	stos   %al,%es:(%rdi)
    5b96:	aa                   	stos   %al,%es:(%rdi)
    5b97:	aa                   	stos   %al,%es:(%rdi)
    5b98:	aa                   	stos   %al,%es:(%rdi)
    5b99:	aa                   	stos   %al,%es:(%rdi)
    5b9a:	aa                   	stos   %al,%es:(%rdi)
    5b9b:	aa                   	stos   %al,%es:(%rdi)
    5b9c:	aa                   	stos   %al,%es:(%rdi)
    5b9d:	aa                   	stos   %al,%es:(%rdi)
    5b9e:	aa                   	stos   %al,%es:(%rdi)
    5b9f:	aa                   	stos   %al,%es:(%rdi)
    5ba0:	aa                   	stos   %al,%es:(%rdi)
    5ba1:	aa                   	stos   %al,%es:(%rdi)
    5ba2:	aa                   	stos   %al,%es:(%rdi)
    5ba3:	aa                   	stos   %al,%es:(%rdi)
    5ba4:	aa                   	stos   %al,%es:(%rdi)
    5ba5:	aa                   	stos   %al,%es:(%rdi)
    5ba6:	aa                   	stos   %al,%es:(%rdi)
    5ba7:	aa                   	stos   %al,%es:(%rdi)
    5ba8:	aa                   	stos   %al,%es:(%rdi)
    5ba9:	aa                   	stos   %al,%es:(%rdi)
    5baa:	aa                   	stos   %al,%es:(%rdi)
    5bab:	aa                   	stos   %al,%es:(%rdi)
    5bac:	aa                   	stos   %al,%es:(%rdi)
    5bad:	aa                   	stos   %al,%es:(%rdi)
    5bae:	aa                   	stos   %al,%es:(%rdi)
    5baf:	aa                   	stos   %al,%es:(%rdi)
    5bb0:	aa                   	stos   %al,%es:(%rdi)
    5bb1:	aa                   	stos   %al,%es:(%rdi)
    5bb2:	aa                   	stos   %al,%es:(%rdi)
    5bb3:	aa                   	stos   %al,%es:(%rdi)
    5bb4:	aa                   	stos   %al,%es:(%rdi)
    5bb5:	aa                   	stos   %al,%es:(%rdi)
    5bb6:	aa                   	stos   %al,%es:(%rdi)
    5bb7:	aa                   	stos   %al,%es:(%rdi)
    5bb8:	aa                   	stos   %al,%es:(%rdi)
    5bb9:	aa                   	stos   %al,%es:(%rdi)
    5bba:	aa                   	stos   %al,%es:(%rdi)
    5bbb:	aa                   	stos   %al,%es:(%rdi)
    5bbc:	aa                   	stos   %al,%es:(%rdi)
    5bbd:	aa                   	stos   %al,%es:(%rdi)
    5bbe:	aa                   	stos   %al,%es:(%rdi)
    5bbf:	aa                   	stos   %al,%es:(%rdi)
    5bc0:	aa                   	stos   %al,%es:(%rdi)
    5bc1:	aa                   	stos   %al,%es:(%rdi)
    5bc2:	aa                   	stos   %al,%es:(%rdi)
    5bc3:	aa                   	stos   %al,%es:(%rdi)
    5bc4:	aa                   	stos   %al,%es:(%rdi)
    5bc5:	aa                   	stos   %al,%es:(%rdi)
    5bc6:	aa                   	stos   %al,%es:(%rdi)
    5bc7:	aa                   	stos   %al,%es:(%rdi)
    5bc8:	aa                   	stos   %al,%es:(%rdi)
    5bc9:	aa                   	stos   %al,%es:(%rdi)
    5bca:	aa                   	stos   %al,%es:(%rdi)
    5bcb:	aa                   	stos   %al,%es:(%rdi)
    5bcc:	aa                   	stos   %al,%es:(%rdi)
    5bcd:	aa                   	stos   %al,%es:(%rdi)
    5bce:	aa                   	stos   %al,%es:(%rdi)
    5bcf:	aa                   	stos   %al,%es:(%rdi)
    5bd0:	aa                   	stos   %al,%es:(%rdi)
    5bd1:	aa                   	stos   %al,%es:(%rdi)
    5bd2:	aa                   	stos   %al,%es:(%rdi)
    5bd3:	aa                   	stos   %al,%es:(%rdi)
    5bd4:	aa                   	stos   %al,%es:(%rdi)
    5bd5:	aa                   	stos   %al,%es:(%rdi)
    5bd6:	aa                   	stos   %al,%es:(%rdi)
    5bd7:	aa                   	stos   %al,%es:(%rdi)
    5bd8:	aa                   	stos   %al,%es:(%rdi)
    5bd9:	aa                   	stos   %al,%es:(%rdi)
    5bda:	aa                   	stos   %al,%es:(%rdi)
    5bdb:	aa                   	stos   %al,%es:(%rdi)
    5bdc:	aa                   	stos   %al,%es:(%rdi)
    5bdd:	aa                   	stos   %al,%es:(%rdi)
    5bde:	aa                   	stos   %al,%es:(%rdi)
    5bdf:	aa                   	stos   %al,%es:(%rdi)
    5be0:	aa                   	stos   %al,%es:(%rdi)
    5be1:	aa                   	stos   %al,%es:(%rdi)
    5be2:	aa                   	stos   %al,%es:(%rdi)
    5be3:	aa                   	stos   %al,%es:(%rdi)
    5be4:	aa                   	stos   %al,%es:(%rdi)
    5be5:	aa                   	stos   %al,%es:(%rdi)
    5be6:	aa                   	stos   %al,%es:(%rdi)
    5be7:	aa                   	stos   %al,%es:(%rdi)
    5be8:	aa                   	stos   %al,%es:(%rdi)
    5be9:	aa                   	stos   %al,%es:(%rdi)
    5bea:	aa                   	stos   %al,%es:(%rdi)
    5beb:	aa                   	stos   %al,%es:(%rdi)
    5bec:	aa                   	stos   %al,%es:(%rdi)
    5bed:	aa                   	stos   %al,%es:(%rdi)
    5bee:	aa                   	stos   %al,%es:(%rdi)
    5bef:	aa                   	stos   %al,%es:(%rdi)
    5bf0:	aa                   	stos   %al,%es:(%rdi)
    5bf1:	aa                   	stos   %al,%es:(%rdi)
    5bf2:	aa                   	stos   %al,%es:(%rdi)
    5bf3:	aa                   	stos   %al,%es:(%rdi)
    5bf4:	aa                   	stos   %al,%es:(%rdi)
    5bf5:	aa                   	stos   %al,%es:(%rdi)
    5bf6:	aa                   	stos   %al,%es:(%rdi)
    5bf7:	aa                   	stos   %al,%es:(%rdi)
    5bf8:	aa                   	stos   %al,%es:(%rdi)
    5bf9:	aa                   	stos   %al,%es:(%rdi)
    5bfa:	aa                   	stos   %al,%es:(%rdi)
    5bfb:	aa                   	stos   %al,%es:(%rdi)
    5bfc:	aa                   	stos   %al,%es:(%rdi)
    5bfd:	aa                   	stos   %al,%es:(%rdi)
    5bfe:	aa                   	stos   %al,%es:(%rdi)
    5bff:	aa                   	stos   %al,%es:(%rdi)
    5c00:	aa                   	stos   %al,%es:(%rdi)
    5c01:	aa                   	stos   %al,%es:(%rdi)
    5c02:	aa                   	stos   %al,%es:(%rdi)
    5c03:	aa                   	stos   %al,%es:(%rdi)
    5c04:	aa                   	stos   %al,%es:(%rdi)
    5c05:	aa                   	stos   %al,%es:(%rdi)
    5c06:	aa                   	stos   %al,%es:(%rdi)
    5c07:	aa                   	stos   %al,%es:(%rdi)
    5c08:	aa                   	stos   %al,%es:(%rdi)
    5c09:	aa                   	stos   %al,%es:(%rdi)
    5c0a:	aa                   	stos   %al,%es:(%rdi)
    5c0b:	aa                   	stos   %al,%es:(%rdi)
    5c0c:	aa                   	stos   %al,%es:(%rdi)
    5c0d:	aa                   	stos   %al,%es:(%rdi)
    5c0e:	aa                   	stos   %al,%es:(%rdi)
    5c0f:	aa                   	stos   %al,%es:(%rdi)
    5c10:	aa                   	stos   %al,%es:(%rdi)
    5c11:	aa                   	stos   %al,%es:(%rdi)
    5c12:	aa                   	stos   %al,%es:(%rdi)
    5c13:	aa                   	stos   %al,%es:(%rdi)
    5c14:	aa                   	stos   %al,%es:(%rdi)
    5c15:	aa                   	stos   %al,%es:(%rdi)
    5c16:	aa                   	stos   %al,%es:(%rdi)
    5c17:	aa                   	stos   %al,%es:(%rdi)
    5c18:	aa                   	stos   %al,%es:(%rdi)
    5c19:	aa                   	stos   %al,%es:(%rdi)
    5c1a:	aa                   	stos   %al,%es:(%rdi)
    5c1b:	aa                   	stos   %al,%es:(%rdi)
    5c1c:	aa                   	stos   %al,%es:(%rdi)
    5c1d:	aa                   	stos   %al,%es:(%rdi)
    5c1e:	aa                   	stos   %al,%es:(%rdi)
    5c1f:	aa                   	stos   %al,%es:(%rdi)
    5c20:	aa                   	stos   %al,%es:(%rdi)
    5c21:	aa                   	stos   %al,%es:(%rdi)
    5c22:	aa                   	stos   %al,%es:(%rdi)
    5c23:	aa                   	stos   %al,%es:(%rdi)
    5c24:	aa                   	stos   %al,%es:(%rdi)
    5c25:	aa                   	stos   %al,%es:(%rdi)
    5c26:	aa                   	stos   %al,%es:(%rdi)
    5c27:	aa                   	stos   %al,%es:(%rdi)
    5c28:	aa                   	stos   %al,%es:(%rdi)
    5c29:	aa                   	stos   %al,%es:(%rdi)
    5c2a:	aa                   	stos   %al,%es:(%rdi)
    5c2b:	aa                   	stos   %al,%es:(%rdi)
    5c2c:	aa                   	stos   %al,%es:(%rdi)
    5c2d:	aa                   	stos   %al,%es:(%rdi)
    5c2e:	aa                   	stos   %al,%es:(%rdi)
    5c2f:	aa                   	stos   %al,%es:(%rdi)
    5c30:	aa                   	stos   %al,%es:(%rdi)
    5c31:	aa                   	stos   %al,%es:(%rdi)
    5c32:	aa                   	stos   %al,%es:(%rdi)
    5c33:	aa                   	stos   %al,%es:(%rdi)
    5c34:	aa                   	stos   %al,%es:(%rdi)
    5c35:	aa                   	stos   %al,%es:(%rdi)
    5c36:	aa                   	stos   %al,%es:(%rdi)
    5c37:	aa                   	stos   %al,%es:(%rdi)
    5c38:	aa                   	stos   %al,%es:(%rdi)
    5c39:	aa                   	stos   %al,%es:(%rdi)
    5c3a:	aa                   	stos   %al,%es:(%rdi)
    5c3b:	aa                   	stos   %al,%es:(%rdi)
    5c3c:	aa                   	stos   %al,%es:(%rdi)
    5c3d:	aa                   	stos   %al,%es:(%rdi)
    5c3e:	aa                   	stos   %al,%es:(%rdi)
    5c3f:	aa                   	stos   %al,%es:(%rdi)
    5c40:	aa                   	stos   %al,%es:(%rdi)
    5c41:	aa                   	stos   %al,%es:(%rdi)
    5c42:	aa                   	stos   %al,%es:(%rdi)
    5c43:	aa                   	stos   %al,%es:(%rdi)
    5c44:	aa                   	stos   %al,%es:(%rdi)
    5c45:	aa                   	stos   %al,%es:(%rdi)
    5c46:	aa                   	stos   %al,%es:(%rdi)
    5c47:	aa                   	stos   %al,%es:(%rdi)
    5c48:	aa                   	stos   %al,%es:(%rdi)
    5c49:	aa                   	stos   %al,%es:(%rdi)
    5c4a:	aa                   	stos   %al,%es:(%rdi)
    5c4b:	aa                   	stos   %al,%es:(%rdi)
    5c4c:	aa                   	stos   %al,%es:(%rdi)
    5c4d:	aa                   	stos   %al,%es:(%rdi)
    5c4e:	aa                   	stos   %al,%es:(%rdi)
    5c4f:	aa                   	stos   %al,%es:(%rdi)
    5c50:	aa                   	stos   %al,%es:(%rdi)
    5c51:	aa                   	stos   %al,%es:(%rdi)
    5c52:	aa                   	stos   %al,%es:(%rdi)
    5c53:	aa                   	stos   %al,%es:(%rdi)
    5c54:	aa                   	stos   %al,%es:(%rdi)
    5c55:	aa                   	stos   %al,%es:(%rdi)
    5c56:	aa                   	stos   %al,%es:(%rdi)
    5c57:	aa                   	stos   %al,%es:(%rdi)
    5c58:	aa                   	stos   %al,%es:(%rdi)
    5c59:	aa                   	stos   %al,%es:(%rdi)
    5c5a:	aa                   	stos   %al,%es:(%rdi)
    5c5b:	aa                   	stos   %al,%es:(%rdi)
    5c5c:	aa                   	stos   %al,%es:(%rdi)
    5c5d:	aa                   	stos   %al,%es:(%rdi)
    5c5e:	aa                   	stos   %al,%es:(%rdi)
    5c5f:	aa                   	stos   %al,%es:(%rdi)
    5c60:	aa                   	stos   %al,%es:(%rdi)
    5c61:	aa                   	stos   %al,%es:(%rdi)
    5c62:	aa                   	stos   %al,%es:(%rdi)
    5c63:	aa                   	stos   %al,%es:(%rdi)
    5c64:	aa                   	stos   %al,%es:(%rdi)
    5c65:	aa                   	stos   %al,%es:(%rdi)
    5c66:	aa                   	stos   %al,%es:(%rdi)
    5c67:	aa                   	stos   %al,%es:(%rdi)
    5c68:	aa                   	stos   %al,%es:(%rdi)
    5c69:	aa                   	stos   %al,%es:(%rdi)
    5c6a:	aa                   	stos   %al,%es:(%rdi)
    5c6b:	aa                   	stos   %al,%es:(%rdi)
    5c6c:	aa                   	stos   %al,%es:(%rdi)
    5c6d:	aa                   	stos   %al,%es:(%rdi)
    5c6e:	aa                   	stos   %al,%es:(%rdi)
    5c6f:	aa                   	stos   %al,%es:(%rdi)
    5c70:	aa                   	stos   %al,%es:(%rdi)
    5c71:	aa                   	stos   %al,%es:(%rdi)
    5c72:	aa                   	stos   %al,%es:(%rdi)
    5c73:	aa                   	stos   %al,%es:(%rdi)
    5c74:	aa                   	stos   %al,%es:(%rdi)
    5c75:	aa                   	stos   %al,%es:(%rdi)
    5c76:	aa                   	stos   %al,%es:(%rdi)
    5c77:	aa                   	stos   %al,%es:(%rdi)
    5c78:	aa                   	stos   %al,%es:(%rdi)
    5c79:	aa                   	stos   %al,%es:(%rdi)
    5c7a:	aa                   	stos   %al,%es:(%rdi)
    5c7b:	aa                   	stos   %al,%es:(%rdi)
    5c7c:	aa                   	stos   %al,%es:(%rdi)
    5c7d:	aa                   	stos   %al,%es:(%rdi)
    5c7e:	aa                   	stos   %al,%es:(%rdi)
    5c7f:	aa                   	stos   %al,%es:(%rdi)
    5c80:	aa                   	stos   %al,%es:(%rdi)
    5c81:	aa                   	stos   %al,%es:(%rdi)
    5c82:	aa                   	stos   %al,%es:(%rdi)
    5c83:	aa                   	stos   %al,%es:(%rdi)
    5c84:	aa                   	stos   %al,%es:(%rdi)
    5c85:	aa                   	stos   %al,%es:(%rdi)
    5c86:	aa                   	stos   %al,%es:(%rdi)
    5c87:	aa                   	stos   %al,%es:(%rdi)
    5c88:	aa                   	stos   %al,%es:(%rdi)
    5c89:	aa                   	stos   %al,%es:(%rdi)
    5c8a:	aa                   	stos   %al,%es:(%rdi)
    5c8b:	aa                   	stos   %al,%es:(%rdi)
    5c8c:	aa                   	stos   %al,%es:(%rdi)
    5c8d:	aa                   	stos   %al,%es:(%rdi)
    5c8e:	aa                   	stos   %al,%es:(%rdi)
    5c8f:	aa                   	stos   %al,%es:(%rdi)
    5c90:	aa                   	stos   %al,%es:(%rdi)
    5c91:	aa                   	stos   %al,%es:(%rdi)
    5c92:	aa                   	stos   %al,%es:(%rdi)
    5c93:	aa                   	stos   %al,%es:(%rdi)
    5c94:	aa                   	stos   %al,%es:(%rdi)
    5c95:	aa                   	stos   %al,%es:(%rdi)
    5c96:	aa                   	stos   %al,%es:(%rdi)
    5c97:	aa                   	stos   %al,%es:(%rdi)
    5c98:	aa                   	stos   %al,%es:(%rdi)
    5c99:	aa                   	stos   %al,%es:(%rdi)
    5c9a:	aa                   	stos   %al,%es:(%rdi)
    5c9b:	aa                   	stos   %al,%es:(%rdi)
    5c9c:	aa                   	stos   %al,%es:(%rdi)
    5c9d:	aa                   	stos   %al,%es:(%rdi)
    5c9e:	aa                   	stos   %al,%es:(%rdi)
    5c9f:	aa                   	stos   %al,%es:(%rdi)
    5ca0:	aa                   	stos   %al,%es:(%rdi)
    5ca1:	aa                   	stos   %al,%es:(%rdi)
    5ca2:	aa                   	stos   %al,%es:(%rdi)
    5ca3:	aa                   	stos   %al,%es:(%rdi)
    5ca4:	aa                   	stos   %al,%es:(%rdi)
    5ca5:	aa                   	stos   %al,%es:(%rdi)
    5ca6:	aa                   	stos   %al,%es:(%rdi)
    5ca7:	aa                   	stos   %al,%es:(%rdi)
    5ca8:	aa                   	stos   %al,%es:(%rdi)
    5ca9:	aa                   	stos   %al,%es:(%rdi)
    5caa:	aa                   	stos   %al,%es:(%rdi)
    5cab:	aa                   	stos   %al,%es:(%rdi)
    5cac:	aa                   	stos   %al,%es:(%rdi)
    5cad:	aa                   	stos   %al,%es:(%rdi)
    5cae:	aa                   	stos   %al,%es:(%rdi)
    5caf:	aa                   	stos   %al,%es:(%rdi)
    5cb0:	aa                   	stos   %al,%es:(%rdi)
    5cb1:	aa                   	stos   %al,%es:(%rdi)
    5cb2:	aa                   	stos   %al,%es:(%rdi)
    5cb3:	aa                   	stos   %al,%es:(%rdi)
    5cb4:	aa                   	stos   %al,%es:(%rdi)
    5cb5:	aa                   	stos   %al,%es:(%rdi)
    5cb6:	aa                   	stos   %al,%es:(%rdi)
    5cb7:	aa                   	stos   %al,%es:(%rdi)
    5cb8:	aa                   	stos   %al,%es:(%rdi)
    5cb9:	aa                   	stos   %al,%es:(%rdi)
    5cba:	aa                   	stos   %al,%es:(%rdi)
    5cbb:	aa                   	stos   %al,%es:(%rdi)
    5cbc:	aa                   	stos   %al,%es:(%rdi)
    5cbd:	aa                   	stos   %al,%es:(%rdi)
    5cbe:	aa                   	stos   %al,%es:(%rdi)
    5cbf:	aa                   	stos   %al,%es:(%rdi)
    5cc0:	aa                   	stos   %al,%es:(%rdi)
    5cc1:	aa                   	stos   %al,%es:(%rdi)
    5cc2:	aa                   	stos   %al,%es:(%rdi)
    5cc3:	aa                   	stos   %al,%es:(%rdi)
    5cc4:	aa                   	stos   %al,%es:(%rdi)
    5cc5:	aa                   	stos   %al,%es:(%rdi)
    5cc6:	aa                   	stos   %al,%es:(%rdi)
    5cc7:	aa                   	stos   %al,%es:(%rdi)
    5cc8:	aa                   	stos   %al,%es:(%rdi)
    5cc9:	aa                   	stos   %al,%es:(%rdi)
    5cca:	aa                   	stos   %al,%es:(%rdi)
    5ccb:	aa                   	stos   %al,%es:(%rdi)
    5ccc:	aa                   	stos   %al,%es:(%rdi)
    5ccd:	aa                   	stos   %al,%es:(%rdi)
    5cce:	aa                   	stos   %al,%es:(%rdi)
    5ccf:	aa                   	stos   %al,%es:(%rdi)
    5cd0:	aa                   	stos   %al,%es:(%rdi)
    5cd1:	aa                   	stos   %al,%es:(%rdi)
    5cd2:	aa                   	stos   %al,%es:(%rdi)
    5cd3:	aa                   	stos   %al,%es:(%rdi)
    5cd4:	aa                   	stos   %al,%es:(%rdi)
    5cd5:	aa                   	stos   %al,%es:(%rdi)
    5cd6:	aa                   	stos   %al,%es:(%rdi)
    5cd7:	aa                   	stos   %al,%es:(%rdi)
    5cd8:	aa                   	stos   %al,%es:(%rdi)
    5cd9:	aa                   	stos   %al,%es:(%rdi)
    5cda:	aa                   	stos   %al,%es:(%rdi)
    5cdb:	aa                   	stos   %al,%es:(%rdi)
    5cdc:	aa                   	stos   %al,%es:(%rdi)
    5cdd:	aa                   	stos   %al,%es:(%rdi)
    5cde:	aa                   	stos   %al,%es:(%rdi)
    5cdf:	aa                   	stos   %al,%es:(%rdi)
    5ce0:	aa                   	stos   %al,%es:(%rdi)
    5ce1:	aa                   	stos   %al,%es:(%rdi)
    5ce2:	aa                   	stos   %al,%es:(%rdi)
    5ce3:	aa                   	stos   %al,%es:(%rdi)
    5ce4:	aa                   	stos   %al,%es:(%rdi)
    5ce5:	aa                   	stos   %al,%es:(%rdi)
    5ce6:	aa                   	stos   %al,%es:(%rdi)
    5ce7:	aa                   	stos   %al,%es:(%rdi)
    5ce8:	aa                   	stos   %al,%es:(%rdi)
    5ce9:	aa                   	stos   %al,%es:(%rdi)
    5cea:	aa                   	stos   %al,%es:(%rdi)
    5ceb:	aa                   	stos   %al,%es:(%rdi)
    5cec:	aa                   	stos   %al,%es:(%rdi)
    5ced:	aa                   	stos   %al,%es:(%rdi)
    5cee:	aa                   	stos   %al,%es:(%rdi)
    5cef:	aa                   	stos   %al,%es:(%rdi)
    5cf0:	aa                   	stos   %al,%es:(%rdi)
    5cf1:	aa                   	stos   %al,%es:(%rdi)
    5cf2:	aa                   	stos   %al,%es:(%rdi)
    5cf3:	aa                   	stos   %al,%es:(%rdi)
    5cf4:	aa                   	stos   %al,%es:(%rdi)
    5cf5:	aa                   	stos   %al,%es:(%rdi)
    5cf6:	aa                   	stos   %al,%es:(%rdi)
    5cf7:	aa                   	stos   %al,%es:(%rdi)
    5cf8:	aa                   	stos   %al,%es:(%rdi)
    5cf9:	aa                   	stos   %al,%es:(%rdi)
    5cfa:	aa                   	stos   %al,%es:(%rdi)
    5cfb:	aa                   	stos   %al,%es:(%rdi)
    5cfc:	aa                   	stos   %al,%es:(%rdi)
    5cfd:	aa                   	stos   %al,%es:(%rdi)
    5cfe:	aa                   	stos   %al,%es:(%rdi)
    5cff:	aa                   	stos   %al,%es:(%rdi)
    5d00:	aa                   	stos   %al,%es:(%rdi)
    5d01:	aa                   	stos   %al,%es:(%rdi)
    5d02:	aa                   	stos   %al,%es:(%rdi)
    5d03:	aa                   	stos   %al,%es:(%rdi)
    5d04:	aa                   	stos   %al,%es:(%rdi)
    5d05:	aa                   	stos   %al,%es:(%rdi)
    5d06:	aa                   	stos   %al,%es:(%rdi)
    5d07:	aa                   	stos   %al,%es:(%rdi)
    5d08:	aa                   	stos   %al,%es:(%rdi)
    5d09:	aa                   	stos   %al,%es:(%rdi)
    5d0a:	aa                   	stos   %al,%es:(%rdi)
    5d0b:	aa                   	stos   %al,%es:(%rdi)
    5d0c:	aa                   	stos   %al,%es:(%rdi)
    5d0d:	aa                   	stos   %al,%es:(%rdi)
    5d0e:	aa                   	stos   %al,%es:(%rdi)
    5d0f:	aa                   	stos   %al,%es:(%rdi)
    5d10:	aa                   	stos   %al,%es:(%rdi)
    5d11:	aa                   	stos   %al,%es:(%rdi)
    5d12:	aa                   	stos   %al,%es:(%rdi)
    5d13:	aa                   	stos   %al,%es:(%rdi)
    5d14:	aa                   	stos   %al,%es:(%rdi)
    5d15:	aa                   	stos   %al,%es:(%rdi)
    5d16:	aa                   	stos   %al,%es:(%rdi)
    5d17:	aa                   	stos   %al,%es:(%rdi)
    5d18:	aa                   	stos   %al,%es:(%rdi)
    5d19:	aa                   	stos   %al,%es:(%rdi)
    5d1a:	aa                   	stos   %al,%es:(%rdi)
    5d1b:	aa                   	stos   %al,%es:(%rdi)
    5d1c:	aa                   	stos   %al,%es:(%rdi)
    5d1d:	aa                   	stos   %al,%es:(%rdi)
    5d1e:	aa                   	stos   %al,%es:(%rdi)
    5d1f:	aa                   	stos   %al,%es:(%rdi)
    5d20:	aa                   	stos   %al,%es:(%rdi)
    5d21:	aa                   	stos   %al,%es:(%rdi)
    5d22:	aa                   	stos   %al,%es:(%rdi)
    5d23:	aa                   	stos   %al,%es:(%rdi)
    5d24:	aa                   	stos   %al,%es:(%rdi)
    5d25:	aa                   	stos   %al,%es:(%rdi)
    5d26:	aa                   	stos   %al,%es:(%rdi)
    5d27:	aa                   	stos   %al,%es:(%rdi)
    5d28:	aa                   	stos   %al,%es:(%rdi)
    5d29:	aa                   	stos   %al,%es:(%rdi)
    5d2a:	aa                   	stos   %al,%es:(%rdi)
    5d2b:	aa                   	stos   %al,%es:(%rdi)
    5d2c:	aa                   	stos   %al,%es:(%rdi)
    5d2d:	aa                   	stos   %al,%es:(%rdi)
    5d2e:	aa                   	stos   %al,%es:(%rdi)
    5d2f:	aa                   	stos   %al,%es:(%rdi)
    5d30:	aa                   	stos   %al,%es:(%rdi)
    5d31:	aa                   	stos   %al,%es:(%rdi)
    5d32:	aa                   	stos   %al,%es:(%rdi)
    5d33:	aa                   	stos   %al,%es:(%rdi)
    5d34:	aa                   	stos   %al,%es:(%rdi)
    5d35:	aa                   	stos   %al,%es:(%rdi)
    5d36:	aa                   	stos   %al,%es:(%rdi)
    5d37:	aa                   	stos   %al,%es:(%rdi)
    5d38:	aa                   	stos   %al,%es:(%rdi)
    5d39:	aa                   	stos   %al,%es:(%rdi)
    5d3a:	aa                   	stos   %al,%es:(%rdi)
    5d3b:	aa                   	stos   %al,%es:(%rdi)
    5d3c:	aa                   	stos   %al,%es:(%rdi)
    5d3d:	aa                   	stos   %al,%es:(%rdi)
    5d3e:	aa                   	stos   %al,%es:(%rdi)
    5d3f:	aa                   	stos   %al,%es:(%rdi)
    5d40:	aa                   	stos   %al,%es:(%rdi)
    5d41:	aa                   	stos   %al,%es:(%rdi)
    5d42:	aa                   	stos   %al,%es:(%rdi)
    5d43:	aa                   	stos   %al,%es:(%rdi)
    5d44:	aa                   	stos   %al,%es:(%rdi)
    5d45:	aa                   	stos   %al,%es:(%rdi)
    5d46:	aa                   	stos   %al,%es:(%rdi)
    5d47:	aa                   	stos   %al,%es:(%rdi)
    5d48:	aa                   	stos   %al,%es:(%rdi)
    5d49:	aa                   	stos   %al,%es:(%rdi)
    5d4a:	aa                   	stos   %al,%es:(%rdi)
    5d4b:	aa                   	stos   %al,%es:(%rdi)
    5d4c:	aa                   	stos   %al,%es:(%rdi)
    5d4d:	aa                   	stos   %al,%es:(%rdi)
    5d4e:	aa                   	stos   %al,%es:(%rdi)
    5d4f:	aa                   	stos   %al,%es:(%rdi)
    5d50:	aa                   	stos   %al,%es:(%rdi)
    5d51:	aa                   	stos   %al,%es:(%rdi)
    5d52:	aa                   	stos   %al,%es:(%rdi)
    5d53:	aa                   	stos   %al,%es:(%rdi)
    5d54:	aa                   	stos   %al,%es:(%rdi)
    5d55:	aa                   	stos   %al,%es:(%rdi)
    5d56:	aa                   	stos   %al,%es:(%rdi)
    5d57:	aa                   	stos   %al,%es:(%rdi)
    5d58:	aa                   	stos   %al,%es:(%rdi)
    5d59:	aa                   	stos   %al,%es:(%rdi)
    5d5a:	aa                   	stos   %al,%es:(%rdi)
    5d5b:	aa                   	stos   %al,%es:(%rdi)
    5d5c:	aa                   	stos   %al,%es:(%rdi)
    5d5d:	aa                   	stos   %al,%es:(%rdi)
    5d5e:	aa                   	stos   %al,%es:(%rdi)
    5d5f:	aa                   	stos   %al,%es:(%rdi)
    5d60:	aa                   	stos   %al,%es:(%rdi)
    5d61:	aa                   	stos   %al,%es:(%rdi)
    5d62:	aa                   	stos   %al,%es:(%rdi)
    5d63:	aa                   	stos   %al,%es:(%rdi)
    5d64:	aa                   	stos   %al,%es:(%rdi)
    5d65:	aa                   	stos   %al,%es:(%rdi)
    5d66:	aa                   	stos   %al,%es:(%rdi)
    5d67:	aa                   	stos   %al,%es:(%rdi)
    5d68:	aa                   	stos   %al,%es:(%rdi)
    5d69:	aa                   	stos   %al,%es:(%rdi)
    5d6a:	aa                   	stos   %al,%es:(%rdi)
    5d6b:	aa                   	stos   %al,%es:(%rdi)
    5d6c:	aa                   	stos   %al,%es:(%rdi)
    5d6d:	aa                   	stos   %al,%es:(%rdi)
    5d6e:	aa                   	stos   %al,%es:(%rdi)
    5d6f:	aa                   	stos   %al,%es:(%rdi)
    5d70:	aa                   	stos   %al,%es:(%rdi)
    5d71:	aa                   	stos   %al,%es:(%rdi)
    5d72:	aa                   	stos   %al,%es:(%rdi)
    5d73:	aa                   	stos   %al,%es:(%rdi)
    5d74:	aa                   	stos   %al,%es:(%rdi)
    5d75:	aa                   	stos   %al,%es:(%rdi)
    5d76:	aa                   	stos   %al,%es:(%rdi)
    5d77:	aa                   	stos   %al,%es:(%rdi)
    5d78:	aa                   	stos   %al,%es:(%rdi)
    5d79:	aa                   	stos   %al,%es:(%rdi)
    5d7a:	aa                   	stos   %al,%es:(%rdi)
    5d7b:	aa                   	stos   %al,%es:(%rdi)
    5d7c:	aa                   	stos   %al,%es:(%rdi)
    5d7d:	aa                   	stos   %al,%es:(%rdi)
    5d7e:	aa                   	stos   %al,%es:(%rdi)
    5d7f:	aa                   	stos   %al,%es:(%rdi)
    5d80:	aa                   	stos   %al,%es:(%rdi)
    5d81:	aa                   	stos   %al,%es:(%rdi)
    5d82:	aa                   	stos   %al,%es:(%rdi)
    5d83:	aa                   	stos   %al,%es:(%rdi)
    5d84:	aa                   	stos   %al,%es:(%rdi)
    5d85:	aa                   	stos   %al,%es:(%rdi)
    5d86:	aa                   	stos   %al,%es:(%rdi)
    5d87:	aa                   	stos   %al,%es:(%rdi)
    5d88:	aa                   	stos   %al,%es:(%rdi)
    5d89:	aa                   	stos   %al,%es:(%rdi)
    5d8a:	aa                   	stos   %al,%es:(%rdi)
    5d8b:	aa                   	stos   %al,%es:(%rdi)
    5d8c:	aa                   	stos   %al,%es:(%rdi)
    5d8d:	aa                   	stos   %al,%es:(%rdi)
    5d8e:	aa                   	stos   %al,%es:(%rdi)
    5d8f:	aa                   	stos   %al,%es:(%rdi)
    5d90:	aa                   	stos   %al,%es:(%rdi)
    5d91:	aa                   	stos   %al,%es:(%rdi)
    5d92:	aa                   	stos   %al,%es:(%rdi)
    5d93:	aa                   	stos   %al,%es:(%rdi)
    5d94:	aa                   	stos   %al,%es:(%rdi)
    5d95:	aa                   	stos   %al,%es:(%rdi)
    5d96:	aa                   	stos   %al,%es:(%rdi)
    5d97:	aa                   	stos   %al,%es:(%rdi)
    5d98:	aa                   	stos   %al,%es:(%rdi)
    5d99:	aa                   	stos   %al,%es:(%rdi)
    5d9a:	aa                   	stos   %al,%es:(%rdi)
    5d9b:	aa                   	stos   %al,%es:(%rdi)
    5d9c:	aa                   	stos   %al,%es:(%rdi)
    5d9d:	aa                   	stos   %al,%es:(%rdi)
    5d9e:	aa                   	stos   %al,%es:(%rdi)
    5d9f:	aa                   	stos   %al,%es:(%rdi)
    5da0:	aa                   	stos   %al,%es:(%rdi)
    5da1:	aa                   	stos   %al,%es:(%rdi)
    5da2:	aa                   	stos   %al,%es:(%rdi)
    5da3:	aa                   	stos   %al,%es:(%rdi)
    5da4:	aa                   	stos   %al,%es:(%rdi)
    5da5:	aa                   	stos   %al,%es:(%rdi)
    5da6:	aa                   	stos   %al,%es:(%rdi)
    5da7:	aa                   	stos   %al,%es:(%rdi)
    5da8:	aa                   	stos   %al,%es:(%rdi)
    5da9:	aa                   	stos   %al,%es:(%rdi)
    5daa:	aa                   	stos   %al,%es:(%rdi)
    5dab:	aa                   	stos   %al,%es:(%rdi)
    5dac:	aa                   	stos   %al,%es:(%rdi)
    5dad:	aa                   	stos   %al,%es:(%rdi)
    5dae:	aa                   	stos   %al,%es:(%rdi)
    5daf:	aa                   	stos   %al,%es:(%rdi)
    5db0:	aa                   	stos   %al,%es:(%rdi)
    5db1:	aa                   	stos   %al,%es:(%rdi)
    5db2:	aa                   	stos   %al,%es:(%rdi)
    5db3:	aa                   	stos   %al,%es:(%rdi)
    5db4:	aa                   	stos   %al,%es:(%rdi)
    5db5:	aa                   	stos   %al,%es:(%rdi)
    5db6:	aa                   	stos   %al,%es:(%rdi)
    5db7:	aa                   	stos   %al,%es:(%rdi)
    5db8:	aa                   	stos   %al,%es:(%rdi)
    5db9:	aa                   	stos   %al,%es:(%rdi)
    5dba:	aa                   	stos   %al,%es:(%rdi)
    5dbb:	aa                   	stos   %al,%es:(%rdi)
    5dbc:	aa                   	stos   %al,%es:(%rdi)
    5dbd:	aa                   	stos   %al,%es:(%rdi)
    5dbe:	aa                   	stos   %al,%es:(%rdi)
    5dbf:	aa                   	stos   %al,%es:(%rdi)
    5dc0:	aa                   	stos   %al,%es:(%rdi)
    5dc1:	aa                   	stos   %al,%es:(%rdi)
    5dc2:	aa                   	stos   %al,%es:(%rdi)
    5dc3:	aa                   	stos   %al,%es:(%rdi)
    5dc4:	aa                   	stos   %al,%es:(%rdi)
    5dc5:	aa                   	stos   %al,%es:(%rdi)
    5dc6:	aa                   	stos   %al,%es:(%rdi)
    5dc7:	aa                   	stos   %al,%es:(%rdi)
    5dc8:	aa                   	stos   %al,%es:(%rdi)
    5dc9:	aa                   	stos   %al,%es:(%rdi)
    5dca:	aa                   	stos   %al,%es:(%rdi)
    5dcb:	aa                   	stos   %al,%es:(%rdi)
    5dcc:	aa                   	stos   %al,%es:(%rdi)
    5dcd:	aa                   	stos   %al,%es:(%rdi)
    5dce:	aa                   	stos   %al,%es:(%rdi)
    5dcf:	aa                   	stos   %al,%es:(%rdi)
    5dd0:	aa                   	stos   %al,%es:(%rdi)
    5dd1:	aa                   	stos   %al,%es:(%rdi)
    5dd2:	aa                   	stos   %al,%es:(%rdi)
    5dd3:	aa                   	stos   %al,%es:(%rdi)
    5dd4:	aa                   	stos   %al,%es:(%rdi)
    5dd5:	aa                   	stos   %al,%es:(%rdi)
    5dd6:	aa                   	stos   %al,%es:(%rdi)
    5dd7:	aa                   	stos   %al,%es:(%rdi)
    5dd8:	aa                   	stos   %al,%es:(%rdi)
    5dd9:	aa                   	stos   %al,%es:(%rdi)
    5dda:	aa                   	stos   %al,%es:(%rdi)
    5ddb:	aa                   	stos   %al,%es:(%rdi)
    5ddc:	aa                   	stos   %al,%es:(%rdi)
    5ddd:	aa                   	stos   %al,%es:(%rdi)
    5dde:	aa                   	stos   %al,%es:(%rdi)
    5ddf:	aa                   	stos   %al,%es:(%rdi)
    5de0:	aa                   	stos   %al,%es:(%rdi)
    5de1:	aa                   	stos   %al,%es:(%rdi)
    5de2:	aa                   	stos   %al,%es:(%rdi)
    5de3:	aa                   	stos   %al,%es:(%rdi)
    5de4:	aa                   	stos   %al,%es:(%rdi)
    5de5:	aa                   	stos   %al,%es:(%rdi)
    5de6:	aa                   	stos   %al,%es:(%rdi)
    5de7:	aa                   	stos   %al,%es:(%rdi)
    5de8:	aa                   	stos   %al,%es:(%rdi)
    5de9:	aa                   	stos   %al,%es:(%rdi)
    5dea:	aa                   	stos   %al,%es:(%rdi)
    5deb:	aa                   	stos   %al,%es:(%rdi)
    5dec:	aa                   	stos   %al,%es:(%rdi)
    5ded:	aa                   	stos   %al,%es:(%rdi)
    5dee:	aa                   	stos   %al,%es:(%rdi)
    5def:	aa                   	stos   %al,%es:(%rdi)
    5df0:	aa                   	stos   %al,%es:(%rdi)
    5df1:	aa                   	stos   %al,%es:(%rdi)
    5df2:	aa                   	stos   %al,%es:(%rdi)
    5df3:	aa                   	stos   %al,%es:(%rdi)
    5df4:	aa                   	stos   %al,%es:(%rdi)
    5df5:	aa                   	stos   %al,%es:(%rdi)
    5df6:	aa                   	stos   %al,%es:(%rdi)
    5df7:	aa                   	stos   %al,%es:(%rdi)
    5df8:	aa                   	stos   %al,%es:(%rdi)
    5df9:	aa                   	stos   %al,%es:(%rdi)
    5dfa:	aa                   	stos   %al,%es:(%rdi)
    5dfb:	aa                   	stos   %al,%es:(%rdi)
    5dfc:	aa                   	stos   %al,%es:(%rdi)
    5dfd:	aa                   	stos   %al,%es:(%rdi)
    5dfe:	aa                   	stos   %al,%es:(%rdi)
    5dff:	aa                   	stos   %al,%es:(%rdi)
    5e00:	aa                   	stos   %al,%es:(%rdi)
    5e01:	aa                   	stos   %al,%es:(%rdi)
    5e02:	aa                   	stos   %al,%es:(%rdi)
    5e03:	aa                   	stos   %al,%es:(%rdi)
    5e04:	aa                   	stos   %al,%es:(%rdi)
    5e05:	aa                   	stos   %al,%es:(%rdi)
    5e06:	aa                   	stos   %al,%es:(%rdi)
    5e07:	aa                   	stos   %al,%es:(%rdi)
    5e08:	aa                   	stos   %al,%es:(%rdi)
    5e09:	aa                   	stos   %al,%es:(%rdi)
    5e0a:	aa                   	stos   %al,%es:(%rdi)
    5e0b:	aa                   	stos   %al,%es:(%rdi)
    5e0c:	aa                   	stos   %al,%es:(%rdi)
    5e0d:	aa                   	stos   %al,%es:(%rdi)
    5e0e:	aa                   	stos   %al,%es:(%rdi)
    5e0f:	aa                   	stos   %al,%es:(%rdi)
    5e10:	aa                   	stos   %al,%es:(%rdi)
    5e11:	aa                   	stos   %al,%es:(%rdi)
    5e12:	aa                   	stos   %al,%es:(%rdi)
    5e13:	aa                   	stos   %al,%es:(%rdi)
    5e14:	aa                   	stos   %al,%es:(%rdi)
    5e15:	aa                   	stos   %al,%es:(%rdi)
    5e16:	aa                   	stos   %al,%es:(%rdi)
    5e17:	aa                   	stos   %al,%es:(%rdi)
    5e18:	aa                   	stos   %al,%es:(%rdi)
    5e19:	aa                   	stos   %al,%es:(%rdi)
    5e1a:	aa                   	stos   %al,%es:(%rdi)
    5e1b:	aa                   	stos   %al,%es:(%rdi)
    5e1c:	aa                   	stos   %al,%es:(%rdi)
    5e1d:	aa                   	stos   %al,%es:(%rdi)
    5e1e:	aa                   	stos   %al,%es:(%rdi)
    5e1f:	aa                   	stos   %al,%es:(%rdi)
    5e20:	aa                   	stos   %al,%es:(%rdi)
    5e21:	aa                   	stos   %al,%es:(%rdi)
    5e22:	aa                   	stos   %al,%es:(%rdi)
    5e23:	aa                   	stos   %al,%es:(%rdi)
    5e24:	aa                   	stos   %al,%es:(%rdi)
    5e25:	aa                   	stos   %al,%es:(%rdi)
    5e26:	aa                   	stos   %al,%es:(%rdi)
    5e27:	aa                   	stos   %al,%es:(%rdi)
    5e28:	aa                   	stos   %al,%es:(%rdi)
    5e29:	aa                   	stos   %al,%es:(%rdi)
    5e2a:	aa                   	stos   %al,%es:(%rdi)
    5e2b:	aa                   	stos   %al,%es:(%rdi)
    5e2c:	aa                   	stos   %al,%es:(%rdi)
    5e2d:	aa                   	stos   %al,%es:(%rdi)
    5e2e:	aa                   	stos   %al,%es:(%rdi)
    5e2f:	aa                   	stos   %al,%es:(%rdi)
    5e30:	aa                   	stos   %al,%es:(%rdi)
    5e31:	aa                   	stos   %al,%es:(%rdi)
    5e32:	aa                   	stos   %al,%es:(%rdi)
    5e33:	aa                   	stos   %al,%es:(%rdi)
    5e34:	aa                   	stos   %al,%es:(%rdi)
    5e35:	aa                   	stos   %al,%es:(%rdi)
    5e36:	aa                   	stos   %al,%es:(%rdi)
    5e37:	aa                   	stos   %al,%es:(%rdi)
    5e38:	aa                   	stos   %al,%es:(%rdi)
    5e39:	aa                   	stos   %al,%es:(%rdi)
    5e3a:	aa                   	stos   %al,%es:(%rdi)
    5e3b:	aa                   	stos   %al,%es:(%rdi)
    5e3c:	aa                   	stos   %al,%es:(%rdi)
    5e3d:	aa                   	stos   %al,%es:(%rdi)
    5e3e:	aa                   	stos   %al,%es:(%rdi)
    5e3f:	aa                   	stos   %al,%es:(%rdi)
    5e40:	aa                   	stos   %al,%es:(%rdi)
    5e41:	aa                   	stos   %al,%es:(%rdi)
    5e42:	aa                   	stos   %al,%es:(%rdi)
    5e43:	aa                   	stos   %al,%es:(%rdi)
    5e44:	aa                   	stos   %al,%es:(%rdi)
    5e45:	aa                   	stos   %al,%es:(%rdi)
    5e46:	aa                   	stos   %al,%es:(%rdi)
    5e47:	aa                   	stos   %al,%es:(%rdi)
    5e48:	aa                   	stos   %al,%es:(%rdi)
    5e49:	aa                   	stos   %al,%es:(%rdi)
    5e4a:	aa                   	stos   %al,%es:(%rdi)
    5e4b:	aa                   	stos   %al,%es:(%rdi)
    5e4c:	aa                   	stos   %al,%es:(%rdi)
    5e4d:	aa                   	stos   %al,%es:(%rdi)
    5e4e:	aa                   	stos   %al,%es:(%rdi)
    5e4f:	aa                   	stos   %al,%es:(%rdi)
    5e50:	aa                   	stos   %al,%es:(%rdi)
    5e51:	aa                   	stos   %al,%es:(%rdi)
    5e52:	aa                   	stos   %al,%es:(%rdi)
    5e53:	aa                   	stos   %al,%es:(%rdi)
    5e54:	aa                   	stos   %al,%es:(%rdi)
    5e55:	aa                   	stos   %al,%es:(%rdi)
    5e56:	aa                   	stos   %al,%es:(%rdi)
    5e57:	aa                   	stos   %al,%es:(%rdi)
    5e58:	aa                   	stos   %al,%es:(%rdi)
    5e59:	aa                   	stos   %al,%es:(%rdi)
    5e5a:	aa                   	stos   %al,%es:(%rdi)
    5e5b:	aa                   	stos   %al,%es:(%rdi)
    5e5c:	aa                   	stos   %al,%es:(%rdi)
    5e5d:	aa                   	stos   %al,%es:(%rdi)
    5e5e:	aa                   	stos   %al,%es:(%rdi)
    5e5f:	aa                   	stos   %al,%es:(%rdi)
    5e60:	aa                   	stos   %al,%es:(%rdi)
    5e61:	aa                   	stos   %al,%es:(%rdi)
    5e62:	aa                   	stos   %al,%es:(%rdi)
    5e63:	aa                   	stos   %al,%es:(%rdi)
    5e64:	aa                   	stos   %al,%es:(%rdi)
    5e65:	aa                   	stos   %al,%es:(%rdi)
    5e66:	aa                   	stos   %al,%es:(%rdi)
    5e67:	aa                   	stos   %al,%es:(%rdi)
    5e68:	aa                   	stos   %al,%es:(%rdi)
    5e69:	aa                   	stos   %al,%es:(%rdi)
    5e6a:	aa                   	stos   %al,%es:(%rdi)
    5e6b:	aa                   	stos   %al,%es:(%rdi)
    5e6c:	aa                   	stos   %al,%es:(%rdi)
    5e6d:	aa                   	stos   %al,%es:(%rdi)
    5e6e:	aa                   	stos   %al,%es:(%rdi)
    5e6f:	aa                   	stos   %al,%es:(%rdi)
    5e70:	aa                   	stos   %al,%es:(%rdi)
    5e71:	aa                   	stos   %al,%es:(%rdi)
    5e72:	aa                   	stos   %al,%es:(%rdi)
    5e73:	aa                   	stos   %al,%es:(%rdi)
    5e74:	aa                   	stos   %al,%es:(%rdi)
    5e75:	aa                   	stos   %al,%es:(%rdi)
    5e76:	aa                   	stos   %al,%es:(%rdi)
    5e77:	aa                   	stos   %al,%es:(%rdi)
    5e78:	aa                   	stos   %al,%es:(%rdi)
    5e79:	aa                   	stos   %al,%es:(%rdi)
    5e7a:	aa                   	stos   %al,%es:(%rdi)
    5e7b:	aa                   	stos   %al,%es:(%rdi)
    5e7c:	aa                   	stos   %al,%es:(%rdi)
    5e7d:	aa                   	stos   %al,%es:(%rdi)
    5e7e:	aa                   	stos   %al,%es:(%rdi)
    5e7f:	aa                   	stos   %al,%es:(%rdi)
    5e80:	aa                   	stos   %al,%es:(%rdi)
    5e81:	aa                   	stos   %al,%es:(%rdi)
    5e82:	aa                   	stos   %al,%es:(%rdi)
    5e83:	aa                   	stos   %al,%es:(%rdi)
    5e84:	aa                   	stos   %al,%es:(%rdi)
    5e85:	aa                   	stos   %al,%es:(%rdi)
    5e86:	aa                   	stos   %al,%es:(%rdi)
    5e87:	aa                   	stos   %al,%es:(%rdi)
    5e88:	aa                   	stos   %al,%es:(%rdi)
    5e89:	aa                   	stos   %al,%es:(%rdi)
    5e8a:	aa                   	stos   %al,%es:(%rdi)
    5e8b:	aa                   	stos   %al,%es:(%rdi)
    5e8c:	aa                   	stos   %al,%es:(%rdi)
    5e8d:	aa                   	stos   %al,%es:(%rdi)
    5e8e:	aa                   	stos   %al,%es:(%rdi)
    5e8f:	aa                   	stos   %al,%es:(%rdi)
    5e90:	aa                   	stos   %al,%es:(%rdi)
    5e91:	aa                   	stos   %al,%es:(%rdi)
    5e92:	aa                   	stos   %al,%es:(%rdi)
    5e93:	aa                   	stos   %al,%es:(%rdi)
    5e94:	aa                   	stos   %al,%es:(%rdi)
    5e95:	aa                   	stos   %al,%es:(%rdi)
    5e96:	aa                   	stos   %al,%es:(%rdi)
    5e97:	aa                   	stos   %al,%es:(%rdi)
    5e98:	aa                   	stos   %al,%es:(%rdi)
    5e99:	aa                   	stos   %al,%es:(%rdi)
    5e9a:	aa                   	stos   %al,%es:(%rdi)
    5e9b:	aa                   	stos   %al,%es:(%rdi)
    5e9c:	aa                   	stos   %al,%es:(%rdi)
    5e9d:	aa                   	stos   %al,%es:(%rdi)
    5e9e:	aa                   	stos   %al,%es:(%rdi)
    5e9f:	aa                   	stos   %al,%es:(%rdi)
    5ea0:	aa                   	stos   %al,%es:(%rdi)
    5ea1:	aa                   	stos   %al,%es:(%rdi)
    5ea2:	aa                   	stos   %al,%es:(%rdi)
    5ea3:	aa                   	stos   %al,%es:(%rdi)
    5ea4:	aa                   	stos   %al,%es:(%rdi)
    5ea5:	aa                   	stos   %al,%es:(%rdi)
    5ea6:	aa                   	stos   %al,%es:(%rdi)
    5ea7:	aa                   	stos   %al,%es:(%rdi)
    5ea8:	aa                   	stos   %al,%es:(%rdi)
    5ea9:	aa                   	stos   %al,%es:(%rdi)
    5eaa:	aa                   	stos   %al,%es:(%rdi)
    5eab:	aa                   	stos   %al,%es:(%rdi)
    5eac:	aa                   	stos   %al,%es:(%rdi)
    5ead:	aa                   	stos   %al,%es:(%rdi)
    5eae:	aa                   	stos   %al,%es:(%rdi)
    5eaf:	aa                   	stos   %al,%es:(%rdi)
    5eb0:	aa                   	stos   %al,%es:(%rdi)
    5eb1:	aa                   	stos   %al,%es:(%rdi)
    5eb2:	aa                   	stos   %al,%es:(%rdi)
    5eb3:	aa                   	stos   %al,%es:(%rdi)
    5eb4:	aa                   	stos   %al,%es:(%rdi)
    5eb5:	aa                   	stos   %al,%es:(%rdi)
    5eb6:	aa                   	stos   %al,%es:(%rdi)
    5eb7:	aa                   	stos   %al,%es:(%rdi)
    5eb8:	aa                   	stos   %al,%es:(%rdi)
    5eb9:	aa                   	stos   %al,%es:(%rdi)
    5eba:	aa                   	stos   %al,%es:(%rdi)
    5ebb:	aa                   	stos   %al,%es:(%rdi)
    5ebc:	aa                   	stos   %al,%es:(%rdi)
    5ebd:	aa                   	stos   %al,%es:(%rdi)
    5ebe:	aa                   	stos   %al,%es:(%rdi)
    5ebf:	aa                   	stos   %al,%es:(%rdi)
    5ec0:	aa                   	stos   %al,%es:(%rdi)
    5ec1:	aa                   	stos   %al,%es:(%rdi)
    5ec2:	aa                   	stos   %al,%es:(%rdi)
    5ec3:	aa                   	stos   %al,%es:(%rdi)
    5ec4:	aa                   	stos   %al,%es:(%rdi)
    5ec5:	aa                   	stos   %al,%es:(%rdi)
    5ec6:	aa                   	stos   %al,%es:(%rdi)
    5ec7:	aa                   	stos   %al,%es:(%rdi)
    5ec8:	aa                   	stos   %al,%es:(%rdi)
    5ec9:	aa                   	stos   %al,%es:(%rdi)
    5eca:	aa                   	stos   %al,%es:(%rdi)
    5ecb:	aa                   	stos   %al,%es:(%rdi)
    5ecc:	aa                   	stos   %al,%es:(%rdi)
    5ecd:	aa                   	stos   %al,%es:(%rdi)
    5ece:	aa                   	stos   %al,%es:(%rdi)
    5ecf:	aa                   	stos   %al,%es:(%rdi)
    5ed0:	aa                   	stos   %al,%es:(%rdi)
    5ed1:	aa                   	stos   %al,%es:(%rdi)
    5ed2:	aa                   	stos   %al,%es:(%rdi)
    5ed3:	aa                   	stos   %al,%es:(%rdi)
    5ed4:	aa                   	stos   %al,%es:(%rdi)
    5ed5:	aa                   	stos   %al,%es:(%rdi)
    5ed6:	aa                   	stos   %al,%es:(%rdi)
    5ed7:	aa                   	stos   %al,%es:(%rdi)
    5ed8:	aa                   	stos   %al,%es:(%rdi)
    5ed9:	aa                   	stos   %al,%es:(%rdi)
    5eda:	aa                   	stos   %al,%es:(%rdi)
    5edb:	aa                   	stos   %al,%es:(%rdi)
    5edc:	aa                   	stos   %al,%es:(%rdi)
    5edd:	aa                   	stos   %al,%es:(%rdi)
    5ede:	aa                   	stos   %al,%es:(%rdi)
    5edf:	aa                   	stos   %al,%es:(%rdi)
    5ee0:	aa                   	stos   %al,%es:(%rdi)
    5ee1:	aa                   	stos   %al,%es:(%rdi)
    5ee2:	aa                   	stos   %al,%es:(%rdi)
    5ee3:	aa                   	stos   %al,%es:(%rdi)
    5ee4:	aa                   	stos   %al,%es:(%rdi)
    5ee5:	aa                   	stos   %al,%es:(%rdi)
    5ee6:	aa                   	stos   %al,%es:(%rdi)
    5ee7:	aa                   	stos   %al,%es:(%rdi)
    5ee8:	aa                   	stos   %al,%es:(%rdi)
    5ee9:	aa                   	stos   %al,%es:(%rdi)
    5eea:	aa                   	stos   %al,%es:(%rdi)
    5eeb:	aa                   	stos   %al,%es:(%rdi)
    5eec:	aa                   	stos   %al,%es:(%rdi)
    5eed:	aa                   	stos   %al,%es:(%rdi)
    5eee:	aa                   	stos   %al,%es:(%rdi)
    5eef:	aa                   	stos   %al,%es:(%rdi)
    5ef0:	aa                   	stos   %al,%es:(%rdi)
    5ef1:	aa                   	stos   %al,%es:(%rdi)
    5ef2:	aa                   	stos   %al,%es:(%rdi)
    5ef3:	aa                   	stos   %al,%es:(%rdi)
    5ef4:	aa                   	stos   %al,%es:(%rdi)
    5ef5:	aa                   	stos   %al,%es:(%rdi)
    5ef6:	aa                   	stos   %al,%es:(%rdi)
    5ef7:	aa                   	stos   %al,%es:(%rdi)
    5ef8:	aa                   	stos   %al,%es:(%rdi)
    5ef9:	aa                   	stos   %al,%es:(%rdi)
    5efa:	aa                   	stos   %al,%es:(%rdi)
    5efb:	aa                   	stos   %al,%es:(%rdi)
    5efc:	aa                   	stos   %al,%es:(%rdi)
    5efd:	aa                   	stos   %al,%es:(%rdi)
    5efe:	aa                   	stos   %al,%es:(%rdi)
    5eff:	aa                   	stos   %al,%es:(%rdi)
    5f00:	aa                   	stos   %al,%es:(%rdi)
    5f01:	aa                   	stos   %al,%es:(%rdi)
    5f02:	aa                   	stos   %al,%es:(%rdi)
    5f03:	aa                   	stos   %al,%es:(%rdi)
    5f04:	aa                   	stos   %al,%es:(%rdi)
    5f05:	aa                   	stos   %al,%es:(%rdi)
    5f06:	aa                   	stos   %al,%es:(%rdi)
    5f07:	aa                   	stos   %al,%es:(%rdi)
    5f08:	aa                   	stos   %al,%es:(%rdi)
    5f09:	aa                   	stos   %al,%es:(%rdi)
    5f0a:	aa                   	stos   %al,%es:(%rdi)
    5f0b:	aa                   	stos   %al,%es:(%rdi)
    5f0c:	aa                   	stos   %al,%es:(%rdi)
    5f0d:	aa                   	stos   %al,%es:(%rdi)
    5f0e:	aa                   	stos   %al,%es:(%rdi)
    5f0f:	aa                   	stos   %al,%es:(%rdi)
    5f10:	aa                   	stos   %al,%es:(%rdi)
    5f11:	aa                   	stos   %al,%es:(%rdi)
    5f12:	aa                   	stos   %al,%es:(%rdi)
    5f13:	aa                   	stos   %al,%es:(%rdi)
    5f14:	aa                   	stos   %al,%es:(%rdi)
    5f15:	aa                   	stos   %al,%es:(%rdi)
    5f16:	aa                   	stos   %al,%es:(%rdi)
    5f17:	aa                   	stos   %al,%es:(%rdi)
    5f18:	aa                   	stos   %al,%es:(%rdi)
    5f19:	aa                   	stos   %al,%es:(%rdi)
    5f1a:	aa                   	stos   %al,%es:(%rdi)
    5f1b:	aa                   	stos   %al,%es:(%rdi)
    5f1c:	aa                   	stos   %al,%es:(%rdi)
    5f1d:	aa                   	stos   %al,%es:(%rdi)
    5f1e:	aa                   	stos   %al,%es:(%rdi)
    5f1f:	aa                   	stos   %al,%es:(%rdi)
    5f20:	aa                   	stos   %al,%es:(%rdi)
    5f21:	aa                   	stos   %al,%es:(%rdi)
    5f22:	aa                   	stos   %al,%es:(%rdi)
    5f23:	aa                   	stos   %al,%es:(%rdi)
    5f24:	aa                   	stos   %al,%es:(%rdi)
    5f25:	aa                   	stos   %al,%es:(%rdi)
    5f26:	aa                   	stos   %al,%es:(%rdi)
    5f27:	aa                   	stos   %al,%es:(%rdi)
    5f28:	aa                   	stos   %al,%es:(%rdi)
    5f29:	aa                   	stos   %al,%es:(%rdi)
    5f2a:	aa                   	stos   %al,%es:(%rdi)
    5f2b:	aa                   	stos   %al,%es:(%rdi)
    5f2c:	aa                   	stos   %al,%es:(%rdi)
    5f2d:	aa                   	stos   %al,%es:(%rdi)
    5f2e:	aa                   	stos   %al,%es:(%rdi)
    5f2f:	aa                   	stos   %al,%es:(%rdi)
    5f30:	aa                   	stos   %al,%es:(%rdi)
    5f31:	aa                   	stos   %al,%es:(%rdi)
    5f32:	aa                   	stos   %al,%es:(%rdi)
    5f33:	aa                   	stos   %al,%es:(%rdi)
    5f34:	aa                   	stos   %al,%es:(%rdi)
    5f35:	aa                   	stos   %al,%es:(%rdi)
    5f36:	aa                   	stos   %al,%es:(%rdi)
    5f37:	aa                   	stos   %al,%es:(%rdi)
    5f38:	aa                   	stos   %al,%es:(%rdi)
    5f39:	aa                   	stos   %al,%es:(%rdi)
    5f3a:	aa                   	stos   %al,%es:(%rdi)
    5f3b:	aa                   	stos   %al,%es:(%rdi)
    5f3c:	aa                   	stos   %al,%es:(%rdi)
    5f3d:	aa                   	stos   %al,%es:(%rdi)
    5f3e:	aa                   	stos   %al,%es:(%rdi)
    5f3f:	aa                   	stos   %al,%es:(%rdi)
    5f40:	aa                   	stos   %al,%es:(%rdi)
    5f41:	aa                   	stos   %al,%es:(%rdi)
    5f42:	aa                   	stos   %al,%es:(%rdi)
    5f43:	aa                   	stos   %al,%es:(%rdi)
    5f44:	aa                   	stos   %al,%es:(%rdi)
    5f45:	aa                   	stos   %al,%es:(%rdi)
    5f46:	aa                   	stos   %al,%es:(%rdi)
    5f47:	aa                   	stos   %al,%es:(%rdi)
    5f48:	aa                   	stos   %al,%es:(%rdi)
    5f49:	aa                   	stos   %al,%es:(%rdi)
    5f4a:	aa                   	stos   %al,%es:(%rdi)
    5f4b:	aa                   	stos   %al,%es:(%rdi)
    5f4c:	aa                   	stos   %al,%es:(%rdi)
    5f4d:	aa                   	stos   %al,%es:(%rdi)
    5f4e:	aa                   	stos   %al,%es:(%rdi)
    5f4f:	aa                   	stos   %al,%es:(%rdi)
    5f50:	aa                   	stos   %al,%es:(%rdi)
    5f51:	aa                   	stos   %al,%es:(%rdi)
    5f52:	aa                   	stos   %al,%es:(%rdi)
    5f53:	aa                   	stos   %al,%es:(%rdi)
    5f54:	aa                   	stos   %al,%es:(%rdi)
    5f55:	aa                   	stos   %al,%es:(%rdi)
    5f56:	aa                   	stos   %al,%es:(%rdi)
    5f57:	aa                   	stos   %al,%es:(%rdi)
    5f58:	aa                   	stos   %al,%es:(%rdi)
    5f59:	aa                   	stos   %al,%es:(%rdi)
    5f5a:	aa                   	stos   %al,%es:(%rdi)
    5f5b:	aa                   	stos   %al,%es:(%rdi)
    5f5c:	aa                   	stos   %al,%es:(%rdi)
    5f5d:	aa                   	stos   %al,%es:(%rdi)
    5f5e:	aa                   	stos   %al,%es:(%rdi)
    5f5f:	aa                   	stos   %al,%es:(%rdi)
    5f60:	aa                   	stos   %al,%es:(%rdi)
    5f61:	aa                   	stos   %al,%es:(%rdi)
    5f62:	aa                   	stos   %al,%es:(%rdi)
    5f63:	aa                   	stos   %al,%es:(%rdi)
    5f64:	aa                   	stos   %al,%es:(%rdi)
    5f65:	aa                   	stos   %al,%es:(%rdi)
    5f66:	aa                   	stos   %al,%es:(%rdi)
    5f67:	aa                   	stos   %al,%es:(%rdi)
    5f68:	aa                   	stos   %al,%es:(%rdi)
    5f69:	aa                   	stos   %al,%es:(%rdi)
    5f6a:	aa                   	stos   %al,%es:(%rdi)
    5f6b:	aa                   	stos   %al,%es:(%rdi)
    5f6c:	aa                   	stos   %al,%es:(%rdi)
    5f6d:	aa                   	stos   %al,%es:(%rdi)
    5f6e:	aa                   	stos   %al,%es:(%rdi)
    5f6f:	aa                   	stos   %al,%es:(%rdi)
    5f70:	aa                   	stos   %al,%es:(%rdi)
    5f71:	aa                   	stos   %al,%es:(%rdi)
    5f72:	aa                   	stos   %al,%es:(%rdi)
    5f73:	aa                   	stos   %al,%es:(%rdi)
    5f74:	aa                   	stos   %al,%es:(%rdi)
    5f75:	aa                   	stos   %al,%es:(%rdi)
    5f76:	aa                   	stos   %al,%es:(%rdi)
    5f77:	aa                   	stos   %al,%es:(%rdi)
    5f78:	aa                   	stos   %al,%es:(%rdi)
    5f79:	aa                   	stos   %al,%es:(%rdi)
    5f7a:	aa                   	stos   %al,%es:(%rdi)
    5f7b:	aa                   	stos   %al,%es:(%rdi)
    5f7c:	aa                   	stos   %al,%es:(%rdi)
    5f7d:	aa                   	stos   %al,%es:(%rdi)
    5f7e:	aa                   	stos   %al,%es:(%rdi)
    5f7f:	aa                   	stos   %al,%es:(%rdi)
    5f80:	aa                   	stos   %al,%es:(%rdi)
    5f81:	aa                   	stos   %al,%es:(%rdi)
    5f82:	aa                   	stos   %al,%es:(%rdi)
    5f83:	aa                   	stos   %al,%es:(%rdi)
    5f84:	aa                   	stos   %al,%es:(%rdi)
    5f85:	aa                   	stos   %al,%es:(%rdi)
    5f86:	aa                   	stos   %al,%es:(%rdi)
    5f87:	aa                   	stos   %al,%es:(%rdi)
    5f88:	aa                   	stos   %al,%es:(%rdi)
    5f89:	aa                   	stos   %al,%es:(%rdi)
    5f8a:	aa                   	stos   %al,%es:(%rdi)
    5f8b:	aa                   	stos   %al,%es:(%rdi)
    5f8c:	aa                   	stos   %al,%es:(%rdi)
    5f8d:	aa                   	stos   %al,%es:(%rdi)
    5f8e:	aa                   	stos   %al,%es:(%rdi)
    5f8f:	aa                   	stos   %al,%es:(%rdi)
    5f90:	aa                   	stos   %al,%es:(%rdi)
    5f91:	aa                   	stos   %al,%es:(%rdi)
    5f92:	aa                   	stos   %al,%es:(%rdi)
    5f93:	aa                   	stos   %al,%es:(%rdi)
    5f94:	aa                   	stos   %al,%es:(%rdi)
    5f95:	aa                   	stos   %al,%es:(%rdi)
    5f96:	aa                   	stos   %al,%es:(%rdi)
    5f97:	aa                   	stos   %al,%es:(%rdi)
    5f98:	aa                   	stos   %al,%es:(%rdi)
    5f99:	aa                   	stos   %al,%es:(%rdi)
    5f9a:	aa                   	stos   %al,%es:(%rdi)
    5f9b:	aa                   	stos   %al,%es:(%rdi)
    5f9c:	aa                   	stos   %al,%es:(%rdi)
    5f9d:	aa                   	stos   %al,%es:(%rdi)
    5f9e:	aa                   	stos   %al,%es:(%rdi)
    5f9f:	aa                   	stos   %al,%es:(%rdi)
    5fa0:	aa                   	stos   %al,%es:(%rdi)
    5fa1:	aa                   	stos   %al,%es:(%rdi)
    5fa2:	aa                   	stos   %al,%es:(%rdi)
    5fa3:	aa                   	stos   %al,%es:(%rdi)
    5fa4:	aa                   	stos   %al,%es:(%rdi)
    5fa5:	aa                   	stos   %al,%es:(%rdi)
    5fa6:	aa                   	stos   %al,%es:(%rdi)
    5fa7:	aa                   	stos   %al,%es:(%rdi)
    5fa8:	aa                   	stos   %al,%es:(%rdi)
    5fa9:	aa                   	stos   %al,%es:(%rdi)
    5faa:	aa                   	stos   %al,%es:(%rdi)
    5fab:	aa                   	stos   %al,%es:(%rdi)
    5fac:	aa                   	stos   %al,%es:(%rdi)
    5fad:	aa                   	stos   %al,%es:(%rdi)
    5fae:	aa                   	stos   %al,%es:(%rdi)
    5faf:	aa                   	stos   %al,%es:(%rdi)
    5fb0:	aa                   	stos   %al,%es:(%rdi)
    5fb1:	aa                   	stos   %al,%es:(%rdi)
    5fb2:	aa                   	stos   %al,%es:(%rdi)
    5fb3:	aa                   	stos   %al,%es:(%rdi)
    5fb4:	aa                   	stos   %al,%es:(%rdi)
    5fb5:	aa                   	stos   %al,%es:(%rdi)
    5fb6:	aa                   	stos   %al,%es:(%rdi)
    5fb7:	aa                   	stos   %al,%es:(%rdi)
    5fb8:	aa                   	stos   %al,%es:(%rdi)
    5fb9:	aa                   	stos   %al,%es:(%rdi)
    5fba:	aa                   	stos   %al,%es:(%rdi)
    5fbb:	aa                   	stos   %al,%es:(%rdi)
    5fbc:	aa                   	stos   %al,%es:(%rdi)
    5fbd:	aa                   	stos   %al,%es:(%rdi)
    5fbe:	aa                   	stos   %al,%es:(%rdi)
    5fbf:	aa                   	stos   %al,%es:(%rdi)
    5fc0:	aa                   	stos   %al,%es:(%rdi)
    5fc1:	aa                   	stos   %al,%es:(%rdi)
    5fc2:	aa                   	stos   %al,%es:(%rdi)
    5fc3:	aa                   	stos   %al,%es:(%rdi)
    5fc4:	aa                   	stos   %al,%es:(%rdi)
    5fc5:	aa                   	stos   %al,%es:(%rdi)
    5fc6:	aa                   	stos   %al,%es:(%rdi)
    5fc7:	aa                   	stos   %al,%es:(%rdi)
    5fc8:	aa                   	stos   %al,%es:(%rdi)
    5fc9:	aa                   	stos   %al,%es:(%rdi)
    5fca:	aa                   	stos   %al,%es:(%rdi)
    5fcb:	aa                   	stos   %al,%es:(%rdi)
    5fcc:	aa                   	stos   %al,%es:(%rdi)
    5fcd:	aa                   	stos   %al,%es:(%rdi)
    5fce:	aa                   	stos   %al,%es:(%rdi)
    5fcf:	aa                   	stos   %al,%es:(%rdi)
    5fd0:	aa                   	stos   %al,%es:(%rdi)
    5fd1:	aa                   	stos   %al,%es:(%rdi)
    5fd2:	aa                   	stos   %al,%es:(%rdi)
    5fd3:	aa                   	stos   %al,%es:(%rdi)
    5fd4:	aa                   	stos   %al,%es:(%rdi)
    5fd5:	aa                   	stos   %al,%es:(%rdi)
    5fd6:	aa                   	stos   %al,%es:(%rdi)
    5fd7:	aa                   	stos   %al,%es:(%rdi)
    5fd8:	aa                   	stos   %al,%es:(%rdi)
    5fd9:	aa                   	stos   %al,%es:(%rdi)
    5fda:	aa                   	stos   %al,%es:(%rdi)
    5fdb:	aa                   	stos   %al,%es:(%rdi)
    5fdc:	aa                   	stos   %al,%es:(%rdi)
    5fdd:	aa                   	stos   %al,%es:(%rdi)
    5fde:	aa                   	stos   %al,%es:(%rdi)
    5fdf:	aa                   	stos   %al,%es:(%rdi)
    5fe0:	aa                   	stos   %al,%es:(%rdi)
    5fe1:	aa                   	stos   %al,%es:(%rdi)
    5fe2:	aa                   	stos   %al,%es:(%rdi)
    5fe3:	aa                   	stos   %al,%es:(%rdi)
    5fe4:	aa                   	stos   %al,%es:(%rdi)
    5fe5:	aa                   	stos   %al,%es:(%rdi)
    5fe6:	aa                   	stos   %al,%es:(%rdi)
    5fe7:	aa                   	stos   %al,%es:(%rdi)
    5fe8:	aa                   	stos   %al,%es:(%rdi)
    5fe9:	aa                   	stos   %al,%es:(%rdi)
    5fea:	aa                   	stos   %al,%es:(%rdi)
    5feb:	aa                   	stos   %al,%es:(%rdi)
    5fec:	aa                   	stos   %al,%es:(%rdi)
    5fed:	aa                   	stos   %al,%es:(%rdi)
    5fee:	aa                   	stos   %al,%es:(%rdi)
    5fef:	aa                   	stos   %al,%es:(%rdi)
    5ff0:	aa                   	stos   %al,%es:(%rdi)
    5ff1:	aa                   	stos   %al,%es:(%rdi)
    5ff2:	aa                   	stos   %al,%es:(%rdi)
    5ff3:	aa                   	stos   %al,%es:(%rdi)
    5ff4:	aa                   	stos   %al,%es:(%rdi)
    5ff5:	aa                   	stos   %al,%es:(%rdi)
    5ff6:	aa                   	stos   %al,%es:(%rdi)
    5ff7:	aa                   	stos   %al,%es:(%rdi)
    5ff8:	aa                   	stos   %al,%es:(%rdi)
    5ff9:	aa                   	stos   %al,%es:(%rdi)
    5ffa:	aa                   	stos   %al,%es:(%rdi)
    5ffb:	aa                   	stos   %al,%es:(%rdi)
    5ffc:	aa                   	stos   %al,%es:(%rdi)
    5ffd:	aa                   	stos   %al,%es:(%rdi)
    5ffe:	aa                   	stos   %al,%es:(%rdi)
    5fff:	aa                   	stos   %al,%es:(%rdi)

0000000000006000 <tss0>:
	...
    602c:	60 61 00 00 00 00 00 00 00 00 00 00 00 00 00 00     `a..............
	...
    604c:	00 60 00 00 00 00 00 00 00 50 00 00 00 00 00 00     .`.......P......
	...
    6064:	00 00 ff ff 40 87 12 00 00 00 00 00 00 00 00 00     ....@...........
	...

0000000000006080 <gdt>:
	...
    6088:	ff                   	(bad)  
    6089:	ff 00                	incl   (%rax)
    608b:	00 00                	add    %al,(%rax)
    608d:	9a                   	(bad)  
    608e:	cf                   	iret   
    608f:	00 ff                	add    %bh,%bh
    6091:	ff 00                	incl   (%rax)
    6093:	00 00                	add    %al,(%rax)
    6095:	92                   	xchg   %eax,%edx
    6096:	cf                   	iret   
    6097:	00 00                	add    %al,(%rax)
    6099:	00 00                	add    %al,(%rax)
    609b:	00 00                	add    %al,(%rax)
    609d:	98                   	cwtl   
    609e:	20 00                	and    %al,(%rax)
    60a0:	00 00                	add    %al,(%rax)
    60a2:	00 00                	add    %al,(%rax)
    60a4:	00 92 00 00 ff ff    	add    %dl,-0x10000(%rdx)
    60aa:	00 00                	add    %al,(%rax)
    60ac:	00 fa                	add    %bh,%dl
    60ae:	cf                   	iret   
    60af:	00 00                	add    %al,(%rax)
    60b1:	00 00                	add    %al,(%rax)
    60b3:	00 00                	add    %al,(%rax)
    60b5:	f2 00 00             	repnz add %al,(%rax)
    60b8:	00 00                	add    %al,(%rax)
    60ba:	00 00                	add    %al,(%rax)
    60bc:	00 f8                	add    %bh,%al
    60be:	20 00                	and    %al,(%rax)
    60c0:	7f 00                	jg     60c2 <gdt+0x42>
    60c2:	00 60 00             	add    %ah,0x0(%rax)
    60c5:	89 00                	mov    %eax,(%rax)
	...

00000000000060d0 <gdt48>:
    60d0:	4f                   	rex.WRXB
    60d1:	00                   	.byte 0x0
    60d2:	80 60 00 00          	andb   $0x0,0x0(%rax)

00000000000060d6 <gdt80>:
    60d6:	4f 00 80 60 00 00 00 	rex.WRXB add %r8b,0x60(%r8)
    60dd:	00 00                	add    %al,(%rax)
	...

00000000000060e0 <z_x86_trampoline_stack>:
    60e0:	aa                   	stos   %al,%es:(%rdi)
    60e1:	aa                   	stos   %al,%es:(%rdi)
    60e2:	aa                   	stos   %al,%es:(%rdi)
    60e3:	aa                   	stos   %al,%es:(%rdi)
    60e4:	aa                   	stos   %al,%es:(%rdi)
    60e5:	aa                   	stos   %al,%es:(%rdi)
    60e6:	aa                   	stos   %al,%es:(%rdi)
    60e7:	aa                   	stos   %al,%es:(%rdi)
    60e8:	aa                   	stos   %al,%es:(%rdi)
    60e9:	aa                   	stos   %al,%es:(%rdi)
    60ea:	aa                   	stos   %al,%es:(%rdi)
    60eb:	aa                   	stos   %al,%es:(%rdi)
    60ec:	aa                   	stos   %al,%es:(%rdi)
    60ed:	aa                   	stos   %al,%es:(%rdi)
    60ee:	aa                   	stos   %al,%es:(%rdi)
    60ef:	aa                   	stos   %al,%es:(%rdi)
    60f0:	aa                   	stos   %al,%es:(%rdi)
    60f1:	aa                   	stos   %al,%es:(%rdi)
    60f2:	aa                   	stos   %al,%es:(%rdi)
    60f3:	aa                   	stos   %al,%es:(%rdi)
    60f4:	aa                   	stos   %al,%es:(%rdi)
    60f5:	aa                   	stos   %al,%es:(%rdi)
    60f6:	aa                   	stos   %al,%es:(%rdi)
    60f7:	aa                   	stos   %al,%es:(%rdi)
    60f8:	aa                   	stos   %al,%es:(%rdi)
    60f9:	aa                   	stos   %al,%es:(%rdi)
    60fa:	aa                   	stos   %al,%es:(%rdi)
    60fb:	aa                   	stos   %al,%es:(%rdi)
    60fc:	aa                   	stos   %al,%es:(%rdi)
    60fd:	aa                   	stos   %al,%es:(%rdi)
    60fe:	aa                   	stos   %al,%es:(%rdi)
    60ff:	aa                   	stos   %al,%es:(%rdi)
    6100:	aa                   	stos   %al,%es:(%rdi)
    6101:	aa                   	stos   %al,%es:(%rdi)
    6102:	aa                   	stos   %al,%es:(%rdi)
    6103:	aa                   	stos   %al,%es:(%rdi)
    6104:	aa                   	stos   %al,%es:(%rdi)
    6105:	aa                   	stos   %al,%es:(%rdi)
    6106:	aa                   	stos   %al,%es:(%rdi)
    6107:	aa                   	stos   %al,%es:(%rdi)
    6108:	aa                   	stos   %al,%es:(%rdi)
    6109:	aa                   	stos   %al,%es:(%rdi)
    610a:	aa                   	stos   %al,%es:(%rdi)
    610b:	aa                   	stos   %al,%es:(%rdi)
    610c:	aa                   	stos   %al,%es:(%rdi)
    610d:	aa                   	stos   %al,%es:(%rdi)
    610e:	aa                   	stos   %al,%es:(%rdi)
    610f:	aa                   	stos   %al,%es:(%rdi)
    6110:	aa                   	stos   %al,%es:(%rdi)
    6111:	aa                   	stos   %al,%es:(%rdi)
    6112:	aa                   	stos   %al,%es:(%rdi)
    6113:	aa                   	stos   %al,%es:(%rdi)
    6114:	aa                   	stos   %al,%es:(%rdi)
    6115:	aa                   	stos   %al,%es:(%rdi)
    6116:	aa                   	stos   %al,%es:(%rdi)
    6117:	aa                   	stos   %al,%es:(%rdi)
    6118:	aa                   	stos   %al,%es:(%rdi)
    6119:	aa                   	stos   %al,%es:(%rdi)
    611a:	aa                   	stos   %al,%es:(%rdi)
    611b:	aa                   	stos   %al,%es:(%rdi)
    611c:	aa                   	stos   %al,%es:(%rdi)
    611d:	aa                   	stos   %al,%es:(%rdi)
    611e:	aa                   	stos   %al,%es:(%rdi)
    611f:	aa                   	stos   %al,%es:(%rdi)
    6120:	aa                   	stos   %al,%es:(%rdi)
    6121:	aa                   	stos   %al,%es:(%rdi)
    6122:	aa                   	stos   %al,%es:(%rdi)
    6123:	aa                   	stos   %al,%es:(%rdi)
    6124:	aa                   	stos   %al,%es:(%rdi)
    6125:	aa                   	stos   %al,%es:(%rdi)
    6126:	aa                   	stos   %al,%es:(%rdi)
    6127:	aa                   	stos   %al,%es:(%rdi)
    6128:	aa                   	stos   %al,%es:(%rdi)
    6129:	aa                   	stos   %al,%es:(%rdi)
    612a:	aa                   	stos   %al,%es:(%rdi)
    612b:	aa                   	stos   %al,%es:(%rdi)
    612c:	aa                   	stos   %al,%es:(%rdi)
    612d:	aa                   	stos   %al,%es:(%rdi)
    612e:	aa                   	stos   %al,%es:(%rdi)
    612f:	aa                   	stos   %al,%es:(%rdi)
    6130:	aa                   	stos   %al,%es:(%rdi)
    6131:	aa                   	stos   %al,%es:(%rdi)
    6132:	aa                   	stos   %al,%es:(%rdi)
    6133:	aa                   	stos   %al,%es:(%rdi)
    6134:	aa                   	stos   %al,%es:(%rdi)
    6135:	aa                   	stos   %al,%es:(%rdi)
    6136:	aa                   	stos   %al,%es:(%rdi)
    6137:	aa                   	stos   %al,%es:(%rdi)
    6138:	aa                   	stos   %al,%es:(%rdi)
    6139:	aa                   	stos   %al,%es:(%rdi)
    613a:	aa                   	stos   %al,%es:(%rdi)
    613b:	aa                   	stos   %al,%es:(%rdi)
    613c:	aa                   	stos   %al,%es:(%rdi)
    613d:	aa                   	stos   %al,%es:(%rdi)
    613e:	aa                   	stos   %al,%es:(%rdi)
    613f:	aa                   	stos   %al,%es:(%rdi)
    6140:	aa                   	stos   %al,%es:(%rdi)
    6141:	aa                   	stos   %al,%es:(%rdi)
    6142:	aa                   	stos   %al,%es:(%rdi)
    6143:	aa                   	stos   %al,%es:(%rdi)
    6144:	aa                   	stos   %al,%es:(%rdi)
    6145:	aa                   	stos   %al,%es:(%rdi)
    6146:	aa                   	stos   %al,%es:(%rdi)
    6147:	aa                   	stos   %al,%es:(%rdi)
    6148:	aa                   	stos   %al,%es:(%rdi)
    6149:	aa                   	stos   %al,%es:(%rdi)
    614a:	aa                   	stos   %al,%es:(%rdi)
    614b:	aa                   	stos   %al,%es:(%rdi)
    614c:	aa                   	stos   %al,%es:(%rdi)
    614d:	aa                   	stos   %al,%es:(%rdi)
    614e:	aa                   	stos   %al,%es:(%rdi)
    614f:	aa                   	stos   %al,%es:(%rdi)
    6150:	aa                   	stos   %al,%es:(%rdi)
    6151:	aa                   	stos   %al,%es:(%rdi)
    6152:	aa                   	stos   %al,%es:(%rdi)
    6153:	aa                   	stos   %al,%es:(%rdi)
    6154:	aa                   	stos   %al,%es:(%rdi)
    6155:	aa                   	stos   %al,%es:(%rdi)
    6156:	aa                   	stos   %al,%es:(%rdi)
    6157:	aa                   	stos   %al,%es:(%rdi)
    6158:	aa                   	stos   %al,%es:(%rdi)
    6159:	aa                   	stos   %al,%es:(%rdi)
    615a:	aa                   	stos   %al,%es:(%rdi)
    615b:	aa                   	stos   %al,%es:(%rdi)
    615c:	aa                   	stos   %al,%es:(%rdi)
    615d:	aa                   	stos   %al,%es:(%rdi)
    615e:	aa                   	stos   %al,%es:(%rdi)
    615f:	aa                   	stos   %al,%es:(%rdi)
    6160:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6167:	00 00 00 
    616a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6171:	00 00 00 
    6174:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    617b:	00 00 00 
    617e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6185:	00 00 00 
    6188:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    618f:	00 00 00 
    6192:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6199:	00 00 00 
    619c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    61a3:	00 00 00 
    61a6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    61ad:	00 00 00 
    61b0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    61b7:	00 00 00 
    61ba:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    61c1:	00 00 00 
    61c4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    61cb:	00 00 00 
    61ce:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    61d5:	00 00 00 
    61d8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    61df:	00 00 00 
    61e2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    61e9:	00 00 00 
    61ec:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    61f3:	00 00 00 
    61f6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    61fd:	00 00 00 
    6200:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6207:	00 00 00 
    620a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6211:	00 00 00 
    6214:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    621b:	00 00 00 
    621e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6225:	00 00 00 
    6228:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    622f:	00 00 00 
    6232:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6239:	00 00 00 
    623c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6243:	00 00 00 
    6246:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    624d:	00 00 00 
    6250:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6257:	00 00 00 
    625a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6261:	00 00 00 
    6264:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    626b:	00 00 00 
    626e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6275:	00 00 00 
    6278:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    627f:	00 00 00 
    6282:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6289:	00 00 00 
    628c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6293:	00 00 00 
    6296:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    629d:	00 00 00 
    62a0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    62a7:	00 00 00 
    62aa:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    62b1:	00 00 00 
    62b4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    62bb:	00 00 00 
    62be:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    62c5:	00 00 00 
    62c8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    62cf:	00 00 00 
    62d2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    62d9:	00 00 00 
    62dc:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    62e3:	00 00 00 
    62e6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    62ed:	00 00 00 
    62f0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    62f7:	00 00 00 
    62fa:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6301:	00 00 00 
    6304:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    630b:	00 00 00 
    630e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6315:	00 00 00 
    6318:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    631f:	00 00 00 
    6322:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6329:	00 00 00 
    632c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6333:	00 00 00 
    6336:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    633d:	00 00 00 
    6340:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6347:	00 00 00 
    634a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6351:	00 00 00 
    6354:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    635b:	00 00 00 
    635e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6365:	00 00 00 
    6368:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    636f:	00 00 00 
    6372:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6379:	00 00 00 
    637c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6383:	00 00 00 
    6386:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    638d:	00 00 00 
    6390:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6397:	00 00 00 
    639a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    63a1:	00 00 00 
    63a4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    63ab:	00 00 00 
    63ae:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    63b5:	00 00 00 
    63b8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    63bf:	00 00 00 
    63c2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    63c9:	00 00 00 
    63cc:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    63d3:	00 00 00 
    63d6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    63dd:	00 00 00 
    63e0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    63e7:	00 00 00 
    63ea:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    63f1:	00 00 00 
    63f4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    63fb:	00 00 00 
    63fe:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6405:	00 00 00 
    6408:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    640f:	00 00 00 
    6412:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6419:	00 00 00 
    641c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6423:	00 00 00 
    6426:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    642d:	00 00 00 
    6430:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6437:	00 00 00 
    643a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6441:	00 00 00 
    6444:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    644b:	00 00 00 
    644e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6455:	00 00 00 
    6458:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    645f:	00 00 00 
    6462:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6469:	00 00 00 
    646c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6473:	00 00 00 
    6476:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    647d:	00 00 00 
    6480:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6487:	00 00 00 
    648a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6491:	00 00 00 
    6494:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    649b:	00 00 00 
    649e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    64a5:	00 00 00 
    64a8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    64af:	00 00 00 
    64b2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    64b9:	00 00 00 
    64bc:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    64c3:	00 00 00 
    64c6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    64cd:	00 00 00 
    64d0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    64d7:	00 00 00 
    64da:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    64e1:	00 00 00 
    64e4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    64eb:	00 00 00 
    64ee:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    64f5:	00 00 00 
    64f8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    64ff:	00 00 00 
    6502:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6509:	00 00 00 
    650c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6513:	00 00 00 
    6516:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    651d:	00 00 00 
    6520:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6527:	00 00 00 
    652a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6531:	00 00 00 
    6534:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    653b:	00 00 00 
    653e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6545:	00 00 00 
    6548:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    654f:	00 00 00 
    6552:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6559:	00 00 00 
    655c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6563:	00 00 00 
    6566:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    656d:	00 00 00 
    6570:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6577:	00 00 00 
    657a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6581:	00 00 00 
    6584:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    658b:	00 00 00 
    658e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6595:	00 00 00 
    6598:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    659f:	00 00 00 
    65a2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    65a9:	00 00 00 
    65ac:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    65b3:	00 00 00 
    65b6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    65bd:	00 00 00 
    65c0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    65c7:	00 00 00 
    65ca:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    65d1:	00 00 00 
    65d4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    65db:	00 00 00 
    65de:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    65e5:	00 00 00 
    65e8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    65ef:	00 00 00 
    65f2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    65f9:	00 00 00 
    65fc:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6603:	00 00 00 
    6606:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    660d:	00 00 00 
    6610:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6617:	00 00 00 
    661a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6621:	00 00 00 
    6624:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    662b:	00 00 00 
    662e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6635:	00 00 00 
    6638:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    663f:	00 00 00 
    6642:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6649:	00 00 00 
    664c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6653:	00 00 00 
    6656:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    665d:	00 00 00 
    6660:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6667:	00 00 00 
    666a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6671:	00 00 00 
    6674:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    667b:	00 00 00 
    667e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6685:	00 00 00 
    6688:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    668f:	00 00 00 
    6692:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6699:	00 00 00 
    669c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    66a3:	00 00 00 
    66a6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    66ad:	00 00 00 
    66b0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    66b7:	00 00 00 
    66ba:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    66c1:	00 00 00 
    66c4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    66cb:	00 00 00 
    66ce:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    66d5:	00 00 00 
    66d8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    66df:	00 00 00 
    66e2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    66e9:	00 00 00 
    66ec:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    66f3:	00 00 00 
    66f6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    66fd:	00 00 00 
    6700:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6707:	00 00 00 
    670a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6711:	00 00 00 
    6714:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    671b:	00 00 00 
    671e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6725:	00 00 00 
    6728:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    672f:	00 00 00 
    6732:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6739:	00 00 00 
    673c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6743:	00 00 00 
    6746:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    674d:	00 00 00 
    6750:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6757:	00 00 00 
    675a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6761:	00 00 00 
    6764:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    676b:	00 00 00 
    676e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6775:	00 00 00 
    6778:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    677f:	00 00 00 
    6782:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6789:	00 00 00 
    678c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6793:	00 00 00 
    6796:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    679d:	00 00 00 
    67a0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    67a7:	00 00 00 
    67aa:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    67b1:	00 00 00 
    67b4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    67bb:	00 00 00 
    67be:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    67c5:	00 00 00 
    67c8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    67cf:	00 00 00 
    67d2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    67d9:	00 00 00 
    67dc:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    67e3:	00 00 00 
    67e6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    67ed:	00 00 00 
    67f0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    67f7:	00 00 00 
    67fa:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6801:	00 00 00 
    6804:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    680b:	00 00 00 
    680e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6815:	00 00 00 
    6818:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    681f:	00 00 00 
    6822:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6829:	00 00 00 
    682c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6833:	00 00 00 
    6836:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    683d:	00 00 00 
    6840:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6847:	00 00 00 
    684a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6851:	00 00 00 
    6854:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    685b:	00 00 00 
    685e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6865:	00 00 00 
    6868:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    686f:	00 00 00 
    6872:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6879:	00 00 00 
    687c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6883:	00 00 00 
    6886:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    688d:	00 00 00 
    6890:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6897:	00 00 00 
    689a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    68a1:	00 00 00 
    68a4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    68ab:	00 00 00 
    68ae:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    68b5:	00 00 00 
    68b8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    68bf:	00 00 00 
    68c2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    68c9:	00 00 00 
    68cc:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    68d3:	00 00 00 
    68d6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    68dd:	00 00 00 
    68e0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    68e7:	00 00 00 
    68ea:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    68f1:	00 00 00 
    68f4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    68fb:	00 00 00 
    68fe:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6905:	00 00 00 
    6908:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    690f:	00 00 00 
    6912:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6919:	00 00 00 
    691c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6923:	00 00 00 
    6926:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    692d:	00 00 00 
    6930:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6937:	00 00 00 
    693a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6941:	00 00 00 
    6944:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    694b:	00 00 00 
    694e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6955:	00 00 00 
    6958:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    695f:	00 00 00 
    6962:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6969:	00 00 00 
    696c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6973:	00 00 00 
    6976:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    697d:	00 00 00 
    6980:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6987:	00 00 00 
    698a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6991:	00 00 00 
    6994:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    699b:	00 00 00 
    699e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    69a5:	00 00 00 
    69a8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    69af:	00 00 00 
    69b2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    69b9:	00 00 00 
    69bc:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    69c3:	00 00 00 
    69c6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    69cd:	00 00 00 
    69d0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    69d7:	00 00 00 
    69da:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    69e1:	00 00 00 
    69e4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    69eb:	00 00 00 
    69ee:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    69f5:	00 00 00 
    69f8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    69ff:	00 00 00 
    6a02:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6a09:	00 00 00 
    6a0c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6a13:	00 00 00 
    6a16:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6a1d:	00 00 00 
    6a20:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6a27:	00 00 00 
    6a2a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6a31:	00 00 00 
    6a34:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6a3b:	00 00 00 
    6a3e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6a45:	00 00 00 
    6a48:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6a4f:	00 00 00 
    6a52:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6a59:	00 00 00 
    6a5c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6a63:	00 00 00 
    6a66:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6a6d:	00 00 00 
    6a70:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6a77:	00 00 00 
    6a7a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6a81:	00 00 00 
    6a84:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6a8b:	00 00 00 
    6a8e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6a95:	00 00 00 
    6a98:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6a9f:	00 00 00 
    6aa2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6aa9:	00 00 00 
    6aac:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6ab3:	00 00 00 
    6ab6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6abd:	00 00 00 
    6ac0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6ac7:	00 00 00 
    6aca:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6ad1:	00 00 00 
    6ad4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6adb:	00 00 00 
    6ade:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6ae5:	00 00 00 
    6ae8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6aef:	00 00 00 
    6af2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6af9:	00 00 00 
    6afc:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6b03:	00 00 00 
    6b06:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6b0d:	00 00 00 
    6b10:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6b17:	00 00 00 
    6b1a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6b21:	00 00 00 
    6b24:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6b2b:	00 00 00 
    6b2e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6b35:	00 00 00 
    6b38:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6b3f:	00 00 00 
    6b42:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6b49:	00 00 00 
    6b4c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6b53:	00 00 00 
    6b56:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6b5d:	00 00 00 
    6b60:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6b67:	00 00 00 
    6b6a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6b71:	00 00 00 
    6b74:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6b7b:	00 00 00 
    6b7e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6b85:	00 00 00 
    6b88:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6b8f:	00 00 00 
    6b92:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6b99:	00 00 00 
    6b9c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6ba3:	00 00 00 
    6ba6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6bad:	00 00 00 
    6bb0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6bb7:	00 00 00 
    6bba:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6bc1:	00 00 00 
    6bc4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6bcb:	00 00 00 
    6bce:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6bd5:	00 00 00 
    6bd8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6bdf:	00 00 00 
    6be2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6be9:	00 00 00 
    6bec:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6bf3:	00 00 00 
    6bf6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6bfd:	00 00 00 
    6c00:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6c07:	00 00 00 
    6c0a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6c11:	00 00 00 
    6c14:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6c1b:	00 00 00 
    6c1e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6c25:	00 00 00 
    6c28:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6c2f:	00 00 00 
    6c32:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6c39:	00 00 00 
    6c3c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6c43:	00 00 00 
    6c46:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6c4d:	00 00 00 
    6c50:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6c57:	00 00 00 
    6c5a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6c61:	00 00 00 
    6c64:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6c6b:	00 00 00 
    6c6e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6c75:	00 00 00 
    6c78:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6c7f:	00 00 00 
    6c82:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6c89:	00 00 00 
    6c8c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6c93:	00 00 00 
    6c96:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6c9d:	00 00 00 
    6ca0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6ca7:	00 00 00 
    6caa:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6cb1:	00 00 00 
    6cb4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6cbb:	00 00 00 
    6cbe:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6cc5:	00 00 00 
    6cc8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6ccf:	00 00 00 
    6cd2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6cd9:	00 00 00 
    6cdc:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6ce3:	00 00 00 
    6ce6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6ced:	00 00 00 
    6cf0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6cf7:	00 00 00 
    6cfa:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6d01:	00 00 00 
    6d04:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6d0b:	00 00 00 
    6d0e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6d15:	00 00 00 
    6d18:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6d1f:	00 00 00 
    6d22:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6d29:	00 00 00 
    6d2c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6d33:	00 00 00 
    6d36:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6d3d:	00 00 00 
    6d40:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6d47:	00 00 00 
    6d4a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6d51:	00 00 00 
    6d54:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6d5b:	00 00 00 
    6d5e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6d65:	00 00 00 
    6d68:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6d6f:	00 00 00 
    6d72:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6d79:	00 00 00 
    6d7c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6d83:	00 00 00 
    6d86:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6d8d:	00 00 00 
    6d90:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6d97:	00 00 00 
    6d9a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6da1:	00 00 00 
    6da4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6dab:	00 00 00 
    6dae:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6db5:	00 00 00 
    6db8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6dbf:	00 00 00 
    6dc2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6dc9:	00 00 00 
    6dcc:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6dd3:	00 00 00 
    6dd6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6ddd:	00 00 00 
    6de0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6de7:	00 00 00 
    6dea:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6df1:	00 00 00 
    6df4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6dfb:	00 00 00 
    6dfe:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6e05:	00 00 00 
    6e08:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6e0f:	00 00 00 
    6e12:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6e19:	00 00 00 
    6e1c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6e23:	00 00 00 
    6e26:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6e2d:	00 00 00 
    6e30:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6e37:	00 00 00 
    6e3a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6e41:	00 00 00 
    6e44:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6e4b:	00 00 00 
    6e4e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6e55:	00 00 00 
    6e58:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6e5f:	00 00 00 
    6e62:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6e69:	00 00 00 
    6e6c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6e73:	00 00 00 
    6e76:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6e7d:	00 00 00 
    6e80:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6e87:	00 00 00 
    6e8a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6e91:	00 00 00 
    6e94:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6e9b:	00 00 00 
    6e9e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6ea5:	00 00 00 
    6ea8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6eaf:	00 00 00 
    6eb2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6eb9:	00 00 00 
    6ebc:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6ec3:	00 00 00 
    6ec6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6ecd:	00 00 00 
    6ed0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6ed7:	00 00 00 
    6eda:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6ee1:	00 00 00 
    6ee4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6eeb:	00 00 00 
    6eee:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6ef5:	00 00 00 
    6ef8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6eff:	00 00 00 
    6f02:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6f09:	00 00 00 
    6f0c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6f13:	00 00 00 
    6f16:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6f1d:	00 00 00 
    6f20:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6f27:	00 00 00 
    6f2a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6f31:	00 00 00 
    6f34:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6f3b:	00 00 00 
    6f3e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6f45:	00 00 00 
    6f48:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6f4f:	00 00 00 
    6f52:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6f59:	00 00 00 
    6f5c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6f63:	00 00 00 
    6f66:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6f6d:	00 00 00 
    6f70:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6f77:	00 00 00 
    6f7a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6f81:	00 00 00 
    6f84:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6f8b:	00 00 00 
    6f8e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6f95:	00 00 00 
    6f98:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6f9f:	00 00 00 
    6fa2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6fa9:	00 00 00 
    6fac:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6fb3:	00 00 00 
    6fb6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6fbd:	00 00 00 
    6fc0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6fc7:	00 00 00 
    6fca:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6fd1:	00 00 00 
    6fd4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6fdb:	00 00 00 
    6fde:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6fe5:	00 00 00 
    6fe8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6fef:	00 00 00 
    6ff2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    6ff9:	00 00 00 
    6ffc:	0f 1f 40 00          	nopl   0x0(%rax)

Disassembly of section text:

0000000000100000 <__rom_region_start>:
 * 0  RIP
 */
.global z_x86_trampoline_to_user
z_x86_trampoline_to_user:
	/* Stash EDI, need a free register */
	pushq	%rdi
  100000:	57                   	push   %rdi

	/* Store old stack pointer and switch to trampoline stack */
	movq	%rsp, %rdi
  100001:	48 89 e7             	mov    %rsp,%rdi
	movq	%gs:__x86_tss64_t_ist2_OFFSET, %rsp
  100004:	65 48 8b 24 25 2c 00 	mov    %gs:0x2c,%rsp
  10000b:	00 00 

	/* Copy context */
	pushq	40(%rdi)	/* SS */
  10000d:	ff 77 28             	pushq  0x28(%rdi)
	pushq	32(%rdi)	/* RSP */
  100010:	ff 77 20             	pushq  0x20(%rdi)
	pushq	24(%rdi)	/* RFLAGS */
  100013:	ff 77 18             	pushq  0x18(%rdi)
	pushq	16(%rdi)	/* CS */
  100016:	ff 77 10             	pushq  0x10(%rdi)
	pushq   8(%rdi)		/* RIP */
  100019:	ff 77 08             	pushq  0x8(%rdi)
	xchgq	%rdi, (%rdi)	/* Exchange old rdi to restore it and put
  10001c:	48 87 3f             	xchg   %rdi,(%rdi)
				   trampoline stack address in its old storage
				   area */

	/* Switch to thread's page table */
	pushq	%rax
  10001f:	50                   	push   %rax
	movq	%gs:__x86_tss64_t_cpu_OFFSET, %rax
  100020:	65 48 8b 04 25 68 00 	mov    %gs:0x68,%rax
  100027:	00 00 
	movq	___cpu_t_current_OFFSET(%rax), %rax
  100029:	48 8b 40 10          	mov    0x10(%rax),%rax
	movq	_thread_offset_to_ptables(%rax), %rax
  10002d:	48 8b 80 78 01 00 00 	mov    0x178(%rax),%rax
	movq	%rax, %cr3
  100034:	0f 22 d8             	mov    %rax,%cr3
	popq	%rax
  100037:	58                   	pop    %rax
	movq	$0, -8(%rsp)	/* Delete stashed RAX data */
  100038:	48 c7 44 24 f8 00 00 	movq   $0x0,-0x8(%rsp)
  10003f:	00 00 

	/* Trampoline stack should have nothing sensitive in it at this point */
	swapgs
  100041:	0f 01 f8             	swapgs 
	iretq
  100044:	48 cf                	iretq  

0000000000100046 <z_x86_syscall_entry_stub>:
 * User RFLAGS store by CPU in R11
 * Current RFLAGS has been masked with ~X86_FMASK_MSR
 */
.global z_x86_syscall_entry_stub
z_x86_syscall_entry_stub:
	swapgs
  100046:	0f 01 f8             	swapgs 
	/* Save original stack pointer from user mode in memory, at the
	 * moment we have no free registers or stack to save it to. This
	 * eventually gets put on the stack before we re-enable interrupts
	 * as this is a per-cpu and not per-thread area.
	 */
	movq	%rsp, %gs:__x86_tss64_t_usp_OFFSET
  100049:	65 48 89 24 25 78 00 	mov    %rsp,%gs:0x78
  100050:	00 00 

#ifdef CONFIG_X86_KPTI
	/* We need to switch to the trampoline stack so that we can
	 * switch to the kernel's page table
	 */
	movq	%gs:__x86_tss64_t_ist2_OFFSET, %rsp
  100052:	65 48 8b 24 25 2c 00 	mov    %gs:0x2c,%rsp
  100059:	00 00 

	/* Load kernel's page table */
	pushq	%rax
  10005b:	50                   	push   %rax

	/* NOTE: Presumes phys=virt */
	movq	$Z_MEM_PHYS_ADDR(z_x86_kernel_ptables), %rax
  10005c:	48 c7 c0 00 40 6e 00 	mov    $0x6e4000,%rax
	movq	%rax, %cr3
  100063:	0f 22 d8             	mov    %rax,%cr3
	popq	%rax
  100066:	58                   	pop    %rax
	movq	$0, -8(%rsp)	/* Delete stashed RAX data */
  100067:	48 c7 44 24 f8 00 00 	movq   $0x0,-0x8(%rsp)
  10006e:	00 00 
#endif /* CONFIG_X86_KPTI */

	/* Switch to the privilege mode stack pointer stored in
	 * x86_tss64.psp
	 */
	movq	%gs:__x86_tss64_t_psp_OFFSET, %rsp
  100070:	65 48 8b 24 25 70 00 	mov    %gs:0x70,%rsp
  100077:	00 00 

	/* We're now on the privilege mode stack; push the old user stack
	 * pointer onto it
	 */
	pushq	%gs:__x86_tss64_t_usp_OFFSET
  100079:	65                   	gs
  10007a:	ff                   	.byte 0xff

000000000010007b <_kobject_text_area_used>:
  10007b:	34 25                	xor    $0x25,%al
  10007d:	78 00                	js     10007f <_kobject_text_area_used+0x4>
  10007f:	00 00                	add    %al,(%rax)
#ifdef CONFIG_X86_KPTI
	movq	$0, %gs:__x86_tss64_t_usp_OFFSET
  100081:	65 48 c7 04 25 78 00 	movq   $0x0,%gs:0x78
  100088:	00 00 00 00 00 00 
#endif

	sti			/* re-enable interrupts */
  10008e:	fb                   	sti    

	/* call_id is in RAX. bounds-check it, must be less than
	 * K_SYSCALL_LIMIT.
	 */
	cmp	$K_SYSCALL_LIMIT, %rax
  10008f:	48 3d 52 01 00 00    	cmp    $0x152,%rax
	jae	_bad_syscall
  100095:	0f 83 97 00 00 00    	jae    100132 <_bad_syscall>

000000000010009b <_id_ok>:

_id_ok:
#ifdef CONFIG_X86_BOUNDS_CHECK_BYPASS_MITIGATION
	/* Prevent speculation with bogus system call IDs */
	lfence
  10009b:	0f ae e8             	lfence 
	 * RBX, RBP, R12-R15, plus floating point / SIMD registers.
	 *
	 * We save caller-saved registers so we can restore to original values
	 * when we call 'sysretq' at the end.
	 */
	pushq	%rdi
  10009e:	57                   	push   %rdi
	subq	$X86_FXSAVE_SIZE, %rsp
  10009f:	48 81 ec 00 02 00 00 	sub    $0x200,%rsp
	fxsave	(%rsp)
  1000a6:	0f ae 04 24          	fxsave (%rsp)
	pushq	%rsi
  1000aa:	56                   	push   %rsi
	pushq	%rdx
  1000ab:	52                   	push   %rdx
	pushq	%r8
  1000ac:	41 50                	push   %r8
	pushq	%r9
  1000ae:	41 51                	push   %r9
	pushq	%r10
  1000b0:	41 52                	push   %r10
	pushq	%r11	/* RFLAGS */
  1000b2:	41 53                	push   %r11
	pushq	%rcx	/* Return address stored by 'syscall' */
  1000b4:	51                   	push   %rcx
	pushq	%rsp	/* SSF parameter */
  1000b5:	54                   	push   %rsp

	/* All other args are in the right registers, except arg4 which
	 * we had to put in r10 instead of RCX
	 */
	movq	%r10, %rcx
  1000b6:	4c 89 d1             	mov    %r10,%rcx

	/* from the call ID in RAX, load R10 with the actual function pointer
	 * to call by looking it up in the system call dispatch table
	 */
	xorq	%r11, %r11
  1000b9:	4d 31 db             	xor    %r11,%r11
	movq	_k_syscall_table(%r11, %rax, 8), %r10
  1000bc:	4d 8b 94 c3 a0 b3 11 	mov    0x11b3a0(%r11,%rax,8),%r10
  1000c3:	00 

	/* Run the marshal function, which is some entry in _k_syscall_table */
	call	*%r10
  1000c4:	41 ff d2             	callq  *%r10
	 * were not used as arguments.
	 *
	 * We also can't have RCX and R11 clobbered as we need the original
	 * values to successfully 'sysretq'.
	 */
	addq	$8, %rsp	/* Discard ssf */
  1000c7:	48 83 c4 08          	add    $0x8,%rsp
	popq	%rcx	/* Restore return address for 'sysretq' */
  1000cb:	59                   	pop    %rcx
	popq	%r11	/* Restore RFLAGS for 'sysretq' */
  1000cc:	41 5b                	pop    %r11
	popq	%r10
  1000ce:	41 5a                	pop    %r10
	popq	%r9
  1000d0:	41 59                	pop    %r9
	popq	%r8
  1000d2:	41 58                	pop    %r8
	popq	%rdx
  1000d4:	5a                   	pop    %rdx
	popq	%rsi
  1000d5:	5e                   	pop    %rsi
	fxrstor	(%rsp)
  1000d6:	0f ae 0c 24          	fxrstor (%rsp)
	addq	$X86_FXSAVE_SIZE, %rsp
  1000da:	48 81 c4 00 02 00 00 	add    $0x200,%rsp
	popq	%rdi
  1000e1:	5f                   	pop    %rdi

#ifdef CONFIG_X86_KPTI
	/* Lock IRQs as we are using per-cpu memory areas and the
	 * trampoline stack
	 */
	cli
  1000e2:	fa                   	cli    

	/* Stash user stack pointer and switch to trampoline stack */
	popq	%gs:__x86_tss64_t_usp_OFFSET
  1000e3:	65 8f 04 25 78 00 00 	popq   %gs:0x78
  1000ea:	00 
	movq	%gs:__x86_tss64_t_ist2_OFFSET, %rsp
  1000eb:	65 48 8b 24 25 2c 00 	mov    %gs:0x2c,%rsp
  1000f2:	00 00 

	/* Switch to thread's page table */
	pushq	%rax
  1000f4:	50                   	push   %rax
	movq	%gs:__x86_tss64_t_cpu_OFFSET, %rax
  1000f5:	65 48 8b 04 25 68 00 	mov    %gs:0x68,%rax
  1000fc:	00 00 
	movq	___cpu_t_current_OFFSET(%rax), %rax
  1000fe:	48 8b 40 10          	mov    0x10(%rax),%rax
	movq	_thread_offset_to_ptables(%rax), %rax
  100102:	48 8b 80 78 01 00 00 	mov    0x178(%rax),%rax
	movq	%rax, %cr3
  100109:	0f 22 d8             	mov    %rax,%cr3
	popq	%rax
  10010c:	58                   	pop    %rax
	movq	$0, -8(%rsp)	/* Delete stashed RAX data */
  10010d:	48 c7 44 24 f8 00 00 	movq   $0x0,-0x8(%rsp)
  100114:	00 00 

	/* Restore saved user stack pointer */
	movq	%gs:__x86_tss64_t_usp_OFFSET, %rsp
  100116:	65 48 8b 24 25 78 00 	mov    %gs:0x78,%rsp
  10011d:	00 00 
	movq	$0, %gs:__x86_tss64_t_usp_OFFSET
  10011f:	65 48 c7 04 25 78 00 	movq   $0x0,%gs:0x78
  100126:	00 00 00 00 00 00 
	 * 'swapgs' and 'sysretq'
	 */
	cli
#endif /* CONFIG_X86_KPTI */

	swapgs
  10012c:	0f 01 f8             	swapgs 
	sysretq
  10012f:	48 0f 07             	rex.W sysret 

0000000000100132 <_bad_syscall>:
	 * handler's ID, and put the bad ID as its first argument.
	 *
	 * TODO: On this and all other arches, simply immediately return
	 * with -ENOSYS, once all syscalls have a return value
	 */
	movq	%rax, %rdi
  100132:	48 89 c7             	mov    %rax,%rdi
	movq	$K_SYSCALL_BAD, %rax
  100135:	48 c7 c0 51 01 00 00 	mov    $0x151,%rax
	jmp	_id_ok
  10013c:	e9 5a ff ff ff       	jmpq   10009b <_id_ok>

0000000000100141 <arch_user_string_nlen>:
 *                              ^ RDI          ^ RSI           ^ RDX
 */
.global arch_user_string_nlen
arch_user_string_nlen:
	/* Initial error value, strlen_done adjusts this if we succeed */
	movl	$-1, %r8d
  100141:	41 b8 ff ff ff ff    	mov    $0xffffffff,%r8d

	/* use RAX as our length count (this function's return value) */
	xor	%rax, %rax
  100147:	48 31 c0             	xor    %rax,%rax

000000000010014a <z_x86_user_string_nlen_fault_start>:

	/* This code might page fault */
strlen_loop:
.global z_x86_user_string_nlen_fault_start
z_x86_user_string_nlen_fault_start:
	cmpb	$0x0, (%rdi, %rax, 1)	/* *(RDI + RAX) == 0? Could fault. */
  10014a:	80 3c 07 00          	cmpb   $0x0,(%rdi,%rax,1)

000000000010014e <z_x86_user_string_nlen_fault_end>:

.global z_x86_user_string_nlen_fault_end
z_x86_user_string_nlen_fault_end:
	je	strlen_done
  10014e:	74 0a                	je     10015a <strlen_done>
	cmp	%rsi, %rax		/* Max length reached? */
  100150:	48 39 f0             	cmp    %rsi,%rax
	je	strlen_done
  100153:	74 05                	je     10015a <strlen_done>
	inc	%rax			/* EAX++ and loop again */
  100155:	48 ff c0             	inc    %rax
	jmp	strlen_loop
  100158:	eb f0                	jmp    10014a <z_x86_user_string_nlen_fault_start>

000000000010015a <strlen_done>:

strlen_done:
	/* Set error value to 0 since we succeeded */
	xorl	%r8d, %r8d
  10015a:	45 31 c0             	xor    %r8d,%r8d

000000000010015d <z_x86_user_string_nlen_fixup>:

.global z_x86_user_string_nlen_fixup
z_x86_user_string_nlen_fixup:
	/* Write error value to 32-bit integer err pointer parameter */
	movl	%r8d, (%rdx)
  10015d:	44 89 02             	mov    %r8d,(%rdx)
	retq
  100160:	c3                   	retq   

0000000000100161 <z_x86_userspace_landing_site>:
 * Trampoline function to put the p3 parameter in the register expected
 * by the calling convention, we couldn't use RCX when we called 'sysret'
 */
z_x86_userspace_landing_site:
	/* Place argument 4 in the correct position */
	movq	%r10, %rcx
  100161:	4c 89 d1             	mov    %r10,%rcx
	call	z_thread_entry
  100164:	e8 32 0e 00 00       	callq  100f9b <z_thread_entry>

0000000000100169 <z_x86_userspace_enter>:
.global z_x86_userspace_enter
z_x86_userspace_enter:
	/* RCX is sysret return address, pass along p3 in r10,
	 * z_x86_userspace_landing_site will fix this up
	 */
	movq	%rcx, %r10
  100169:	49 89 ca             	mov    %rcx,%r10

	/* switch to privilege mode stack so we can erase thread stack buffer,
	 * the buffer is the page immediately before the thread stack
	 */
	movq	%r9, %rsp
  10016c:	4c 89 cc             	mov    %r9,%rsp

	/* Push callee-saved regs and go back into C code to erase the stack
	 * buffer and set US bit in page tables for it
	 */
	pushq	%rdx
  10016f:	52                   	push   %rdx
	pushq	%rsi
  100170:	56                   	push   %rsi
	pushq	%rdi
  100171:	57                   	push   %rdi
	pushq	%r8
  100172:	41 50                	push   %r8
	pushq	%r10
  100174:	41 52                	push   %r10
	callq	z_x86_current_stack_perms
  100176:	e8 f9 95 00 00       	callq  109774 <z_x86_current_stack_perms>
	popq	%r10
  10017b:	41 5a                	pop    %r10
	popq	%r8
  10017d:	41 58                	pop    %r8
	popq	%rdi
  10017f:	5f                   	pop    %rdi
	popq	%rsi
  100180:	5e                   	pop    %rsi
	popq	%rdx
  100181:	5a                   	pop    %rdx

	/* Reset to the beginning of the user stack */
	movq	%r8, %rsp
  100182:	4c 89 c4             	mov    %r8,%rsp

	/* set sysret entry point */
	movq	$z_x86_userspace_landing_site, %rcx
  100185:	48 c7 c1 61 01 10 00 	mov    $0x100161,%rcx

	/* Copy RFLAGS into r11, required by sysret */
	pushfq
  10018c:	9c                   	pushfq 
	movq	(%rsp), %r11
  10018d:	4c 8b 1c 24          	mov    (%rsp),%r11
	movq	$0, (%rsp)	/* Now a debugger-friendly return address */
  100191:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
  100198:	00 

	/* cleanse other registers */
	xorq	%rbx, %rbx
  100199:	48 31 db             	xor    %rbx,%rbx
	xorq	%rbp, %rbp
  10019c:	48 31 ed             	xor    %rbp,%rbp
	xorq	%r12, %r12
  10019f:	4d 31 e4             	xor    %r12,%r12
	xorq	%r13, %r13
  1001a2:	4d 31 ed             	xor    %r13,%r13
	xorq	%r14, %r14
  1001a5:	4d 31 f6             	xor    %r14,%r14
	xorq	%r15, %r15
  1001a8:	4d 31 ff             	xor    %r15,%r15

	cli
  1001ab:	fa                   	cli    

#ifdef CONFIG_X86_KPTI
	/* Switch to thread's page table. We have free registers so no need
	 * to involve the trampoline stack.
	 */
	movq	%gs:__x86_tss64_t_cpu_OFFSET, %rax
  1001ac:	65 48 8b 04 25 68 00 	mov    %gs:0x68,%rax
  1001b3:	00 00 
	movq	___cpu_t_current_OFFSET(%rax), %rax
  1001b5:	48 8b 40 10          	mov    0x10(%rax),%rax
	movq	_thread_offset_to_ptables(%rax), %rax
  1001b9:	48 8b 80 78 01 00 00 	mov    0x178(%rax),%rax
	movq	%rax, %cr3
  1001c0:	0f 22 d8             	mov    %rax,%cr3
#endif
	swapgs
  1001c3:	0f 01 f8             	swapgs 
	sysretq
  1001c6:	48 0f 07             	rex.W sysret 

00000000001001c9 <_OffsetAbsSyms>:
#include "ia32_offsets.c"
#endif

GEN_OFFSET_SYM(_thread_arch_t, flags);

GEN_ABS_SYM_END
  1001c9:	c3                   	retq   

00000000001001ca <arch_is_user_context>:

static inline bool arch_is_user_context(void)
{
	int cs;

	__asm__ volatile ("mov %%cs, %[cs_val]" : [cs_val] "=r" (cs));
  1001ca:	8c c8                	mov    %cs,%eax

	return (cs & 0x3) != 0;
  1001cc:	a8 03                	test   $0x3,%al
  1001ce:	0f 95 c0             	setne  %al
}
  1001d1:	c3                   	retq   

00000000001001d2 <k_poll_signal_init>:

extern void z_impl_k_poll_signal_init(struct k_poll_signal * sig);

__pinned_func
static inline void k_poll_signal_init(struct k_poll_signal * sig)
{
  1001d2:	55                   	push   %rbp
  1001d3:	48 89 e5             	mov    %rsp,%rbp
#if defined(__ZEPHYR_SUPERVISOR__)
	ret = false;
#elif defined(__ZEPHYR_USER__)
	ret = true;
#else
	ret = arch_is_user_context();
  1001d6:	e8 ef ff ff ff       	callq  1001ca <arch_is_user_context>
#ifdef CONFIG_USERSPACE
	if (z_syscall_trap()) {
  1001db:	84 c0                	test   %al,%al
  1001dd:	74 09                	je     1001e8 <k_poll_signal_init+0x16>
	register uintptr_t rax __asm__("%rax") = call_id;
  1001df:	b8 a1 00 00 00       	mov    $0xa1,%eax
	__asm__ volatile("syscall\n\t"
  1001e4:	0f 05                	syscall 
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_poll_signal_init(sig);
}
  1001e6:	5d                   	pop    %rbp
  1001e7:	c3                   	retq   
  1001e8:	5d                   	pop    %rbp
	z_impl_k_poll_signal_init(sig);
  1001e9:	e9 25 54 01 00       	jmpq   115613 <z_impl_k_poll_signal_init>

00000000001001ee <k_object_access_grant.constprop.0>:
#endif

extern void z_impl_k_object_access_grant(const void * object, struct k_thread * thread);

__pinned_func
static inline void k_object_access_grant(const void * object, struct k_thread * thread)
  1001ee:	55                   	push   %rbp
  1001ef:	48 89 e5             	mov    %rsp,%rbp
  1001f2:	e8 d3 ff ff ff       	callq  1001ca <arch_is_user_context>
{
#ifdef CONFIG_USERSPACE
	if (z_syscall_trap()) {
  1001f7:	84 c0                	test   %al,%al
  1001f9:	74 0e                	je     100209 <k_object_access_grant.constprop.0+0x1b>
	register uintptr_t rax __asm__("%rax") = call_id;
  1001fb:	b8 97 00 00 00       	mov    $0x97,%eax
	register uintptr_t rsi __asm__("%rsi") = arg2;
  100200:	be 00 60 12 00       	mov    $0x126000,%esi
	__asm__ volatile("syscall\n\t"
  100205:	0f 05                	syscall 
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_object_access_grant(object, thread);
}
  100207:	5d                   	pop    %rbp
  100208:	c3                   	retq   
	z_impl_k_object_access_grant(object, thread);
  100209:	be 00 60 12 00       	mov    $0x126000,%esi
}
  10020e:	5d                   	pop    %rbp
	z_impl_k_object_access_grant(object, thread);
  10020f:	e9 33 6d 01 00       	jmpq   116f47 <z_impl_k_object_access_grant>

0000000000100214 <thread_routine>:
// void thread_routine(void *param1, void *param2, void *param3)
// void thread_routine(struct k_poll_signal *ptr_doorbell_sig, void *param2, void *param3)
void thread_routine(struct k_poll_signal *ptr_doorbell_sig, struct k_poll_event *ptr_doorbell_evt, void *param3)
//  void thread_routine(context_k_poll *ptr_k_poll_variables, void *param2, void *param3)
//  void thread_routine(context_k_poll *ptr_k_poll_ptr_variables, void *param2, void *param3)
{
  100214:	55                   	push   %rbp
  100215:	48 89 e5             	mov    %rsp,%rbp
  100218:	41 54                	push   %r12
  10021a:	49 89 fc             	mov    %rdi,%r12
  10021d:	48 89 f7             	mov    %rsi,%rdi
  100220:	48 83 ec 18          	sub    $0x18,%rsp
  100224:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%rbp)
  10022b:	e8 9a ff ff ff       	callq  1001ca <arch_is_user_context>
	if (z_syscall_trap()) {
  100230:	84 c0                	test   %al,%al
  100232:	74 11                	je     100245 <thread_routine+0x31>
	register uintptr_t rsi __asm__("%rsi") = arg2;
  100234:	48 8b 75 ec          	mov    -0x14(%rbp),%rsi
	register uintptr_t rax __asm__("%rax") = call_id;
  100238:	b8 9f 00 00 00       	mov    $0x9f,%eax
	register uintptr_t rdx __asm__("%rdx") = arg3;
  10023d:	48 83 ca ff          	or     $0xffffffffffffffff,%rdx
	__asm__ volatile("syscall\n\t"
  100241:	0f 05                	syscall 
		return (int) arch_syscall_invoke3(*(uintptr_t *)&events, *(uintptr_t *)&num_events, *(uintptr_t *)&timeout, K_SYSCALL_K_POLL);
  100243:	eb 0c                	jmp    100251 <thread_routine+0x3d>
	return z_impl_k_poll(events, num_events, timeout);
  100245:	8b 75 ec             	mov    -0x14(%rbp),%esi
  100248:	48 83 ca ff          	or     $0xffffffffffffffff,%rdx
  10024c:	e8 dc 4c 01 00       	callq  114f2d <z_impl_k_poll>
	// create the pointer to the data of the shm areas code data, safe data, unsafe data and safety results data
	// struct k_poll_event *ptr_doorbell_evt = (struct k_poll_event *)param1;
	// struct k_poll_signal *ptr_doorbell_sig = (struct k_poll_signal *)param2;

	k_poll(ptr_doorbell_evt, 1, K_FOREVER);
	k_poll_signal_init(ptr_doorbell_sig);
  100251:	4c 89 e7             	mov    %r12,%rdi
  100254:	e8 79 ff ff ff       	callq  1001d2 <k_poll_signal_init>

	// k_poll(ptr_k_poll_ptr_variables->ptr_doorbell_evt, 1, K_FOREVER);
	// k_poll_signal_init(ptr_k_poll_ptr_variables->ptr_doorbell_sig);

	printk("\ntest\n");
}
  100259:	48 83 c4 18          	add    $0x18,%rsp
	printk("\ntest\n");
  10025d:	bf ba ce 11 00       	mov    $0x11ceba,%edi
  100262:	31 c0                	xor    %eax,%eax
}
  100264:	41 5c                	pop    %r12
  100266:	5d                   	pop    %rbp
	printk("\ntest\n");
  100267:	e9 8c 03 00 00       	jmpq   1005f8 <printk>

000000000010026c <main>:
{
  10026c:	55                   	push   %rbp
  10026d:	48 89 e5             	mov    %rsp,%rbp
  100270:	41 54                	push   %r12
  100272:	48 83 ec 58          	sub    $0x58,%rsp
	struct k_mem_partition *partitions[] = {&evt_part, &sig_part};
  100276:	48 c7 45 b8 30 13 5e 	movq   $0x5e1330,-0x48(%rbp)
  10027d:	00 
  10027e:	48 c7 45 c0 10 13 5e 	movq   $0x5e1310,-0x40(%rbp)
  100285:	00 
  100286:	e8 3f ff ff ff       	callq  1001ca <arch_is_user_context>

__pinned_func
static inline const struct device * device_get_binding(const char * name)
{
#ifdef CONFIG_USERSPACE
	if (z_syscall_trap()) {
  10028b:	84 c0                	test   %al,%al
  10028d:	74 0e                	je     10029d <main+0x31>
	register uintptr_t rax __asm__("%rax") = call_id;
  10028f:	b8 2e 00 00 00       	mov    $0x2e,%eax
	register uintptr_t rdi __asm__("%rdi") = arg1;
  100294:	bf c1 ce 11 00       	mov    $0x11cec1,%edi
	__asm__ volatile("syscall\n\t"
  100299:	0f 05                	syscall 
	return rax;
  10029b:	eb 0a                	jmp    1002a7 <main+0x3b>
		/* coverity[OVERRUN] */
		return (const struct device *) arch_syscall_invoke1(*(uintptr_t *)&name, K_SYSCALL_DEVICE_GET_BINDING);
	}
#endif
	compiler_barrier();
	return z_impl_device_get_binding(name);
  10029d:	bf c1 ce 11 00       	mov    $0x11cec1,%edi
  1002a2:	e8 c7 cb 00 00       	callq  10ce6e <z_impl_device_get_binding>
  1002a7:	49 89 c4             	mov    %rax,%r12
	if (!ptr_ivshmem_device)
  1002aa:	48 85 c0             	test   %rax,%rax
  1002ad:	75 11                	jne    1002c0 <main+0x54>
		DEBUG("\nptr_ivshmem_device device cannot be found\n")
  1002af:	bf c9 ce 11 00       	mov    $0x11cec9,%edi
  1002b4:	31 c0                	xor    %eax,%eax
  1002b6:	e8 3d 03 00 00       	callq  1005f8 <printk>
		return 0;
  1002bb:	e9 77 01 00 00       	jmpq   100437 <main+0x1cb>
	k_thread_access_grant(&thread, &doorbell_sig, &doorbell_evt, ptr_ivshmem_device);
  1002c0:	bf 00 40 12 00       	mov    $0x124000,%edi
  1002c5:	e8 24 ff ff ff       	callq  1001ee <k_object_access_grant.constprop.0>
  1002ca:	bf 00 50 12 00       	mov    $0x125000,%edi
  1002cf:	e8 1a ff ff ff       	callq  1001ee <k_object_access_grant.constprop.0>
  1002d4:	4c 89 e7             	mov    %r12,%rdi
  1002d7:	e8 12 ff ff ff       	callq  1001ee <k_object_access_grant.constprop.0>
	k_poll_signal_init(&doorbell_sig);
  1002dc:	bf 00 40 12 00       	mov    $0x124000,%edi
  1002e1:	e8 ec fe ff ff       	callq  1001d2 <k_poll_signal_init>
	k_poll_event_init(&doorbell_evt, K_POLL_TYPE_SIGNAL, K_POLL_MODE_NOTIFY_ONLY, &doorbell_sig);
  1002e6:	31 d2                	xor    %edx,%edx
  1002e8:	b9 00 40 12 00       	mov    $0x124000,%ecx
  1002ed:	be 01 00 00 00       	mov    $0x1,%esi
  1002f2:	bf 00 50 12 00       	mov    $0x125000,%edi
  1002f7:	e8 2f 4b 01 00       	callq  114e2b <k_poll_event_init>


extern int z_impl_ivshmem_register_handler(const struct device * dev, struct k_poll_signal * signal, uint16_t vector);

__pinned_func
static inline int ivshmem_register_handler(const struct device * dev, struct k_poll_signal * signal, uint16_t vector)
  1002fc:	66 c7 45 ae 00 00    	movw   $0x0,-0x52(%rbp)
  100302:	e8 c3 fe ff ff       	callq  1001ca <arch_is_user_context>
{
#ifdef CONFIG_USERSPACE
	if (z_syscall_trap()) {
  100307:	84 c0                	test   %al,%al
  100309:	74 15                	je     100320 <main+0xb4>
	register uintptr_t rdx __asm__("%rdx") = arg3;
  10030b:	48 8b 55 ae          	mov    -0x52(%rbp),%rdx
	register uintptr_t rax __asm__("%rax") = call_id;
  10030f:	b8 79 00 00 00       	mov    $0x79,%eax
	register uintptr_t rdi __asm__("%rdi") = arg1;
  100314:	4c 89 e7             	mov    %r12,%rdi
	register uintptr_t rsi __asm__("%rsi") = arg2;
  100317:	be 00 40 12 00       	mov    $0x124000,%esi
	__asm__ volatile("syscall\n\t"
  10031c:	0f 05                	syscall 
		/* coverity[OVERRUN] */
		return (int) arch_syscall_invoke3(*(uintptr_t *)&dev, *(uintptr_t *)&signal, *(uintptr_t *)&vector, K_SYSCALL_IVSHMEM_REGISTER_HANDLER);
  10031e:	eb 14                	jmp    100334 <main+0xc8>
						  uint16_t vector)
{
	const struct ivshmem_driver_api *api =
		(const struct ivshmem_driver_api *)dev->api;

	return api->register_handler(dev, signal, vector);
  100320:	49 8b 44 24 10       	mov    0x10(%r12),%rax
	}
#endif
	compiler_barrier();
	return z_impl_ivshmem_register_handler(dev, signal, vector);
  100325:	0f b7 55 ae          	movzwl -0x52(%rbp),%edx
  100329:	be 00 40 12 00       	mov    $0x124000,%esi
  10032e:	4c 89 e7             	mov    %r12,%rdi
  100331:	ff 50 20             	callq  *0x20(%rax)
	if (ivshmem_register_handler(ptr_ivshmem_device, &doorbell_sig, vector))
  100334:	85 c0                	test   %eax,%eax
  100336:	74 13                	je     10034b <main+0xdf>
		DEBUG("Could not get notifications on vector %u", vector)
  100338:	31 f6                	xor    %esi,%esi
  10033a:	bf f5 ce 11 00       	mov    $0x11cef5,%edi
  10033f:	31 c0                	xor    %eax,%eax
  100341:	e8 b2 02 00 00       	callq  1005f8 <printk>
		return 0;
  100346:	e9 ec 00 00 00       	jmpq   100437 <main+0x1cb>
static inline k_tid_t k_thread_create(struct k_thread * new_thread, k_thread_stack_t * stack, size_t stack_size, k_thread_entry_t entry, void * p1, void * p2, void * p3, int prio, uint32_t options, k_timeout_t delay)
  10034b:	c7 45 b0 01 00 00 00 	movl   $0x1,-0x50(%rbp)
  100352:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%rbp)
  100359:	e8 6c fe ff ff       	callq  1001ca <arch_is_user_context>
	if (z_syscall_trap()) {
  10035e:	84 c0                	test   %al,%al
  100360:	74 50                	je     1003b2 <main+0x146>
		uintptr_t more[] = {
  100362:	48 8b 45 b4          	mov    -0x4c(%rbp),%rax
  100366:	48 c7 45 c8 00 50 12 	movq   $0x125000,-0x38(%rbp)
  10036d:	00 
	register uintptr_t rdi __asm__("%rdi") = arg1;
  10036e:	bf 00 60 12 00       	mov    $0x126000,%edi
	register uintptr_t rsi __asm__("%rsi") = arg2;
  100373:	be 00 70 5d 00       	mov    $0x5d7000,%esi
	register uintptr_t rdx __asm__("%rdx") = arg3;
  100378:	ba e8 03 00 00       	mov    $0x3e8,%edx
	register uintptr_t r10 __asm__("%r10") = arg4; /* RCX unavailable */
  10037d:	41 ba 14 02 10 00    	mov    $0x100214,%r10d
	register uintptr_t r9 __asm__("%r9") = arg6;
  100383:	4c 8d 4d c8          	lea    -0x38(%rbp),%r9
  100387:	48 c7 45 d0 00 00 00 	movq   $0x0,-0x30(%rbp)
  10038e:	00 
  10038f:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  100393:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
	register uintptr_t r8 __asm__("%r8") = arg5;
  100397:	41 b8 00 40 12 00    	mov    $0x124000,%r8d
  10039d:	48 c7 45 e8 ff ff ff 	movq   $0xffffffffffffffff,-0x18(%rbp)
  1003a4:	ff 
  1003a5:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	register uintptr_t rax __asm__("%rax") = call_id;
  1003a9:	b8 b7 00 00 00       	mov    $0xb7,%eax
	__asm__ volatile("syscall\n\t"
  1003ae:	0f 05                	syscall 
	return rax;
  1003b0:	eb 35                	jmp    1003e7 <main+0x17b>
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
  1003b2:	8b 45 b0             	mov    -0x50(%rbp),%eax
  1003b5:	6a ff                	pushq  $0xffffffffffffffff
  1003b7:	41 b9 00 50 12 00    	mov    $0x125000,%r9d
  1003bd:	b9 14 02 10 00       	mov    $0x100214,%ecx
  1003c2:	41 b8 00 40 12 00    	mov    $0x124000,%r8d
  1003c8:	ba e8 03 00 00       	mov    $0x3e8,%edx
  1003cd:	be 00 70 5d 00       	mov    $0x5d7000,%esi
  1003d2:	bf 00 60 12 00       	mov    $0x126000,%edi
  1003d7:	50                   	push   %rax
  1003d8:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  1003db:	50                   	push   %rax
  1003dc:	6a 00                	pushq  $0x0
  1003de:	e8 92 da 00 00       	callq  10de75 <z_impl_k_thread_create>
  1003e3:	48 83 c4 20          	add    $0x20,%rsp
	k_mem_domain_init(&domain, size, partitions);
  1003e7:	be 02 00 00 00       	mov    $0x2,%esi
  1003ec:	bf e0 63 12 00       	mov    $0x1263e0,%edi
  1003f1:	48 8d 55 b8          	lea    -0x48(%rbp),%rdx
 *             or NULL if the thread should no longer have a memory pool.
 */
static inline void k_thread_heap_assign(struct k_thread *thread,
					struct k_heap *heap)
{
	thread->resource_pool = heap;
  1003f5:	48 c7 05 58 5d 02 00 	movq   $0x5e14a0,0x25d58(%rip)        # 126158 <thread+0x158>
  1003fc:	a0 14 5e 00 
  100400:	e8 43 5b 01 00       	callq  115f48 <k_mem_domain_init>
	k_mem_domain_add_thread(&domain, &thread);
  100405:	be 00 60 12 00       	mov    $0x126000,%esi
  10040a:	bf e0 63 12 00       	mov    $0x1263e0,%edi
  10040f:	e8 5f 61 01 00       	callq  116573 <k_mem_domain_add_thread>
  100414:	e8 b1 fd ff ff       	callq  1001ca <arch_is_user_context>
	if (z_syscall_trap()) {
  100419:	84 c0                	test   %al,%al
  10041b:	74 0e                	je     10042b <main+0x1bf>
	register uintptr_t rax __asm__("%rax") = call_id;
  10041d:	b8 c2 00 00 00       	mov    $0xc2,%eax
	register uintptr_t rdi __asm__("%rdi") = arg1;
  100422:	bf 00 60 12 00       	mov    $0x126000,%edi
	__asm__ volatile("syscall\n\t"
  100427:	0f 05                	syscall 
	return rax;
  100429:	eb 0e                	jmp    100439 <main+0x1cd>
	z_impl_k_thread_start(thread);
  10042b:	bf 00 60 12 00       	mov    $0x126000,%edi
  100430:	e8 ad d3 00 00       	callq  10d7e2 <z_impl_k_thread_start>
}
  100435:	eb 02                	jmp    100439 <main+0x1cd>
  100437:	31 c0                	xor    %eax,%eax
  100439:	4c 8b 65 f8          	mov    -0x8(%rbp),%r12
  10043d:	c9                   	leaveq 
  10043e:	c3                   	retq   

000000000010043f <char_out>:

static int char_out(int c, void *ctx_p)
{
	struct out_context *ctx = ctx_p;

	ctx->count++;
  10043f:	ff 06                	incl   (%rsi)
	return _char_out(c);
  100441:	ff 25 f1 0f 4e 00    	jmpq   *0x4e0ff1(%rip)        # 5e1438 <_char_out>

0000000000100447 <str_out>:
	int count;
};

static int str_out(int c, struct str_context *ctx)
{
	if (ctx->str == NULL || ctx->count >= ctx->max) {
  100447:	8b 56 0c             	mov    0xc(%rsi),%edx
  10044a:	48 8b 06             	mov    (%rsi),%rax
{
  10044d:	41 89 f8             	mov    %edi,%r8d
		ctx->count++;
		return c;
	}

	if (ctx->count == ctx->max - 1) {
		ctx->str[ctx->count++] = '\0';
  100450:	8d 7a 01             	lea    0x1(%rdx),%edi
	if (ctx->str == NULL || ctx->count >= ctx->max) {
  100453:	48 85 c0             	test   %rax,%rax
  100456:	74 07                	je     10045f <str_out+0x18>
  100458:	8b 4e 08             	mov    0x8(%rsi),%ecx
  10045b:	39 d1                	cmp    %edx,%ecx
  10045d:	7f 05                	jg     100464 <str_out+0x1d>
		ctx->count++;
  10045f:	89 7e 0c             	mov    %edi,0xc(%rsi)
		return c;
  100462:	eb 17                	jmp    10047b <str_out+0x34>
		ctx->str[ctx->count++] = '\0';
  100464:	4c 63 ca             	movslq %edx,%r9
	if (ctx->count == ctx->max - 1) {
  100467:	ff c9                	dec    %ecx
		ctx->str[ctx->count++] = '\0';
  100469:	89 7e 0c             	mov    %edi,0xc(%rsi)
  10046c:	4c 01 c8             	add    %r9,%rax
	if (ctx->count == ctx->max - 1) {
  10046f:	39 d1                	cmp    %edx,%ecx
  100471:	75 05                	jne    100478 <str_out+0x31>
		ctx->str[ctx->count++] = '\0';
  100473:	c6 00 00             	movb   $0x0,(%rax)
  100476:	eb 03                	jmp    10047b <str_out+0x34>
	} else {
		ctx->str[ctx->count++] = c;
  100478:	44 88 00             	mov    %r8b,(%rax)
	}

	return c;
}
  10047b:	44 89 c0             	mov    %r8d,%eax
  10047e:	c3                   	retq   

000000000010047f <__printk_hook_install>:
	_char_out = fn;
  10047f:	48 89 3d b2 0f 4e 00 	mov    %rdi,0x4e0fb2(%rip)        # 5e1438 <_char_out>
}
  100486:	c3                   	retq   

0000000000100487 <z_impl_k_str_out>:
{
  100487:	55                   	push   %rbp
  100488:	48 89 e5             	mov    %rsp,%rbp
  10048b:	41 54                	push   %r12
  10048d:	4c 8d 24 37          	lea    (%rdi,%rsi,1),%r12
  100491:	53                   	push   %rbx
  100492:	48 89 fb             	mov    %rdi,%rbx
	for (i = 0; i < n; i++) {
  100495:	4c 39 e3             	cmp    %r12,%rbx
  100498:	74 0e                	je     1004a8 <z_impl_k_str_out+0x21>
		_char_out(c[i]);
  10049a:	0f be 3b             	movsbl (%rbx),%edi
  10049d:	48 ff c3             	inc    %rbx
  1004a0:	ff 15 92 0f 4e 00    	callq  *0x4e0f92(%rip)        # 5e1438 <_char_out>
	for (i = 0; i < n; i++) {
  1004a6:	eb ed                	jmp    100495 <z_impl_k_str_out+0xe>
}
  1004a8:	5b                   	pop    %rbx
  1004a9:	41 5c                	pop    %r12
  1004ab:	5d                   	pop    %rbp
  1004ac:	c3                   	retq   

00000000001004ad <buf_flush>:
{
  1004ad:	55                   	push   %rbp
  1004ae:	48 89 e5             	mov    %rsp,%rbp
  1004b1:	53                   	push   %rbx
  1004b2:	48 89 fb             	mov    %rdi,%rbx
	k_str_out(ctx->buf, ctx->buf_count);
  1004b5:	48 83 c7 08          	add    $0x8,%rdi
{
  1004b9:	52                   	push   %rdx
	k_str_out(ctx->buf, ctx->buf_count);
  1004ba:	8b 77 fc             	mov    -0x4(%rdi),%esi
	__asm__ volatile ("mov %%cs, %[cs_val]" : [cs_val] "=r" (cs));
  1004bd:	8c c8                	mov    %cs,%eax

__pinned_func
static inline void k_str_out(char * c, size_t n)
{
#ifdef CONFIG_USERSPACE
	if (z_syscall_trap()) {
  1004bf:	a8 03                	test   $0x3,%al
  1004c1:	74 09                	je     1004cc <buf_flush+0x1f>
	register uintptr_t rax __asm__("%rax") = call_id;
  1004c3:	b8 b5 00 00 00       	mov    $0xb5,%eax
	__asm__ volatile("syscall\n\t"
  1004c8:	0f 05                	syscall 
	return rax;
  1004ca:	eb 05                	jmp    1004d1 <buf_flush+0x24>
		arch_syscall_invoke2(*(uintptr_t *)&c, *(uintptr_t *)&n, K_SYSCALL_K_STR_OUT);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_str_out(c, n);
  1004cc:	e8 b6 ff ff ff       	callq  100487 <z_impl_k_str_out>
	ctx->buf_count = 0U;
  1004d1:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%rbx)
}
  1004d8:	58                   	pop    %rax
  1004d9:	5b                   	pop    %rbx
  1004da:	5d                   	pop    %rbp
  1004db:	c3                   	retq   

00000000001004dc <vprintk>:
{
  1004dc:	55                   	push   %rbp
  1004dd:	48 89 fa             	mov    %rdi,%rdx
  1004e0:	48 89 e5             	mov    %rsp,%rbp
  1004e3:	41 54                	push   %r12
  1004e5:	48 83 ec 38          	sub    $0x38,%rsp
	__asm__ volatile ("mov %%cs, %[cs_val]" : [cs_val] "=r" (cs));
  1004e9:	8c c8                	mov    %cs,%eax
	if (k_is_user_context()) {
  1004eb:	a8 03                	test   $0x3,%al
  1004ed:	4c 8d 65 c8          	lea    -0x38(%rbp),%r12
  1004f1:	74 2c                	je     10051f <vprintk+0x43>
		struct buf_out_context ctx = { 0 };
  1004f3:	31 c0                	xor    %eax,%eax
  1004f5:	b9 0a 00 00 00       	mov    $0xa,%ecx
  1004fa:	4c 89 e7             	mov    %r12,%rdi
  1004fd:	f3 ab                	rep stos %eax,%es:(%rdi)
		cbvprintf(buf_char_out, &ctx, fmt, ap);
  1004ff:	48 89 f1             	mov    %rsi,%rcx
  100502:	bf 3e 05 10 00       	mov    $0x10053e,%edi
  100507:	4c 89 e6             	mov    %r12,%rsi
  10050a:	e8 fc 19 00 00       	callq  101f0b <cbvprintf>
		if (ctx.buf_count) {
  10050f:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  100513:	74 21                	je     100536 <vprintk+0x5a>
			buf_flush(&ctx);
  100515:	4c 89 e7             	mov    %r12,%rdi
  100518:	e8 90 ff ff ff       	callq  1004ad <buf_flush>
  10051d:	eb 17                	jmp    100536 <vprintk+0x5a>
		cbvprintf(char_out, &ctx, fmt, ap);
  10051f:	48 89 f1             	mov    %rsi,%rcx
  100522:	bf 3f 04 10 00       	mov    $0x10043f,%edi
  100527:	4c 89 e6             	mov    %r12,%rsi
		struct out_context ctx = { 0 };
  10052a:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%rbp)
		cbvprintf(char_out, &ctx, fmt, ap);
  100531:	e8 d5 19 00 00       	callq  101f0b <cbvprintf>
}
  100536:	48 83 c4 38          	add    $0x38,%rsp
  10053a:	41 5c                	pop    %r12
  10053c:	5d                   	pop    %rbp
  10053d:	c3                   	retq   

000000000010053e <buf_char_out>:
{
  10053e:	55                   	push   %rbp
  10053f:	48 89 e5             	mov    %rsp,%rbp
  100542:	41 54                	push   %r12
  100544:	41 89 fc             	mov    %edi,%r12d
  100547:	51                   	push   %rcx
	ctx->buf[ctx->buf_count++] = c;
  100548:	8b 46 04             	mov    0x4(%rsi),%eax
	ctx->count++;
  10054b:	ff 06                	incl   (%rsi)
	ctx->buf[ctx->buf_count++] = c;
  10054d:	8d 50 01             	lea    0x1(%rax),%edx
  100550:	89 56 04             	mov    %edx,0x4(%rsi)
  100553:	40 88 7c 06 08       	mov    %dil,0x8(%rsi,%rax,1)
	if (ctx->buf_count == CONFIG_PRINTK_BUFFER_SIZE) {
  100558:	83 fa 20             	cmp    $0x20,%edx
  10055b:	75 08                	jne    100565 <buf_char_out+0x27>
  10055d:	48 89 f7             	mov    %rsi,%rdi
		buf_flush(ctx);
  100560:	e8 48 ff ff ff       	callq  1004ad <buf_flush>
}
  100565:	44 89 e0             	mov    %r12d,%eax
  100568:	5a                   	pop    %rdx
  100569:	41 5c                	pop    %r12
  10056b:	5d                   	pop    %rbp
  10056c:	c3                   	retq   

000000000010056d <z_mrsh_k_str_out>:
#include <syscalls/kernel.h>

extern void z_vrfy_k_str_out(char * c, size_t n);
uintptr_t z_mrsh_k_str_out(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
  10056d:	55                   	push   %rbp
  10056e:	48 89 e5             	mov    %rsp,%rbp
  100571:	41 54                	push   %r12
  100573:	49 89 fc             	mov    %rdi,%r12
  100576:	48 83 ec 18          	sub    $0x18,%rsp
	_current->syscall_frame = ssf;
  10057a:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  10057e:	48 8b 05 cb 81 02 00 	mov    0x281cb(%rip),%rax        # 128750 <_kernel+0x10>
	Z_OOPS(Z_SYSCALL_MEMORY_READ(c, n));
  100585:	48 89 75 e8          	mov    %rsi,-0x18(%rbp)
  100589:	48 89 90 40 01 00 00 	mov    %rdx,0x140(%rax)
  100590:	31 d2                	xor    %edx,%edx
  100592:	e8 25 8e 00 00       	callq  1093bc <arch_buffer_validate>
  100597:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  10059b:	85 c0                	test   %eax,%eax
  10059d:	74 35                	je     1005d4 <z_mrsh_k_str_out+0x67>
  10059f:	49 89 f0             	mov    %rsi,%r8
  1005a2:	bf 1e cf 11 00       	mov    $0x11cf1e,%edi
  1005a7:	31 c0                	xor    %eax,%eax
  1005a9:	41 b9 de 0d 12 00    	mov    $0x120dde,%r9d
  1005af:	4c 89 e1             	mov    %r12,%rcx
  1005b2:	ba 30 be 11 00       	mov    $0x11be30,%edx
  1005b7:	be 45 00 00 00       	mov    $0x45,%esi
  1005bc:	e8 05 2b 00 00       	callq  1030c6 <z_log_minimal_printk>
  1005c1:	48 8b 05 88 81 02 00 	mov    0x28188(%rip),%rax        # 128750 <_kernel+0x10>
  1005c8:	48 8b b8 40 01 00 00 	mov    0x140(%rax),%rdi
  1005cf:	e8 39 96 00 00       	callq  109c0d <arch_syscall_oops>
	z_impl_k_str_out((char *)c, n);
  1005d4:	4c 89 e7             	mov    %r12,%rdi
  1005d7:	e8 ab fe ff ff       	callq  100487 <z_impl_k_str_out>
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	z_vrfy_k_str_out(*(char **)&arg0, *(size_t*)&arg1)
;
	_current->syscall_frame = NULL;
  1005dc:	48 8b 05 6d 81 02 00 	mov    0x2816d(%rip),%rax        # 128750 <_kernel+0x10>
  1005e3:	48 c7 80 40 01 00 00 	movq   $0x0,0x140(%rax)
  1005ea:	00 00 00 00 
	return 0;
}
  1005ee:	48 83 c4 18          	add    $0x18,%rsp
  1005f2:	31 c0                	xor    %eax,%eax
  1005f4:	41 5c                	pop    %r12
  1005f6:	5d                   	pop    %rbp
  1005f7:	c3                   	retq   

00000000001005f8 <printk>:
{
  1005f8:	55                   	push   %rbp
  1005f9:	48 89 e5             	mov    %rsp,%rbp
  1005fc:	48 81 ec d0 00 00 00 	sub    $0xd0,%rsp
  100603:	48 89 b5 58 ff ff ff 	mov    %rsi,-0xa8(%rbp)
  10060a:	48 89 95 60 ff ff ff 	mov    %rdx,-0xa0(%rbp)
  100611:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  100618:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  10061f:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  100626:	84 c0                	test   %al,%al
  100628:	74 20                	je     10064a <printk+0x52>
  10062a:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  10062e:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  100632:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  100636:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  10063a:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  10063e:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  100642:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  100646:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
	va_start(ap, fmt);
  10064a:	48 8d 45 10          	lea    0x10(%rbp),%rax
	vprintk(fmt, ap);
  10064e:	48 8d b5 38 ff ff ff 	lea    -0xc8(%rbp),%rsi
	va_start(ap, fmt);
  100655:	c7 85 38 ff ff ff 08 	movl   $0x8,-0xc8(%rbp)
  10065c:	00 00 00 
  10065f:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  100666:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  10066d:	c7 85 3c ff ff ff 30 	movl   $0x30,-0xc4(%rbp)
  100674:	00 00 00 
  100677:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
	vprintk(fmt, ap);
  10067e:	e8 59 fe ff ff       	callq  1004dc <vprintk>
}
  100683:	c9                   	leaveq 
  100684:	c3                   	retq   

0000000000100685 <vsnprintk>:

	return ret;
}

int vsnprintk(char *str, size_t size, const char *fmt, va_list ap)
{
  100685:	55                   	push   %rbp
  100686:	48 89 e5             	mov    %rsp,%rbp
  100689:	53                   	push   %rbx
  10068a:	48 89 fb             	mov    %rdi,%rbx
  10068d:	48 83 ec 18          	sub    $0x18,%rsp
	struct str_context ctx = { str, size, 0 };
  100691:	48 89 7d e0          	mov    %rdi,-0x20(%rbp)

	cbvprintf(str_out, &ctx, fmt, ap);
  100695:	bf 47 04 10 00       	mov    $0x100447,%edi
	struct str_context ctx = { str, size, 0 };
  10069a:	89 75 e8             	mov    %esi,-0x18(%rbp)
	cbvprintf(str_out, &ctx, fmt, ap);
  10069d:	48 8d 75 e0          	lea    -0x20(%rbp),%rsi
	struct str_context ctx = { str, size, 0 };
  1006a1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
	cbvprintf(str_out, &ctx, fmt, ap);
  1006a8:	e8 5e 18 00 00       	callq  101f0b <cbvprintf>

	if (ctx.count < ctx.max) {
  1006ad:	8b 45 ec             	mov    -0x14(%rbp),%eax
  1006b0:	3b 45 e8             	cmp    -0x18(%rbp),%eax
  1006b3:	7d 07                	jge    1006bc <vsnprintk+0x37>
		str[ctx.count] = '\0';
  1006b5:	48 63 d0             	movslq %eax,%rdx
  1006b8:	c6 04 13 00          	movb   $0x0,(%rbx,%rdx,1)
	}

	return ctx.count;
}
  1006bc:	48 83 c4 18          	add    $0x18,%rsp
  1006c0:	5b                   	pop    %rbx
  1006c1:	5d                   	pop    %rbp
  1006c2:	c3                   	retq   

00000000001006c3 <snprintk>:
{
  1006c3:	55                   	push   %rbp
  1006c4:	48 89 e5             	mov    %rsp,%rbp
  1006c7:	48 81 ec d0 00 00 00 	sub    $0xd0,%rsp
  1006ce:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  1006d5:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  1006dc:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  1006e3:	84 c0                	test   %al,%al
  1006e5:	74 20                	je     100707 <snprintk+0x44>
  1006e7:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  1006eb:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  1006ef:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  1006f3:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  1006f7:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  1006fb:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  1006ff:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  100703:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
	va_start(ap, fmt);
  100707:	48 8d 45 10          	lea    0x10(%rbp),%rax
	ret = vsnprintk(str, size, fmt, ap);
  10070b:	48 8d 8d 38 ff ff ff 	lea    -0xc8(%rbp),%rcx
	va_start(ap, fmt);
  100712:	c7 85 38 ff ff ff 18 	movl   $0x18,-0xc8(%rbp)
  100719:	00 00 00 
  10071c:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  100723:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  10072a:	c7 85 3c ff ff ff 30 	movl   $0x30,-0xc4(%rbp)
  100731:	00 00 00 
  100734:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
	ret = vsnprintk(str, size, fmt, ap);
  10073b:	e8 45 ff ff ff       	callq  100685 <vsnprintk>
}
  100740:	c9                   	leaveq 
  100741:	c3                   	retq   

0000000000100742 <set_child>:
}

static void set_child(struct rbnode *n, uint8_t side, void *val)
{
	CHECK(n);
	if (side != 0U) {
  100742:	40 84 f6             	test   %sil,%sil
  100745:	74 05                	je     10074c <set_child+0xa>
		n->children[1] = val;
  100747:	48 89 57 08          	mov    %rdx,0x8(%rdi)
  10074b:	c3                   	retq   
	} else {
		uintptr_t old = (uintptr_t) n->children[0];
		uintptr_t new = (uintptr_t) val;

		n->children[0] = (void *) (new | (old & 1UL));
  10074c:	48 8b 07             	mov    (%rdi),%rax
  10074f:	83 e0 01             	and    $0x1,%eax
  100752:	48 09 c2             	or     %rax,%rdx
  100755:	48 89 17             	mov    %rdx,(%rdi)
	}
}
  100758:	c3                   	retq   

0000000000100759 <find_and_stack>:
 * contain at least tree->max_depth entries!  Returns the number of
 * entries pushed onto the stack.
 */
static int find_and_stack(struct rbtree *tree, struct rbnode *node,
			  struct rbnode **stack)
{
  100759:	55                   	push   %rbp
  10075a:	48 89 e5             	mov    %rsp,%rbp
  10075d:	41 57                	push   %r15
  10075f:	41 56                	push   %r14
  100761:	49 89 fe             	mov    %rdi,%r14
  100764:	41 55                	push   %r13
  100766:	49 89 f5             	mov    %rsi,%r13
  100769:	41 54                	push   %r12
	int sz = 0;

	stack[sz++] = tree->root;
  10076b:	41 bc 01 00 00 00    	mov    $0x1,%r12d
{
  100771:	53                   	push   %rbx
  100772:	48 89 d3             	mov    %rdx,%rbx
  100775:	51                   	push   %rcx
	stack[sz++] = tree->root;
  100776:	48 8b 07             	mov    (%rdi),%rax
  100779:	48 89 02             	mov    %rax,(%rdx)

	while (stack[sz - 1] != node) {
  10077c:	41 8d 44 24 ff       	lea    -0x1(%r12),%eax
  100781:	48 98                	cltq   
  100783:	4c 8d 3c c3          	lea    (%rbx,%rax,8),%r15
  100787:	49 8b 37             	mov    (%r15),%rsi
  10078a:	4c 39 ee             	cmp    %r13,%rsi
  10078d:	74 30                	je     1007bf <find_and_stack+0x66>
		uint8_t side = tree->lessthan_fn(node, stack[sz - 1]) ? 0U : 1U;
  10078f:	4c 89 ef             	mov    %r13,%rdi
  100792:	41 ff 56 08          	callq  *0x8(%r14)
  100796:	41 89 c0             	mov    %eax,%r8d
		struct rbnode *ch = get_child(stack[sz - 1], side);
  100799:	49 8b 07             	mov    (%r15),%rax
	if (side != 0U) {
  10079c:	45 84 c0             	test   %r8b,%r8b
  10079f:	75 06                	jne    1007a7 <find_and_stack+0x4e>
		return n->children[1];
  1007a1:	48 8b 40 08          	mov    0x8(%rax),%rax
  1007a5:	eb 07                	jmp    1007ae <find_and_stack+0x55>
	uintptr_t l = (uintptr_t) n->children[0];
  1007a7:	48 8b 00             	mov    (%rax),%rax
	l &= ~1UL;
  1007aa:	48 83 e0 fe          	and    $0xfffffffffffffffe,%rax

		if (ch != NULL) {
  1007ae:	48 85 c0             	test   %rax,%rax
  1007b1:	74 0c                	je     1007bf <find_and_stack+0x66>
			stack[sz++] = ch;
  1007b3:	49 63 d4             	movslq %r12d,%rdx
  1007b6:	41 ff c4             	inc    %r12d
  1007b9:	48 89 04 d3          	mov    %rax,(%rbx,%rdx,8)
  1007bd:	eb bd                	jmp    10077c <find_and_stack+0x23>
			break;
		}
	}

	return sz;
}
  1007bf:	5a                   	pop    %rdx
  1007c0:	44 89 e0             	mov    %r12d,%eax
  1007c3:	5b                   	pop    %rbx
  1007c4:	41 5c                	pop    %r12
  1007c6:	41 5d                	pop    %r13
  1007c8:	41 5e                	pop    %r14
  1007ca:	41 5f                	pop    %r15
  1007cc:	5d                   	pop    %rbp
  1007cd:	c3                   	retq   

00000000001007ce <rotate>:
 *  N  c  -->  a   P
 * a b            b c
 *
 */
static void rotate(struct rbnode **stack, int stacksz)
{
  1007ce:	55                   	push   %rbp
	CHECK(stacksz >= 2);

	struct rbnode *parent = stack[stacksz - 2];
  1007cf:	8d 46 fe             	lea    -0x2(%rsi),%eax
  1007d2:	48 98                	cltq   
{
  1007d4:	48 89 e5             	mov    %rsp,%rbp
  1007d7:	41 55                	push   %r13
  1007d9:	41 54                	push   %r12
	struct rbnode *parent = stack[stacksz - 2];
  1007db:	4c 8d 24 c7          	lea    (%rdi,%rax,8),%r12
	struct rbnode *child = stack[stacksz - 1];
  1007df:	8d 46 ff             	lea    -0x1(%rsi),%eax
{
  1007e2:	53                   	push   %rbx
	struct rbnode *child = stack[stacksz - 1];
  1007e3:	48 98                	cltq   
{
  1007e5:	52                   	push   %rdx
	struct rbnode *parent = stack[stacksz - 2];
  1007e6:	4d 8b 04 24          	mov    (%r12),%r8
	struct rbnode *child = stack[stacksz - 1];
  1007ea:	48 8d 1c c7          	lea    (%rdi,%rax,8),%rbx
  1007ee:	48 8b 0b             	mov    (%rbx),%rcx
	return (get_child(parent, 1U) == child) ? 1U : 0U;
  1007f1:	49 3b 48 08          	cmp    0x8(%r8),%rcx
  1007f5:	75 0c                	jne    100803 <rotate+0x35>
		return n->children[1];
  1007f7:	4c 8b 51 08          	mov    0x8(%rcx),%r10
	return (get_child(parent, 1U) == child) ? 1U : 0U;
  1007fb:	41 bd 01 00 00 00    	mov    $0x1,%r13d
		return n->children[1];
  100801:	eb 0a                	jmp    10080d <rotate+0x3f>
	l &= ~1UL;
  100803:	4c 8b 11             	mov    (%rcx),%r10
	return (get_child(parent, 1U) == child) ? 1U : 0U;
  100806:	45 31 ed             	xor    %r13d,%r13d
	l &= ~1UL;
  100809:	49 83 e2 fe          	and    $0xfffffffffffffffe,%r10
	uint8_t side = get_side(parent, child);
	struct rbnode *a = get_child(child, side);
	struct rbnode *b = get_child(child, (side == 0U) ? 1U : 0U);
  10080d:	45 89 eb             	mov    %r13d,%r11d
  100810:	41 83 f3 01          	xor    $0x1,%r11d
  100814:	45 0f b6 db          	movzbl %r11b,%r11d
	if (side != 0U) {
  100818:	45 84 ed             	test   %r13b,%r13b
  10081b:	75 06                	jne    100823 <rotate+0x55>
		return n->children[1];
  10081d:	4c 8b 49 08          	mov    0x8(%rcx),%r9
  100821:	eb 07                	jmp    10082a <rotate+0x5c>
	l &= ~1UL;
  100823:	4c 8b 09             	mov    (%rcx),%r9
  100826:	49 83 e1 fe          	and    $0xfffffffffffffffe,%r9

	if (stacksz >= 3) {
  10082a:	83 fe 02             	cmp    $0x2,%esi
  10082d:	7e 1c                	jle    10084b <rotate+0x7d>
		struct rbnode *grandparent = stack[stacksz - 3];
  10082f:	83 ee 03             	sub    $0x3,%esi

		set_child(grandparent, get_side(grandparent, parent), child);
  100832:	48 89 ca             	mov    %rcx,%rdx
		struct rbnode *grandparent = stack[stacksz - 3];
  100835:	48 63 f6             	movslq %esi,%rsi
  100838:	48 8b 3c f7          	mov    (%rdi,%rsi,8),%rdi
	return (get_child(parent, 1U) == child) ? 1U : 0U;
  10083c:	31 f6                	xor    %esi,%esi
  10083e:	4c 39 47 08          	cmp    %r8,0x8(%rdi)
  100842:	40 0f 94 c6          	sete   %sil
		set_child(grandparent, get_side(grandparent, parent), child);
  100846:	e8 f7 fe ff ff       	callq  100742 <set_child>
	}

	set_child(child, side, a);
  10084b:	44 89 ee             	mov    %r13d,%esi
  10084e:	48 89 cf             	mov    %rcx,%rdi
  100851:	4c 89 d2             	mov    %r10,%rdx
  100854:	e8 e9 fe ff ff       	callq  100742 <set_child>
	set_child(child, (side == 0U) ? 1U : 0U, parent);
  100859:	4c 89 c2             	mov    %r8,%rdx
  10085c:	44 89 de             	mov    %r11d,%esi
  10085f:	e8 de fe ff ff       	callq  100742 <set_child>
	set_child(parent, side, b);
  100864:	44 89 ee             	mov    %r13d,%esi
  100867:	4c 89 ca             	mov    %r9,%rdx
  10086a:	4c 89 c7             	mov    %r8,%rdi
  10086d:	e8 d0 fe ff ff       	callq  100742 <set_child>
	stack[stacksz - 2] = child;
  100872:	49 89 0c 24          	mov    %rcx,(%r12)
	stack[stacksz - 1] = parent;
  100876:	4c 89 03             	mov    %r8,(%rbx)
}
  100879:	58                   	pop    %rax
  10087a:	5b                   	pop    %rbx
  10087b:	41 5c                	pop    %r12
  10087d:	41 5d                	pop    %r13
  10087f:	5d                   	pop    %rbp
  100880:	c3                   	retq   

0000000000100881 <rb_insert>:
	 */
	set_color(stack[0], BLACK);
}

void rb_insert(struct rbtree *tree, struct rbnode *node)
{
  100881:	55                   	push   %rbp
  100882:	48 89 e5             	mov    %rsp,%rbp
  100885:	41 57                	push   %r15
  100887:	41 56                	push   %r14
  100889:	49 89 f6             	mov    %rsi,%r14
  10088c:	41 55                	push   %r13
  10088e:	49 89 fd             	mov    %rdi,%r13
  100891:	41 54                	push   %r12
  100893:	53                   	push   %rbx
  100894:	48 83 ec 28          	sub    $0x28,%rsp
		n->children[0] = (void *) (new | (old & 1UL));
  100898:	48 83 26 01          	andq   $0x1,(%rsi)
	set_child(node, 0U, NULL);
	set_child(node, 1U, NULL);

	if (tree->root == NULL) {
  10089c:	48 83 3f 00          	cmpq   $0x0,(%rdi)
		n->children[1] = val;
  1008a0:	48 c7 46 08 00 00 00 	movq   $0x0,0x8(%rsi)
  1008a7:	00 
	if (tree->root == NULL) {
  1008a8:	75 17                	jne    1008c1 <rb_insert+0x40>
		tree->root = node;
  1008aa:	49 89 75 00          	mov    %rsi,0x0(%r13)
		tree->max_depth = 1;
  1008ae:	c7 47 10 01 00 00 00 	movl   $0x1,0x10(%rdi)
	*p = (*p & ~1UL) | (uint8_t)color;
  1008b5:	48 c7 06 01 00 00 00 	movq   $0x1,(%rsi)
		set_color(node, BLACK);
		return;
  1008bc:	e9 60 01 00 00       	jmpq   100a21 <rb_insert+0x1a0>
	}

#ifdef CONFIG_MISRA_SANE
	struct rbnode **stack = &tree->iter_stack[0];
#else
	struct rbnode *stack[tree->max_depth + 1];
  1008c1:	8b 47 10             	mov    0x10(%rdi),%eax
  1008c4:	48 89 e3             	mov    %rsp,%rbx
  1008c7:	48 89 5d c8          	mov    %rbx,-0x38(%rbp)
  1008cb:	ff c0                	inc    %eax
  1008cd:	48 98                	cltq   
  1008cf:	48 8d 04 c5 0f 00 00 	lea    0xf(,%rax,8),%rax
  1008d6:	00 
  1008d7:	48 83 e0 f0          	and    $0xfffffffffffffff0,%rax
  1008db:	48 29 c4             	sub    %rax,%rsp
  1008de:	4c 8d 44 24 07       	lea    0x7(%rsp),%r8
  1008e3:	4c 89 c3             	mov    %r8,%rbx
  1008e6:	49 83 e0 f8          	and    $0xfffffffffffffff8,%r8
#endif

	int stacksz = find_and_stack(tree, node, stack);
  1008ea:	4c 89 c2             	mov    %r8,%rdx
  1008ed:	4c 89 45 c0          	mov    %r8,-0x40(%rbp)
	struct rbnode *stack[tree->max_depth + 1];
  1008f1:	48 c1 eb 03          	shr    $0x3,%rbx
	int stacksz = find_and_stack(tree, node, stack);
  1008f5:	e8 5f fe ff ff       	callq  100759 <find_and_stack>

	struct rbnode *parent = stack[stacksz - 1];
  1008fa:	4c 8b 45 c0          	mov    -0x40(%rbp),%r8

	uint8_t side = tree->lessthan_fn(node, parent) ? 0U : 1U;
  1008fe:	4c 89 f7             	mov    %r14,%rdi
	struct rbnode *parent = stack[stacksz - 1];
  100901:	44 8d 48 ff          	lea    -0x1(%rax),%r9d
	int stacksz = find_and_stack(tree, node, stack);
  100905:	41 89 c7             	mov    %eax,%r15d
	struct rbnode *parent = stack[stacksz - 1];
  100908:	4d 63 c9             	movslq %r9d,%r9
  10090b:	4c 89 45 b8          	mov    %r8,-0x48(%rbp)
  10090f:	4f 8b 24 c8          	mov    (%r8,%r9,8),%r12
  100913:	4c 89 4d c0          	mov    %r9,-0x40(%rbp)
	uint8_t side = tree->lessthan_fn(node, parent) ? 0U : 1U;
  100917:	4c 89 e6             	mov    %r12,%rsi
  10091a:	41 ff 55 08          	callq  *0x8(%r13)

	set_child(parent, side, node);
  10091e:	4c 89 e7             	mov    %r12,%rdi
  100921:	4c 89 f2             	mov    %r14,%rdx
	set_color(node, RED);

	stack[stacksz++] = node;
  100924:	45 8d 67 01          	lea    0x1(%r15),%r12d
	uint8_t side = tree->lessthan_fn(node, parent) ? 0U : 1U;
  100928:	83 f0 01             	xor    $0x1,%eax
	set_child(parent, side, node);
  10092b:	0f b6 f0             	movzbl %al,%esi
  10092e:	e8 0f fe ff ff       	callq  100742 <set_child>
	stack[stacksz++] = node;
  100933:	4c 8b 45 b8          	mov    -0x48(%rbp),%r8
  100937:	49 63 c7             	movslq %r15d,%rax
	*p = (*p & ~1UL) | (uint8_t)color;
  10093a:	49 83 26 fe          	andq   $0xfffffffffffffffe,(%r14)
	stack[stacksz++] = node;
  10093e:	4c 8b 4d c0          	mov    -0x40(%rbp),%r9
  100942:	41 83 ef 02          	sub    $0x2,%r15d
  100946:	44 89 e6             	mov    %r12d,%esi
  100949:	4d 89 34 c0          	mov    %r14,(%r8,%rax,8)
	while (stacksz > 1) {
  10094d:	4d 63 ff             	movslq %r15d,%r15
  100950:	4f 8d 0c c8          	lea    (%r8,%r9,8),%r9
  100954:	4b 8d 3c f8          	lea    (%r8,%r15,8),%rdi
  100958:	83 fe 01             	cmp    $0x1,%esi
  10095b:	0f 8e 9a 00 00 00    	jle    1009fb <rb_insert+0x17a>
		struct rbnode *parent = stack[stacksz - 2];
  100961:	49 8b 11             	mov    (%r9),%rdx
  100964:	8d 4e fe             	lea    -0x2(%rsi),%ecx
  100967:	4d 89 ce             	mov    %r9,%r14
		if (is_black(parent)) {
  10096a:	f6 02 01             	testb  $0x1,(%rdx)
  10096d:	0f 85 94 00 00 00    	jne    100a07 <rb_insert+0x186>
		struct rbnode *grandparent = stack[stacksz - 3];
  100973:	4c 8b 1f             	mov    (%rdi),%r11
  100976:	49 89 ff             	mov    %rdi,%r15
	return (get_child(parent, 1U) == child) ? 1U : 0U;
  100979:	45 31 d2             	xor    %r10d,%r10d
		return n->children[1];
  10097c:	49 8b 43 08          	mov    0x8(%r11),%rax
	return (get_child(parent, 1U) == child) ? 1U : 0U;
  100980:	48 39 c2             	cmp    %rax,%rdx
  100983:	75 0a                	jne    10098f <rb_insert+0x10e>
	l &= ~1UL;
  100985:	49 8b 03             	mov    (%r11),%rax
	return (get_child(parent, 1U) == child) ? 1U : 0U;
  100988:	41 b2 01             	mov    $0x1,%r10b
	l &= ~1UL;
  10098b:	48 83 e0 fe          	and    $0xfffffffffffffffe,%rax
		if ((aunt != NULL) && is_red(aunt)) {
  10098f:	48 85 c0             	test   %rax,%rax
  100992:	74 1d                	je     1009b1 <rb_insert+0x130>
  100994:	49 83 e9 10          	sub    $0x10,%r9
  100998:	48 83 ef 10          	sub    $0x10,%rdi
  10099c:	f6 00 01             	testb  $0x1,(%rax)
  10099f:	75 10                	jne    1009b1 <rb_insert+0x130>
	*p = (*p & ~1UL) | (uint8_t)color;
  1009a1:	49 83 23 fe          	andq   $0xfffffffffffffffe,(%r11)
			stacksz -= 2;
  1009a5:	89 ce                	mov    %ecx,%esi
	*p = (*p & ~1UL) | (uint8_t)color;
  1009a7:	48 83 0a 01          	orq    $0x1,(%rdx)
  1009ab:	48 83 08 01          	orq    $0x1,(%rax)
			continue;
  1009af:	eb a7                	jmp    100958 <rb_insert+0xd7>
		struct rbnode *node = stack[stacksz - 1];
  1009b1:	44 8d 4e ff          	lea    -0x1(%rsi),%r9d
	return (get_child(parent, 1U) == child) ? 1U : 0U;
  1009b5:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
		struct rbnode *node = stack[stacksz - 1];
  1009b9:	49 63 c1             	movslq %r9d,%rax
	return (get_child(parent, 1U) == child) ? 1U : 0U;
  1009bc:	49 39 0c c0          	cmp    %rcx,(%r8,%rax,8)
  1009c0:	0f 94 c0             	sete   %al
		if (parent_side != side) {
  1009c3:	44 38 d0             	cmp    %r10b,%al
  1009c6:	74 18                	je     1009e0 <rb_insert+0x15f>
			rotate(stack, stacksz);
  1009c8:	4c 89 c7             	mov    %r8,%rdi
  1009cb:	44 89 4d b8          	mov    %r9d,-0x48(%rbp)
  1009cf:	4c 89 45 c0          	mov    %r8,-0x40(%rbp)
  1009d3:	e8 f6 fd ff ff       	callq  1007ce <rotate>
  1009d8:	44 8b 4d b8          	mov    -0x48(%rbp),%r9d
  1009dc:	4c 8b 45 c0          	mov    -0x40(%rbp),%r8
		rotate(stack, stacksz - 1);
  1009e0:	44 89 ce             	mov    %r9d,%esi
  1009e3:	4c 89 c7             	mov    %r8,%rdi
  1009e6:	e8 e3 fd ff ff       	callq  1007ce <rotate>
		set_color(stack[stacksz - 3], BLACK);
  1009eb:	49 8b 07             	mov    (%r15),%rax
	*p = (*p & ~1UL) | (uint8_t)color;
  1009ee:	48 83 08 01          	orq    $0x1,(%rax)
		set_color(stack[stacksz - 2], RED);
  1009f2:	49 8b 06             	mov    (%r14),%rax
	*p = (*p & ~1UL) | (uint8_t)color;
  1009f5:	48 83 20 fe          	andq   $0xfffffffffffffffe,(%rax)
}
  1009f9:	eb 0c                	jmp    100a07 <rb_insert+0x186>
	set_color(stack[0], BLACK);
  1009fb:	48 8b 04 dd 00 00 00 	mov    0x0(,%rbx,8),%rax
  100a02:	00 
	*p = (*p & ~1UL) | (uint8_t)color;
  100a03:	48 83 08 01          	orq    $0x1,(%rax)
	fix_extra_red(stack, stacksz);

	if (stacksz > tree->max_depth) {
  100a07:	45 39 65 10          	cmp    %r12d,0x10(%r13)
  100a0b:	7d 04                	jge    100a11 <rb_insert+0x190>
		tree->max_depth = stacksz;
  100a0d:	45 89 65 10          	mov    %r12d,0x10(%r13)
	}

	/* We may have rotated up into the root! */
	tree->root = stack[0];
  100a11:	48 8b 04 dd 00 00 00 	mov    0x0(,%rbx,8),%rax
  100a18:	00 
  100a19:	49 89 45 00          	mov    %rax,0x0(%r13)
	CHECK(is_black(tree->root));
  100a1d:	48 8b 65 c8          	mov    -0x38(%rbp),%rsp
}
  100a21:	48 8d 65 d8          	lea    -0x28(%rbp),%rsp
  100a25:	5b                   	pop    %rbx
  100a26:	41 5c                	pop    %r12
  100a28:	41 5d                	pop    %r13
  100a2a:	41 5e                	pop    %r14
  100a2c:	41 5f                	pop    %r15
  100a2e:	5d                   	pop    %rbp
  100a2f:	c3                   	retq   

0000000000100a30 <rb_remove>:
		return;
	}
}

void rb_remove(struct rbtree *tree, struct rbnode *node)
{
  100a30:	55                   	push   %rbp
  100a31:	48 89 e5             	mov    %rsp,%rbp
  100a34:	41 57                	push   %r15
  100a36:	41 56                	push   %r14
  100a38:	41 55                	push   %r13
  100a3a:	41 54                	push   %r12
  100a3c:	53                   	push   %rbx
  100a3d:	48 89 f3             	mov    %rsi,%rbx
  100a40:	48 83 ec 48          	sub    $0x48,%rsp
	struct rbnode *tmp;
#ifdef CONFIG_MISRA_SANE
	struct rbnode **stack = &tree->iter_stack[0];
#else
	struct rbnode *stack[tree->max_depth + 1];
  100a44:	8b 47 10             	mov    0x10(%rdi),%eax
{
  100a47:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  100a4b:	48 89 65 b8          	mov    %rsp,-0x48(%rbp)
	struct rbnode *stack[tree->max_depth + 1];
  100a4f:	89 45 c0             	mov    %eax,-0x40(%rbp)
  100a52:	ff c0                	inc    %eax
  100a54:	48 98                	cltq   
  100a56:	48 8d 04 c5 0f 00 00 	lea    0xf(,%rax,8),%rax
  100a5d:	00 
  100a5e:	48 83 e0 f0          	and    $0xfffffffffffffff0,%rax
  100a62:	48 29 c4             	sub    %rax,%rsp
  100a65:	4c 8d 44 24 07       	lea    0x7(%rsp),%r8
  100a6a:	4c 89 c0             	mov    %r8,%rax
  100a6d:	49 83 e0 f8          	and    $0xfffffffffffffff8,%r8
  100a71:	48 c1 e8 03          	shr    $0x3,%rax
#endif

	int stacksz = find_and_stack(tree, node, stack);
  100a75:	4c 89 c2             	mov    %r8,%rdx
	struct rbnode *stack[tree->max_depth + 1];
  100a78:	4d 89 c4             	mov    %r8,%r12
  100a7b:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
	int stacksz = find_and_stack(tree, node, stack);
  100a7f:	e8 d5 fc ff ff       	callq  100759 <find_and_stack>
  100a84:	89 c1                	mov    %eax,%ecx

	if (node != stack[stacksz - 1]) {
  100a86:	ff c8                	dec    %eax
  100a88:	48 98                	cltq   
  100a8a:	4d 8d 14 c4          	lea    (%r12,%rax,8),%r10
  100a8e:	49 39 1a             	cmp    %rbx,(%r10)
  100a91:	0f 85 e1 02 00 00    	jne    100d78 <rb_remove+0x348>
	/* We can only remove a node with zero or one child, if we
	 * have two then pick the "biggest" child of side 0 (smallest
	 * of 1 would work too) and swap our spot in the tree with
	 * that one
	 */
	if ((get_child(node, 0U) != NULL) && (get_child(node, 1U) != NULL)) {
  100a97:	4c 8b 0b             	mov    (%rbx),%r9
  100a9a:	49 83 e1 fe          	and    $0xfffffffffffffffe,%r9
  100a9e:	0f 84 09 01 00 00    	je     100bad <rb_remove+0x17d>
  100aa4:	48 83 7b 08 00       	cmpq   $0x0,0x8(%rbx)
  100aa9:	0f 84 fe 00 00 00    	je     100bad <rb_remove+0x17d>
		int stacksz0 = stacksz;
		struct rbnode *hiparent, *loparent;
		struct rbnode *node2 = get_child(node, 0U);

		hiparent = (stacksz > 1) ? stack[stacksz - 2] : NULL;
  100aaf:	31 ff                	xor    %edi,%edi
  100ab1:	83 f9 01             	cmp    $0x1,%ecx
  100ab4:	7e 09                	jle    100abf <rb_remove+0x8f>
  100ab6:	8d 41 fe             	lea    -0x2(%rcx),%eax
  100ab9:	48 98                	cltq   
  100abb:	49 8b 3c c4          	mov    (%r12,%rax,8),%rdi
		stack[stacksz++] = node2;
  100abf:	48 63 c1             	movslq %ecx,%rax
  100ac2:	4d 89 0c c4          	mov    %r9,(%r12,%rax,8)
		return n->children[1];
  100ac6:	49 8b 41 08          	mov    0x8(%r9),%rax
		while (get_child(node2, 1U) != NULL) {
			node2 = get_child(node2, 1U);
			stack[stacksz++] = node2;
  100aca:	ff c1                	inc    %ecx
		while (get_child(node2, 1U) != NULL) {
  100acc:	48 85 c0             	test   %rax,%rax
  100acf:	74 0c                	je     100add <rb_remove+0xad>
			stack[stacksz++] = node2;
  100ad1:	48 63 d1             	movslq %ecx,%rdx
  100ad4:	49 89 c1             	mov    %rax,%r9
  100ad7:	49 89 04 d4          	mov    %rax,(%r12,%rdx,8)
  100adb:	eb e9                	jmp    100ac6 <rb_remove+0x96>
		}

		loparent = stack[stacksz - 2];
  100add:	8d 41 fe             	lea    -0x2(%rcx),%eax
  100ae0:	48 98                	cltq   
  100ae2:	4d 8b 1c c4          	mov    (%r12,%rax,8),%r11
		 * upper node.  Remember to swap the color bits of the
		 * two nodes also.  And of course we don't have parent
		 * pointers, so the stack tracking this structure
		 * needs to be swapped too!
		 */
		if (hiparent != NULL) {
  100ae6:	48 85 ff             	test   %rdi,%rdi
  100ae9:	74 14                	je     100aff <rb_remove+0xcf>
	return (get_child(parent, 1U) == child) ? 1U : 0U;
  100aeb:	31 f6                	xor    %esi,%esi
  100aed:	48 39 5f 08          	cmp    %rbx,0x8(%rdi)
			set_child(hiparent, get_side(hiparent, node), node2);
  100af1:	4c 89 ca             	mov    %r9,%rdx
	return (get_child(parent, 1U) == child) ? 1U : 0U;
  100af4:	40 0f 94 c6          	sete   %sil
			set_child(hiparent, get_side(hiparent, node), node2);
  100af8:	e8 45 fc ff ff       	callq  100742 <set_child>
  100afd:	eb 07                	jmp    100b06 <rb_remove+0xd6>
		} else {
			tree->root = node2;
  100aff:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  100b03:	4c 89 08             	mov    %r9,(%rax)
		}

		if (loparent == node) {
  100b06:	4c 39 db             	cmp    %r11,%rbx
  100b09:	75 1e                	jne    100b29 <rb_remove+0xf9>
		n->children[0] = (void *) (new | (old & 1UL));
  100b0b:	48 8b 03             	mov    (%rbx),%rax
	l &= ~1UL;
  100b0e:	49 8b 11             	mov    (%r9),%rdx
		n->children[0] = (void *) (new | (old & 1UL));
  100b11:	83 e0 01             	and    $0x1,%eax
	l &= ~1UL;
  100b14:	48 83 e2 fe          	and    $0xfffffffffffffffe,%rdx
		n->children[0] = (void *) (new | (old & 1UL));
  100b18:	48 09 d0             	or     %rdx,%rax
  100b1b:	48 89 03             	mov    %rax,(%rbx)
  100b1e:	49 8b 01             	mov    (%r9),%rax
  100b21:	83 e0 01             	and    $0x1,%eax
  100b24:	48 09 d8             	or     %rbx,%rax
  100b27:	eb 38                	jmp    100b61 <rb_remove+0x131>
	return (get_child(parent, 1U) == child) ? 1U : 0U;
  100b29:	31 f6                	xor    %esi,%esi
  100b2b:	4d 39 4b 08          	cmp    %r9,0x8(%r11)
			set_child(node, 0U, get_child(node2, 0U));
			set_child(node2, 0U, node);
		} else {
			set_child(loparent, get_side(loparent, node2), node);
  100b2f:	48 89 da             	mov    %rbx,%rdx
  100b32:	4c 89 df             	mov    %r11,%rdi
	return (get_child(parent, 1U) == child) ? 1U : 0U;
  100b35:	40 0f 94 c6          	sete   %sil
			set_child(loparent, get_side(loparent, node2), node);
  100b39:	e8 04 fc ff ff       	callq  100742 <set_child>
	uintptr_t l = (uintptr_t) n->children[0];
  100b3e:	48 8b 13             	mov    (%rbx),%rdx
	l &= ~1UL;
  100b41:	49 8b 31             	mov    (%r9),%rsi
		n->children[0] = (void *) (new | (old & 1UL));
  100b44:	48 89 d0             	mov    %rdx,%rax
	l &= ~1UL;
  100b47:	48 83 e6 fe          	and    $0xfffffffffffffffe,%rsi
  100b4b:	48 83 e2 fe          	and    $0xfffffffffffffffe,%rdx
		n->children[0] = (void *) (new | (old & 1UL));
  100b4f:	83 e0 01             	and    $0x1,%eax
  100b52:	48 09 f0             	or     %rsi,%rax
  100b55:	48 89 03             	mov    %rax,(%rbx)
  100b58:	49 8b 01             	mov    (%r9),%rax
  100b5b:	83 e0 01             	and    $0x1,%eax
  100b5e:	48 09 d0             	or     %rdx,%rax
  100b61:	49 89 01             	mov    %rax,(%r9)
		return n->children[1];
  100b64:	48 8b 43 08          	mov    0x8(%rbx),%rax
		n->children[1] = val;
  100b68:	49 89 41 08          	mov    %rax,0x8(%r9)

		set_child(node2, 1U, get_child(node, 1U));
		set_child(node, 1U, NULL);

		tmp = stack[stacksz0 - 1];
		stack[stacksz0 - 1] = stack[stacksz - 1];
  100b6c:	8d 41 ff             	lea    -0x1(%rcx),%eax
		tmp = stack[stacksz0 - 1];
  100b6f:	49 8b 12             	mov    (%r10),%rdx
		stack[stacksz0 - 1] = stack[stacksz - 1];
  100b72:	48 98                	cltq   
		n->children[1] = val;
  100b74:	48 c7 43 08 00 00 00 	movq   $0x0,0x8(%rbx)
  100b7b:	00 
		stack[stacksz0 - 1] = stack[stacksz - 1];
  100b7c:	49 8b 34 c4          	mov    (%r12,%rax,8),%rsi
  100b80:	49 89 32             	mov    %rsi,(%r10)
	return ((uintptr_t)n->children[0]) & 1UL;
  100b83:	48 8b 33             	mov    (%rbx),%rsi
		stack[stacksz - 1] = tmp;
  100b86:	49 89 14 c4          	mov    %rdx,(%r12,%rax,8)
	*p = (*p & ~1UL) | (uint8_t)color;
  100b8a:	49 8b 11             	mov    (%r9),%rdx
  100b8d:	48 89 f0             	mov    %rsi,%rax
  100b90:	83 e6 01             	and    $0x1,%esi
  100b93:	48 83 e0 fe          	and    $0xfffffffffffffffe,%rax
  100b97:	83 e2 01             	and    $0x1,%edx
  100b9a:	48 09 c2             	or     %rax,%rdx
  100b9d:	48 89 13             	mov    %rdx,(%rbx)
  100ba0:	49 8b 01             	mov    (%r9),%rax
  100ba3:	48 83 e0 fe          	and    $0xfffffffffffffffe,%rax
  100ba7:	48 09 f0             	or     %rsi,%rax
  100baa:	49 89 01             	mov    %rax,(%r9)
	uintptr_t l = (uintptr_t) n->children[0];
  100bad:	48 8b 03             	mov    (%rbx),%rax
	CHECK((get_child(node, 0U) == NULL) ||
	      (get_child(node, 1U) == NULL));

	struct rbnode *child = get_child(node, 0U);

	if (child == NULL) {
  100bb0:	49 89 c5             	mov    %rax,%r13
  100bb3:	49 83 e5 fe          	and    $0xfffffffffffffffe,%r13
  100bb7:	75 04                	jne    100bbd <rb_remove+0x18d>
		return n->children[1];
  100bb9:	4c 8b 6b 08          	mov    0x8(%rbx),%r13
		child = get_child(node, 1U);
	}

	/* Removing the root */
	if (stacksz < 2) {
  100bbd:	83 f9 01             	cmp    $0x1,%ecx
  100bc0:	7f 26                	jg     100be8 <rb_remove+0x1b8>
		tree->root = child;
  100bc2:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  100bc6:	4c 89 28             	mov    %r13,(%rax)
		if (child != NULL) {
  100bc9:	4d 85 ed             	test   %r13,%r13
  100bcc:	74 0a                	je     100bd8 <rb_remove+0x1a8>
	*p = (*p & ~1UL) | (uint8_t)color;
  100bce:	49 83 4d 00 01       	orq    $0x1,0x0(%r13)
}
  100bd3:	e9 a0 01 00 00       	jmpq   100d78 <rb_remove+0x348>
			set_color(child, BLACK);
		} else {
			tree->max_depth = 0;
  100bd8:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  100bdc:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%rax)
  100be3:	e9 90 01 00 00       	jmpq   100d78 <rb_remove+0x348>
		}
		return;
	}

	struct rbnode *parent = stack[stacksz - 2];
  100be8:	8d 51 fe             	lea    -0x2(%rcx),%edx
  100beb:	48 63 d2             	movslq %edx,%rdx
  100bee:	49 8b 3c d4          	mov    (%r12,%rdx,8),%rdi
	/* Special case: if the node to be removed is childless, then
	 * we leave it in place while we do the missing black
	 * rotations, which will replace it with a proper NULL when
	 * they isolate it.
	 */
	if (child == NULL) {
  100bf2:	4d 85 ed             	test   %r13,%r13
  100bf5:	0f 85 01 01 00 00    	jne    100cfc <rb_remove+0x2cc>
		if (is_black(node)) {
  100bfb:	a8 01                	test   $0x1,%al
  100bfd:	0f 84 e6 00 00 00    	je     100ce9 <rb_remove+0x2b9>
		struct rbnode *n = stack[stacksz - 1];
  100c03:	8d 41 ff             	lea    -0x1(%rcx),%eax
	return (get_child(parent, 1U) == child) ? 1U : 0U;
  100c06:	31 d2                	xor    %edx,%edx
		struct rbnode *n = stack[stacksz - 1];
  100c08:	48 98                	cltq   
  100c0a:	4d 8d 1c c4          	lea    (%r12,%rax,8),%r11
  100c0e:	49 8b 03             	mov    (%r11),%rax
  100c11:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
		struct rbnode *parent = stack[stacksz - 2];
  100c15:	8d 41 fe             	lea    -0x2(%rcx),%eax
  100c18:	48 98                	cltq   
  100c1a:	4d 8b 2c c4          	mov    (%r12,%rax,8),%r13
		return n->children[1];
  100c1e:	4d 8b 7d 08          	mov    0x8(%r13),%r15
	return (get_child(parent, 1U) == child) ? 1U : 0U;
  100c22:	4c 39 7d c0          	cmp    %r15,-0x40(%rbp)
  100c26:	75 0a                	jne    100c32 <rb_remove+0x202>
	l &= ~1UL;
  100c28:	4d 8b 7d 00          	mov    0x0(%r13),%r15
	return (get_child(parent, 1U) == child) ? 1U : 0U;
  100c2c:	b2 01                	mov    $0x1,%dl
	l &= ~1UL;
  100c2e:	49 83 e7 fe          	and    $0xfffffffffffffffe,%r15
	return ((uintptr_t)n->children[0]) & 1UL;
  100c32:	41 89 ce             	mov    %ecx,%r14d
		if (!is_black(sib)) {
  100c35:	41 f6 07 01          	testb  $0x1,(%r15)
  100c39:	75 4b                	jne    100c86 <rb_remove+0x256>
			stack[stacksz - 1] = sib;
  100c3b:	4d 89 3b             	mov    %r15,(%r11)
			rotate(stack, stacksz);
  100c3e:	89 ce                	mov    %ecx,%esi
  100c40:	4c 89 e7             	mov    %r12,%rdi
			stack[stacksz++] = n;
  100c43:	41 ff c6             	inc    %r14d
  100c46:	88 55 9f             	mov    %dl,-0x61(%rbp)
  100c49:	89 4d a0             	mov    %ecx,-0x60(%rbp)
			stack[stacksz - 1] = sib;
  100c4c:	4c 89 5d a8          	mov    %r11,-0x58(%rbp)
			rotate(stack, stacksz);
  100c50:	e8 79 fb ff ff       	callq  1007ce <rotate>
			stack[stacksz++] = n;
  100c55:	48 63 4d a0          	movslq -0x60(%rbp),%rcx
  100c59:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
			parent = stack[stacksz - 2];
  100c5d:	4c 8b 5d a8          	mov    -0x58(%rbp),%r11
	if (side != 0U) {
  100c61:	8a 55 9f             	mov    -0x61(%rbp),%dl
	*p = (*p & ~1UL) | (uint8_t)color;
  100c64:	49 83 65 00 fe       	andq   $0xfffffffffffffffe,0x0(%r13)
  100c69:	49 83 0f 01          	orq    $0x1,(%r15)
			stack[stacksz++] = n;
  100c6d:	49 89 04 cc          	mov    %rax,(%r12,%rcx,8)
			parent = stack[stacksz - 2];
  100c71:	4d 8b 2b             	mov    (%r11),%r13
	if (side != 0U) {
  100c74:	84 d2                	test   %dl,%dl
  100c76:	75 06                	jne    100c7e <rb_remove+0x24e>
		return n->children[1];
  100c78:	4d 8b 7d 08          	mov    0x8(%r13),%r15
  100c7c:	eb 08                	jmp    100c86 <rb_remove+0x256>
	l &= ~1UL;
  100c7e:	4d 8b 7d 00          	mov    0x0(%r13),%r15
  100c82:	49 83 e7 fe          	and    $0xfffffffffffffffe,%r15
		if (((c0 == NULL) || is_black(c0)) && ((c1 == NULL) ||
  100c86:	49 8b 3f             	mov    (%r15),%rdi
		return n->children[1];
  100c89:	49 8b 4f 08          	mov    0x8(%r15),%rcx
		if (((c0 == NULL) || is_black(c0)) && ((c1 == NULL) ||
  100c8d:	48 83 e7 fe          	and    $0xfffffffffffffffe,%rdi
  100c91:	74 05                	je     100c98 <rb_remove+0x268>
  100c93:	f6 07 01             	testb  $0x1,(%rdi)
  100c96:	74 44                	je     100cdc <rb_remove+0x2ac>
  100c98:	48 85 c9             	test   %rcx,%rcx
  100c9b:	74 09                	je     100ca6 <rb_remove+0x276>
  100c9d:	f6 01 01             	testb  $0x1,(%rcx)
  100ca0:	0f 84 e5 00 00 00    	je     100d8b <rb_remove+0x35b>
			if (n == null_node) {
  100ca6:	48 3b 5d c0          	cmp    -0x40(%rbp),%rbx
  100caa:	75 0d                	jne    100cb9 <rb_remove+0x289>
				set_child(parent, n_side, NULL);
  100cac:	0f b6 f2             	movzbl %dl,%esi
  100caf:	4c 89 ef             	mov    %r13,%rdi
  100cb2:	31 d2                	xor    %edx,%edx
  100cb4:	e8 89 fa ff ff       	callq  100742 <set_child>
	return get_color(n) == BLACK;
  100cb9:	49 8b 45 00          	mov    0x0(%r13),%rax
	*p = (*p & ~1UL) | (uint8_t)color;
  100cbd:	49 83 27 fe          	andq   $0xfffffffffffffffe,(%r15)
			if (is_black(parent)) {
  100cc1:	a8 01                	test   $0x1,%al
  100cc3:	0f 84 94 00 00 00    	je     100d5d <rb_remove+0x32d>
				stacksz--;
  100cc9:	41 8d 4e ff          	lea    -0x1(%r14),%ecx
	while (stacksz > 1) {
  100ccd:	41 83 fe 02          	cmp    $0x2,%r14d
  100cd1:	0f 85 2c ff ff ff    	jne    100c03 <rb_remove+0x1d3>
  100cd7:	e9 89 00 00 00       	jmpq   100d65 <rb_remove+0x335>
	if (side != 0U) {
  100cdc:	84 d2                	test   %dl,%dl
  100cde:	0f 85 af 00 00 00    	jne    100d93 <rb_remove+0x363>
  100ce4:	e9 bf 00 00 00       	jmpq   100da8 <rb_remove+0x378>
	return (get_child(parent, 1U) == child) ? 1U : 0U;
  100ce9:	31 f6                	xor    %esi,%esi
  100ceb:	48 39 5f 08          	cmp    %rbx,0x8(%rdi)
  100cef:	40 0f 94 c6          	sete   %sil
			fix_missing_black(stack, stacksz, node);
		} else {
			/* Red childless nodes can just be dropped */
			set_child(parent, get_side(parent, node), NULL);
  100cf3:	31 d2                	xor    %edx,%edx
  100cf5:	e8 48 fa ff ff       	callq  100742 <set_child>
  100cfa:	eb 69                	jmp    100d65 <rb_remove+0x335>
	return (get_child(parent, 1U) == child) ? 1U : 0U;
  100cfc:	31 f6                	xor    %esi,%esi
  100cfe:	48 39 5f 08          	cmp    %rbx,0x8(%rdi)
		}
	} else {
		set_child(parent, get_side(parent, node), child);
  100d02:	4c 89 ea             	mov    %r13,%rdx
	return (get_child(parent, 1U) == child) ? 1U : 0U;
  100d05:	40 0f 94 c6          	sete   %sil
		set_child(parent, get_side(parent, node), child);
  100d09:	e8 34 fa ff ff       	callq  100742 <set_child>

		/* Check colors, if one was red (at least one must have been
		 * black in a valid tree), then we're done.
		 */
		__ASSERT(is_black(node) || is_black(child), "both nodes red?!");
  100d0e:	f6 03 01             	testb  $0x1,(%rbx)
  100d11:	75 3d                	jne    100d50 <rb_remove+0x320>
  100d13:	41 f6 45 00 01       	testb  $0x1,0x0(%r13)
  100d18:	75 36                	jne    100d50 <rb_remove+0x320>
  100d1a:	be 88 cf 11 00       	mov    $0x11cf88,%esi
  100d1f:	b9 e7 01 00 00       	mov    $0x1e7,%ecx
  100d24:	ba 69 cf 11 00       	mov    $0x11cf69,%edx
  100d29:	31 c0                	xor    %eax,%eax
  100d2b:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  100d30:	e8 c3 f8 ff ff       	callq  1005f8 <printk>
  100d35:	bf c7 cf 11 00       	mov    $0x11cfc7,%edi
  100d3a:	31 c0                	xor    %eax,%eax
  100d3c:	e8 b7 f8 ff ff       	callq  1005f8 <printk>
  100d41:	be e7 01 00 00       	mov    $0x1e7,%esi
  100d46:	bf 69 cf 11 00       	mov    $0x11cf69,%edi
  100d4b:	e8 48 1e 00 00       	callq  102b98 <assert_post_action>
	return ((uintptr_t)n->children[0]) & 1UL;
  100d50:	49 8b 45 00          	mov    0x0(%r13),%rax
		if (is_red(node) || is_red(child)) {
  100d54:	f6 03 01             	testb  $0x1,(%rbx)
  100d57:	74 04                	je     100d5d <rb_remove+0x32d>
  100d59:	a8 01                	test   $0x1,%al
  100d5b:	75 08                	jne    100d65 <rb_remove+0x335>
	*p = (*p & ~1UL) | (uint8_t)color;
  100d5d:	48 83 c8 01          	or     $0x1,%rax
  100d61:	49 89 45 00          	mov    %rax,0x0(%r13)
			set_color(child, BLACK);
		}
	}

	/* We may have rotated up into the root! */
	tree->root = stack[0];
  100d65:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  100d69:	48 8b 5d c8          	mov    -0x38(%rbp),%rbx
  100d6d:	48 8b 04 c5 00 00 00 	mov    0x0(,%rax,8),%rax
  100d74:	00 
  100d75:	48 89 03             	mov    %rax,(%rbx)
  100d78:	48 8b 65 b8          	mov    -0x48(%rbp),%rsp
}
  100d7c:	48 8d 65 d8          	lea    -0x28(%rbp),%rsp
  100d80:	5b                   	pop    %rbx
  100d81:	41 5c                	pop    %r12
  100d83:	41 5d                	pop    %r13
  100d85:	41 5e                	pop    %r14
  100d87:	41 5f                	pop    %r15
  100d89:	5d                   	pop    %rbp
  100d8a:	c3                   	retq   
	if (side != 0U) {
  100d8b:	84 d2                	test   %dl,%dl
  100d8d:	0f 84 cb 00 00 00    	je     100e5e <rb_remove+0x42e>
		if (!((outer != NULL) && is_red(outer))) {
  100d93:	48 89 fe             	mov    %rdi,%rsi
  100d96:	48 85 ff             	test   %rdi,%rdi
  100d99:	74 19                	je     100db4 <rb_remove+0x384>
  100d9b:	f6 06 01             	testb  $0x1,(%rsi)
  100d9e:	74 6e                	je     100e0e <rb_remove+0x3de>
	if (side != 0U) {
  100da0:	84 d2                	test   %dl,%dl
  100da2:	48 0f 44 cf          	cmove  %rdi,%rcx
  100da6:	eb 0c                	jmp    100db4 <rb_remove+0x384>
		if (!((outer != NULL) && is_red(outer))) {
  100da8:	48 85 c9             	test   %rcx,%rcx
  100dab:	0f 85 ad 00 00 00    	jne    100e5e <rb_remove+0x42e>
  100db1:	48 89 f9             	mov    %rdi,%rcx
			stack[stacksz - 1] = sib;
  100db4:	41 8d 76 ff          	lea    -0x1(%r14),%esi
			rotate(stack, stacksz);
  100db8:	4c 89 e7             	mov    %r12,%rdi
  100dbb:	88 55 9f             	mov    %dl,-0x61(%rbp)
			stack[stacksz - 1] = sib;
  100dbe:	48 63 f6             	movslq %esi,%rsi
			stack[stacksz++] = inner;
  100dc1:	48 89 4d a8          	mov    %rcx,-0x58(%rbp)
			stack[stacksz - 1] = sib;
  100dc5:	4d 8d 1c f4          	lea    (%r12,%rsi,8),%r11
			stack[stacksz++] = inner;
  100dc9:	49 63 f6             	movslq %r14d,%rsi
			stack[stacksz - 1] = sib;
  100dcc:	4d 89 3b             	mov    %r15,(%r11)
			stack[stacksz++] = inner;
  100dcf:	49 89 0c f4          	mov    %rcx,(%r12,%rsi,8)
  100dd3:	41 8d 76 01          	lea    0x1(%r14),%esi
			stack[stacksz - 1] = sib;
  100dd7:	4c 89 5d a0          	mov    %r11,-0x60(%rbp)
			rotate(stack, stacksz);
  100ddb:	e8 ee f9 ff ff       	callq  1007ce <rotate>
	*p = (*p & ~1UL) | (uint8_t)color;
  100de0:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
			sib = stack[stacksz - 2];
  100de4:	4c 8b 5d a0          	mov    -0x60(%rbp),%r11
	if (side != 0U) {
  100de8:	8a 55 9f             	mov    -0x61(%rbp),%dl
	*p = (*p & ~1UL) | (uint8_t)color;
  100deb:	49 83 27 fe          	andq   $0xfffffffffffffffe,(%r15)
			sib = stack[stacksz - 2];
  100def:	4d 8b 3b             	mov    (%r11),%r15
	*p = (*p & ~1UL) | (uint8_t)color;
  100df2:	48 83 09 01          	orq    $0x1,(%rcx)
	if (side != 0U) {
  100df6:	84 d2                	test   %dl,%dl
  100df8:	75 06                	jne    100e00 <rb_remove+0x3d0>
		return n->children[1];
  100dfa:	49 8b 77 08          	mov    0x8(%r15),%rsi
  100dfe:	eb 07                	jmp    100e07 <rb_remove+0x3d7>
	l &= ~1UL;
  100e00:	49 8b 37             	mov    (%r15),%rsi
  100e03:	48 83 e6 fe          	and    $0xfffffffffffffffe,%rsi
			stack[stacksz - 2] = n;
  100e07:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  100e0b:	49 89 03             	mov    %rax,(%r11)
	*p = (*p & ~1UL) | (uint8_t)color;
  100e0e:	49 8b 0f             	mov    (%r15),%rcx
  100e11:	49 8b 7d 00          	mov    0x0(%r13),%rdi
  100e15:	88 55 a8             	mov    %dl,-0x58(%rbp)
  100e18:	83 e7 01             	and    $0x1,%edi
  100e1b:	48 83 e1 fe          	and    $0xfffffffffffffffe,%rcx
  100e1f:	48 09 f9             	or     %rdi,%rcx
		rotate(stack, stacksz);
  100e22:	4c 89 e7             	mov    %r12,%rdi
	*p = (*p & ~1UL) | (uint8_t)color;
  100e25:	49 89 0f             	mov    %rcx,(%r15)
		stack[stacksz - 1] = sib;
  100e28:	41 8d 4e ff          	lea    -0x1(%r14),%ecx
	*p = (*p & ~1UL) | (uint8_t)color;
  100e2c:	49 83 4d 00 01       	orq    $0x1,0x0(%r13)
		stack[stacksz - 1] = sib;
  100e31:	48 63 c9             	movslq %ecx,%rcx
	*p = (*p & ~1UL) | (uint8_t)color;
  100e34:	48 83 0e 01          	orq    $0x1,(%rsi)
		rotate(stack, stacksz);
  100e38:	44 89 f6             	mov    %r14d,%esi
		stack[stacksz - 1] = sib;
  100e3b:	4d 89 3c cc          	mov    %r15,(%r12,%rcx,8)
		rotate(stack, stacksz);
  100e3f:	e8 8a f9 ff ff       	callq  1007ce <rotate>
		if (n == null_node) {
  100e44:	48 3b 5d c0          	cmp    -0x40(%rbp),%rbx
  100e48:	8a 55 a8             	mov    -0x58(%rbp),%dl
  100e4b:	0f 85 14 ff ff ff    	jne    100d65 <rb_remove+0x335>
			set_child(parent, n_side, NULL);
  100e51:	0f b6 f2             	movzbl %dl,%esi
  100e54:	4c 89 ef             	mov    %r13,%rdi
  100e57:	31 d2                	xor    %edx,%edx
  100e59:	e9 97 fe ff ff       	jmpq   100cf5 <rb_remove+0x2c5>
	if (side != 0U) {
  100e5e:	48 89 ce             	mov    %rcx,%rsi
  100e61:	e9 35 ff ff ff       	jmpq   100d9b <rb_remove+0x36b>

0000000000100e66 <rb_contains>:
{
	return is_black(node);
}

bool rb_contains(struct rbtree *tree, struct rbnode *node)
{
  100e66:	55                   	push   %rbp
  100e67:	48 89 e5             	mov    %rsp,%rbp
  100e6a:	41 55                	push   %r13
  100e6c:	49 89 fd             	mov    %rdi,%r13
  100e6f:	41 54                	push   %r12
  100e71:	49 89 f4             	mov    %rsi,%r12
  100e74:	53                   	push   %rbx
  100e75:	51                   	push   %rcx
	struct rbnode *n = tree->root;
  100e76:	48 8b 1f             	mov    (%rdi),%rbx

	while ((n != NULL) && (n != node)) {
  100e79:	48 85 db             	test   %rbx,%rbx
  100e7c:	74 22                	je     100ea0 <rb_contains+0x3a>
  100e7e:	4c 39 e3             	cmp    %r12,%rbx
  100e81:	74 1d                	je     100ea0 <rb_contains+0x3a>
		n = get_child(n, tree->lessthan_fn(n, node));
  100e83:	4c 89 e6             	mov    %r12,%rsi
  100e86:	48 89 df             	mov    %rbx,%rdi
  100e89:	41 ff 55 08          	callq  *0x8(%r13)
	if (side != 0U) {
  100e8d:	84 c0                	test   %al,%al
  100e8f:	74 06                	je     100e97 <rb_contains+0x31>
		return n->children[1];
  100e91:	48 8b 5b 08          	mov    0x8(%rbx),%rbx
  100e95:	eb e2                	jmp    100e79 <rb_contains+0x13>
	uintptr_t l = (uintptr_t) n->children[0];
  100e97:	48 8b 1b             	mov    (%rbx),%rbx
	l &= ~1UL;
  100e9a:	48 83 e3 fe          	and    $0xfffffffffffffffe,%rbx
	return (struct rbnode *) l;
  100e9e:	eb d9                	jmp    100e79 <rb_contains+0x13>
	}

	return n == node;
  100ea0:	4c 39 e3             	cmp    %r12,%rbx
}
  100ea3:	5a                   	pop    %rdx
  100ea4:	5b                   	pop    %rbx
	return n == node;
  100ea5:	0f 94 c0             	sete   %al
}
  100ea8:	41 5c                	pop    %r12
  100eaa:	41 5d                	pop    %r13
  100eac:	5d                   	pop    %rbp
  100ead:	c3                   	retq   

0000000000100eae <sys_sem_init>:
}

int sys_sem_init(struct sys_sem *sem, unsigned int initial_count,
		 unsigned int limit)
{
	if (sem == NULL || limit == SYS_SEM_MINIMUM ||
  100eae:	48 85 ff             	test   %rdi,%rdi
  100eb1:	74 14                	je     100ec7 <sys_sem_init+0x19>
  100eb3:	85 d2                	test   %edx,%edx
  100eb5:	74 10                	je     100ec7 <sys_sem_init+0x19>
	    initial_count > limit || limit > INT_MAX) {
  100eb7:	39 f2                	cmp    %esi,%edx
  100eb9:	72 0c                	jb     100ec7 <sys_sem_init+0x19>
  100ebb:	85 d2                	test   %edx,%edx
  100ebd:	78 08                	js     100ec7 <sys_sem_init+0x19>
{
	/* This builtin, as described by Intel, is not a traditional
	 * test-and-set operation, but rather an atomic exchange operation. It
	 * writes value into *ptr, and returns the previous contents of *ptr.
	 */
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
  100ebf:	87 37                	xchg   %esi,(%rdi)
	}

	atomic_set(&sem->futex.val, initial_count);
	sem->limit = limit;

	return 0;
  100ec1:	31 c0                	xor    %eax,%eax
	sem->limit = limit;
  100ec3:	89 57 04             	mov    %edx,0x4(%rdi)
	return 0;
  100ec6:	c3                   	retq   
		return -EINVAL;
  100ec7:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
}
  100ecc:	c3                   	retq   

0000000000100ecd <sys_sem_give>:
int sys_sem_give(struct sys_sem *sem)
{
	int ret = 0;
	atomic_t old_value;

	old_value = bounded_inc(&sem->futex.val,
  100ecd:	8b 77 04             	mov    0x4(%rdi),%esi
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
  100ed0:	8b 17                	mov    (%rdi),%edx
		if (old_value >= maximum) {
  100ed2:	39 d6                	cmp    %edx,%esi
  100ed4:	7e 14                	jle    100eea <sys_sem_give+0x1d>
			    minimum + 1 : old_value + 1;
  100ed6:	b9 01 00 00 00       	mov    $0x1,%ecx
  100edb:	85 d2                	test   %edx,%edx
  100edd:	78 03                	js     100ee2 <sys_sem_give+0x15>
  100edf:	8d 4a 01             	lea    0x1(%rdx),%ecx
	return __atomic_compare_exchange_n(target, &old_value, new_value,
  100ee2:	89 d0                	mov    %edx,%eax
  100ee4:	f0 0f b1 0f          	lock cmpxchg %ecx,(%rdi)
	} while (atomic_cas(val, old_value, new_value) == 0U);
  100ee8:	75 e6                	jne    100ed0 <sys_sem_give+0x3>
				SYS_SEM_MINIMUM, sem->limit);
	if (old_value < 0) {
  100eea:	85 d2                	test   %edx,%edx
  100eec:	79 34                	jns    100f22 <sys_sem_give+0x55>
{
  100eee:	55                   	push   %rbp
  100eef:	48 89 e5             	mov    %rsp,%rbp
  100ef2:	48 83 ec 10          	sub    $0x10,%rsp
  100ef6:	c6 45 ff 01          	movb   $0x1,-0x1(%rbp)
  100efa:	8c c8                	mov    %cs,%eax
	if (z_syscall_trap()) {
  100efc:	a8 03                	test   $0x3,%al
  100efe:	74 0d                	je     100f0d <sys_sem_give+0x40>
	register uintptr_t rsi __asm__("%rsi") = arg2;
  100f00:	48 8b 75 ff          	mov    -0x1(%rbp),%rsi
	register uintptr_t rax __asm__("%rax") = call_id;
  100f04:	b8 85 00 00 00       	mov    $0x85,%eax
	__asm__ volatile("syscall\n\t"
  100f09:	0f 05                	syscall 
		return (int) arch_syscall_invoke2(*(uintptr_t *)&futex, *(uintptr_t *)&wake_all, K_SYSCALL_K_FUTEX_WAKE);
  100f0b:	eb 09                	jmp    100f16 <sys_sem_give+0x49>
	return z_impl_k_futex_wake(futex, wake_all);
  100f0d:	0f b6 75 ff          	movzbl -0x1(%rbp),%esi
  100f11:	e8 a3 4b 01 00       	callq  115ab9 <z_impl_k_futex_wake>
		return -EAGAIN;
	} else {
		;
	}
	return ret;
}
  100f16:	c9                   	leaveq 
  100f17:	85 c0                	test   %eax,%eax
  100f19:	ba 00 00 00 00       	mov    $0x0,%edx
  100f1e:	0f 4f c2             	cmovg  %edx,%eax
  100f21:	c3                   	retq   
		return -EAGAIN;
  100f22:	39 57 04             	cmp    %edx,0x4(%rdi)
  100f25:	b8 00 00 00 00       	mov    $0x0,%eax
  100f2a:	ba f5 ff ff ff       	mov    $0xfffffff5,%edx
  100f2f:	0f 4e c2             	cmovle %edx,%eax
}
  100f32:	c3                   	retq   

0000000000100f33 <sys_sem_take>:

int sys_sem_take(struct sys_sem *sem, k_timeout_t timeout)
{
  100f33:	55                   	push   %rbp
  100f34:	48 89 e5             	mov    %rsp,%rbp
  100f37:	41 54                	push   %r12
  100f39:	49 89 f4             	mov    %rsi,%r12
  100f3c:	53                   	push   %rbx
  100f3d:	48 89 fb             	mov    %rdi,%rbx
  100f40:	48 83 ec 10          	sub    $0x10,%rsp
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
  100f44:	8b 13                	mov    (%rbx),%edx
		if (old_value < minimum) {
  100f46:	85 d2                	test   %edx,%edx
  100f48:	79 20                	jns    100f6a <sys_sem_take+0x37>
static inline int k_futex_wait(struct k_futex * futex, int expected, k_timeout_t timeout)
  100f4a:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%rbp)
	__asm__ volatile ("mov %%cs, %[cs_val]" : [cs_val] "=r" (cs));
  100f51:	8c c8                	mov    %cs,%eax
	if (z_syscall_trap()) {
  100f53:	a8 03                	test   $0x3,%al
  100f55:	74 26                	je     100f7d <sys_sem_take+0x4a>
	register uintptr_t rsi __asm__("%rsi") = arg2;
  100f57:	48 8b 75 ec          	mov    -0x14(%rbp),%rsi
	register uintptr_t rax __asm__("%rax") = call_id;
  100f5b:	b8 84 00 00 00       	mov    $0x84,%eax
	register uintptr_t rdi __asm__("%rdi") = arg1;
  100f60:	48 89 df             	mov    %rbx,%rdi
	register uintptr_t rdx __asm__("%rdx") = arg3;
  100f63:	4c 89 e2             	mov    %r12,%rdx
	__asm__ volatile("syscall\n\t"
  100f66:	0f 05                	syscall 
		return (int) arch_syscall_invoke3(*(uintptr_t *)&futex, *(uintptr_t *)&expected, *(uintptr_t *)&timeout, K_SYSCALL_K_FUTEX_WAIT);
  100f68:	eb 21                	jmp    100f8b <sys_sem_take+0x58>
		new_value = old_value - 1;
  100f6a:	8d 4a ff             	lea    -0x1(%rdx),%ecx
	return __atomic_compare_exchange_n(target, &old_value, new_value,
  100f6d:	89 d0                	mov    %edx,%eax
  100f6f:	f0 0f b1 0b          	lock cmpxchg %ecx,(%rbx)
	} while (atomic_cas(val, old_value, new_value) == 0);
  100f73:	75 cf                	jne    100f44 <sys_sem_take+0x11>
	atomic_t old_value;

	do {
		old_value = bounded_dec(&sem->futex.val,
					SYS_SEM_MINIMUM);
		if (old_value > 0) {
  100f75:	85 d2                	test   %edx,%edx
  100f77:	74 d1                	je     100f4a <sys_sem_take+0x17>
			return 0;
  100f79:	31 c0                	xor    %eax,%eax
  100f7b:	eb 17                	jmp    100f94 <sys_sem_take+0x61>
	return z_impl_k_futex_wait(futex, expected, timeout);
  100f7d:	8b 75 ec             	mov    -0x14(%rbp),%esi
  100f80:	4c 89 e2             	mov    %r12,%rdx
  100f83:	48 89 df             	mov    %rbx,%rdi
  100f86:	e8 8f 4c 01 00       	callq  115c1a <z_impl_k_futex_wait>
		}

		ret = k_futex_wait(&sem->futex,
				   SYS_SEM_CONTENDED, timeout);
	} while (ret == 0 || ret == -EAGAIN);
  100f8b:	85 c0                	test   %eax,%eax
  100f8d:	74 b5                	je     100f44 <sys_sem_take+0x11>
  100f8f:	83 f8 f5             	cmp    $0xfffffff5,%eax
  100f92:	74 b0                	je     100f44 <sys_sem_take+0x11>

	return ret;
}
  100f94:	5a                   	pop    %rdx
  100f95:	59                   	pop    %rcx
  100f96:	5b                   	pop    %rbx
  100f97:	41 5c                	pop    %r12
  100f99:	5d                   	pop    %rbp
  100f9a:	c3                   	retq   

0000000000100f9b <z_thread_entry>:
 * This routine does not return, and is marked as such so the compiler won't
 * generate preamble code that is only used by functions that actually return.
 */
FUNC_NORETURN void z_thread_entry(k_thread_entry_t entry,
				 void *p1, void *p2, void *p3)
{
  100f9b:	55                   	push   %rbp
  100f9c:	49 89 f8             	mov    %rdi,%r8
  100f9f:	48 89 f7             	mov    %rsi,%rdi
  100fa2:	48 89 d6             	mov    %rdx,%rsi
  100fa5:	48 89 ca             	mov    %rcx,%rdx
  100fa8:	48 89 e5             	mov    %rsp,%rbp
#ifdef CONFIG_THREAD_LOCAL_STORAGE
	z_tls_current = z_current_get();
#endif
	entry(p1, p2, p3);
  100fab:	41 ff d0             	callq  *%r8
	__asm__ volatile ("mov %%cs, %[cs_val]" : [cs_val] "=r" (cs));
  100fae:	8c c8                	mov    %cs,%eax
	if (z_syscall_trap()) {
  100fb0:	a8 03                	test   $0x3,%al
  100fb2:	74 09                	je     100fbd <z_thread_entry+0x22>
	register uintptr_t rax __asm__("%rax") = call_id;
  100fb4:	b8 48 01 00 00       	mov    $0x148,%eax
	__asm__ volatile("syscall\n\t"
  100fb9:	0f 05                	syscall 
	return rax;
  100fbb:	eb 05                	jmp    100fc2 <z_thread_entry+0x27>
	return z_impl_z_current_get();
  100fbd:	e8 8c 17 01 00       	callq  11274e <z_impl_z_current_get>
  100fc2:	48 89 c7             	mov    %rax,%rdi
	__asm__ volatile ("mov %%cs, %[cs_val]" : [cs_val] "=r" (cs));
  100fc5:	8c c8                	mov    %cs,%eax
	if (z_syscall_trap()) {
  100fc7:	a8 03                	test   $0x3,%al
  100fc9:	74 09                	je     100fd4 <z_thread_entry+0x39>
	register uintptr_t rax __asm__("%rax") = call_id;
  100fcb:	b8 b6 00 00 00       	mov    $0xb6,%eax
	__asm__ volatile("syscall\n\t"
  100fd0:	0f 05                	syscall 
	return rax;
  100fd2:	eb 05                	jmp    100fd9 <timeutil_timegm64>
	z_impl_k_thread_abort(thread);
  100fd4:	e8 a4 19 01 00       	callq  11297d <z_impl_k_thread_abort>

0000000000100fd9 <timeutil_timegm64>:
}

int64_t timeutil_timegm64(const struct tm *tm)
{
	int64_t y = 1900 + (int64_t)tm->tm_year;
	unsigned int m = tm->tm_mon + 1;
  100fd9:	8b 47 10             	mov    0x10(%rdi),%eax
	int64_t y = 1900 + (int64_t)tm->tm_year;
  100fdc:	48 63 4f 14          	movslq 0x14(%rdi),%rcx
	unsigned int m = tm->tm_mon + 1;
  100fe0:	44 8d 40 01          	lea    0x1(%rax),%r8d
	unsigned int d = tm->tm_mday - 1;
  100fe4:	8b 47 0c             	mov    0xc(%rdi),%eax
	int64_t y = 1900 + (int64_t)tm->tm_year;
  100fe7:	48 81 c1 6c 07 00 00 	add    $0x76c,%rcx
	unsigned int d = tm->tm_mday - 1;
  100fee:	44 8d 48 ff          	lea    -0x1(%rax),%r9d
	y -= m <= 2;
  100ff2:	31 c0                	xor    %eax,%eax
  100ff4:	41 83 f8 02          	cmp    $0x2,%r8d
  100ff8:	0f 96 c0             	setbe  %al
	int64_t era = (y >= 0 ? y : y - 399) / 400;
  100ffb:	48 29 c1             	sub    %rax,%rcx
  100ffe:	79 14                	jns    101014 <timeutil_timegm64+0x3b>
  101000:	48 8d 81 71 fe ff ff 	lea    -0x18f(%rcx),%rax
  101007:	41 ba 90 01 00 00    	mov    $0x190,%r10d
  10100d:	48 99                	cqto   
  10100f:	49 f7 fa             	idiv   %r10
  101012:	eb 0d                	jmp    101021 <timeutil_timegm64+0x48>
  101014:	48 89 c8             	mov    %rcx,%rax
  101017:	be 90 01 00 00       	mov    $0x190,%esi
  10101c:	48 99                	cqto   
  10101e:	48 f7 fe             	idiv   %rsi
	int64_t ndays = time_days_from_civil(y, m, d);
	int64_t time = tm->tm_sec;
  101021:	48 63 17             	movslq (%rdi),%rdx
	int64_t era = (y >= 0 ? y : y - 399) / 400;
  101024:	48 89 c6             	mov    %rax,%rsi
	unsigned int yoe = y - era * 400;
  101027:	69 c0 70 fe ff ff    	imul   $0xfffffe70,%eax,%eax
  10102d:	01 c8                	add    %ecx,%eax

	time += 60LL * (tm->tm_min + 60LL * tm->tm_hour);
  10102f:	48 63 4f 08          	movslq 0x8(%rdi),%rcx
	unsigned int doy = (153U * (m + (m > 2 ? -3 : 9)) + 2U) / 5U + d;
  101033:	41 83 f8 03          	cmp    $0x3,%r8d
	time += 60LL * (tm->tm_min + 60LL * tm->tm_hour);
  101037:	48 63 7f 04          	movslq 0x4(%rdi),%rdi
	unsigned int doy = (153U * (m + (m > 2 ? -3 : 9)) + 2U) / 5U + d;
  10103b:	45 19 d2             	sbb    %r10d,%r10d
	return era * 146097 + (time_t)doe - 719468;
  10103e:	48 69 f6 b1 3a 02 00 	imul   $0x23ab1,%rsi,%rsi
	time += 60LL * (tm->tm_min + 60LL * tm->tm_hour);
  101045:	48 6b c9 3c          	imul   $0x3c,%rcx,%rcx
	unsigned int doy = (153U * (m + (m > 2 ? -3 : 9)) + 2U) / 5U + d;
  101049:	41 83 e2 0c          	and    $0xc,%r10d
	time += 60LL * (tm->tm_min + 60LL * tm->tm_hour);
  10104d:	48 01 f9             	add    %rdi,%rcx
	unsigned int doe = yoe * 365U + yoe / 4U - yoe / 100U + doy;
  101050:	69 f8 6d 01 00 00    	imul   $0x16d,%eax,%edi
	time += 60LL * (tm->tm_min + 60LL * tm->tm_hour);
  101056:	48 6b c9 3c          	imul   $0x3c,%rcx,%rcx
  10105a:	48 01 d1             	add    %rdx,%rcx
	unsigned int doe = yoe * 365U + yoe / 4U - yoe / 100U + doy;
  10105d:	89 c2                	mov    %eax,%edx
  10105f:	c1 ea 02             	shr    $0x2,%edx
  101062:	01 d7                	add    %edx,%edi
  101064:	31 d2                	xor    %edx,%edx
  101066:	44 01 cf             	add    %r9d,%edi
  101069:	41 b9 64 00 00 00    	mov    $0x64,%r9d
  10106f:	41 f7 f1             	div    %r9d
	unsigned int doy = (153U * (m + (m > 2 ? -3 : 9)) + 2U) / 5U + d;
  101072:	31 d2                	xor    %edx,%edx
	unsigned int doe = yoe * 365U + yoe / 4U - yoe / 100U + doy;
  101074:	29 c7                	sub    %eax,%edi
	unsigned int doy = (153U * (m + (m > 2 ? -3 : 9)) + 2U) / 5U + d;
  101076:	43 8d 44 10 fd       	lea    -0x3(%r8,%r10,1),%eax
  10107b:	41 b8 05 00 00 00    	mov    $0x5,%r8d
  101081:	69 c0 99 00 00 00    	imul   $0x99,%eax,%eax
  101087:	83 c0 02             	add    $0x2,%eax
  10108a:	41 f7 f0             	div    %r8d
	return era * 146097 + (time_t)doe - 719468;
  10108d:	01 f8                	add    %edi,%eax
  10108f:	48 8d 84 30 94 05 f5 	lea    -0xafa6c(%rax,%rsi,1),%rax
  101096:	ff 
	time += 86400LL * ndays;
  101097:	48 69 c0 80 51 01 00 	imul   $0x15180,%rax,%rax
  10109e:	48 01 c8             	add    %rcx,%rax

	return time;
}
  1010a1:	c3                   	retq   

00000000001010a2 <timeutil_timegm>:

time_t timeutil_timegm(const struct tm *tm)
{
  1010a2:	55                   	push   %rbp
  1010a3:	48 89 e5             	mov    %rsp,%rbp
  1010a6:	41 54                	push   %r12
  1010a8:	51                   	push   %rcx
	int64_t time = timeutil_timegm64(tm);
  1010a9:	e8 2b ff ff ff       	callq  100fd9 <timeutil_timegm64>
  1010ae:	49 89 c4             	mov    %rax,%r12
	__asm__ volatile ("mov %%cs, %[cs_val]" : [cs_val] "=r" (cs));
  1010b1:	8c c8                	mov    %cs,%eax

__pinned_func
static inline int * z_errno(void)
{
#ifdef CONFIG_USERSPACE
	if (z_syscall_trap()) {
  1010b3:	a8 03                	test   $0x3,%al
  1010b5:	74 09                	je     1010c0 <timeutil_timegm+0x1e>
	register uintptr_t rax __asm__("%rax") = call_id;
  1010b7:	b8 49 01 00 00       	mov    $0x149,%eax
	__asm__ volatile("syscall\n\t"
  1010bc:	0f 05                	syscall 
		/* coverity[OVERRUN] */
		return (int *) arch_syscall_invoke0(K_SYSCALL_Z_ERRNO);
  1010be:	eb 05                	jmp    1010c5 <timeutil_timegm+0x23>
	}
#endif
	compiler_barrier();
	return z_impl_z_errno();
  1010c0:	e8 bd bf 00 00       	callq  10d082 <z_impl_z_errno>
	time_t rv = (time_t)time;

	errno = 0;
  1010c5:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
		errno = ERANGE;
		rv = -1;
	}

	return rv;
}
  1010cb:	4c 89 e0             	mov    %r12,%rax
  1010ce:	5a                   	pop    %rdx
  1010cf:	41 5c                	pop    %r12
  1010d1:	5d                   	pop    %rbp
  1010d2:	c3                   	retq   

00000000001010d3 <chunk_size>:

static inline chunkid_t chunk_field(struct z_heap *h, chunkid_t c,
				    enum chunk_fields f)
{
	chunk_unit_t *buf = chunk_buf(h);
	void *cmem = &buf[c];
  1010d3:	89 f6                	mov    %esi,%esi
	return chunk_field(h, c, SIZE_AND_USED) & 1U;
}

static inline chunksz_t chunk_size(struct z_heap *h, chunkid_t c)
{
	return chunk_field(h, c, SIZE_AND_USED) >> 1;
  1010d5:	8b 44 f7 04          	mov    0x4(%rdi,%rsi,8),%eax
  1010d9:	d1 e8                	shr    %eax
}
  1010db:	c3                   	retq   

00000000001010dc <set_chunk_used>:

static inline void set_chunk_used(struct z_heap *h, chunkid_t c, bool used)
{
	chunk_unit_t *buf = chunk_buf(h);
	void *cmem = &buf[c];
  1010dc:	89 f6                	mov    %esi,%esi
{
  1010de:	41 89 d0             	mov    %edx,%r8d
	void *cmem = &buf[c];
  1010e1:	48 8d 04 f7          	lea    (%rdi,%rsi,8),%rax

	if (big_heap(h)) {
		if (used) {
			((uint32_t *)cmem)[SIZE_AND_USED] |= 1U;
  1010e5:	8b 48 04             	mov    0x4(%rax),%ecx
		} else {
			((uint32_t *)cmem)[SIZE_AND_USED] &= ~1U;
  1010e8:	89 ca                	mov    %ecx,%edx
  1010ea:	83 e2 fe             	and    $0xfffffffe,%edx
		if (used) {
  1010ed:	45 84 c0             	test   %r8b,%r8b
  1010f0:	74 05                	je     1010f7 <set_chunk_used+0x1b>
			((uint32_t *)cmem)[SIZE_AND_USED] |= 1U;
  1010f2:	83 c9 01             	or     $0x1,%ecx
  1010f5:	89 ca                	mov    %ecx,%edx
  1010f7:	89 50 04             	mov    %edx,0x4(%rax)
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
		} else {
			((uint16_t *)cmem)[SIZE_AND_USED] &= ~1U;
		}
	}
}
  1010fa:	c3                   	retq   

00000000001010fb <free_list_remove_bidx>:

	return ret;
}

static void free_list_remove_bidx(struct z_heap *h, chunkid_t c, int bidx)
{
  1010fb:	89 d1                	mov    %edx,%ecx
	void *cmem = &buf[c];
  1010fd:	89 f2                	mov    %esi,%edx
  1010ff:	48 c1 e2 03          	shl    $0x3,%rdx
		return ((uint32_t *)cmem)[f];
  101103:	8b 44 17 0c          	mov    0xc(%rdi,%rdx,1),%eax

	CHECK(!chunk_used(h, c));
	CHECK(b->next != 0);
	CHECK(h->avail_buckets & (1 << bidx));

	if (next_free_chunk(h, c) == c) {
  101107:	39 c6                	cmp    %eax,%esi
  101109:	48 63 f1             	movslq %ecx,%rsi
  10110c:	75 13                	jne    101121 <free_list_remove_bidx+0x26>
		/* this is the last chunk */
		h->avail_buckets &= ~(1 << bidx);
  10110e:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  101113:	d3 c0                	rol    %cl,%eax
  101115:	21 47 0c             	and    %eax,0xc(%rdi)
		b->next = 0;
  101118:	c7 44 b7 10 00 00 00 	movl   $0x0,0x10(%rdi,%rsi,4)
  10111f:	00 

		b->next = second;
		set_next_free_chunk(h, first, second);
		set_prev_free_chunk(h, second, first);
	}
}
  101120:	c3                   	retq   
  101121:	8b 4c 17 08          	mov    0x8(%rdi,%rdx,1),%ecx
		b->next = second;
  101125:	89 44 b7 10          	mov    %eax,0x10(%rdi,%rsi,4)
		((uint32_t *)cmem)[f] = val;
  101129:	89 44 cf 0c          	mov    %eax,0xc(%rdi,%rcx,8)
  10112d:	89 4c c7 08          	mov    %ecx,0x8(%rdi,%rax,8)
}
  101131:	c3                   	retq   

0000000000101132 <alloc_chunk>:
	return chunksz_in * CHUNK_UNIT - chunk_header_bytes(h);
}

static inline int bucket_idx(struct z_heap *h, chunksz_t sz)
{
	unsigned int usable_sz = sz - min_chunk_size(h) + 1;
  101132:	8d 56 ff             	lea    -0x1(%rsi),%edx
	return 31 - __builtin_clz(usable_sz);
  101135:	41 b9 1f 00 00 00    	mov    $0x1f,%r9d
	set_chunk_used(h, c, false);
	free_chunk(h, c);
}

static chunkid_t alloc_chunk(struct z_heap *h, chunksz_t sz)
{
  10113b:	55                   	push   %rbp
  10113c:	0f bd d2             	bsr    %edx,%edx
  10113f:	83 f2 1f             	xor    $0x1f,%edx
  101142:	41 29 d1             	sub    %edx,%r9d
  101145:	48 89 e5             	mov    %rsp,%rbp
  101148:	53                   	push   %rbx
  101149:	49 63 c1             	movslq %r9d,%rax
  10114c:	51                   	push   %rcx
  10114d:	4c 8d 1c 87          	lea    (%rdi,%rax,4),%r11
	 * course.  But even in pathological situations we still
	 * maintain our constant time performance and at worst see
	 * fragmentation waste of the order of the block allocated
	 * only.
	 */
	if (b->next) {
  101151:	41 8b 5b 10          	mov    0x10(%r11),%ebx
  101155:	85 db                	test   %ebx,%ebx
  101157:	74 32                	je     10118b <alloc_chunk+0x59>
  101159:	89 f1                	mov    %esi,%ecx
		chunkid_t first = b->next;
		int i = CONFIG_SYS_HEAP_ALLOC_LOOPS;
  10115b:	41 ba 03 00 00 00    	mov    $0x3,%r10d
		do {
			chunkid_t c = b->next;
  101161:	45 8b 43 10          	mov    0x10(%r11),%r8d
			if (chunk_size(h, c) >= sz) {
  101165:	44 89 c6             	mov    %r8d,%esi
  101168:	e8 66 ff ff ff       	callq  1010d3 <chunk_size>
  10116d:	39 c8                	cmp    %ecx,%eax
  10116f:	72 05                	jb     101176 <alloc_chunk+0x44>
				free_list_remove_bidx(h, c, bi);
  101171:	44 89 ca             	mov    %r9d,%edx
  101174:	eb 35                	jmp    1011ab <alloc_chunk+0x79>
		return ((uint32_t *)cmem)[f];
  101176:	42 8b 44 c7 0c       	mov    0xc(%rdi,%r8,8),%eax
				return c;
			}
			b->next = next_free_chunk(h, c);
			CHECK(b->next != 0);
		} while (--i && b->next != first);
  10117b:	41 ff ca             	dec    %r10d
			b->next = next_free_chunk(h, c);
  10117e:	41 89 43 10          	mov    %eax,0x10(%r11)
		} while (--i && b->next != first);
  101182:	39 c3                	cmp    %eax,%ebx
  101184:	74 05                	je     10118b <alloc_chunk+0x59>
  101186:	45 85 d2             	test   %r10d,%r10d
  101189:	75 d6                	jne    101161 <alloc_chunk+0x2f>
	}

	/* Otherwise pick the smallest non-empty bucket guaranteed to
	 * fit and use that unconditionally.
	 */
	uint32_t bmask = h->avail_buckets & ~((1 << (bi + 1)) - 1);
  10118b:	b9 20 00 00 00       	mov    $0x20,%ecx
  101190:	41 83 c8 ff          	or     $0xffffffff,%r8d
  101194:	29 d1                	sub    %edx,%ecx
  101196:	41 d3 e0             	shl    %cl,%r8d

	if (bmask != 0U) {
  101199:	44 23 47 0c          	and    0xc(%rdi),%r8d
  10119d:	74 14                	je     1011b3 <alloc_chunk+0x81>
		int minbucket = __builtin_ctz(bmask);
  10119f:	41 0f bc d0          	bsf    %r8d,%edx
		chunkid_t c = h->buckets[minbucket].next;
  1011a3:	48 63 c2             	movslq %edx,%rax
  1011a6:	44 8b 44 87 10       	mov    0x10(%rdi,%rax,4),%r8d

		free_list_remove_bidx(h, c, minbucket);
  1011ab:	44 89 c6             	mov    %r8d,%esi
  1011ae:	e8 48 ff ff ff       	callq  1010fb <free_list_remove_bidx>
		CHECK(chunk_size(h, c) >= sz);
		return c;
	}

	return 0;
}
  1011b3:	5a                   	pop    %rdx
  1011b4:	44 89 c0             	mov    %r8d,%eax
  1011b7:	5b                   	pop    %rbx
  1011b8:	5d                   	pop    %rbp
  1011b9:	c3                   	retq   

00000000001011ba <free_list_remove>:
{
  1011ba:	55                   	push   %rbp
  1011bb:	48 89 e5             	mov    %rsp,%rbp
  1011be:	48 83 ec 10          	sub    $0x10,%rsp
	return big_heap(h) && chunk_size(h, c) == 1U;
  1011c2:	89 75 fc             	mov    %esi,-0x4(%rbp)
  1011c5:	e8 09 ff ff ff       	callq  1010d3 <chunk_size>
	if (!solo_free_header(h, c)) {
  1011ca:	8b 75 fc             	mov    -0x4(%rbp),%esi
  1011cd:	83 f8 01             	cmp    $0x1,%eax
  1011d0:	74 15                	je     1011e7 <free_list_remove+0x2d>
}
  1011d2:	c9                   	leaveq 
	unsigned int usable_sz = sz - min_chunk_size(h) + 1;
  1011d3:	ff c8                	dec    %eax
	return 31 - __builtin_clz(usable_sz);
  1011d5:	ba 1f 00 00 00       	mov    $0x1f,%edx
  1011da:	0f bd c0             	bsr    %eax,%eax
  1011dd:	83 f0 1f             	xor    $0x1f,%eax
  1011e0:	29 c2                	sub    %eax,%edx
		free_list_remove_bidx(h, c, bidx);
  1011e2:	e9 14 ff ff ff       	jmpq   1010fb <free_list_remove_bidx>
}
  1011e7:	c9                   	leaveq 
  1011e8:	c3                   	retq   

00000000001011e9 <free_list_add>:
{
  1011e9:	55                   	push   %rbp
  1011ea:	89 f2                	mov    %esi,%edx
  1011ec:	48 89 e5             	mov    %rsp,%rbp
	return big_heap(h) && chunk_size(h, c) == 1U;
  1011ef:	e8 df fe ff ff       	callq  1010d3 <chunk_size>
	if (!solo_free_header(h, c)) {
  1011f4:	83 f8 01             	cmp    $0x1,%eax
  1011f7:	74 5b                	je     101254 <free_list_add+0x6b>
	unsigned int usable_sz = sz - min_chunk_size(h) + 1;
  1011f9:	ff c8                	dec    %eax
	return 31 - __builtin_clz(usable_sz);
  1011fb:	b9 1f 00 00 00       	mov    $0x1f,%ecx
	void *cmem = &buf[c];
  101200:	41 89 d0             	mov    %edx,%r8d
	return 31 - __builtin_clz(usable_sz);
  101203:	0f bd c0             	bsr    %eax,%eax
  101206:	4e 8d 04 c5 08 00 00 	lea    0x8(,%r8,8),%r8
  10120d:	00 
  10120e:	83 f0 1f             	xor    $0x1f,%eax
		((uint32_t *)cmem)[f] = val;
  101211:	4e 8d 0c 07          	lea    (%rdi,%r8,1),%r9
  101215:	4e 8d 44 07 04       	lea    0x4(%rdi,%r8,1),%r8
	return 31 - __builtin_clz(usable_sz);
  10121a:	29 c1                	sub    %eax,%ecx
	if (b->next == 0U) {
  10121c:	48 63 c1             	movslq %ecx,%rax
  10121f:	48 83 c0 04          	add    $0x4,%rax
  101223:	8b 34 87             	mov    (%rdi,%rax,4),%esi
  101226:	85 f6                	test   %esi,%esi
  101228:	75 15                	jne    10123f <free_list_add+0x56>
		h->avail_buckets |= (1 << bidx);
  10122a:	be 01 00 00 00       	mov    $0x1,%esi
  10122f:	d3 e6                	shl    %cl,%esi
  101231:	09 77 0c             	or     %esi,0xc(%rdi)
		b->next = c;
  101234:	89 14 87             	mov    %edx,(%rdi,%rax,4)
		((uint32_t *)cmem)[f] = val;
  101237:	41 89 11             	mov    %edx,(%r9)
  10123a:	41 89 10             	mov    %edx,(%r8)
}
  10123d:	eb 15                	jmp    101254 <free_list_add+0x6b>
	void *cmem = &buf[c];
  10123f:	89 f0                	mov    %esi,%eax
		return ((uint32_t *)cmem)[f];
  101241:	48 8d 4c c7 08       	lea    0x8(%rdi,%rax,8),%rcx
  101246:	8b 01                	mov    (%rcx),%eax
		((uint32_t *)cmem)[f] = val;
  101248:	41 89 01             	mov    %eax,(%r9)
  10124b:	41 89 30             	mov    %esi,(%r8)
  10124e:	89 54 c7 0c          	mov    %edx,0xc(%rdi,%rax,8)
  101252:	89 11                	mov    %edx,(%rcx)
}
  101254:	5d                   	pop    %rbp
  101255:	c3                   	retq   

0000000000101256 <merge_chunks>:
{
  101256:	55                   	push   %rbp
  101257:	89 f1                	mov    %esi,%ecx
  101259:	41 89 d0             	mov    %edx,%r8d
	chunksz_t newsz = chunk_size(h, lc) + chunk_size(h, rc);
  10125c:	89 ce                	mov    %ecx,%esi
{
  10125e:	48 89 e5             	mov    %rsp,%rbp
	chunksz_t newsz = chunk_size(h, lc) + chunk_size(h, rc);
  101261:	e8 6d fe ff ff       	callq  1010d3 <chunk_size>
  101266:	44 89 c6             	mov    %r8d,%esi
  101269:	89 c2                	mov    %eax,%edx
  10126b:	e8 63 fe ff ff       	callq  1010d3 <chunk_size>
	return c + chunk_size(h, c);
  101270:	44 89 c6             	mov    %r8d,%esi
  101273:	01 c2                	add    %eax,%edx
	chunk_set(h, c, SIZE_AND_USED, size << 1);
  101275:	8d 04 12             	lea    (%rdx,%rdx,1),%eax
  101278:	89 44 cf 04          	mov    %eax,0x4(%rdi,%rcx,8)
	return c + chunk_size(h, c);
  10127c:	e8 52 fe ff ff       	callq  1010d3 <chunk_size>
}
  101281:	5d                   	pop    %rbp
	void *cmem = &buf[c];
  101282:	44 01 c0             	add    %r8d,%eax
		((uint32_t *)cmem)[f] = val;
  101285:	89 14 c7             	mov    %edx,(%rdi,%rax,8)
  101288:	c3                   	retq   

0000000000101289 <free_chunk>:
{
  101289:	55                   	push   %rbp
  10128a:	41 89 f1             	mov    %esi,%r9d
  10128d:	48 89 e5             	mov    %rsp,%rbp
	return c + chunk_size(h, c);
  101290:	e8 3e fe ff ff       	callq  1010d3 <chunk_size>
  101295:	44 01 c8             	add    %r9d,%eax
	if (!chunk_used(h, right_chunk(h, c))) {
  101298:	f6 44 c7 04 01       	testb  $0x1,0x4(%rdi,%rax,8)
  10129d:	75 1c                	jne    1012bb <free_chunk+0x32>
  10129f:	48 89 c6             	mov    %rax,%rsi
		free_list_remove(h, right_chunk(h, c));
  1012a2:	e8 13 ff ff ff       	callq  1011ba <free_list_remove>
  1012a7:	44 89 ce             	mov    %r9d,%esi
  1012aa:	e8 24 fe ff ff       	callq  1010d3 <chunk_size>
		merge_chunks(h, c, right_chunk(h, c));
  1012af:	44 89 ce             	mov    %r9d,%esi
  1012b2:	41 8d 14 01          	lea    (%r9,%rax,1),%edx
  1012b6:	e8 9b ff ff ff       	callq  101256 <merge_chunks>
	void *cmem = &buf[c];
  1012bb:	44 89 c8             	mov    %r9d,%eax
	return c - chunk_field(h, c, LEFT_SIZE);
  1012be:	44 89 ce             	mov    %r9d,%esi
		return ((uint32_t *)cmem)[f];
  1012c1:	4c 8d 14 c7          	lea    (%rdi,%rax,8),%r10
	return c - chunk_field(h, c, LEFT_SIZE);
  1012c5:	41 2b 32             	sub    (%r10),%esi
	void *cmem = &buf[c];
  1012c8:	89 f0                	mov    %esi,%eax
	if (!chunk_used(h, left_chunk(h, c))) {
  1012ca:	f6 44 c7 04 01       	testb  $0x1,0x4(%rdi,%rax,8)
  1012cf:	75 16                	jne    1012e7 <free_chunk+0x5e>
		free_list_remove(h, left_chunk(h, c));
  1012d1:	e8 e4 fe ff ff       	callq  1011ba <free_list_remove>
	return c - chunk_field(h, c, LEFT_SIZE);
  1012d6:	44 89 ce             	mov    %r9d,%esi
		merge_chunks(h, left_chunk(h, c), c);
  1012d9:	44 89 ca             	mov    %r9d,%edx
  1012dc:	41 2b 32             	sub    (%r10),%esi
  1012df:	e8 72 ff ff ff       	callq  101256 <merge_chunks>
  1012e4:	45 2b 0a             	sub    (%r10),%r9d
	free_list_add(h, c);
  1012e7:	44 89 ce             	mov    %r9d,%esi
}
  1012ea:	5d                   	pop    %rbp
	free_list_add(h, c);
  1012eb:	e9 f9 fe ff ff       	jmpq   1011e9 <free_list_add>

00000000001012f0 <split_chunks>:
{
  1012f0:	55                   	push   %rbp
  1012f1:	89 f1                	mov    %esi,%ecx
	chunksz_t sz0 = chunk_size(h, lc);
  1012f3:	89 ce                	mov    %ecx,%esi
	chunksz_t rsz = sz0 - lsz;
  1012f5:	41 89 c8             	mov    %ecx,%r8d
  1012f8:	41 29 d0             	sub    %edx,%r8d
{
  1012fb:	48 89 e5             	mov    %rsp,%rbp
	chunksz_t sz0 = chunk_size(h, lc);
  1012fe:	e8 d0 fd ff ff       	callq  1010d3 <chunk_size>
	chunksz_t lsz = rc - lc;
  101303:	89 d6                	mov    %edx,%esi
  101305:	29 ce                	sub    %ecx,%esi
	chunksz_t rsz = sz0 - lsz;
  101307:	41 01 c0             	add    %eax,%r8d
	chunk_set(h, c, SIZE_AND_USED, size << 1);
  10130a:	8d 04 36             	lea    (%rsi,%rsi,1),%eax
  10130d:	89 44 cf 04          	mov    %eax,0x4(%rdi,%rcx,8)
	void *cmem = &buf[c];
  101311:	89 d0                	mov    %edx,%eax
	chunk_set(h, c, SIZE_AND_USED, size << 1);
  101313:	43 8d 0c 00          	lea    (%r8,%r8,1),%ecx
		((uint32_t *)cmem)[f] = val;
  101317:	89 34 c7             	mov    %esi,(%rdi,%rax,8)
	return c + chunk_size(h, c);
  10131a:	89 d6                	mov    %edx,%esi
	chunk_set(h, c, SIZE_AND_USED, size << 1);
  10131c:	89 4c c7 04          	mov    %ecx,0x4(%rdi,%rax,8)
	return c + chunk_size(h, c);
  101320:	e8 ae fd ff ff       	callq  1010d3 <chunk_size>
}
  101325:	5d                   	pop    %rbp
	void *cmem = &buf[c];
  101326:	01 d0                	add    %edx,%eax
		((uint32_t *)cmem)[f] = val;
  101328:	44 89 04 c7          	mov    %r8d,(%rdi,%rax,8)
  10132c:	c3                   	retq   

000000000010132d <sys_heap_free>:
	if (mem == NULL) {
  10132d:	48 85 f6             	test   %rsi,%rsi
  101330:	0f 84 d2 00 00 00    	je     101408 <sys_heap_free+0xdb>
{
  101336:	55                   	push   %rbp
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
  101337:	48 8d 46 f8          	lea    -0x8(%rsi),%rax
  10133b:	b9 08 00 00 00       	mov    $0x8,%ecx
{
  101340:	48 89 e5             	mov    %rsp,%rbp
  101343:	41 55                	push   %r13
  101345:	49 89 f5             	mov    %rsi,%r13
  101348:	41 54                	push   %r12
  10134a:	53                   	push   %rbx
  10134b:	52                   	push   %rdx
	struct z_heap *h = heap->heap;
  10134c:	4c 8b 27             	mov    (%rdi),%r12
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
  10134f:	4c 29 e0             	sub    %r12,%rax
  101352:	48 99                	cqto   
  101354:	48 f7 f9             	idiv   %rcx
  101357:	48 89 c3             	mov    %rax,%rbx
	void *cmem = &buf[c];
  10135a:	89 c0                	mov    %eax,%eax
	__ASSERT(chunk_used(h, c),
  10135c:	41 f6 44 c4 04 01    	testb  $0x1,0x4(%r12,%rax,8)
  101362:	75 39                	jne    10139d <sys_heap_free+0x70>
  101364:	b9 9a 00 00 00       	mov    $0x9a,%ecx
  101369:	ba da cf 11 00       	mov    $0x11cfda,%edx
  10136e:	be fb cf 11 00       	mov    $0x11cffb,%esi
  101373:	31 c0                	xor    %eax,%eax
  101375:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  10137a:	e8 79 f2 ff ff       	callq  1005f8 <printk>
  10137f:	4c 89 ee             	mov    %r13,%rsi
  101382:	bf 0c d0 11 00       	mov    $0x11d00c,%edi
  101387:	31 c0                	xor    %eax,%eax
  101389:	e8 6a f2 ff ff       	callq  1005f8 <printk>
  10138e:	be 9a 00 00 00       	mov    $0x9a,%esi
  101393:	bf da cf 11 00       	mov    $0x11cfda,%edi
  101398:	e8 fb 17 00 00       	callq  102b98 <assert_post_action>
	return c + chunk_size(h, c);
  10139d:	89 de                	mov    %ebx,%esi
  10139f:	4c 89 e7             	mov    %r12,%rdi
  1013a2:	e8 2c fd ff ff       	callq  1010d3 <chunk_size>
  1013a7:	8d 14 18             	lea    (%rax,%rbx,1),%edx
  1013aa:	48 89 d0             	mov    %rdx,%rax
	return c - chunk_field(h, c, LEFT_SIZE);
  1013ad:	41 2b 04 d4          	sub    (%r12,%rdx,8),%eax
	__ASSERT(left_chunk(h, right_chunk(h, c)) == c,
  1013b1:	39 c3                	cmp    %eax,%ebx
  1013b3:	74 39                	je     1013ee <sys_heap_free+0xc1>
  1013b5:	b9 a2 00 00 00       	mov    $0xa2,%ecx
  1013ba:	ba da cf 11 00       	mov    $0x11cfda,%edx
  1013bf:	be 44 d0 11 00       	mov    $0x11d044,%esi
  1013c4:	31 c0                	xor    %eax,%eax
  1013c6:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  1013cb:	e8 28 f2 ff ff       	callq  1005f8 <printk>
  1013d0:	4c 89 ee             	mov    %r13,%rsi
  1013d3:	bf 6a d0 11 00       	mov    $0x11d06a,%edi
  1013d8:	31 c0                	xor    %eax,%eax
  1013da:	e8 19 f2 ff ff       	callq  1005f8 <printk>
  1013df:	be a2 00 00 00       	mov    $0xa2,%esi
  1013e4:	bf da cf 11 00       	mov    $0x11cfda,%edi
  1013e9:	e8 aa 17 00 00       	callq  102b98 <assert_post_action>
	set_chunk_used(h, c, false);
  1013ee:	89 de                	mov    %ebx,%esi
  1013f0:	4c 89 e7             	mov    %r12,%rdi
  1013f3:	31 d2                	xor    %edx,%edx
  1013f5:	e8 e2 fc ff ff       	callq  1010dc <set_chunk_used>
}
  1013fa:	58                   	pop    %rax
	free_chunk(h, c);
  1013fb:	89 de                	mov    %ebx,%esi
}
  1013fd:	5b                   	pop    %rbx
  1013fe:	41 5c                	pop    %r12
  101400:	41 5d                	pop    %r13
  101402:	5d                   	pop    %rbp
	free_chunk(h, c);
  101403:	e9 81 fe ff ff       	jmpq   101289 <free_chunk>
  101408:	c3                   	retq   

0000000000101409 <sys_heap_alloc>:

void *sys_heap_alloc(struct sys_heap *heap, size_t bytes)
{
	struct z_heap *h = heap->heap;
  101409:	48 8b 3f             	mov    (%rdi),%rdi

	if (bytes == 0U || size_too_big(h, bytes)) {
  10140c:	48 85 f6             	test   %rsi,%rsi
  10140f:	74 67                	je     101478 <sys_heap_alloc+0x6f>
{
	/*
	 * Quick check to bail out early if size is too big.
	 * Also guards against potential arithmetic overflows elsewhere.
	 */
	return (bytes / CHUNK_UNIT) >= h->end_chunk;
  101411:	48 89 f0             	mov    %rsi,%rax
  101414:	8b 57 08             	mov    0x8(%rdi),%edx
  101417:	48 c1 e8 03          	shr    $0x3,%rax
  10141b:	48 39 c2             	cmp    %rax,%rdx
  10141e:	76 58                	jbe    101478 <sys_heap_alloc+0x6f>
{
  101420:	55                   	push   %rbp
  101421:	48 89 e5             	mov    %rsp,%rbp
  101424:	53                   	push   %rbx
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
  101425:	48 8d 5e 0f          	lea    0xf(%rsi),%rbx
  101429:	51                   	push   %rcx
  10142a:	48 c1 eb 03          	shr    $0x3,%rbx
		return NULL;
	}

	chunksz_t chunk_sz = bytes_to_chunksz(h, bytes);
	chunkid_t c = alloc_chunk(h, chunk_sz);
  10142e:	89 de                	mov    %ebx,%esi
  101430:	e8 fd fc ff ff       	callq  101132 <alloc_chunk>
  101435:	41 89 c2             	mov    %eax,%r10d
		return NULL;
  101438:	31 c0                	xor    %eax,%eax
	if (c == 0U) {
  10143a:	45 85 d2             	test   %r10d,%r10d
  10143d:	74 35                	je     101474 <sys_heap_alloc+0x6b>
		return NULL;
	}

	/* Split off remainder if any */
	if (chunk_size(h, c) > chunk_sz) {
  10143f:	44 89 d6             	mov    %r10d,%esi
  101442:	e8 8c fc ff ff       	callq  1010d3 <chunk_size>
  101447:	39 d8                	cmp    %ebx,%eax
  101449:	76 17                	jbe    101462 <sys_heap_alloc+0x59>
		split_chunks(h, c, c + chunk_sz);
  10144b:	45 8d 0c 1a          	lea    (%r10,%rbx,1),%r9d
  10144f:	44 89 d6             	mov    %r10d,%esi
  101452:	44 89 ca             	mov    %r9d,%edx
  101455:	e8 96 fe ff ff       	callq  1012f0 <split_chunks>
		free_list_add(h, c + chunk_sz);
  10145a:	44 89 ce             	mov    %r9d,%esi
  10145d:	e8 87 fd ff ff       	callq  1011e9 <free_list_add>
	}

	set_chunk_used(h, c, true);
  101462:	ba 01 00 00 00       	mov    $0x1,%edx
  101467:	44 89 d6             	mov    %r10d,%esi
  10146a:	e8 6d fc ff ff       	callq  1010dc <set_chunk_used>
	uint8_t *ret = ((uint8_t *)&buf[c]) + chunk_header_bytes(h);
  10146f:	4a 8d 44 d7 08       	lea    0x8(%rdi,%r10,8),%rax
	return chunk_mem(h, c);
}
  101474:	5a                   	pop    %rdx
  101475:	5b                   	pop    %rbx
  101476:	5d                   	pop    %rbp
  101477:	c3                   	retq   
		return NULL;
  101478:	31 c0                	xor    %eax,%eax
}
  10147a:	c3                   	retq   

000000000010147b <sys_heap_aligned_alloc>:

void *sys_heap_aligned_alloc(struct sys_heap *heap, size_t align, size_t bytes)
{
  10147b:	55                   	push   %rbp
  10147c:	48 89 e5             	mov    %rsp,%rbp
  10147f:	41 57                	push   %r15
  101481:	41 56                	push   %r14
  101483:	41 55                	push   %r13
  101485:	49 89 d5             	mov    %rdx,%r13
  101488:	41 54                	push   %r12
  10148a:	53                   	push   %rbx
	 * We allow for one bit of rewind in addition to the alignment
	 * value to efficiently accommodate z_heap_aligned_alloc().
	 * So if e.g. align = 0x28 (32 | 8) this means we align to a 32-byte
	 * boundary and then rewind 8 bytes.
	 */
	rew = align & -align;
  10148b:	48 89 f3             	mov    %rsi,%rbx
  10148e:	48 f7 db             	neg    %rbx
  101491:	48 21 f3             	and    %rsi,%rbx
{
  101494:	48 83 ec 18          	sub    $0x18,%rsp
	struct z_heap *h = heap->heap;
  101498:	4c 8b 27             	mov    (%rdi),%r12
	if (align != rew) {
  10149b:	48 39 de             	cmp    %rbx,%rsi
  10149e:	74 19                	je     1014b9 <sys_heap_aligned_alloc+0x3e>
	return sizeof(void *) > 4U || chunks > 0x7fffU;
  1014a0:	48 83 fb 08          	cmp    $0x8,%rbx
  1014a4:	41 b8 08 00 00 00    	mov    $0x8,%r8d
  1014aa:	49 89 df             	mov    %rbx,%r15
  1014ad:	4c 0f 46 c3          	cmovbe %rbx,%r8
		align -= rew;
  1014b1:	48 29 de             	sub    %rbx,%rsi
  1014b4:	48 89 f3             	mov    %rsi,%rbx
  1014b7:	eb 25                	jmp    1014de <sys_heap_aligned_alloc+0x63>
		gap = MIN(rew, chunk_header_bytes(h));
	} else {
		if (align <= chunk_header_bytes(h)) {
  1014b9:	48 83 fe 08          	cmp    $0x8,%rsi
  1014bd:	77 16                	ja     1014d5 <sys_heap_aligned_alloc+0x5a>
		free_list_add(h, c_end);
	}

	set_chunk_used(h, c, true);
	return mem;
}
  1014bf:	48 83 c4 18          	add    $0x18,%rsp
			return sys_heap_alloc(heap, bytes);
  1014c3:	48 89 d6             	mov    %rdx,%rsi
}
  1014c6:	5b                   	pop    %rbx
  1014c7:	41 5c                	pop    %r12
  1014c9:	41 5d                	pop    %r13
  1014cb:	41 5e                	pop    %r14
  1014cd:	41 5f                	pop    %r15
  1014cf:	5d                   	pop    %rbp
			return sys_heap_alloc(heap, bytes);
  1014d0:	e9 34 ff ff ff       	jmpq   101409 <sys_heap_alloc>
		rew = 0;
  1014d5:	45 31 ff             	xor    %r15d,%r15d
		gap = chunk_header_bytes(h);
  1014d8:	41 b8 08 00 00 00    	mov    $0x8,%r8d
	__ASSERT((align & (align - 1)) == 0, "align must be a power of 2");
  1014de:	4c 8d 73 ff          	lea    -0x1(%rbx),%r14
  1014e2:	49 85 de             	test   %rbx,%r14
  1014e5:	74 3e                	je     101525 <sys_heap_aligned_alloc+0xaa>
  1014e7:	b9 0d 01 00 00       	mov    $0x10d,%ecx
  1014ec:	ba da cf 11 00       	mov    $0x11cfda,%edx
  1014f1:	31 c0                	xor    %eax,%eax
  1014f3:	4c 89 45 c8          	mov    %r8,-0x38(%rbp)
  1014f7:	be a6 d0 11 00       	mov    $0x11d0a6,%esi
  1014fc:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  101501:	e8 f2 f0 ff ff       	callq  1005f8 <printk>
  101506:	bf c1 d0 11 00       	mov    $0x11d0c1,%edi
  10150b:	31 c0                	xor    %eax,%eax
  10150d:	e8 e6 f0 ff ff       	callq  1005f8 <printk>
  101512:	be 0d 01 00 00       	mov    $0x10d,%esi
  101517:	bf da cf 11 00       	mov    $0x11cfda,%edi
  10151c:	e8 77 16 00 00       	callq  102b98 <assert_post_action>
  101521:	4c 8b 45 c8          	mov    -0x38(%rbp),%r8
	if (bytes == 0 || size_too_big(h, bytes)) {
  101525:	4d 85 ed             	test   %r13,%r13
  101528:	75 08                	jne    101532 <sys_heap_aligned_alloc+0xb7>
		return NULL;
  10152a:	45 31 d2             	xor    %r10d,%r10d
  10152d:	e9 b3 00 00 00       	jmpq   1015e5 <sys_heap_aligned_alloc+0x16a>
	return (bytes / CHUNK_UNIT) >= h->end_chunk;
  101532:	4c 89 e8             	mov    %r13,%rax
  101535:	41 8b 54 24 08       	mov    0x8(%r12),%edx
  10153a:	48 c1 e8 03          	shr    $0x3,%rax
	if (bytes == 0 || size_too_big(h, bytes)) {
  10153e:	48 39 c2             	cmp    %rax,%rdx
  101541:	76 e7                	jbe    10152a <sys_heap_aligned_alloc+0xaf>
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
  101543:	4a 8d 74 2b 0f       	lea    0xf(%rbx,%r13,1),%rsi
	chunkid_t c0 = alloc_chunk(h, padded_sz);
  101548:	4c 89 e7             	mov    %r12,%rdi
  10154b:	4c 29 c6             	sub    %r8,%rsi
  10154e:	48 c1 ee 03          	shr    $0x3,%rsi
  101552:	e8 db fb ff ff       	callq  101132 <alloc_chunk>
  101557:	41 89 c1             	mov    %eax,%r9d
	if (c0 == 0) {
  10155a:	85 c0                	test   %eax,%eax
  10155c:	74 cc                	je     10152a <sys_heap_aligned_alloc+0xaf>
	uint8_t *ret = ((uint8_t *)&buf[c]) + chunk_header_bytes(h);
  10155e:	89 c0                	mov    %eax,%eax
	mem = (uint8_t *) ROUND_UP(mem + rew, align) - rew;
  101560:	48 f7 db             	neg    %rbx
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
  101563:	b9 08 00 00 00       	mov    $0x8,%ecx
	mem = (uint8_t *) ROUND_UP(mem + rew, align) - rew;
  101568:	4d 8d 54 c7 08       	lea    0x8(%r15,%rax,8),%r10
  10156d:	4d 01 e2             	add    %r12,%r10
  101570:	4d 01 f2             	add    %r14,%r10
  101573:	4c 21 d3             	and    %r10,%rbx
  101576:	4c 29 fb             	sub    %r15,%rbx
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
  101579:	48 8d 43 f8          	lea    -0x8(%rbx),%rax
	mem = (uint8_t *) ROUND_UP(mem + rew, align) - rew;
  10157d:	49 89 da             	mov    %rbx,%r10
	chunk_unit_t *end = (chunk_unit_t *) ROUND_UP(mem + bytes, CHUNK_UNIT);
  101580:	4a 8d 5c 2b 07       	lea    0x7(%rbx,%r13,1),%rbx
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
  101585:	4c 29 e0             	sub    %r12,%rax
	chunk_unit_t *end = (chunk_unit_t *) ROUND_UP(mem + bytes, CHUNK_UNIT);
  101588:	48 83 e3 f8          	and    $0xfffffffffffffff8,%rbx
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
  10158c:	48 99                	cqto   
	chunkid_t c_end = end - chunk_buf(h);
  10158e:	4c 29 e3             	sub    %r12,%rbx
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
  101591:	48 f7 f9             	idiv   %rcx
	chunkid_t c_end = end - chunk_buf(h);
  101594:	48 c1 fb 03          	sar    $0x3,%rbx
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
  101598:	49 89 c3             	mov    %rax,%r11
	if (c > c0) {
  10159b:	41 39 c1             	cmp    %eax,%r9d
  10159e:	73 12                	jae    1015b2 <sys_heap_aligned_alloc+0x137>
		split_chunks(h, c0, c);
  1015a0:	44 89 ce             	mov    %r9d,%esi
  1015a3:	89 c2                	mov    %eax,%edx
  1015a5:	e8 46 fd ff ff       	callq  1012f0 <split_chunks>
		free_list_add(h, c0);
  1015aa:	44 89 ce             	mov    %r9d,%esi
  1015ad:	e8 37 fc ff ff       	callq  1011e9 <free_list_add>
	return c + chunk_size(h, c);
  1015b2:	44 89 de             	mov    %r11d,%esi
  1015b5:	4c 89 e7             	mov    %r12,%rdi
  1015b8:	e8 16 fb ff ff       	callq  1010d3 <chunk_size>
  1015bd:	44 01 d8             	add    %r11d,%eax
	if (right_chunk(h, c) > c_end) {
  1015c0:	39 c3                	cmp    %eax,%ebx
  1015c2:	73 11                	jae    1015d5 <sys_heap_aligned_alloc+0x15a>
		split_chunks(h, c, c_end);
  1015c4:	44 89 de             	mov    %r11d,%esi
  1015c7:	89 da                	mov    %ebx,%edx
  1015c9:	e8 22 fd ff ff       	callq  1012f0 <split_chunks>
		free_list_add(h, c_end);
  1015ce:	89 de                	mov    %ebx,%esi
  1015d0:	e8 14 fc ff ff       	callq  1011e9 <free_list_add>
	set_chunk_used(h, c, true);
  1015d5:	ba 01 00 00 00       	mov    $0x1,%edx
  1015da:	44 89 de             	mov    %r11d,%esi
  1015dd:	4c 89 e7             	mov    %r12,%rdi
  1015e0:	e8 f7 fa ff ff       	callq  1010dc <set_chunk_used>
}
  1015e5:	48 83 c4 18          	add    $0x18,%rsp
  1015e9:	4c 89 d0             	mov    %r10,%rax
  1015ec:	5b                   	pop    %rbx
  1015ed:	41 5c                	pop    %r12
  1015ef:	41 5d                	pop    %r13
  1015f1:	41 5e                	pop    %r14
  1015f3:	41 5f                	pop    %r15
  1015f5:	5d                   	pop    %rbp
  1015f6:	c3                   	retq   

00000000001015f7 <sys_heap_init>:
}

void sys_heap_init(struct sys_heap *heap, void *mem, size_t bytes)
{
	/* Must fit in a 31 bit count of HUNK_UNIT */
	__ASSERT(bytes / CHUNK_UNIT <= 0x7fffffffU, "heap size is too big");
  1015f7:	48 b8 ff ff ff ff 03 	movabs $0x3ffffffff,%rax
  1015fe:	00 00 00 
{
  101601:	55                   	push   %rbp
  101602:	48 89 e5             	mov    %rsp,%rbp
  101605:	41 56                	push   %r14
  101607:	49 89 f6             	mov    %rsi,%r14
  10160a:	41 55                	push   %r13
  10160c:	49 89 fd             	mov    %rdi,%r13
  10160f:	41 54                	push   %r12
  101611:	53                   	push   %rbx
  101612:	48 89 d3             	mov    %rdx,%rbx
	__ASSERT(bytes / CHUNK_UNIT <= 0x7fffffffU, "heap size is too big");
  101615:	48 39 c2             	cmp    %rax,%rdx
  101618:	76 2e                	jbe    101648 <sys_heap_init+0x51>
  10161a:	be de d0 11 00       	mov    $0x11d0de,%esi
  10161f:	b9 7f 01 00 00       	mov    $0x17f,%ecx
  101624:	ba da cf 11 00       	mov    $0x11cfda,%edx
  101629:	31 c0                	xor    %eax,%eax
  10162b:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  101630:	e8 c3 ef ff ff       	callq  1005f8 <printk>
  101635:	bf f8 d0 11 00       	mov    $0x11d0f8,%edi
  10163a:	31 c0                	xor    %eax,%eax
  10163c:	e8 b7 ef ff ff       	callq  1005f8 <printk>
  101641:	be 7f 01 00 00       	mov    $0x17f,%esi
  101646:	eb 32                	jmp    10167a <sys_heap_init+0x83>

	/* Reserve the end marker chunk's header */
	__ASSERT(bytes > heap_footer_bytes(bytes), "heap size is too small");
  101648:	48 83 fa 08          	cmp    $0x8,%rdx
  10164c:	77 36                	ja     101684 <sys_heap_init+0x8d>
  10164e:	be 0f d1 11 00       	mov    $0x11d10f,%esi
  101653:	b9 82 01 00 00       	mov    $0x182,%ecx
  101658:	ba da cf 11 00       	mov    $0x11cfda,%edx
  10165d:	31 c0                	xor    %eax,%eax
  10165f:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  101664:	e8 8f ef ff ff       	callq  1005f8 <printk>
  101669:	bf 30 d1 11 00       	mov    $0x11d130,%edi
  10166e:	31 c0                	xor    %eax,%eax
  101670:	e8 83 ef ff ff       	callq  1005f8 <printk>
  101675:	be 82 01 00 00       	mov    $0x182,%esi
  10167a:	bf da cf 11 00       	mov    $0x11cfda,%edi
  10167f:	e8 14 15 00 00       	callq  102b98 <assert_post_action>
	bytes -= heap_footer_bytes(bytes);

	/* Round the start up, the end down */
	uintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);
  101684:	4d 8d 66 07          	lea    0x7(%r14),%r12
	uintptr_t end = ROUND_DOWN((uint8_t *)mem + bytes, CHUNK_UNIT);
  101688:	49 8d 5c 1e f8       	lea    -0x8(%r14,%rbx,1),%rbx
	uintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);
  10168d:	49 83 e4 f8          	and    $0xfffffffffffffff8,%r12
	uintptr_t end = ROUND_DOWN((uint8_t *)mem + bytes, CHUNK_UNIT);
  101691:	48 83 e3 f8          	and    $0xfffffffffffffff8,%rbx
	chunksz_t heap_sz = (end - addr) / CHUNK_UNIT;
  101695:	4c 29 e3             	sub    %r12,%rbx
  101698:	48 c1 eb 03          	shr    $0x3,%rbx

	CHECK(end > addr);
	__ASSERT(heap_sz > chunksz(sizeof(struct z_heap)), "heap size is too small");
  10169c:	83 fb 02             	cmp    $0x2,%ebx
  10169f:	77 36                	ja     1016d7 <sys_heap_init+0xe0>
  1016a1:	be 49 d1 11 00       	mov    $0x11d149,%esi
  1016a6:	b9 8b 01 00 00       	mov    $0x18b,%ecx
  1016ab:	ba da cf 11 00       	mov    $0x11cfda,%edx
  1016b0:	31 c0                	xor    %eax,%eax
  1016b2:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  1016b7:	e8 3c ef ff ff       	callq  1005f8 <printk>
  1016bc:	bf 30 d1 11 00       	mov    $0x11d130,%edi
  1016c1:	31 c0                	xor    %eax,%eax
  1016c3:	e8 30 ef ff ff       	callq  1005f8 <printk>
  1016c8:	be 8b 01 00 00       	mov    $0x18b,%esi
  1016cd:	bf da cf 11 00       	mov    $0x11cfda,%edi
  1016d2:	e8 c1 14 00 00       	callq  102b98 <assert_post_action>
	unsigned int usable_sz = sz - min_chunk_size(h) + 1;
  1016d7:	8d 43 ff             	lea    -0x1(%rbx),%eax
	heap->heap = h;
	h->end_chunk = heap_sz;
	h->avail_buckets = 0;

	int nb_buckets = bucket_idx(h, heap_sz) + 1;
	chunksz_t chunk0_size = chunksz(sizeof(struct z_heap) +
  1016da:	ba 24 00 00 00       	mov    $0x24,%edx
	int nb_buckets = bucket_idx(h, heap_sz) + 1;
  1016df:	41 be 20 00 00 00    	mov    $0x20,%r14d
	heap->heap = h;
  1016e5:	4d 89 65 00          	mov    %r12,0x0(%r13)
	return 31 - __builtin_clz(usable_sz);
  1016e9:	0f bd c0             	bsr    %eax,%eax
	h->end_chunk = heap_sz;
  1016ec:	41 89 5c 24 08       	mov    %ebx,0x8(%r12)
	h->avail_buckets = 0;
  1016f1:	41 c7 44 24 0c 00 00 	movl   $0x0,0xc(%r12)
  1016f8:	00 00 
  1016fa:	83 f0 1f             	xor    $0x1f,%eax
	chunksz_t chunk0_size = chunksz(sizeof(struct z_heap) +
  1016fd:	29 c2                	sub    %eax,%edx
	int nb_buckets = bucket_idx(h, heap_sz) + 1;
  1016ff:	41 29 c6             	sub    %eax,%r14d
	chunksz_t chunk0_size = chunksz(sizeof(struct z_heap) +
  101702:	48 63 c2             	movslq %edx,%rax
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
  101705:	4c 8d 2c 85 07 00 00 	lea    0x7(,%rax,4),%r13
  10170c:	00 
  10170d:	49 c1 ed 03          	shr    $0x3,%r13
				     nb_buckets * sizeof(struct z_heap_bucket));

	__ASSERT(chunk0_size + min_chunk_size(h) <= heap_sz, "heap size is too small");
  101711:	41 8d 45 02          	lea    0x2(%r13),%eax
  101715:	39 d8                	cmp    %ebx,%eax
  101717:	76 36                	jbe    10174f <sys_heap_init+0x158>
  101719:	be 72 d1 11 00       	mov    $0x11d172,%esi
  10171e:	b9 96 01 00 00       	mov    $0x196,%ecx
  101723:	ba da cf 11 00       	mov    $0x11cfda,%edx
  101728:	31 c0                	xor    %eax,%eax
  10172a:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  10172f:	e8 c4 ee ff ff       	callq  1005f8 <printk>
  101734:	bf 30 d1 11 00       	mov    $0x11d130,%edi
  101739:	31 c0                	xor    %eax,%eax
  10173b:	e8 b8 ee ff ff       	callq  1005f8 <printk>
  101740:	be 96 01 00 00       	mov    $0x196,%esi
  101745:	bf da cf 11 00       	mov    $0x11cfda,%edi
  10174a:	e8 49 14 00 00       	callq  102b98 <assert_post_action>
{
  10174f:	31 c0                	xor    %eax,%eax

	for (int i = 0; i < nb_buckets; i++) {
  101751:	41 39 c6             	cmp    %eax,%r14d
  101754:	7e 0e                	jle    101764 <sys_heap_init+0x16d>
		h->buckets[i].next = 0;
  101756:	41 c7 44 84 10 00 00 	movl   $0x0,0x10(%r12,%rax,4)
  10175d:	00 00 
	for (int i = 0; i < nb_buckets; i++) {
  10175f:	48 ff c0             	inc    %rax
  101762:	eb ed                	jmp    101751 <sys_heap_init+0x15a>
	chunk_set(h, c, SIZE_AND_USED, size << 1);
  101764:	43 8d 44 2d 00       	lea    0x0(%r13,%r13,1),%eax
	}

	/* chunk containing our struct z_heap */
	set_chunk_size(h, 0, chunk0_size);
	set_left_chunk_size(h, 0, 0);
	set_chunk_used(h, 0, true);
  101769:	4c 89 e7             	mov    %r12,%rdi
  10176c:	ba 01 00 00 00       	mov    $0x1,%edx
  101771:	31 f6                	xor    %esi,%esi
  101773:	41 89 44 24 04       	mov    %eax,0x4(%r12)
		((uint32_t *)cmem)[f] = val;
  101778:	41 c7 04 24 00 00 00 	movl   $0x0,(%r12)
  10177f:	00 
  101780:	e8 57 f9 ff ff       	callq  1010dc <set_chunk_used>

	/* chunk containing the free heap */
	set_chunk_size(h, chunk0_size, heap_sz - chunk0_size);
  101785:	89 da                	mov    %ebx,%edx
  101787:	47 89 2c ec          	mov    %r13d,(%r12,%r13,8)
	set_left_chunk_size(h, chunk0_size, chunk0_size);

	/* the end marker chunk */
	set_chunk_size(h, heap_sz, 0);
	set_left_chunk_size(h, heap_sz, heap_sz - chunk0_size);
	set_chunk_used(h, heap_sz, true);
  10178b:	89 de                	mov    %ebx,%esi
	set_chunk_size(h, chunk0_size, heap_sz - chunk0_size);
  10178d:	44 29 ea             	sub    %r13d,%edx
	chunk_set(h, c, SIZE_AND_USED, size << 1);
  101790:	8d 04 12             	lea    (%rdx,%rdx,1),%eax
  101793:	43 89 44 ec 04       	mov    %eax,0x4(%r12,%r13,8)
	void *cmem = &buf[c];
  101798:	89 d8                	mov    %ebx,%eax
		((uint32_t *)cmem)[f] = val;
  10179a:	41 89 14 c4          	mov    %edx,(%r12,%rax,8)
	set_chunk_used(h, heap_sz, true);
  10179e:	ba 01 00 00 00       	mov    $0x1,%edx
  1017a3:	41 c7 44 c4 04 00 00 	movl   $0x0,0x4(%r12,%rax,8)
  1017aa:	00 00 
  1017ac:	e8 2b f9 ff ff       	callq  1010dc <set_chunk_used>

	free_list_add(h, chunk0_size);
}
  1017b1:	5b                   	pop    %rbx
	free_list_add(h, chunk0_size);
  1017b2:	44 89 ee             	mov    %r13d,%esi
}
  1017b5:	41 5c                	pop    %r12
  1017b7:	41 5d                	pop    %r13
  1017b9:	41 5e                	pop    %r14
  1017bb:	5d                   	pop    %rbp
	free_list_add(h, chunk0_size);
  1017bc:	e9 28 fa ff ff       	jmpq   1011e9 <free_list_add>

00000000001017c1 <setup_bundle_data.constprop.0>:

static void setup_bundle_data(sys_bitarray_t *bitarray,
			      struct bundle_data *bd,
			      size_t offset, size_t num_bits)
{
	bd->sidx = offset / bundle_bitness(bitarray);
  1017c1:	49 89 f1             	mov    %rsi,%r9
	bd->soff = offset % bundle_bitness(bitarray);
  1017c4:	48 89 f1             	mov    %rsi,%rcx

	bd->eidx = (offset + num_bits - 1) / bundle_bitness(bitarray);
  1017c7:	48 8d 74 16 ff       	lea    -0x1(%rsi,%rdx,1),%rsi
	bd->eoff = (offset + num_bits - 1) % bundle_bitness(bitarray);

	bd->smask = ~(BIT(bd->soff) - 1);
  1017cc:	ba 01 00 00 00       	mov    $0x1,%edx
	bd->soff = offset % bundle_bitness(bitarray);
  1017d1:	83 e1 1f             	and    $0x1f,%ecx
	bd->eidx = (offset + num_bits - 1) / bundle_bitness(bitarray);
  1017d4:	49 89 f0             	mov    %rsi,%r8
	bd->smask = ~(BIT(bd->soff) - 1);
  1017d7:	48 89 d0             	mov    %rdx,%rax
	bd->eoff = (offset + num_bits - 1) % bundle_bitness(bitarray);
  1017da:	83 e6 1f             	and    $0x1f,%esi
	bd->smask = ~(BIT(bd->soff) - 1);
  1017dd:	48 d3 e0             	shl    %cl,%rax
	bd->soff = offset % bundle_bitness(bitarray);
  1017e0:	48 89 4f 10          	mov    %rcx,0x10(%rdi)
	bd->emask = (BIT(bd->eoff) - 1) | BIT(bd->eoff);
  1017e4:	89 f1                	mov    %esi,%ecx
	bd->sidx = offset / bundle_bitness(bitarray);
  1017e6:	49 c1 e9 05          	shr    $0x5,%r9
	bd->emask = (BIT(bd->eoff) - 1) | BIT(bd->eoff);
  1017ea:	48 d3 e2             	shl    %cl,%rdx
	bd->eidx = (offset + num_bits - 1) / bundle_bitness(bitarray);
  1017ed:	49 c1 e8 05          	shr    $0x5,%r8
	bd->smask = ~(BIT(bd->soff) - 1);
  1017f1:	f7 d8                	neg    %eax
	bd->sidx = offset / bundle_bitness(bitarray);
  1017f3:	4c 89 0f             	mov    %r9,(%rdi)
	bd->emask = (BIT(bd->eoff) - 1) | BIT(bd->eoff);
  1017f6:	8d 4a ff             	lea    -0x1(%rdx),%ecx
	bd->eidx = (offset + num_bits - 1) / bundle_bitness(bitarray);
  1017f9:	4c 89 47 08          	mov    %r8,0x8(%rdi)
	bd->emask = (BIT(bd->eoff) - 1) | BIT(bd->eoff);
  1017fd:	09 ca                	or     %ecx,%edx
	bd->eoff = (offset + num_bits - 1) % bundle_bitness(bitarray);
  1017ff:	48 89 77 18          	mov    %rsi,0x18(%rdi)
	bd->smask = ~(BIT(bd->soff) - 1);
  101803:	89 47 20             	mov    %eax,0x20(%rdi)
	bd->emask = (BIT(bd->eoff) - 1) | BIT(bd->eoff);
  101806:	89 57 24             	mov    %edx,0x24(%rdi)

	if (bd->sidx == bd->eidx) {
  101809:	4d 39 c1             	cmp    %r8,%r9
  10180c:	75 05                	jne    101813 <setup_bundle_data.constprop.0+0x52>
		/* The region lies within the same bundle. So combine the masks. */
		bd->smask &= bd->emask;
  10180e:	21 d0                	and    %edx,%eax
  101810:	89 47 20             	mov    %eax,0x20(%rdi)
	}
}
  101813:	c3                   	retq   

0000000000101814 <match_region>:
 */
static bool match_region(sys_bitarray_t *bitarray, size_t offset,
			 size_t num_bits, bool match_set,
			 struct bundle_data *bd,
			 size_t *mismatch)
{
  101814:	55                   	push   %rbp
  101815:	41 89 cb             	mov    %ecx,%r11d
  101818:	48 89 e5             	mov    %rsp,%rbp
  10181b:	41 55                	push   %r13
  10181d:	41 54                	push   %r12
  10181f:	4d 89 cc             	mov    %r9,%r12
  101822:	53                   	push   %rbx
  101823:	48 89 fb             	mov    %rdi,%rbx
  101826:	4c 89 c7             	mov    %r8,%rdi
  101829:	41 52                	push   %r10
  10182b:	41 89 ca             	mov    %ecx,%r10d
	uint32_t mismatch_bundle;
	uint32_t mismatch_mask;
	size_t mismatch_bundle_idx;
	size_t mismatch_bit_off;

	setup_bundle_data(bitarray, bd, offset, num_bits);
  10182e:	e8 8e ff ff ff       	callq  1017c1 <setup_bundle_data.constprop.0>

	if (bd->sidx == bd->eidx) {
  101833:	4c 8b 2f             	mov    (%rdi),%r13
  101836:	48 8b 57 08          	mov    0x8(%rdi),%rdx
  10183a:	48 8b 4b 08          	mov    0x8(%rbx),%rcx
  10183e:	8b 5f 20             	mov    0x20(%rdi),%ebx
  101841:	49 39 d5             	cmp    %rdx,%r13
		bundle = bitarray->bundles[bd->sidx];
  101844:	42 8b 04 a9          	mov    (%rcx,%r13,4),%eax
	if (bd->sidx == bd->eidx) {
  101848:	75 17                	jne    101861 <match_region+0x4d>
		if (!match_set) {
  10184a:	45 84 d2             	test   %r10b,%r10b
  10184d:	75 02                	jne    101851 <match_region+0x3d>
			bundle = ~bundle;
  10184f:	f7 d0                	not    %eax
		}

		if ((bundle & bd->smask) != bd->smask) {
  101851:	89 da                	mov    %ebx,%edx
		}
	}

out:
	/* All bits in region matched. */
	return true;
  101853:	41 b0 01             	mov    $0x1,%r8b
		if ((bundle & bd->smask) != bd->smask) {
  101856:	21 c2                	and    %eax,%edx
  101858:	39 d3                	cmp    %edx,%ebx
  10185a:	75 14                	jne    101870 <match_region+0x5c>
  10185c:	e9 aa 00 00 00       	jmpq   10190b <match_region+0xf7>
	if (!match_set) {
  101861:	45 84 d2             	test   %r10b,%r10b
  101864:	75 02                	jne    101868 <match_region+0x54>
		bundle = ~bundle;
  101866:	f7 d0                	not    %eax
	if ((bundle & bd->smask) != bd->smask) {
  101868:	89 de                	mov    %ebx,%esi
  10186a:	21 c6                	and    %eax,%esi
  10186c:	39 f3                	cmp    %esi,%ebx
  10186e:	74 06                	je     101876 <match_region+0x62>
		mismatch_bundle = ~bundle & bd->smask;
  101870:	f7 d0                	not    %eax
  101872:	21 c3                	and    %eax,%ebx
		goto mismatch;
  101874:	eb 46                	jmp    1018bc <match_region+0xa8>
	bundle = bitarray->bundles[bd->eidx];
  101876:	8b 1c 91             	mov    (%rcx,%rdx,4),%ebx
	if (!match_set) {
  101879:	45 84 d2             	test   %r10b,%r10b
  10187c:	75 02                	jne    101880 <match_region+0x6c>
		bundle = ~bundle;
  10187e:	f7 d3                	not    %ebx
	if ((bundle & bd->emask) != bd->emask) {
  101880:	8b 47 24             	mov    0x24(%rdi),%eax
  101883:	89 c6                	mov    %eax,%esi
  101885:	21 de                	and    %ebx,%esi
  101887:	39 f0                	cmp    %esi,%eax
  101889:	74 09                	je     101894 <match_region+0x80>
		mismatch_bundle = ~bundle & bd->emask;
  10188b:	f7 d3                	not    %ebx
		goto mismatch;
  10188d:	49 89 d5             	mov    %rdx,%r13
		mismatch_bundle = ~bundle & bd->emask;
  101890:	21 c3                	and    %eax,%ebx
		goto mismatch;
  101892:	eb 28                	jmp    1018bc <match_region+0xa8>
	for (idx = bd->sidx + 1; idx < bd->eidx; idx++) {
  101894:	41 8d 45 01          	lea    0x1(%r13),%eax
  101898:	4c 63 e8             	movslq %eax,%r13
  10189b:	4c 39 ea             	cmp    %r13,%rdx
  10189e:	76 17                	jbe    1018b7 <match_region+0xa3>
		bundle = bitarray->bundles[idx];
  1018a0:	42 8b 1c a9          	mov    (%rcx,%r13,4),%ebx
		if (match_set) {
  1018a4:	45 84 db             	test   %r11b,%r11b
  1018a7:	74 02                	je     1018ab <match_region+0x97>
			bundle = ~bundle;
  1018a9:	f7 d3                	not    %ebx
		if (bundle != 0U) {
  1018ab:	85 db                	test   %ebx,%ebx
  1018ad:	74 04                	je     1018b3 <match_region+0x9f>
			mismatch_bundle = ~bundle;
  1018af:	f7 d3                	not    %ebx
			goto mismatch;
  1018b1:	eb 09                	jmp    1018bc <match_region+0xa8>
	for (idx = bd->sidx + 1; idx < bd->eidx; idx++) {
  1018b3:	ff c0                	inc    %eax
  1018b5:	eb e1                	jmp    101898 <match_region+0x84>
	return true;
  1018b7:	41 b0 01             	mov    $0x1,%r8b
  1018ba:	eb 4f                	jmp    10190b <match_region+0xf7>
		mismatch_bit_off = find_lsb_set(mismatch_bundle) - 1;
		mismatch_bit_off += mismatch_bundle_idx *
				    bundle_bitness(bitarray);
		*mismatch = (uint32_t)mismatch_bit_off;
	}
	return false;
  1018bc:	45 31 c0             	xor    %r8d,%r8d
	if (mismatch != NULL) {
  1018bf:	4d 85 e4             	test   %r12,%r12
  1018c2:	74 47                	je     10190b <match_region+0xf7>
		__ASSERT_NO_MSG(mismatch_bundle != 0);
  1018c4:	85 db                	test   %ebx,%ebx
  1018c6:	75 2a                	jne    1018f2 <match_region+0xde>
  1018c8:	be c2 d1 11 00       	mov    $0x11d1c2,%esi
  1018cd:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  1018d2:	b9 9b 00 00 00       	mov    $0x9b,%ecx
  1018d7:	31 c0                	xor    %eax,%eax
  1018d9:	ba 9d d1 11 00       	mov    $0x11d19d,%edx
  1018de:	e8 15 ed ff ff       	callq  1005f8 <printk>
  1018e3:	be 9b 00 00 00       	mov    $0x9b,%esi
  1018e8:	bf 9d d1 11 00       	mov    $0x11d19d,%edi
  1018ed:	e8 a6 12 00 00       	callq  102b98 <assert_post_action>
 */

static ALWAYS_INLINE unsigned int find_lsb_set(uint32_t op)
{
#ifdef CONFIG_TOOLCHAIN_HAS_BUILTIN_FFS
	return __builtin_ffs(op);
  1018f2:	0f bc db             	bsf    %ebx,%ebx
		mismatch_bit_off = find_lsb_set(mismatch_bundle) - 1;
  1018f5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  1018fa:	0f 44 d8             	cmove  %eax,%ebx
		mismatch_bit_off += mismatch_bundle_idx *
  1018fd:	49 c1 e5 05          	shl    $0x5,%r13
	return false;
  101901:	45 31 c0             	xor    %r8d,%r8d
		*mismatch = (uint32_t)mismatch_bit_off;
  101904:	41 01 dd             	add    %ebx,%r13d
  101907:	4d 89 2c 24          	mov    %r13,(%r12)
}
  10190b:	5a                   	pop    %rdx
  10190c:	44 89 c0             	mov    %r8d,%eax
  10190f:	5b                   	pop    %rbx
  101910:	41 5c                	pop    %r12
  101912:	41 5d                	pop    %r13
  101914:	5d                   	pop    %rbp
  101915:	c3                   	retq   

0000000000101916 <set_region>:
 *                 prior call to match_region().
 */
static void set_region(sys_bitarray_t *bitarray, size_t offset,
		       size_t num_bits, bool to_set,
		       struct bundle_data *bd)
{
  101916:	55                   	push   %rbp
  101917:	49 89 fa             	mov    %rdi,%r10
  10191a:	41 89 cb             	mov    %ecx,%r11d
  10191d:	48 89 e5             	mov    %rsp,%rbp
  101920:	48 83 ec 30          	sub    $0x30,%rsp
	int idx;
	struct bundle_data bdata;

	if (bd == NULL) {
  101924:	4d 85 c0             	test   %r8,%r8
  101927:	75 0c                	jne    101935 <set_region+0x1f>
		bd = &bdata;
		setup_bundle_data(bitarray, bd, offset, num_bits);
  101929:	48 8d 7d d8          	lea    -0x28(%rbp),%rdi
  10192d:	e8 8f fe ff ff       	callq  1017c1 <setup_bundle_data.constprop.0>
		bd = &bdata;
  101932:	49 89 f8             	mov    %rdi,%r8
	}

	if (bd->sidx == bd->eidx) {
  101935:	49 8b 00             	mov    (%r8),%rax
		/* Start/end at same bundle */
		if (to_set) {
			bitarray->bundles[bd->sidx] |= bd->smask;
  101938:	49 8b 7a 08          	mov    0x8(%r10),%rdi
	if (bd->sidx == bd->eidx) {
  10193c:	49 8b 70 08          	mov    0x8(%r8),%rsi
			bitarray->bundles[bd->sidx] |= bd->smask;
  101940:	41 8b 48 20          	mov    0x20(%r8),%ecx
  101944:	4c 8d 14 87          	lea    (%rdi,%rax,4),%r10
  101948:	41 8b 12             	mov    (%r10),%edx
	if (bd->sidx == bd->eidx) {
  10194b:	48 39 f0             	cmp    %rsi,%rax
  10194e:	75 13                	jne    101963 <set_region+0x4d>
			bitarray->bundles[bd->sidx] |= bd->smask;
  101950:	89 c8                	mov    %ecx,%eax
  101952:	f7 d0                	not    %eax
  101954:	21 d0                	and    %edx,%eax
  101956:	09 ca                	or     %ecx,%edx
  101958:	45 84 db             	test   %r11b,%r11b
  10195b:	0f 44 d0             	cmove  %eax,%edx
  10195e:	41 89 12             	mov    %edx,(%r10)
  101961:	eb 4d                	jmp    1019b0 <set_region+0x9a>
		 * separately. For in-between bundles,
		 * set/clear all bits.
		 */
		if (to_set) {
			bitarray->bundles[bd->sidx] |= bd->smask;
			bitarray->bundles[bd->eidx] |= bd->emask;
  101963:	4c 8d 0c b7          	lea    (%rdi,%rsi,4),%r9
			for (idx = bd->sidx + 1; idx < bd->eidx; idx++) {
  101967:	ff c0                	inc    %eax
		if (to_set) {
  101969:	45 84 db             	test   %r11b,%r11b
  10196c:	74 1f                	je     10198d <set_region+0x77>
			bitarray->bundles[bd->sidx] |= bd->smask;
  10196e:	09 ca                	or     %ecx,%edx
  101970:	41 89 12             	mov    %edx,(%r10)
			bitarray->bundles[bd->eidx] |= bd->emask;
  101973:	41 8b 50 24          	mov    0x24(%r8),%edx
  101977:	41 09 11             	or     %edx,(%r9)
			for (idx = bd->sidx + 1; idx < bd->eidx; idx++) {
  10197a:	48 63 d0             	movslq %eax,%rdx
  10197d:	48 39 d6             	cmp    %rdx,%rsi
  101980:	76 2e                	jbe    1019b0 <set_region+0x9a>
				bitarray->bundles[idx] = ~0U;
  101982:	c7 04 97 ff ff ff ff 	movl   $0xffffffff,(%rdi,%rdx,4)
			for (idx = bd->sidx + 1; idx < bd->eidx; idx++) {
  101989:	ff c0                	inc    %eax
  10198b:	eb ed                	jmp    10197a <set_region+0x64>
			}
		} else {
			bitarray->bundles[bd->sidx] &= ~bd->smask;
  10198d:	f7 d1                	not    %ecx
  10198f:	21 ca                	and    %ecx,%edx
  101991:	41 89 12             	mov    %edx,(%r10)
			bitarray->bundles[bd->eidx] &= ~bd->emask;
  101994:	41 8b 50 24          	mov    0x24(%r8),%edx
  101998:	f7 d2                	not    %edx
  10199a:	41 21 11             	and    %edx,(%r9)
			for (idx = bd->sidx + 1; idx < bd->eidx; idx++) {
  10199d:	48 63 d0             	movslq %eax,%rdx
  1019a0:	48 39 d6             	cmp    %rdx,%rsi
  1019a3:	76 0b                	jbe    1019b0 <set_region+0x9a>
				bitarray->bundles[idx] = 0U;
  1019a5:	c7 04 97 00 00 00 00 	movl   $0x0,(%rdi,%rdx,4)
			for (idx = bd->sidx + 1; idx < bd->eidx; idx++) {
  1019ac:	ff c0                	inc    %eax
  1019ae:	eb ed                	jmp    10199d <set_region+0x87>
			}
		}
	}
}
  1019b0:	c9                   	leaveq 
  1019b1:	c3                   	retq   

00000000001019b2 <set_clear_region>:
	return is_region_set_clear(bitarray, num_bits, offset, false);
}

static int set_clear_region(sys_bitarray_t *bitarray, size_t num_bits,
			    size_t offset, bool to_set)
{
  1019b2:	55                   	push   %rbp
	int ret;
	size_t off_end = offset + num_bits - 1;
  1019b3:	48 8d 44 16 ff       	lea    -0x1(%rsi,%rdx,1),%rax
{
  1019b8:	48 89 e5             	mov    %rsp,%rbp
  1019bb:	41 57                	push   %r15
  1019bd:	49 89 d7             	mov    %rdx,%r15
  1019c0:	41 56                	push   %r14
	k_spinlock_key_t key = k_spin_lock(&bitarray->lock);
  1019c2:	4c 8d 77 10          	lea    0x10(%rdi),%r14
{
  1019c6:	41 55                	push   %r13
  1019c8:	49 89 f5             	mov    %rsi,%r13
  1019cb:	41 54                	push   %r12
  1019cd:	49 89 fc             	mov    %rdi,%r12
  1019d0:	53                   	push   %rbx
  1019d1:	48 83 ec 28          	sub    $0x28,%rsp
  1019d5:	89 4d c4             	mov    %ecx,-0x3c(%rbp)
	size_t off_end = offset + num_bits - 1;
  1019d8:	48 89 45 c8          	mov    %rax,-0x38(%rbp)

static ALWAYS_INLINE unsigned int arch_irq_lock(void)
{
	unsigned long key;

	__asm__ volatile ("pushfq; cli; popq %0" : "=g" (key) : : "memory");
  1019dc:	9c                   	pushfq 
  1019dd:	fa                   	cli    
  1019de:	8f 45 b8             	popq   -0x48(%rbp)
	 * actually a wrapper for a global spinlock!
	 */
	k.key = arch_irq_lock();

#ifdef CONFIG_SPIN_VALIDATE
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  1019e1:	4c 89 f7             	mov    %r14,%rdi
  1019e4:	e8 90 be 00 00       	callq  10d879 <z_spin_lock_valid>
  1019e9:	84 c0                	test   %al,%al
  1019eb:	75 37                	jne    101a24 <set_clear_region+0x72>
  1019ed:	b9 8e 00 00 00       	mov    $0x8e,%ecx
  1019f2:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  1019f7:	be fd d1 11 00       	mov    $0x11d1fd,%esi
  1019fc:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  101a01:	e8 f2 eb ff ff       	callq  1005f8 <printk>
  101a06:	4c 89 f6             	mov    %r14,%rsi
  101a09:	bf 12 d2 11 00       	mov    $0x11d212,%edi
  101a0e:	31 c0                	xor    %eax,%eax
  101a10:	e8 e3 eb ff ff       	callq  1005f8 <printk>
  101a15:	be 8e 00 00 00       	mov    $0x8e,%esi
  101a1a:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  101a1f:	e8 74 11 00 00       	callq  102b98 <assert_post_action>
	while (!atomic_cas(&l->locked, 0, 1)) {
	}
#endif

#ifdef CONFIG_SPIN_VALIDATE
	z_spin_lock_set_owner(l);
  101a24:	4c 89 f7             	mov    %r14,%rdi
  101a27:	e8 91 be 00 00       	callq  10d8bd <z_spin_lock_set_owner>

	__ASSERT_NO_MSG(bitarray->num_bits > 0);
  101a2c:	41 83 3c 24 00       	cmpl   $0x0,(%r12)
  101a31:	75 2a                	jne    101a5d <set_clear_region+0xab>
  101a33:	be 2a d2 11 00       	mov    $0x11d22a,%esi
  101a38:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  101a3d:	b9 19 02 00 00       	mov    $0x219,%ecx
  101a42:	31 c0                	xor    %eax,%eax
  101a44:	ba 9d d1 11 00       	mov    $0x11d19d,%edx
  101a49:	e8 aa eb ff ff       	callq  1005f8 <printk>
  101a4e:	be 19 02 00 00       	mov    $0x219,%esi
  101a53:	bf 9d d1 11 00       	mov    $0x11d19d,%edi
  101a58:	e8 3b 11 00 00       	callq  102b98 <assert_post_action>

	if ((num_bits == 0)
	    || (num_bits > bitarray->num_bits)
	    || (offset >= bitarray->num_bits)
	    || (off_end >= bitarray->num_bits)) {
		ret = -EINVAL;
  101a5d:	bb ea ff ff ff       	mov    $0xffffffea,%ebx
	if ((num_bits == 0)
  101a62:	4d 85 ed             	test   %r13,%r13
  101a65:	74 38                	je     101a9f <set_clear_region+0xed>
	    || (num_bits > bitarray->num_bits)
  101a67:	41 8b 04 24          	mov    (%r12),%eax
  101a6b:	4c 39 e8             	cmp    %r13,%rax
  101a6e:	0f 92 c1             	setb   %cl
	    || (offset >= bitarray->num_bits)
  101a71:	4c 39 f8             	cmp    %r15,%rax
  101a74:	0f 96 c2             	setbe  %dl
	    || (off_end >= bitarray->num_bits)) {
  101a77:	08 d1                	or     %dl,%cl
  101a79:	75 1f                	jne    101a9a <set_clear_region+0xe8>
  101a7b:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  101a7f:	76 19                	jbe    101a9a <set_clear_region+0xe8>
		goto out;
	}

	set_region(bitarray, offset, num_bits, to_set, NULL);
  101a81:	0f b6 4d c4          	movzbl -0x3c(%rbp),%ecx
  101a85:	45 31 c0             	xor    %r8d,%r8d
  101a88:	4c 89 ea             	mov    %r13,%rdx
  101a8b:	4c 89 fe             	mov    %r15,%rsi
  101a8e:	4c 89 e7             	mov    %r12,%rdi
	ret = 0;
  101a91:	31 db                	xor    %ebx,%ebx
	set_region(bitarray, offset, num_bits, to_set, NULL);
  101a93:	e8 7e fe ff ff       	callq  101916 <set_region>
	ret = 0;
  101a98:	eb 05                	jmp    101a9f <set_clear_region+0xed>
		ret = -EINVAL;
  101a9a:	bb ea ff ff ff       	mov    $0xffffffea,%ebx
static ALWAYS_INLINE void k_spin_unlock(struct k_spinlock *l,
					k_spinlock_key_t key)
{
	ARG_UNUSED(l);
#ifdef CONFIG_SPIN_VALIDATE
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  101a9f:	4c 89 f7             	mov    %r14,%rdi
  101aa2:	e8 f2 bd 00 00       	callq  10d899 <z_spin_unlock_valid>
  101aa7:	84 c0                	test   %al,%al
  101aa9:	75 37                	jne    101ae2 <set_clear_region+0x130>
  101aab:	b9 b9 00 00 00       	mov    $0xb9,%ecx
  101ab0:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  101ab5:	be 41 d2 11 00       	mov    $0x11d241,%esi
  101aba:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  101abf:	e8 34 eb ff ff       	callq  1005f8 <printk>
  101ac4:	4c 89 f6             	mov    %r14,%rsi
  101ac7:	bf 58 d2 11 00       	mov    $0x11d258,%edi
  101acc:	31 c0                	xor    %eax,%eax
  101ace:	e8 25 eb ff ff       	callq  1005f8 <printk>
  101ad3:	be b9 00 00 00       	mov    $0xb9,%esi
  101ad8:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  101add:	e8 b6 10 00 00       	callq  102b98 <assert_post_action>

#endif /* CONFIG_PCIE_MSI */

static ALWAYS_INLINE void arch_irq_unlock(unsigned int key)
{
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  101ae2:	0f ba 65 b8 09       	btl    $0x9,-0x48(%rbp)
  101ae7:	73 01                	jae    101aea <set_clear_region+0x138>
		__asm__ volatile ("sti" ::: "memory");
  101ae9:	fb                   	sti    

out:
	k_spin_unlock(&bitarray->lock, key);
	return ret;
}
  101aea:	48 83 c4 28          	add    $0x28,%rsp
  101aee:	89 d8                	mov    %ebx,%eax
  101af0:	5b                   	pop    %rbx
  101af1:	41 5c                	pop    %r12
  101af3:	41 5d                	pop    %r13
  101af5:	41 5e                	pop    %r14
  101af7:	41 5f                	pop    %r15
  101af9:	5d                   	pop    %rbp
  101afa:	c3                   	retq   

0000000000101afb <sys_bitarray_alloc>:
{
  101afb:	55                   	push   %rbp
  101afc:	48 89 e5             	mov    %rsp,%rbp
  101aff:	41 57                	push   %r15
  101b01:	41 56                	push   %r14
	key = k_spin_lock(&bitarray->lock);
  101b03:	4c 8d 77 10          	lea    0x10(%rdi),%r14
{
  101b07:	41 55                	push   %r13
  101b09:	49 89 f5             	mov    %rsi,%r13
  101b0c:	41 54                	push   %r12
  101b0e:	49 89 fc             	mov    %rdi,%r12
  101b11:	53                   	push   %rbx
  101b12:	48 89 d3             	mov    %rdx,%rbx
  101b15:	48 83 ec 48          	sub    $0x48,%rsp
  101b19:	9c                   	pushfq 
  101b1a:	fa                   	cli    
  101b1b:	8f 45 90             	popq   -0x70(%rbp)
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  101b1e:	4c 89 f7             	mov    %r14,%rdi
  101b21:	e8 53 bd 00 00       	callq  10d879 <z_spin_lock_valid>
  101b26:	84 c0                	test   %al,%al
  101b28:	75 37                	jne    101b61 <sys_bitarray_alloc+0x66>
  101b2a:	b9 8e 00 00 00       	mov    $0x8e,%ecx
  101b2f:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  101b34:	be fd d1 11 00       	mov    $0x11d1fd,%esi
  101b39:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  101b3e:	e8 b5 ea ff ff       	callq  1005f8 <printk>
  101b43:	4c 89 f6             	mov    %r14,%rsi
  101b46:	bf 12 d2 11 00       	mov    $0x11d212,%edi
  101b4b:	31 c0                	xor    %eax,%eax
  101b4d:	e8 a6 ea ff ff       	callq  1005f8 <printk>
  101b52:	be 8e 00 00 00       	mov    $0x8e,%esi
  101b57:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  101b5c:	e8 37 10 00 00       	callq  102b98 <assert_post_action>
	z_spin_lock_set_owner(l);
  101b61:	4c 89 f7             	mov    %r14,%rdi
  101b64:	e8 54 bd 00 00       	callq  10d8bd <z_spin_lock_set_owner>
	__ASSERT_NO_MSG(bitarray->num_bits > 0);
  101b69:	41 83 3c 24 00       	cmpl   $0x0,(%r12)
  101b6e:	75 2a                	jne    101b9a <sys_bitarray_alloc+0x9f>
  101b70:	be 2a d2 11 00       	mov    $0x11d22a,%esi
  101b75:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  101b7a:	b9 8c 01 00 00       	mov    $0x18c,%ecx
  101b7f:	31 c0                	xor    %eax,%eax
  101b81:	ba 9d d1 11 00       	mov    $0x11d19d,%edx
  101b86:	e8 6d ea ff ff       	callq  1005f8 <printk>
  101b8b:	be 8c 01 00 00       	mov    $0x18c,%esi
  101b90:	bf 9d d1 11 00       	mov    $0x11d19d,%edi
  101b95:	e8 fe 0f 00 00       	callq  102b98 <assert_post_action>
	if ((num_bits == 0) || (num_bits > bitarray->num_bits)) {
  101b9a:	4d 85 ed             	test   %r13,%r13
  101b9d:	0f 84 af 00 00 00    	je     101c52 <sys_bitarray_alloc+0x157>
  101ba3:	48 85 db             	test   %rbx,%rbx
  101ba6:	0f 84 a6 00 00 00    	je     101c52 <sys_bitarray_alloc+0x157>
  101bac:	41 8b 0c 24          	mov    (%r12),%ecx
		ret = -EINVAL;
  101bb0:	41 bf ea ff ff ff    	mov    $0xffffffea,%r15d
	if ((num_bits == 0) || (num_bits > bitarray->num_bits)) {
  101bb6:	4c 39 e9             	cmp    %r13,%rcx
  101bb9:	0f 82 99 00 00 00    	jb     101c58 <sys_bitarray_alloc+0x15d>
  101bbf:	41 8b 7c 24 04       	mov    0x4(%r12),%edi
	for (ret = 0; ret < bitarray->num_bundles; ret++) {
  101bc4:	31 d2                	xor    %edx,%edx
  101bc6:	89 d6                	mov    %edx,%esi
  101bc8:	c1 e6 05             	shl    $0x5,%esi
  101bcb:	39 fa                	cmp    %edi,%edx
  101bcd:	74 28                	je     101bf7 <sys_bitarray_alloc+0xfc>
		if (~bitarray->bundles[ret] == 0U) {
  101bcf:	4d 8b 44 24 08       	mov    0x8(%r12),%r8
  101bd4:	48 63 c2             	movslq %edx,%rax
  101bd7:	41 8b 04 80          	mov    (%r8,%rax,4),%eax
  101bdb:	83 f8 ff             	cmp    $0xffffffff,%eax
  101bde:	75 04                	jne    101be4 <sys_bitarray_alloc+0xe9>
	for (ret = 0; ret < bitarray->num_bundles; ret++) {
  101be0:	ff c2                	inc    %edx
  101be2:	eb e2                	jmp    101bc6 <sys_bitarray_alloc+0xcb>
		if (bitarray->bundles[ret] != 0U) {
  101be4:	85 c0                	test   %eax,%eax
  101be6:	74 0f                	je     101bf7 <sys_bitarray_alloc+0xfc>
			off_start = find_lsb_set(~bitarray->bundles[ret]) - 1;
  101be8:	f7 d0                	not    %eax
  101bea:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  101bef:	0f bc c0             	bsf    %eax,%eax
  101bf2:	0f 44 c2             	cmove  %edx,%eax
			bit_idx += off_start;
  101bf5:	01 c6                	add    %eax,%esi
	off_end = bitarray->num_bits - num_bits;
  101bf7:	4c 29 e9             	sub    %r13,%rcx
  101bfa:	48 89 4d 98          	mov    %rcx,-0x68(%rbp)
	while (bit_idx <= off_end) {
  101bfe:	41 89 f7             	mov    %esi,%r15d
  101c01:	4c 3b 7d 98          	cmp    -0x68(%rbp),%r15
  101c05:	77 43                	ja     101c4a <sys_bitarray_alloc+0x14f>
		if (match_region(bitarray, bit_idx, num_bits, false,
  101c07:	31 c9                	xor    %ecx,%ecx
  101c09:	4c 8d 4d a0          	lea    -0x60(%rbp),%r9
  101c0d:	4c 8d 45 a8          	lea    -0x58(%rbp),%r8
  101c11:	4c 89 ea             	mov    %r13,%rdx
  101c14:	4c 89 fe             	mov    %r15,%rsi
  101c17:	4c 89 e7             	mov    %r12,%rdi
  101c1a:	e8 f5 fb ff ff       	callq  101814 <match_region>
  101c1f:	84 c0                	test   %al,%al
  101c21:	74 1f                	je     101c42 <sys_bitarray_alloc+0x147>
			set_region(bitarray, bit_idx, num_bits, true, &bd);
  101c23:	4c 89 fe             	mov    %r15,%rsi
  101c26:	4c 8d 45 a8          	lea    -0x58(%rbp),%r8
  101c2a:	b9 01 00 00 00       	mov    $0x1,%ecx
  101c2f:	4c 89 ea             	mov    %r13,%rdx
  101c32:	4c 89 e7             	mov    %r12,%rdi
  101c35:	e8 dc fc ff ff       	callq  101916 <set_region>
			*offset = bit_idx;
  101c3a:	4c 89 3b             	mov    %r15,(%rbx)
			ret = 0;
  101c3d:	45 31 ff             	xor    %r15d,%r15d
			break;
  101c40:	eb 16                	jmp    101c58 <sys_bitarray_alloc+0x15d>
		bit_idx = mismatch + 1;
  101c42:	8b 45 a0             	mov    -0x60(%rbp),%eax
  101c45:	8d 70 01             	lea    0x1(%rax),%esi
  101c48:	eb b4                	jmp    101bfe <sys_bitarray_alloc+0x103>
	ret = -ENOSPC;
  101c4a:	41 bf e4 ff ff ff    	mov    $0xffffffe4,%r15d
out:
  101c50:	eb 06                	jmp    101c58 <sys_bitarray_alloc+0x15d>
		ret = -EINVAL;
  101c52:	41 bf ea ff ff ff    	mov    $0xffffffea,%r15d
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  101c58:	4c 89 f7             	mov    %r14,%rdi
  101c5b:	e8 39 bc 00 00       	callq  10d899 <z_spin_unlock_valid>
  101c60:	84 c0                	test   %al,%al
  101c62:	75 37                	jne    101c9b <sys_bitarray_alloc+0x1a0>
  101c64:	b9 b9 00 00 00       	mov    $0xb9,%ecx
  101c69:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  101c6e:	be 41 d2 11 00       	mov    $0x11d241,%esi
  101c73:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  101c78:	e8 7b e9 ff ff       	callq  1005f8 <printk>
  101c7d:	4c 89 f6             	mov    %r14,%rsi
  101c80:	bf 58 d2 11 00       	mov    $0x11d258,%edi
  101c85:	31 c0                	xor    %eax,%eax
  101c87:	e8 6c e9 ff ff       	callq  1005f8 <printk>
  101c8c:	be b9 00 00 00       	mov    $0xb9,%esi
  101c91:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  101c96:	e8 fd 0e 00 00       	callq  102b98 <assert_post_action>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  101c9b:	0f ba 65 90 09       	btl    $0x9,-0x70(%rbp)
  101ca0:	73 01                	jae    101ca3 <sys_bitarray_alloc+0x1a8>
		__asm__ volatile ("sti" ::: "memory");
  101ca2:	fb                   	sti    
}
  101ca3:	48 83 c4 48          	add    $0x48,%rsp
  101ca7:	44 89 f8             	mov    %r15d,%eax
  101caa:	5b                   	pop    %rbx
  101cab:	41 5c                	pop    %r12
  101cad:	41 5d                	pop    %r13
  101caf:	41 5e                	pop    %r14
  101cb1:	41 5f                	pop    %r15
  101cb3:	5d                   	pop    %rbp
  101cb4:	c3                   	retq   

0000000000101cb5 <sys_bitarray_free>:
{
  101cb5:	55                   	push   %rbp
	size_t off_end = offset + num_bits - 1;
  101cb6:	48 8d 44 16 ff       	lea    -0x1(%rsi,%rdx,1),%rax
{
  101cbb:	48 89 e5             	mov    %rsp,%rbp
  101cbe:	41 57                	push   %r15
	key = k_spin_lock(&bitarray->lock);
  101cc0:	4c 8d 7f 10          	lea    0x10(%rdi),%r15
{
  101cc4:	41 56                	push   %r14
  101cc6:	49 89 d6             	mov    %rdx,%r14
  101cc9:	41 55                	push   %r13
  101ccb:	49 89 f5             	mov    %rsi,%r13
  101cce:	41 54                	push   %r12
  101cd0:	49 89 fc             	mov    %rdi,%r12
  101cd3:	53                   	push   %rbx
  101cd4:	48 83 ec 48          	sub    $0x48,%rsp
	size_t off_end = offset + num_bits - 1;
  101cd8:	48 89 45 98          	mov    %rax,-0x68(%rbp)
  101cdc:	9c                   	pushfq 
  101cdd:	fa                   	cli    
  101cde:	8f 45 90             	popq   -0x70(%rbp)
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  101ce1:	4c 89 ff             	mov    %r15,%rdi
  101ce4:	e8 90 bb 00 00       	callq  10d879 <z_spin_lock_valid>
  101ce9:	84 c0                	test   %al,%al
  101ceb:	75 37                	jne    101d24 <sys_bitarray_free+0x6f>
  101ced:	b9 8e 00 00 00       	mov    $0x8e,%ecx
  101cf2:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  101cf7:	be fd d1 11 00       	mov    $0x11d1fd,%esi
  101cfc:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  101d01:	e8 f2 e8 ff ff       	callq  1005f8 <printk>
  101d06:	4c 89 fe             	mov    %r15,%rsi
  101d09:	bf 12 d2 11 00       	mov    $0x11d212,%edi
  101d0e:	31 c0                	xor    %eax,%eax
  101d10:	e8 e3 e8 ff ff       	callq  1005f8 <printk>
  101d15:	be 8e 00 00 00       	mov    $0x8e,%esi
  101d1a:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  101d1f:	e8 74 0e 00 00       	callq  102b98 <assert_post_action>
	z_spin_lock_set_owner(l);
  101d24:	4c 89 ff             	mov    %r15,%rdi
  101d27:	e8 91 bb 00 00       	callq  10d8bd <z_spin_lock_set_owner>
	__ASSERT_NO_MSG(bitarray->num_bits > 0);
  101d2c:	41 83 3c 24 00       	cmpl   $0x0,(%r12)
  101d31:	75 2a                	jne    101d5d <sys_bitarray_free+0xa8>
  101d33:	be 2a d2 11 00       	mov    $0x11d22a,%esi
  101d38:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  101d3d:	b9 d3 01 00 00       	mov    $0x1d3,%ecx
  101d42:	31 c0                	xor    %eax,%eax
  101d44:	ba 9d d1 11 00       	mov    $0x11d19d,%edx
  101d49:	e8 aa e8 ff ff       	callq  1005f8 <printk>
  101d4e:	be d3 01 00 00       	mov    $0x1d3,%esi
  101d53:	bf 9d d1 11 00       	mov    $0x11d19d,%edi
  101d58:	e8 3b 0e 00 00       	callq  102b98 <assert_post_action>
		ret = -EINVAL;
  101d5d:	bb ea ff ff ff       	mov    $0xffffffea,%ebx
	if ((num_bits == 0)
  101d62:	4d 85 ed             	test   %r13,%r13
  101d65:	74 5a                	je     101dc1 <sys_bitarray_free+0x10c>
	    || (num_bits > bitarray->num_bits)
  101d67:	41 8b 04 24          	mov    (%r12),%eax
  101d6b:	4c 39 e8             	cmp    %r13,%rax
  101d6e:	0f 92 c1             	setb   %cl
	    || (offset >= bitarray->num_bits)
  101d71:	4c 39 f0             	cmp    %r14,%rax
  101d74:	0f 96 c2             	setbe  %dl
	    || (off_end >= bitarray->num_bits)) {
  101d77:	08 d1                	or     %dl,%cl
  101d79:	75 41                	jne    101dbc <sys_bitarray_free+0x107>
  101d7b:	48 3b 45 98          	cmp    -0x68(%rbp),%rax
  101d7f:	76 3b                	jbe    101dbc <sys_bitarray_free+0x107>
	if (match_region(bitarray, offset, num_bits, true, &bd, NULL)) {
  101d81:	45 31 c9             	xor    %r9d,%r9d
  101d84:	4c 8d 45 a8          	lea    -0x58(%rbp),%r8
  101d88:	b9 01 00 00 00       	mov    $0x1,%ecx
  101d8d:	4c 89 ea             	mov    %r13,%rdx
  101d90:	4c 89 f6             	mov    %r14,%rsi
  101d93:	4c 89 e7             	mov    %r12,%rdi
		ret = -EFAULT;
  101d96:	bb f2 ff ff ff       	mov    $0xfffffff2,%ebx
	if (match_region(bitarray, offset, num_bits, true, &bd, NULL)) {
  101d9b:	e8 74 fa ff ff       	callq  101814 <match_region>
  101da0:	84 c0                	test   %al,%al
  101da2:	74 1d                	je     101dc1 <sys_bitarray_free+0x10c>
		set_region(bitarray, offset, num_bits, false, &bd);
  101da4:	4c 8d 45 a8          	lea    -0x58(%rbp),%r8
  101da8:	31 c9                	xor    %ecx,%ecx
  101daa:	4c 89 ea             	mov    %r13,%rdx
  101dad:	4c 89 f6             	mov    %r14,%rsi
  101db0:	4c 89 e7             	mov    %r12,%rdi
		ret = 0;
  101db3:	31 db                	xor    %ebx,%ebx
		set_region(bitarray, offset, num_bits, false, &bd);
  101db5:	e8 5c fb ff ff       	callq  101916 <set_region>
		ret = 0;
  101dba:	eb 05                	jmp    101dc1 <sys_bitarray_free+0x10c>
		ret = -EINVAL;
  101dbc:	bb ea ff ff ff       	mov    $0xffffffea,%ebx
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  101dc1:	4c 89 ff             	mov    %r15,%rdi
  101dc4:	e8 d0 ba 00 00       	callq  10d899 <z_spin_unlock_valid>
  101dc9:	84 c0                	test   %al,%al
  101dcb:	75 37                	jne    101e04 <sys_bitarray_free+0x14f>
  101dcd:	b9 b9 00 00 00       	mov    $0xb9,%ecx
  101dd2:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  101dd7:	be 41 d2 11 00       	mov    $0x11d241,%esi
  101ddc:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  101de1:	e8 12 e8 ff ff       	callq  1005f8 <printk>
  101de6:	4c 89 fe             	mov    %r15,%rsi
  101de9:	bf 58 d2 11 00       	mov    $0x11d258,%edi
  101dee:	31 c0                	xor    %eax,%eax
  101df0:	e8 03 e8 ff ff       	callq  1005f8 <printk>
  101df5:	be b9 00 00 00       	mov    $0xb9,%esi
  101dfa:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  101dff:	e8 94 0d 00 00       	callq  102b98 <assert_post_action>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  101e04:	0f ba 65 90 09       	btl    $0x9,-0x70(%rbp)
  101e09:	73 01                	jae    101e0c <sys_bitarray_free+0x157>
		__asm__ volatile ("sti" ::: "memory");
  101e0b:	fb                   	sti    
}
  101e0c:	48 83 c4 48          	add    $0x48,%rsp
  101e10:	89 d8                	mov    %ebx,%eax
  101e12:	5b                   	pop    %rbx
  101e13:	41 5c                	pop    %r12
  101e15:	41 5d                	pop    %r13
  101e17:	41 5e                	pop    %r14
  101e19:	41 5f                	pop    %r15
  101e1b:	5d                   	pop    %rbp
  101e1c:	c3                   	retq   

0000000000101e1d <sys_bitarray_set_region>:

int sys_bitarray_set_region(sys_bitarray_t *bitarray, size_t num_bits,
			    size_t offset)
{
	return set_clear_region(bitarray, num_bits, offset, true);
  101e1d:	b9 01 00 00 00       	mov    $0x1,%ecx
  101e22:	e9 8b fb ff ff       	jmpq   1019b2 <set_clear_region>

0000000000101e27 <encode_uint>:
static char *encode_uint(uint_value_type value,
			 struct conversion *conv,
			 char *bps,
			 const char *bpe)
{
	bool upcase = isupper((int)conv->specifier);
  101e27:	44 0f b6 56 03       	movzbl 0x3(%rsi),%r10d
{
  101e2c:	49 89 c8             	mov    %rcx,%r8
  101e2f:	49 89 d1             	mov    %rdx,%r9
	switch (specifier) {
  101e32:	b9 08 00 00 00       	mov    $0x8,%ecx
	bool upcase = isupper((int)conv->specifier);
  101e37:	44 89 d0             	mov    %r10d,%eax
extern "C" {
#endif

static inline int isupper(int a)
{
	return (int)(((unsigned)(a)-(unsigned)'A') < 26U);
  101e3a:	41 83 ea 41          	sub    $0x41,%r10d
	switch (specifier) {
  101e3e:	3c 6f                	cmp    $0x6f,%al
  101e40:	74 3c                	je     101e7e <encode_uint+0x57>
  101e42:	77 04                	ja     101e48 <encode_uint+0x21>
		return 16;
  101e44:	3c 58                	cmp    $0x58,%al
  101e46:	eb 05                	jmp    101e4d <encode_uint+0x26>
	switch (specifier) {
  101e48:	83 e0 f7             	and    $0xfffffff7,%eax
		return 16;
  101e4b:	3c 70                	cmp    $0x70,%al
  101e4d:	b9 0a 00 00 00       	mov    $0xa,%ecx
  101e52:	b8 10 00 00 00       	mov    $0x10,%eax
  101e57:	48 0f 44 c8          	cmove  %rax,%rcx
	const unsigned int radix = conversion_radix(conv->specifier);
	char *bp = bps + (bpe - bps);
  101e5b:	eb 21                	jmp    101e7e <encode_uint+0x57>

	do {
		unsigned int lsv = (unsigned int)(value % radix);

		*--bp = (lsv <= 9) ? ('0' + lsv)
			: upcase ? ('A' + lsv - 10) : ('a' + lsv - 10);
  101e5d:	44 8d 5a 57          	lea    0x57(%rdx),%r11d
		*--bp = (lsv <= 9) ? ('0' + lsv)
  101e61:	41 83 fa 19          	cmp    $0x19,%r10d
  101e65:	77 04                	ja     101e6b <encode_uint+0x44>
			: upcase ? ('A' + lsv - 10) : ('a' + lsv - 10);
  101e67:	44 8d 5a 37          	lea    0x37(%rdx),%r11d
		*--bp = (lsv <= 9) ? ('0' + lsv)
  101e6b:	49 ff c8             	dec    %r8
  101e6e:	45 88 18             	mov    %r11b,(%r8)
		value /= radix;
	} while ((value != 0) && (bps < bp));
  101e71:	48 39 cf             	cmp    %rcx,%rdi
  101e74:	72 1c                	jb     101e92 <encode_uint+0x6b>
  101e76:	4d 39 c8             	cmp    %r9,%r8
  101e79:	76 17                	jbe    101e92 <encode_uint+0x6b>
		value /= radix;
  101e7b:	48 89 c7             	mov    %rax,%rdi
		unsigned int lsv = (unsigned int)(value % radix);
  101e7e:	48 89 f8             	mov    %rdi,%rax
  101e81:	31 d2                	xor    %edx,%edx
  101e83:	48 f7 f1             	div    %rcx
		*--bp = (lsv <= 9) ? ('0' + lsv)
  101e86:	44 8d 5a 30          	lea    0x30(%rdx),%r11d
  101e8a:	48 83 fa 09          	cmp    $0x9,%rdx
  101e8e:	76 db                	jbe    101e6b <encode_uint+0x44>
  101e90:	eb cb                	jmp    101e5d <encode_uint+0x36>

	/* Record required alternate forms.  This can be determined
	 * from the radix without re-checking specifier.
	 */
	if (conv->flag_hash) {
  101e92:	f6 06 20             	testb  $0x20,(%rsi)
  101e95:	74 16                	je     101ead <encode_uint+0x86>
		if (radix == 8) {
  101e97:	48 83 f9 08          	cmp    $0x8,%rcx
  101e9b:	75 06                	jne    101ea3 <encode_uint+0x7c>
			conv->altform_0 = true;
  101e9d:	80 4e 02 08          	orb    $0x8,0x2(%rsi)
  101ea1:	eb 0a                	jmp    101ead <encode_uint+0x86>
		} else if (radix == 16) {
  101ea3:	48 83 f9 10          	cmp    $0x10,%rcx
  101ea7:	75 04                	jne    101ead <encode_uint+0x86>
			conv->altform_0c = true;
  101ea9:	80 4e 02 10          	orb    $0x10,0x2(%rsi)
			;
		}
	}

	return bp;
}
  101ead:	4c 89 c0             	mov    %r8,%rax
  101eb0:	c3                   	retq   

0000000000101eb1 <outs>:
/* Outline function to emit all characters in [sp, ep). */
static int outs(cbprintf_cb out,
		void *ctx,
		const char *sp,
		const char *ep)
{
  101eb1:	55                   	push   %rbp
  101eb2:	48 89 e5             	mov    %rsp,%rbp
  101eb5:	41 57                	push   %r15
  101eb7:	49 89 f7             	mov    %rsi,%r15
  101eba:	41 56                	push   %r14
  101ebc:	49 89 fe             	mov    %rdi,%r14
  101ebf:	41 55                	push   %r13
  101ec1:	49 89 cd             	mov    %rcx,%r13
  101ec4:	41 54                	push   %r12
  101ec6:	49 89 d4             	mov    %rdx,%r12
  101ec9:	53                   	push   %rbx
	size_t count = 0;
  101eca:	31 db                	xor    %ebx,%ebx
{
  101ecc:	41 50                	push   %r8

	while ((sp < ep) || ((ep == NULL) && *sp)) {
  101ece:	49 8d 04 1c          	lea    (%r12,%rbx,1),%rax
  101ed2:	49 39 c5             	cmp    %rax,%r13
  101ed5:	76 16                	jbe    101eed <outs+0x3c>
		int rc = out((int)*sp++, ctx);
  101ed7:	31 c0                	xor    %eax,%eax
  101ed9:	41 0f be 3c 1c       	movsbl (%r12,%rbx,1),%edi
  101ede:	4c 89 fe             	mov    %r15,%rsi
  101ee1:	41 ff d6             	callq  *%r14

		if (rc < 0) {
  101ee4:	85 c0                	test   %eax,%eax
  101ee6:	78 17                	js     101eff <outs+0x4e>
			return rc;
		}
		++count;
  101ee8:	48 ff c3             	inc    %rbx
  101eeb:	eb e1                	jmp    101ece <outs+0x1d>
	while ((sp < ep) || ((ep == NULL) && *sp)) {
  101eed:	4d 85 ed             	test   %r13,%r13
  101ef0:	74 04                	je     101ef6 <outs+0x45>
	}

	return (int)count;
  101ef2:	89 d8                	mov    %ebx,%eax
  101ef4:	eb 09                	jmp    101eff <outs+0x4e>
	while ((sp < ep) || ((ep == NULL) && *sp)) {
  101ef6:	41 80 3c 1c 00       	cmpb   $0x0,(%r12,%rbx,1)
  101efb:	75 da                	jne    101ed7 <outs+0x26>
  101efd:	eb f3                	jmp    101ef2 <outs+0x41>
}
  101eff:	5a                   	pop    %rdx
  101f00:	5b                   	pop    %rbx
  101f01:	41 5c                	pop    %r12
  101f03:	41 5d                	pop    %r13
  101f05:	41 5e                	pop    %r14
  101f07:	41 5f                	pop    %r15
  101f09:	5d                   	pop    %rbp
  101f0a:	c3                   	retq   

0000000000101f0b <cbvprintf>:

int cbvprintf(cbprintf_cb out, void *ctx, const char *fp, va_list ap)
{
  101f0b:	55                   	push   %rbp
  101f0c:	48 89 e5             	mov    %rsp,%rbp
  101f0f:	41 57                	push   %r15
  101f11:	49 89 f7             	mov    %rsi,%r15
  101f14:	41 56                	push   %r14
  101f16:	49 89 fe             	mov    %rdi,%r14
  101f19:	41 55                	push   %r13
  101f1b:	41 54                	push   %r12
  101f1d:	49 89 cc             	mov    %rcx,%r12
  101f20:	53                   	push   %rbx
	char buf[CONVERTED_BUFLEN];
	size_t count = 0;
  101f21:	31 db                	xor    %ebx,%ebx
{
  101f23:	48 83 ec 68          	sub    $0x68,%rsp
		return rc; \
	} \
	count += rc; \
} while (false)

	while (*fp != 0) {
  101f27:	0f be 3a             	movsbl (%rdx),%edi
  101f2a:	40 84 ff             	test   %dil,%dil
  101f2d:	0f 84 70 09 00 00    	je     1028a3 <cbvprintf+0x998>
		if (*fp != '%') {
			OUTC(*fp++);
  101f33:	48 8d 42 01          	lea    0x1(%rdx),%rax
  101f37:	4c 89 fe             	mov    %r15,%rsi
  101f3a:	48 89 45 80          	mov    %rax,-0x80(%rbp)
		if (*fp != '%') {
  101f3e:	40 80 ff 25          	cmp    $0x25,%dil
  101f42:	0f 85 66 06 00 00    	jne    1025ae <cbvprintf+0x6a3>
		 * mitigate LLVM code generation bug.
		 */
		struct {
			union argument_value value;
			struct conversion conv;
		} state = {
  101f48:	31 c0                	xor    %eax,%eax
  101f4a:	48 8d 7d b0          	lea    -0x50(%rbp),%rdi
  101f4e:	b9 08 00 00 00       	mov    $0x8,%ecx
	if (*sp == '%') {
  101f53:	80 7a 01 25          	cmpb   $0x25,0x1(%rdx)
		} state = {
  101f57:	f3 ab                	rep stos %eax,%es:(%rdi)
	if (*sp == '%') {
  101f59:	75 11                	jne    101f6c <cbvprintf+0x61>
		conv->specifier = *sp++;
  101f5b:	48 8d 42 02          	lea    0x2(%rdx),%rax
  101f5f:	c6 45 c3 25          	movb   $0x25,-0x3d(%rbp)
  101f63:	48 89 45 80          	mov    %rax,-0x80(%rbp)
		return sp;
  101f67:	e9 df 02 00 00       	jmpq   10224b <cbvprintf+0x340>
  101f6c:	45 31 d2             	xor    %r10d,%r10d
  101f6f:	45 31 c9             	xor    %r9d,%r9d
  101f72:	31 ff                	xor    %edi,%edi
  101f74:	31 f6                	xor    %esi,%esi
  101f76:	31 c9                	xor    %ecx,%ecx
		switch (*sp) {
  101f78:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  101f7c:	8a 00                	mov    (%rax),%al
  101f7e:	3c 2b                	cmp    $0x2b,%al
  101f80:	74 56                	je     101fd8 <cbvprintf+0xcd>
  101f82:	7f 0a                	jg     101f8e <cbvprintf+0x83>
  101f84:	3c 20                	cmp    $0x20,%al
  101f86:	74 55                	je     101fdd <cbvprintf+0xd2>
  101f88:	3c 23                	cmp    $0x23,%al
  101f8a:	74 56                	je     101fe2 <cbvprintf+0xd7>
  101f8c:	eb 08                	jmp    101f96 <cbvprintf+0x8b>
  101f8e:	3c 2d                	cmp    $0x2d,%al
  101f90:	74 55                	je     101fe7 <cbvprintf+0xdc>
  101f92:	3c 30                	cmp    $0x30,%al
  101f94:	74 55                	je     101feb <cbvprintf+0xe0>
  101f96:	84 c9                	test   %cl,%cl
  101f98:	74 04                	je     101f9e <cbvprintf+0x93>
  101f9a:	80 4d c0 04          	orb    $0x4,-0x40(%rbp)
  101f9e:	40 84 f6             	test   %sil,%sil
  101fa1:	74 04                	je     101fa7 <cbvprintf+0x9c>
  101fa3:	80 4d c0 08          	orb    $0x8,-0x40(%rbp)
  101fa7:	40 84 ff             	test   %dil,%dil
  101faa:	74 04                	je     101fb0 <cbvprintf+0xa5>
  101fac:	80 4d c0 10          	orb    $0x10,-0x40(%rbp)
  101fb0:	45 84 c9             	test   %r9b,%r9b
  101fb3:	74 04                	je     101fb9 <cbvprintf+0xae>
  101fb5:	80 4d c0 20          	orb    $0x20,-0x40(%rbp)
  101fb9:	45 84 d2             	test   %r10b,%r10b
  101fbc:	74 04                	je     101fc2 <cbvprintf+0xb7>
  101fbe:	80 4d c0 40          	orb    $0x40,-0x40(%rbp)
	if (conv->flag_zero && conv->flag_dash) {
  101fc2:	8a 4d c0             	mov    -0x40(%rbp),%cl
  101fc5:	89 ce                	mov    %ecx,%esi
  101fc7:	83 e6 44             	and    $0x44,%esi
  101fca:	40 80 fe 44          	cmp    $0x44,%sil
  101fce:	75 24                	jne    101ff4 <cbvprintf+0xe9>
		conv->flag_zero = false;
  101fd0:	83 e1 bf             	and    $0xffffffbf,%ecx
  101fd3:	88 4d c0             	mov    %cl,-0x40(%rbp)
  101fd6:	eb 1c                	jmp    101ff4 <cbvprintf+0xe9>
			conv->flag_plus = true;
  101fd8:	40 b6 01             	mov    $0x1,%sil
  101fdb:	eb 11                	jmp    101fee <cbvprintf+0xe3>
			conv->flag_space = true;
  101fdd:	40 b7 01             	mov    $0x1,%dil
  101fe0:	eb 0c                	jmp    101fee <cbvprintf+0xe3>
			conv->flag_hash = true;
  101fe2:	41 b1 01             	mov    $0x1,%r9b
  101fe5:	eb 07                	jmp    101fee <cbvprintf+0xe3>
		switch (*sp) {
  101fe7:	b1 01                	mov    $0x1,%cl
  101fe9:	eb 03                	jmp    101fee <cbvprintf+0xe3>
			conv->flag_zero = true;
  101feb:	41 b2 01             	mov    $0x1,%r10b
			++sp;
  101fee:	48 ff 45 80          	incq   -0x80(%rbp)
  101ff2:	eb 84                	jmp    101f78 <cbvprintf+0x6d>
	conv->width_present = true;
  101ff4:	80 4d c0 80          	orb    $0x80,-0x40(%rbp)
	if (*sp == '*') {
  101ff8:	3c 2a                	cmp    $0x2a,%al
			++sp;
  101ffa:	48 8b 45 80          	mov    -0x80(%rbp),%rax
	if (*sp == '*') {
  101ffe:	75 09                	jne    102009 <cbvprintf+0xfe>
		conv->width_star = true;
  102000:	80 4d c1 01          	orb    $0x1,-0x3f(%rbp)
			++sp;
  102004:	48 ff c0             	inc    %rax
		return ++sp;
  102007:	eb 51                	jmp    10205a <cbvprintf+0x14f>
	size_t val = 0;
  102009:	31 c9                	xor    %ecx,%ecx
	while (isdigit((int)(unsigned char)*sp)) {
  10200b:	48 0f be 30          	movsbq (%rax),%rsi
		val = 10U * val + *sp++ - '0';
  10200f:	4c 8d 48 01          	lea    0x1(%rax),%r9
			(((unsigned)c) <= (unsigned)'~'));
}

static inline int isdigit(int a)
{
	return (int)(((unsigned)(a)-(unsigned)'0') < 10U);
  102013:	40 0f b6 fe          	movzbl %sil,%edi
  102017:	83 ef 30             	sub    $0x30,%edi
	while (isdigit((int)(unsigned char)*sp)) {
  10201a:	83 ff 09             	cmp    $0x9,%edi
  10201d:	77 0e                	ja     10202d <cbvprintf+0x122>
		val = 10U * val + *sp++ - '0';
  10201f:	48 6b c9 0a          	imul   $0xa,%rcx,%rcx
  102023:	4c 89 c8             	mov    %r9,%rax
  102026:	48 8d 4c 31 d0       	lea    -0x30(%rcx,%rsi,1),%rcx
  10202b:	eb de                	jmp    10200b <cbvprintf+0x100>
	if (sp != wp) {
  10202d:	48 39 45 80          	cmp    %rax,-0x80(%rbp)
  102031:	74 27                	je     10205a <cbvprintf+0x14f>
		conv->width_value = width;
  102033:	89 4d c4             	mov    %ecx,-0x3c(%rbp)
				      || (width != (size_t)conv->width_value));
  102036:	be 01 00 00 00       	mov    $0x1,%esi
  10203b:	85 c9                	test   %ecx,%ecx
  10203d:	78 0e                	js     10204d <cbvprintf+0x142>
  10203f:	48 63 f1             	movslq %ecx,%rsi
  102042:	48 39 ce             	cmp    %rcx,%rsi
  102045:	40 0f 95 c6          	setne  %sil
  102049:	40 0f b6 f6          	movzbl %sil,%esi
		conv->unsupported |= ((conv->width_value < 0)
  10204d:	8a 4d c0             	mov    -0x40(%rbp),%cl
  102050:	01 f6                	add    %esi,%esi
  102052:	83 e1 fd             	and    $0xfffffffd,%ecx
  102055:	09 f1                	or     %esi,%ecx
  102057:	88 4d c0             	mov    %cl,-0x40(%rbp)
	conv->prec_present = (*sp == '.');
  10205a:	40 8a 38             	mov    (%rax),%dil
  10205d:	40 80 ff 2e          	cmp    $0x2e,%dil
  102061:	0f 94 c1             	sete   %cl
  102064:	8d 34 09             	lea    (%rcx,%rcx,1),%esi
  102067:	8a 4d c1             	mov    -0x3f(%rbp),%cl
  10206a:	83 e1 fd             	and    $0xfffffffd,%ecx
  10206d:	09 f1                	or     %esi,%ecx
  10206f:	88 4d c1             	mov    %cl,-0x3f(%rbp)
	if (!conv->prec_present) {
  102072:	40 80 ff 2e          	cmp    $0x2e,%dil
  102076:	75 6c                	jne    1020e4 <cbvprintf+0x1d9>
	if (*sp == '*') {
  102078:	80 78 01 2a          	cmpb   $0x2a,0x1(%rax)
  10207c:	74 07                	je     102085 <cbvprintf+0x17a>
	++sp;
  10207e:	48 ff c0             	inc    %rax
	size_t val = 0;
  102081:	31 f6                	xor    %esi,%esi
  102083:	eb 0c                	jmp    102091 <cbvprintf+0x186>
		conv->prec_star = true;
  102085:	83 c9 04             	or     $0x4,%ecx
		return ++sp;
  102088:	48 83 c0 02          	add    $0x2,%rax
		conv->prec_star = true;
  10208c:	88 4d c1             	mov    %cl,-0x3f(%rbp)
		return ++sp;
  10208f:	eb 53                	jmp    1020e4 <cbvprintf+0x1d9>
	while (isdigit((int)(unsigned char)*sp)) {
  102091:	48 0f be 08          	movsbq (%rax),%rcx
		val = 10U * val + *sp++ - '0';
  102095:	4c 8d 48 01          	lea    0x1(%rax),%r9
  102099:	0f b6 f9             	movzbl %cl,%edi
  10209c:	83 ef 30             	sub    $0x30,%edi
	while (isdigit((int)(unsigned char)*sp)) {
  10209f:	83 ff 09             	cmp    $0x9,%edi
  1020a2:	77 0e                	ja     1020b2 <cbvprintf+0x1a7>
		val = 10U * val + *sp++ - '0';
  1020a4:	48 6b f6 0a          	imul   $0xa,%rsi,%rsi
  1020a8:	4c 89 c8             	mov    %r9,%rax
  1020ab:	48 8d 74 0e d0       	lea    -0x30(%rsi,%rcx,1),%rsi
  1020b0:	eb df                	jmp    102091 <cbvprintf+0x186>
	conv->unsupported |= ((conv->prec_value < 0)
  1020b2:	8a 4d c0             	mov    -0x40(%rbp),%cl
	conv->prec_value = prec;
  1020b5:	89 75 c8             	mov    %esi,-0x38(%rbp)
			      || (prec != (size_t)conv->prec_value));
  1020b8:	bf 01 00 00 00       	mov    $0x1,%edi
	conv->unsupported |= ((conv->prec_value < 0)
  1020bd:	d0 e9                	shr    %cl
  1020bf:	83 e1 01             	and    $0x1,%ecx
			      || (prec != (size_t)conv->prec_value));
  1020c2:	85 f6                	test   %esi,%esi
  1020c4:	78 0e                	js     1020d4 <cbvprintf+0x1c9>
  1020c6:	48 63 fe             	movslq %esi,%rdi
  1020c9:	48 39 f7             	cmp    %rsi,%rdi
  1020cc:	40 0f 95 c7          	setne  %dil
  1020d0:	40 0f b6 ff          	movzbl %dil,%edi
	conv->unsupported |= ((conv->prec_value < 0)
  1020d4:	40 8a 75 c0          	mov    -0x40(%rbp),%sil
  1020d8:	09 f9                	or     %edi,%ecx
  1020da:	01 c9                	add    %ecx,%ecx
  1020dc:	83 e6 fd             	and    $0xfffffffd,%esi
  1020df:	09 f1                	or     %esi,%ecx
  1020e1:	88 4d c0             	mov    %cl,-0x40(%rbp)
	switch (*sp) {
  1020e4:	8a 08                	mov    (%rax),%cl
		if (*++sp == 'h') {
  1020e6:	48 8d 70 01          	lea    0x1(%rax),%rsi
	switch (*sp) {
  1020ea:	80 f9 6c             	cmp    $0x6c,%cl
  1020ed:	74 3b                	je     10212a <cbvprintf+0x21f>
  1020ef:	7f 11                	jg     102102 <cbvprintf+0x1f7>
  1020f1:	80 f9 68             	cmp    $0x68,%cl
  1020f4:	74 1b                	je     102111 <cbvprintf+0x206>
  1020f6:	80 f9 6a             	cmp    $0x6a,%cl
  1020f9:	74 52                	je     10214d <cbvprintf+0x242>
  1020fb:	80 f9 4c             	cmp    $0x4c,%cl
  1020fe:	74 71                	je     102171 <cbvprintf+0x266>
  102100:	eb 0a                	jmp    10210c <cbvprintf+0x201>
  102102:	80 f9 74             	cmp    $0x74,%cl
  102105:	74 5c                	je     102163 <cbvprintf+0x258>
  102107:	80 f9 7a             	cmp    $0x7a,%cl
  10210a:	74 4c                	je     102158 <cbvprintf+0x24d>
  10210c:	48 89 c6             	mov    %rax,%rsi
  10210f:	eb 6f                	jmp    102180 <cbvprintf+0x275>
		if (*++sp == 'h') {
  102111:	80 78 01 68          	cmpb   $0x68,0x1(%rax)
  102115:	8a 4d c1             	mov    -0x3f(%rbp),%cl
  102118:	75 08                	jne    102122 <cbvprintf+0x217>
			conv->length_mod = LENGTH_HH;
  10211a:	83 e1 87             	and    $0xffffff87,%ecx
  10211d:	83 c9 08             	or     $0x8,%ecx
  102120:	eb 17                	jmp    102139 <cbvprintf+0x22e>
			conv->length_mod = LENGTH_H;
  102122:	83 e1 87             	and    $0xffffff87,%ecx
  102125:	83 c9 10             	or     $0x10,%ecx
  102128:	eb 1e                	jmp    102148 <cbvprintf+0x23d>
		if (*++sp == 'l') {
  10212a:	80 78 01 6c          	cmpb   $0x6c,0x1(%rax)
  10212e:	8a 4d c1             	mov    -0x3f(%rbp),%cl
  102131:	75 0f                	jne    102142 <cbvprintf+0x237>
			conv->length_mod = LENGTH_LL;
  102133:	83 e1 87             	and    $0xffffff87,%ecx
  102136:	83 c9 20             	or     $0x20,%ecx
  102139:	88 4d c1             	mov    %cl,-0x3f(%rbp)
			++sp;
  10213c:	48 8d 70 02          	lea    0x2(%rax),%rsi
  102140:	eb 3e                	jmp    102180 <cbvprintf+0x275>
			conv->length_mod = LENGTH_L;
  102142:	83 e1 87             	and    $0xffffff87,%ecx
  102145:	83 c9 18             	or     $0x18,%ecx
  102148:	88 4d c1             	mov    %cl,-0x3f(%rbp)
  10214b:	eb 33                	jmp    102180 <cbvprintf+0x275>
		conv->length_mod = LENGTH_J;
  10214d:	8a 45 c1             	mov    -0x3f(%rbp),%al
  102150:	83 e0 87             	and    $0xffffff87,%eax
  102153:	83 c8 28             	or     $0x28,%eax
  102156:	eb 14                	jmp    10216c <cbvprintf+0x261>
		conv->length_mod = LENGTH_Z;
  102158:	8a 45 c1             	mov    -0x3f(%rbp),%al
  10215b:	83 e0 87             	and    $0xffffff87,%eax
  10215e:	83 c8 30             	or     $0x30,%eax
  102161:	eb 09                	jmp    10216c <cbvprintf+0x261>
		conv->length_mod = LENGTH_T;
  102163:	8a 45 c1             	mov    -0x3f(%rbp),%al
  102166:	83 e0 87             	and    $0xffffff87,%eax
  102169:	83 c8 38             	or     $0x38,%eax
  10216c:	88 45 c1             	mov    %al,-0x3f(%rbp)
		break;
  10216f:	eb 0f                	jmp    102180 <cbvprintf+0x275>
		conv->unsupported = true;
  102171:	8b 45 c0             	mov    -0x40(%rbp),%eax
  102174:	66 25 fd 87          	and    $0x87fd,%ax
  102178:	66 0d 02 40          	or     $0x4002,%ax
  10217c:	66 89 45 c0          	mov    %ax,-0x40(%rbp)
	conv->specifier = *sp++;
  102180:	48 8d 46 01          	lea    0x1(%rsi),%rax
		if (conv->length_mod == LENGTH_UPPER_L) {
  102184:	8a 4d c1             	mov    -0x3f(%rbp),%cl
	conv->specifier = *sp++;
  102187:	48 89 45 80          	mov    %rax,-0x80(%rbp)
  10218b:	8a 06                	mov    (%rsi),%al
  10218d:	88 45 c3             	mov    %al,-0x3d(%rbp)
	switch (conv->specifier) {
  102190:	3c 78                	cmp    $0x78,%al
  102192:	0f 8f 97 00 00 00    	jg     10222f <cbvprintf+0x324>
  102198:	3c 57                	cmp    $0x57,%al
  10219a:	7f 11                	jg     1021ad <cbvprintf+0x2a2>
  10219c:	3c 41                	cmp    $0x41,%al
  10219e:	74 51                	je     1021f1 <cbvprintf+0x2e6>
  1021a0:	83 e8 45             	sub    $0x45,%eax
  1021a3:	3c 02                	cmp    $0x2,%al
  1021a5:	0f 87 84 00 00 00    	ja     10222f <cbvprintf+0x324>
  1021ab:	eb 44                	jmp    1021f1 <cbvprintf+0x2e6>
  1021ad:	8d 70 a8             	lea    -0x58(%rax),%esi
  1021b0:	40 80 fe 20          	cmp    $0x20,%sil
  1021b4:	77 79                	ja     10222f <cbvprintf+0x324>
  1021b6:	40 0f b6 f6          	movzbl %sil,%esi
  1021ba:	ff 24 f5 60 c8 11 00 	jmpq   *0x11c860(,%rsi,8)
		conv->specifier_cat = SPECIFIER_SINT;
  1021c1:	40 8a 75 c2          	mov    -0x3e(%rbp),%sil
  1021c5:	83 e6 f8             	and    $0xfffffff8,%esi
  1021c8:	83 ce 01             	or     $0x1,%esi
  1021cb:	eb 0a                	jmp    1021d7 <cbvprintf+0x2cc>
		conv->specifier_cat = SPECIFIER_UINT;
  1021cd:	40 8a 75 c2          	mov    -0x3e(%rbp),%sil
  1021d1:	83 e6 f8             	and    $0xfffffff8,%esi
  1021d4:	83 ce 02             	or     $0x2,%esi
		if (conv->length_mod == LENGTH_UPPER_L) {
  1021d7:	83 e1 78             	and    $0x78,%ecx
		conv->specifier_cat = SPECIFIER_UINT;
  1021da:	40 88 75 c2          	mov    %sil,-0x3e(%rbp)
		if (conv->length_mod == LENGTH_UPPER_L) {
  1021de:	80 f9 40             	cmp    $0x40,%cl
  1021e1:	75 04                	jne    1021e7 <cbvprintf+0x2dc>
			conv->invalid = true;
  1021e3:	80 4d c0 01          	orb    $0x1,-0x40(%rbp)
	bool unsupported = false;
  1021e7:	31 f6                	xor    %esi,%esi
		if (conv->specifier == 'c') {
  1021e9:	3c 63                	cmp    $0x63,%al
  1021eb:	75 48                	jne    102235 <cbvprintf+0x32a>
			unsupported = (conv->length_mod != LENGTH_NONE);
  1021ed:	84 c9                	test   %cl,%cl
  1021ef:	eb 38                	jmp    102229 <cbvprintf+0x31e>
		conv->specifier_cat = SPECIFIER_FP;
  1021f1:	8a 45 c2             	mov    -0x3e(%rbp),%al
			unsupported = true;
  1021f4:	40 b6 01             	mov    $0x1,%sil
		conv->specifier_cat = SPECIFIER_FP;
  1021f7:	83 e0 f8             	and    $0xfffffff8,%eax
  1021fa:	83 c8 04             	or     $0x4,%eax
  1021fd:	88 45 c2             	mov    %al,-0x3e(%rbp)
			break;
  102200:	eb 33                	jmp    102235 <cbvprintf+0x32a>
		conv->specifier_cat = SPECIFIER_PTR;
  102202:	8a 45 c2             	mov    -0x3e(%rbp),%al
		if (conv->length_mod == LENGTH_UPPER_L) {
  102205:	83 e1 78             	and    $0x78,%ecx
		conv->specifier_cat = SPECIFIER_PTR;
  102208:	83 e0 f8             	and    $0xfffffff8,%eax
  10220b:	83 c8 03             	or     $0x3,%eax
		if (conv->length_mod == LENGTH_UPPER_L) {
  10220e:	80 f9 40             	cmp    $0x40,%cl
		conv->specifier_cat = SPECIFIER_PTR;
  102211:	88 45 c2             	mov    %al,-0x3e(%rbp)
		if (conv->length_mod == LENGTH_UPPER_L) {
  102214:	40 0f 94 c6          	sete   %sil
  102218:	eb 1b                	jmp    102235 <cbvprintf+0x32a>
		conv->specifier_cat = SPECIFIER_PTR;
  10221a:	8a 45 c2             	mov    -0x3e(%rbp),%al
  10221d:	83 e0 f8             	and    $0xfffffff8,%eax
  102220:	83 c8 03             	or     $0x3,%eax
		if (conv->length_mod != LENGTH_NONE) {
  102223:	80 e1 78             	and    $0x78,%cl
		conv->specifier_cat = SPECIFIER_PTR;
  102226:	88 45 c2             	mov    %al,-0x3e(%rbp)
		if (conv->length_mod != LENGTH_NONE) {
  102229:	40 0f 95 c6          	setne  %sil
  10222d:	eb 06                	jmp    102235 <cbvprintf+0x32a>
		conv->invalid = true;
  10222f:	80 4d c0 01          	orb    $0x1,-0x40(%rbp)
	bool unsupported = false;
  102233:	31 f6                	xor    %esi,%esi
	conv->unsupported |= unsupported;
  102235:	8a 4d c0             	mov    -0x40(%rbp),%cl
  102238:	89 c8                	mov    %ecx,%eax
  10223a:	83 e1 fd             	and    $0xfffffffd,%ecx
  10223d:	d0 e8                	shr    %al
  10223f:	83 e0 01             	and    $0x1,%eax
  102242:	09 f0                	or     %esi,%eax
  102244:	01 c0                	add    %eax,%eax
  102246:	09 c8                	or     %ecx,%eax
  102248:	88 45 c0             	mov    %al,-0x40(%rbp)
		fp = extract_conversion(conv, sp);

		/* If dynamic width is specified, process it,
		 * otherwise set width if present.
		 */
		if (conv->width_star) {
  10224b:	40 8a 75 c1          	mov    -0x3f(%rbp),%sil
  10224f:	40 f6 c6 01          	test   $0x1,%sil
  102253:	74 39                	je     10228e <cbvprintf+0x383>
			width = va_arg(ap, int);
  102255:	41 8b 0c 24          	mov    (%r12),%ecx
  102259:	83 f9 2f             	cmp    $0x2f,%ecx
  10225c:	77 10                	ja     10226e <cbvprintf+0x363>
  10225e:	89 c8                	mov    %ecx,%eax
  102260:	83 c1 08             	add    $0x8,%ecx
  102263:	49 03 44 24 10       	add    0x10(%r12),%rax
  102268:	41 89 0c 24          	mov    %ecx,(%r12)
  10226c:	eb 0e                	jmp    10227c <cbvprintf+0x371>
  10226e:	49 8b 44 24 08       	mov    0x8(%r12),%rax
  102273:	48 8d 48 08          	lea    0x8(%rax),%rcx
  102277:	49 89 4c 24 08       	mov    %rcx,0x8(%r12)
  10227c:	8b 00                	mov    (%rax),%eax
  10227e:	89 45 8c             	mov    %eax,-0x74(%rbp)

			if (width < 0) {
  102281:	85 c0                	test   %eax,%eax
  102283:	79 1c                	jns    1022a1 <cbvprintf+0x396>
				conv->flag_dash = true;
  102285:	80 4d c0 04          	orb    $0x4,-0x40(%rbp)
				width = -width;
  102289:	f7 5d 8c             	negl   -0x74(%rbp)
  10228c:	eb 13                	jmp    1022a1 <cbvprintf+0x396>
			}
		} else if (conv->width_present) {
  10228e:	80 7d c0 00          	cmpb   $0x0,-0x40(%rbp)
		int width = -1;
  102292:	c7 45 8c ff ff ff ff 	movl   $0xffffffff,-0x74(%rbp)
		} else if (conv->width_present) {
  102299:	79 06                	jns    1022a1 <cbvprintf+0x396>
			width = conv->width_value;
  10229b:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  10229e:	89 45 8c             	mov    %eax,-0x74(%rbp)

		/* If dynamic precision is specified, process it, otherwise
		 * set precision if present.  For floating point where
		 * precision is not present use 6.
		 */
		if (conv->prec_star) {
  1022a1:	40 f6 c6 04          	test   $0x4,%sil
  1022a5:	74 39                	je     1022e0 <cbvprintf+0x3d5>
			int arg = va_arg(ap, int);
  1022a7:	41 8b 0c 24          	mov    (%r12),%ecx
  1022ab:	83 f9 2f             	cmp    $0x2f,%ecx
  1022ae:	77 10                	ja     1022c0 <cbvprintf+0x3b5>
  1022b0:	89 c8                	mov    %ecx,%eax
  1022b2:	83 c1 08             	add    $0x8,%ecx
  1022b5:	49 03 44 24 10       	add    0x10(%r12),%rax
  1022ba:	41 89 0c 24          	mov    %ecx,(%r12)
  1022be:	eb 0e                	jmp    1022ce <cbvprintf+0x3c3>
  1022c0:	49 8b 44 24 08       	mov    0x8(%r12),%rax
  1022c5:	48 8d 48 08          	lea    0x8(%rax),%rcx
  1022c9:	49 89 4c 24 08       	mov    %rcx,0x8(%r12)
  1022ce:	44 8b 10             	mov    (%rax),%r10d

			if (arg < 0) {
  1022d1:	45 85 d2             	test   %r10d,%r10d
  1022d4:	79 18                	jns    1022ee <cbvprintf+0x3e3>
				conv->prec_present = false;
  1022d6:	80 65 c1 fd          	andb   $0xfd,-0x3f(%rbp)
		int precision = -1;
  1022da:	41 83 ca ff          	or     $0xffffffff,%r10d
  1022de:	eb 0e                	jmp    1022ee <cbvprintf+0x3e3>
  1022e0:	41 83 ca ff          	or     $0xffffffff,%r10d
			} else {
				precision = arg;
			}
		} else if (conv->prec_present) {
  1022e4:	40 80 e6 02          	and    $0x2,%sil
  1022e8:	74 04                	je     1022ee <cbvprintf+0x3e3>
			precision = conv->prec_value;
  1022ea:	44 8b 55 c8          	mov    -0x38(%rbp),%r10d
		 * https://stackoverflow.com/a/8048892.
		 */
		enum specifier_cat_enum specifier_cat
			= (enum specifier_cat_enum)conv->specifier_cat;
		enum length_mod_enum length_mod
			= (enum length_mod_enum)conv->length_mod;
  1022ee:	8a 4d c1             	mov    -0x3f(%rbp),%cl
			= (enum specifier_cat_enum)conv->specifier_cat;
  1022f1:	8a 45 c2             	mov    -0x3e(%rbp),%al
		conv->pad0_value = 0;
  1022f4:	48 c7 45 c4 00 00 00 	movq   $0x0,-0x3c(%rbp)
  1022fb:	00 
			= (enum length_mod_enum)conv->length_mod;
  1022fc:	c0 e9 03             	shr    $0x3,%cl
		enum specifier_cat_enum specifier_cat
  1022ff:	83 e0 07             	and    $0x7,%eax
			= (enum length_mod_enum)conv->length_mod;
  102302:	83 e1 0f             	and    $0xf,%ecx
		enum length_mod_enum length_mod
  102305:	0f b6 f1             	movzbl %cl,%esi
		/* Extract the value based on the argument category and length.
		 *
		 * Note that the length modifier doesn't affect the value of a
		 * pointer argument.
		 */
		if (specifier_cat == SPECIFIER_SINT) {
  102308:	83 f8 01             	cmp    $0x1,%eax
  10230b:	0f 85 d4 00 00 00    	jne    1023e5 <cbvprintf+0x4da>
			switch (length_mod) {
			default:
			case LENGTH_NONE:
			case LENGTH_HH:
			case LENGTH_H:
				value->sint = va_arg(ap, int);
  102311:	41 8b 04 24          	mov    (%r12),%eax
			switch (length_mod) {
  102315:	80 f9 05             	cmp    $0x5,%cl
  102318:	0f 84 1a 01 00 00    	je     102438 <cbvprintf+0x52d>
  10231e:	77 10                	ja     102330 <cbvprintf+0x425>
  102320:	80 f9 03             	cmp    $0x3,%cl
  102323:	74 3f                	je     102364 <cbvprintf+0x459>
  102325:	80 f9 04             	cmp    $0x4,%cl
  102328:	0f 84 0a 01 00 00    	je     102438 <cbvprintf+0x52d>
  10232e:	eb 0c                	jmp    10233c <cbvprintf+0x431>
  102330:	8d 79 0a             	lea    0xa(%rcx),%edi
  102333:	83 e7 0f             	and    $0xf,%edi
  102336:	40 80 ff 01          	cmp    $0x1,%dil
  10233a:	76 5d                	jbe    102399 <cbvprintf+0x48e>
				value->sint = va_arg(ap, int);
  10233c:	83 f8 2f             	cmp    $0x2f,%eax
  10233f:	77 10                	ja     102351 <cbvprintf+0x446>
  102341:	89 c7                	mov    %eax,%edi
  102343:	83 c0 08             	add    $0x8,%eax
  102346:	49 03 7c 24 10       	add    0x10(%r12),%rdi
  10234b:	41 89 04 24          	mov    %eax,(%r12)
  10234f:	eb 0e                	jmp    10235f <cbvprintf+0x454>
  102351:	49 8b 7c 24 08       	mov    0x8(%r12),%rdi
  102356:	48 8d 47 08          	lea    0x8(%rdi),%rax
  10235a:	49 89 44 24 08       	mov    %rax,0x8(%r12)
  10235f:	48 63 07             	movslq (%rdi),%rax
  102362:	eb 5b                	jmp    1023bf <cbvprintf+0x4b4>
				break;
			case LENGTH_L:
				if (WCHAR_IS_SIGNED
  102364:	80 7d c3 63          	cmpb   $0x63,-0x3d(%rbp)
  102368:	0f 85 ca 00 00 00    	jne    102438 <cbvprintf+0x52d>
				    && (conv->specifier == 'c')) {
					value->sint = (wchar_t)va_arg(ap,
  10236e:	83 f8 2f             	cmp    $0x2f,%eax
  102371:	77 10                	ja     102383 <cbvprintf+0x478>
  102373:	89 c6                	mov    %eax,%esi
  102375:	83 c0 08             	add    $0x8,%eax
  102378:	49 03 74 24 10       	add    0x10(%r12),%rsi
  10237d:	41 89 04 24          	mov    %eax,(%r12)
  102381:	eb 0e                	jmp    102391 <cbvprintf+0x486>
  102383:	49 8b 74 24 08       	mov    0x8(%r12),%rsi
  102388:	48 8d 46 08          	lea    0x8(%rsi),%rax
  10238c:	49 89 44 24 08       	mov    %rax,0x8(%r12)
  102391:	48 63 06             	movslq (%rsi),%rax
  102394:	e9 a9 01 00 00       	jmpq   102542 <cbvprintf+0x637>
				 * unsigned and signed equivalents of each
				 * other.  This can be checked in a platform
				 * test.
				 */
				value->sint =
					(sint_value_type)va_arg(ap, ptrdiff_t);
  102399:	83 f8 2f             	cmp    $0x2f,%eax
  10239c:	77 10                	ja     1023ae <cbvprintf+0x4a3>
  10239e:	89 c7                	mov    %eax,%edi
  1023a0:	83 c0 08             	add    $0x8,%eax
  1023a3:	49 03 7c 24 10       	add    0x10(%r12),%rdi
  1023a8:	41 89 04 24          	mov    %eax,(%r12)
  1023ac:	eb 0e                	jmp    1023bc <cbvprintf+0x4b1>
  1023ae:	49 8b 7c 24 08       	mov    0x8(%r12),%rdi
  1023b3:	48 8d 47 08          	lea    0x8(%rdi),%rax
  1023b7:	49 89 44 24 08       	mov    %rax,0x8(%r12)
  1023bc:	48 8b 07             	mov    (%rdi),%rax
				value->sint =
  1023bf:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
				break;
			}
			if (length_mod == LENGTH_HH) {
  1023c3:	83 fe 01             	cmp    $0x1,%esi
  1023c6:	75 0a                	jne    1023d2 <cbvprintf+0x4c7>
				value->sint = (char)value->sint;
  1023c8:	48 0f be 45 b0       	movsbq -0x50(%rbp),%rax
  1023cd:	e9 70 01 00 00       	jmpq   102542 <cbvprintf+0x637>
			} else if (length_mod == LENGTH_H) {
  1023d2:	83 fe 02             	cmp    $0x2,%esi
  1023d5:	0f 85 6b 01 00 00    	jne    102546 <cbvprintf+0x63b>
				value->sint = (short)value->sint;
  1023db:	48 0f bf 45 b0       	movswq -0x50(%rbp),%rax
  1023e0:	e9 5d 01 00 00       	jmpq   102542 <cbvprintf+0x637>
			}
		} else if (specifier_cat == SPECIFIER_UINT) {
  1023e5:	83 f8 02             	cmp    $0x2,%eax
  1023e8:	0f 85 c7 00 00 00    	jne    1024b5 <cbvprintf+0x5aa>
				value->sint = va_arg(ap, int);
  1023ee:	41 8b 04 24          	mov    (%r12),%eax
			switch (length_mod) {
  1023f2:	80 f9 05             	cmp    $0x5,%cl
  1023f5:	74 41                	je     102438 <cbvprintf+0x52d>
  1023f7:	77 0c                	ja     102405 <cbvprintf+0x4fa>
  1023f9:	80 f9 03             	cmp    $0x3,%cl
  1023fc:	74 3a                	je     102438 <cbvprintf+0x52d>
  1023fe:	80 f9 04             	cmp    $0x4,%cl
  102401:	74 35                	je     102438 <cbvprintf+0x52d>
  102403:	eb 0c                	jmp    102411 <cbvprintf+0x506>
  102405:	8d 79 0a             	lea    0xa(%rcx),%edi
  102408:	83 e7 0f             	and    $0xf,%edi
  10240b:	40 80 ff 01          	cmp    $0x1,%dil
  10240f:	76 52                	jbe    102463 <cbvprintf+0x558>
			default:
			case LENGTH_NONE:
			case LENGTH_HH:
			case LENGTH_H:
				value->uint = va_arg(ap, unsigned int);
  102411:	83 f8 2f             	cmp    $0x2f,%eax
  102414:	77 10                	ja     102426 <cbvprintf+0x51b>
  102416:	89 c7                	mov    %eax,%edi
  102418:	83 c0 08             	add    $0x8,%eax
  10241b:	49 03 7c 24 10       	add    0x10(%r12),%rdi
  102420:	41 89 04 24          	mov    %eax,(%r12)
  102424:	eb 0e                	jmp    102434 <cbvprintf+0x529>
  102426:	49 8b 7c 24 08       	mov    0x8(%r12),%rdi
  10242b:	48 8d 47 08          	lea    0x8(%rdi),%rax
  10242f:	49 89 44 24 08       	mov    %rax,0x8(%r12)
  102434:	8b 07                	mov    (%rdi),%eax
  102436:	eb 51                	jmp    102489 <cbvprintf+0x57e>
					(uint_value_type)va_arg(ap,
						unsigned long long);
				break;
			case LENGTH_J:
				value->uint =
					(uint_value_type)va_arg(ap,
  102438:	83 f8 2f             	cmp    $0x2f,%eax
  10243b:	77 10                	ja     10244d <cbvprintf+0x542>
  10243d:	89 c6                	mov    %eax,%esi
  10243f:	83 c0 08             	add    $0x8,%eax
  102442:	49 03 74 24 10       	add    0x10(%r12),%rsi
  102447:	41 89 04 24          	mov    %eax,(%r12)
  10244b:	eb 0e                	jmp    10245b <cbvprintf+0x550>
  10244d:	49 8b 74 24 08       	mov    0x8(%r12),%rsi
  102452:	48 8d 46 08          	lea    0x8(%rsi),%rax
  102456:	49 89 44 24 08       	mov    %rax,0x8(%r12)
  10245b:	48 8b 06             	mov    (%rsi),%rax
  10245e:	e9 df 00 00 00       	jmpq   102542 <cbvprintf+0x637>
								uintmax_t);
				break;
			case LENGTH_Z:		/* size_t */
			case LENGTH_T:		/* ptrdiff_t */
				value->uint =
					(uint_value_type)va_arg(ap, size_t);
  102463:	83 f8 2f             	cmp    $0x2f,%eax
  102466:	77 10                	ja     102478 <cbvprintf+0x56d>
  102468:	89 c7                	mov    %eax,%edi
  10246a:	83 c0 08             	add    $0x8,%eax
  10246d:	49 03 7c 24 10       	add    0x10(%r12),%rdi
  102472:	41 89 04 24          	mov    %eax,(%r12)
  102476:	eb 0e                	jmp    102486 <cbvprintf+0x57b>
  102478:	49 8b 7c 24 08       	mov    0x8(%r12),%rdi
  10247d:	48 8d 47 08          	lea    0x8(%rdi),%rax
  102481:	49 89 44 24 08       	mov    %rax,0x8(%r12)
  102486:	48 8b 07             	mov    (%rdi),%rax
				value->uint =
  102489:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
				break;
			}
			if (length_mod == LENGTH_HH) {
  10248d:	83 fe 01             	cmp    $0x1,%esi
  102490:	75 0d                	jne    10249f <cbvprintf+0x594>
				value->uint = (unsigned char)value->uint;
  102492:	48 81 65 b0 ff 00 00 	andq   $0xff,-0x50(%rbp)
  102499:	00 
  10249a:	e9 a7 00 00 00       	jmpq   102546 <cbvprintf+0x63b>
			} else if (length_mod == LENGTH_H) {
  10249f:	83 fe 02             	cmp    $0x2,%esi
  1024a2:	0f 85 9e 00 00 00    	jne    102546 <cbvprintf+0x63b>
				value->uint = (unsigned short)value->uint;
  1024a8:	48 81 65 b0 ff ff 00 	andq   $0xffff,-0x50(%rbp)
  1024af:	00 
  1024b0:	e9 91 00 00 00       	jmpq   102546 <cbvprintf+0x63b>
			}
		} else if (specifier_cat == SPECIFIER_FP) {
  1024b5:	83 f8 04             	cmp    $0x4,%eax
  1024b8:	75 59                	jne    102513 <cbvprintf+0x608>
			if (length_mod == LENGTH_UPPER_L) {
  1024ba:	83 fe 08             	cmp    $0x8,%esi
  1024bd:	75 1d                	jne    1024dc <cbvprintf+0x5d1>
				value->ldbl = va_arg(ap, long double);
  1024bf:	49 8b 44 24 08       	mov    0x8(%r12),%rax
  1024c4:	48 83 c0 0f          	add    $0xf,%rax
  1024c8:	48 83 e0 f0          	and    $0xfffffffffffffff0,%rax
  1024cc:	48 8d 70 10          	lea    0x10(%rax),%rsi
  1024d0:	49 89 74 24 08       	mov    %rsi,0x8(%r12)
  1024d5:	db 28                	fldt   (%rax)
  1024d7:	db 7d b0             	fstpt  -0x50(%rbp)
  1024da:	eb 6a                	jmp    102546 <cbvprintf+0x63b>
			} else {
				value->dbl = va_arg(ap, double);
  1024dc:	41 8b 74 24 04       	mov    0x4(%r12),%esi
  1024e1:	81 fe af 00 00 00    	cmp    $0xaf,%esi
  1024e7:	77 11                	ja     1024fa <cbvprintf+0x5ef>
  1024e9:	89 f0                	mov    %esi,%eax
  1024eb:	83 c6 10             	add    $0x10,%esi
  1024ee:	49 03 44 24 10       	add    0x10(%r12),%rax
  1024f3:	41 89 74 24 04       	mov    %esi,0x4(%r12)
  1024f8:	eb 0e                	jmp    102508 <cbvprintf+0x5fd>
  1024fa:	49 8b 44 24 08       	mov    0x8(%r12),%rax
  1024ff:	48 8d 70 08          	lea    0x8(%rax),%rsi
  102503:	49 89 74 24 08       	mov    %rsi,0x8(%r12)
  102508:	f2 0f 10 00          	movsd  (%rax),%xmm0
  10250c:	f2 0f 11 45 b0       	movsd  %xmm0,-0x50(%rbp)
  102511:	eb 33                	jmp    102546 <cbvprintf+0x63b>
			}
		} else if (specifier_cat == SPECIFIER_PTR) {
  102513:	83 f8 03             	cmp    $0x3,%eax
  102516:	75 2e                	jne    102546 <cbvprintf+0x63b>
			value->ptr = va_arg(ap, void *);
  102518:	41 8b 34 24          	mov    (%r12),%esi
  10251c:	83 fe 2f             	cmp    $0x2f,%esi
  10251f:	77 10                	ja     102531 <cbvprintf+0x626>
  102521:	89 f0                	mov    %esi,%eax
  102523:	83 c6 08             	add    $0x8,%esi
  102526:	49 03 44 24 10       	add    0x10(%r12),%rax
  10252b:	41 89 34 24          	mov    %esi,(%r12)
  10252f:	eb 0e                	jmp    10253f <cbvprintf+0x634>
  102531:	49 8b 44 24 08       	mov    0x8(%r12),%rax
  102536:	48 8d 70 08          	lea    0x8(%rax),%rsi
  10253a:	49 89 74 24 08       	mov    %rsi,0x8(%r12)
  10253f:	48 8b 00             	mov    (%rax),%rax
  102542:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
		/* We've now consumed all arguments related to this
		 * specification.  If the conversion is invalid, or is
		 * something we don't support, then output the original
		 * specification and move on.
		 */
		if (conv->invalid || conv->unsupported) {
  102546:	40 8a 7d c0          	mov    -0x40(%rbp),%dil
  10254a:	40 f6 c7 03          	test   $0x3,%dil
  10254e:	74 21                	je     102571 <cbvprintf+0x666>
			OUTS(sp, fp);
  102550:	48 8b 4d 80          	mov    -0x80(%rbp),%rcx
  102554:	4c 89 fe             	mov    %r15,%rsi
  102557:	4c 89 f7             	mov    %r14,%rdi
  10255a:	e8 52 f9 ff ff       	callq  101eb1 <outs>
  10255f:	85 c0                	test   %eax,%eax
  102561:	0f 88 3e 03 00 00    	js     1028a5 <cbvprintf+0x99a>
  102567:	48 98                	cltq   
  102569:	48 01 c3             	add    %rax,%rbx
			continue;
  10256c:	e9 29 03 00 00       	jmpq   10289a <cbvprintf+0x98f>
		}

		/* Do formatting, either into the buffer or
		 * referencing external data.
		 */
		switch (conv->specifier) {
  102571:	8a 45 c3             	mov    -0x3d(%rbp),%al
  102574:	3c 78                	cmp    $0x78,%al
  102576:	0f 87 1e 03 00 00    	ja     10289a <cbvprintf+0x98f>
  10257c:	3c 62                	cmp    $0x62,%al
  10257e:	77 11                	ja     102591 <cbvprintf+0x686>
  102580:	3c 25                	cmp    $0x25,%al
  102582:	74 22                	je     1025a6 <cbvprintf+0x69b>
  102584:	3c 58                	cmp    $0x58,%al
  102586:	0f 84 a8 00 00 00    	je     102634 <cbvprintf+0x729>
  10258c:	e9 09 03 00 00       	jmpq   10289a <cbvprintf+0x98f>
  102591:	83 e8 63             	sub    $0x63,%eax
  102594:	3c 15                	cmp    $0x15,%al
  102596:	0f 87 fe 02 00 00    	ja     10289a <cbvprintf+0x98f>
  10259c:	0f b6 c0             	movzbl %al,%eax
  10259f:	ff 24 c5 68 c9 11 00 	jmpq   *0x11c968(,%rax,8)
		case '%':
			OUTC('%');
  1025a6:	4c 89 fe             	mov    %r15,%rsi
  1025a9:	bf 25 00 00 00       	mov    $0x25,%edi
  1025ae:	31 c0                	xor    %eax,%eax
  1025b0:	41 ff d6             	callq  *%r14
  1025b3:	85 c0                	test   %eax,%eax
  1025b5:	0f 88 ea 02 00 00    	js     1028a5 <cbvprintf+0x99a>
  1025bb:	48 ff c3             	inc    %rbx
			break;
  1025be:	e9 d7 02 00 00       	jmpq   10289a <cbvprintf+0x98f>
		case 's': {
			bps = (const char *)value->ptr;
  1025c3:	4c 8b 6d b0          	mov    -0x50(%rbp),%r13

			size_t len;

			if (precision >= 0) {
  1025c7:	45 85 d2             	test   %r10d,%r10d
  1025ca:	78 0d                	js     1025d9 <cbvprintf+0x6ce>
				len = strnlen(bps, precision);
  1025cc:	49 63 f2             	movslq %r10d,%rsi
  1025cf:	4c 89 ef             	mov    %r13,%rdi
  1025d2:	e8 13 7a 00 00       	callq  109fea <strnlen>
  1025d7:	eb 08                	jmp    1025e1 <cbvprintf+0x6d6>
			} else {
				len = strlen(bps);
  1025d9:	4c 89 ef             	mov    %r13,%rdi
  1025dc:	e8 fb 79 00 00       	callq  109fdc <strlen>
			}

			bpe = bps + len;
  1025e1:	4c 01 e8             	add    %r13,%rax
		char sign = 0;
  1025e4:	45 31 c9             	xor    %r9d,%r9d
			bpe = bps + len;
  1025e7:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
			precision = -1;

			break;
  1025ee:	e9 0f 01 00 00       	jmpq   102702 <cbvprintf+0x7f7>
		}
		case 'c':
			bps = buf;
			buf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;
  1025f3:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
			bps = buf;
  1025f7:	4c 8d 6d 9a          	lea    -0x66(%rbp),%r13
			buf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;
  1025fb:	88 45 9a             	mov    %al,-0x66(%rbp)
			bpe = buf + 1;
  1025fe:	48 8d 45 9b          	lea    -0x65(%rbp),%rax
  102602:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
  102609:	e9 0f 01 00 00       	jmpq   10271d <cbvprintf+0x812>
			break;
		case 'd':
		case 'i':
			if (conv->flag_plus) {
				sign = '+';
  10260e:	41 b1 2b             	mov    $0x2b,%r9b
			if (conv->flag_plus) {
  102611:	40 f6 c7 08          	test   $0x8,%dil
  102615:	75 08                	jne    10261f <cbvprintf+0x714>
			} else if (conv->flag_space) {
				sign = ' ';
  102617:	44 8d 0c 3f          	lea    (%rdi,%rdi,1),%r9d
  10261b:	41 83 e1 20          	and    $0x20,%r9d

			/* sint/uint overlay in the union, and so
			 * can't appear in read and write operations
			 * in the same statement.
			 */
			sint = value->sint;
  10261f:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
			if (sint < 0) {
  102623:	48 85 c0             	test   %rax,%rax
  102626:	79 0f                	jns    102637 <cbvprintf+0x72c>
				sign = '-';
				value->uint = (uint_value_type)-sint;
  102628:	48 f7 d8             	neg    %rax
				sign = '-';
  10262b:	41 b1 2d             	mov    $0x2d,%r9b
				value->uint = (uint_value_type)-sint;
  10262e:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
  102632:	eb 03                	jmp    102637 <cbvprintf+0x72c>
		switch (conv->specifier) {
  102634:	45 31 c9             	xor    %r9d,%r9d
			__fallthrough;
		case 'o':
		case 'u':
		case 'x':
		case 'X':
			bps = encode_uint(value->uint, conv, buf, bpe);
  102637:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
  10263b:	48 8d 4d b0          	lea    -0x50(%rbp),%rcx
  10263f:	48 8d 55 9a          	lea    -0x66(%rbp),%rdx
  102643:	44 88 4d 88          	mov    %r9b,-0x78(%rbp)
  102647:	48 8d 75 c0          	lea    -0x40(%rbp),%rsi
  10264b:	44 89 95 78 ff ff ff 	mov    %r10d,-0x88(%rbp)
  102652:	e8 d0 f7 ff ff       	callq  101e27 <encode_uint>
  102657:	44 8a 4d 88          	mov    -0x78(%rbp),%r9b
  10265b:	49 89 c5             	mov    %rax,%r13
  10265e:	44 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%r10d
		const char *bpe = buf + sizeof(buf);
  102665:	48 8d 45 b0          	lea    -0x50(%rbp),%rax
  102669:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
			/* Update pad0 values based on precision and converted
			 * length.  Note that a non-empty sign is not in the
			 * converted sequence, but it does not affect the
			 * padding size.
			 */
			if (precision >= 0) {
  102670:	45 85 d2             	test   %r10d,%r10d
  102673:	0f 88 89 00 00 00    	js     102702 <cbvprintf+0x7f7>
				size_t len = bpe - bps;
  102679:	4c 29 e8             	sub    %r13,%rax
				 * conversions with precision.
				 */
				conv->flag_zero = false;

				/* Set pad0_value to satisfy precision */
				if (len < (size_t)precision) {
  10267c:	49 63 d2             	movslq %r10d,%rdx
				conv->flag_zero = false;
  10267f:	80 65 c0 bf          	andb   $0xbf,-0x40(%rbp)
				if (len < (size_t)precision) {
  102683:	48 39 c2             	cmp    %rax,%rdx
  102686:	76 7a                	jbe    102702 <cbvprintf+0x7f7>
					conv->pad0_value = precision - (int)len;
  102688:	41 29 c2             	sub    %eax,%r10d
  10268b:	44 89 55 c4          	mov    %r10d,-0x3c(%rbp)
  10268f:	eb 71                	jmp    102702 <cbvprintf+0x7f7>
		case 'p':
			/* Implementation-defined: null is "(nil)", non-null
			 * has 0x prefix followed by significant address hex
			 * digits, no leading zeros.
			 */
			if (value->ptr != NULL) {
  102691:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
  102695:	48 85 ff             	test   %rdi,%rdi
  102698:	74 72                	je     10270c <cbvprintf+0x801>
				bps = encode_uint((uintptr_t)value->ptr, conv,
  10269a:	48 8d 4d b0          	lea    -0x50(%rbp),%rcx
  10269e:	48 8d 55 9a          	lea    -0x66(%rbp),%rdx
  1026a2:	44 89 95 78 ff ff ff 	mov    %r10d,-0x88(%rbp)
  1026a9:	48 8d 75 c0          	lea    -0x40(%rbp),%rsi
  1026ad:	e8 75 f7 ff ff       	callq  101e27 <encode_uint>
		char sign = 0;
  1026b2:	45 31 c9             	xor    %r9d,%r9d
				bps = encode_uint((uintptr_t)value->ptr, conv,
  1026b5:	49 89 c5             	mov    %rax,%r13
						  buf, bpe);

				/* Use 0x prefix */
				conv->altform_0c = true;
  1026b8:	66 8b 45 c2          	mov    -0x3e(%rbp),%ax
  1026bc:	66 25 ef 00          	and    $0xef,%ax
  1026c0:	66 0d 10 78          	or     $0x7810,%ax
  1026c4:	66 89 45 c2          	mov    %ax,-0x3e(%rbp)
				conv->specifier = 'x';

				goto prec_int_pad0;
  1026c8:	eb 94                	jmp    10265e <cbvprintf+0x753>
			bpe = bps + 5;

			break;
		case 'n':
			if (IS_ENABLED(CONFIG_CBPRINTF_N_SPECIFIER)) {
				store_count(conv, value->ptr, count);
  1026ca:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  1026ce:	48 63 c3             	movslq %ebx,%rax
	switch ((enum length_mod_enum)conv->length_mod) {
  1026d1:	80 f9 07             	cmp    $0x7,%cl
  1026d4:	0f 87 c0 01 00 00    	ja     10289a <cbvprintf+0x98f>
  1026da:	0f b6 c9             	movzbl %cl,%ecx
  1026dd:	ff 24 cd 18 ca 11 00 	jmpq   *0x11ca18(,%rcx,8)
		*(int *)dp = count;
  1026e4:	89 02                	mov    %eax,(%rdx)
		break;
  1026e6:	e9 af 01 00 00       	jmpq   10289a <cbvprintf+0x98f>
		*(signed char *)dp = (signed char)count;
  1026eb:	88 1a                	mov    %bl,(%rdx)
		break;
  1026ed:	e9 a8 01 00 00       	jmpq   10289a <cbvprintf+0x98f>
		*(short *)dp = (short)count;
  1026f2:	66 89 1a             	mov    %bx,(%rdx)
		break;
  1026f5:	e9 a0 01 00 00       	jmpq   10289a <cbvprintf+0x98f>
		*(ptrdiff_t *)dp = (ptrdiff_t)count;
  1026fa:	48 89 02             	mov    %rax,(%rdx)
		break;
  1026fd:	e9 98 01 00 00       	jmpq   10289a <cbvprintf+0x98f>
		}

		/* If we don't have a converted value to emit, move
		 * on.
		 */
		if (bps == NULL) {
  102702:	4d 85 ed             	test   %r13,%r13
  102705:	75 19                	jne    102720 <cbvprintf+0x815>
  102707:	e9 8e 01 00 00       	jmpq   10289a <cbvprintf+0x98f>
			bpe = bps + 5;
  10270c:	48 c7 85 78 ff ff ff 	movq   $0x11d272,-0x88(%rbp)
  102713:	72 d2 11 00 
			bps = "(nil)";
  102717:	41 bd 6d d2 11 00    	mov    $0x11d26d,%r13d
  10271d:	45 31 c9             	xor    %r9d,%r9d
		 *   * any exponent content from the converted value
		 * * for non-FP:
		 *   * any pad0_prefix
		 *   * the converted value
		 */
		size_t nj_len = (bpe - bps);
  102720:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax

		if (sign != 0) {
			nj_len += 1U;
		}

		if (conv->altform_0c) {
  102727:	8a 4d c2             	mov    -0x3e(%rbp),%cl
		size_t nj_len = (bpe - bps);
  10272a:	4c 29 e8             	sub    %r13,%rax
			nj_len += 1U;
  10272d:	41 80 f9 01          	cmp    $0x1,%r9b
  102731:	48 83 d8 ff          	sbb    $0xffffffffffffffff,%rax
		if (conv->altform_0c) {
  102735:	f6 c1 10             	test   $0x10,%cl
  102738:	74 06                	je     102740 <cbvprintf+0x835>
			nj_len += 2U;
  10273a:	48 83 c0 02          	add    $0x2,%rax
  10273e:	eb 0c                	jmp    10274c <cbvprintf+0x841>
		} else if (conv->altform_0) {
  102740:	89 ca                	mov    %ecx,%edx
  102742:	83 e2 08             	and    $0x8,%edx
			nj_len += 1U;
  102745:	80 fa 01             	cmp    $0x1,%dl
  102748:	48 83 d8 ff          	sbb    $0xffffffffffffffff,%rax
		}

		nj_len += conv->pad0_value;
  10274c:	48 63 55 c4          	movslq -0x3c(%rbp),%rdx
  102750:	48 01 d0             	add    %rdx,%rax
		if (conv->pad_fp) {
  102753:	80 e1 40             	and    $0x40,%cl
  102756:	74 07                	je     10275f <cbvprintf+0x854>
			nj_len += conv->pad0_pre_exp;
  102758:	48 63 55 c8          	movslq -0x38(%rbp),%rdx
  10275c:	48 01 d0             	add    %rdx,%rax
		 * result in no padding.
		 *
		 * If a non-negative padding width is present and we're doing
		 * right-justification, emit the padding now.
		 */
		if (width > 0) {
  10275f:	83 7d 8c 00          	cmpl   $0x0,-0x74(%rbp)
  102763:	7e 72                	jle    1027d7 <cbvprintf+0x8cc>
			width -= (int)nj_len;
  102765:	29 45 8c             	sub    %eax,-0x74(%rbp)

			if (!conv->flag_dash) {
  102768:	8a 45 c0             	mov    -0x40(%rbp),%al
  10276b:	a8 04                	test   $0x4,%al
  10276d:	75 68                	jne    1027d7 <cbvprintf+0x8cc>
				char pad = ' ';

				/* If we're zero-padding we have to emit the
				 * sign first.
				 */
				if (conv->flag_zero) {
  10276f:	a8 40                	test   $0x40,%al
  102771:	74 23                	je     102796 <cbvprintf+0x88b>
					if (sign != 0) {
  102773:	45 84 c9             	test   %r9b,%r9b
  102776:	74 22                	je     10279a <cbvprintf+0x88f>
						OUTC(sign);
  102778:	31 c0                	xor    %eax,%eax
  10277a:	41 0f be f9          	movsbl %r9b,%edi
  10277e:	4c 89 fe             	mov    %r15,%rsi
  102781:	41 ff d6             	callq  *%r14
  102784:	85 c0                	test   %eax,%eax
  102786:	0f 88 19 01 00 00    	js     1028a5 <cbvprintf+0x99a>
  10278c:	48 ff c3             	inc    %rbx
						sign = 0;
					}
					pad = '0';
  10278f:	b0 30                	mov    $0x30,%al
						sign = 0;
  102791:	45 31 c9             	xor    %r9d,%r9d
  102794:	eb 06                	jmp    10279c <cbvprintf+0x891>
				char pad = ' ';
  102796:	b0 20                	mov    $0x20,%al
  102798:	eb 02                	jmp    10279c <cbvprintf+0x891>
					pad = '0';
  10279a:	b0 30                	mov    $0x30,%al
  10279c:	8b 4d 8c             	mov    -0x74(%rbp),%ecx
				}

				while (width-- > 0) {
					OUTC(pad);
  10279f:	0f be d0             	movsbl %al,%edx
				while (width-- > 0) {
  1027a2:	ff 4d 8c             	decl   -0x74(%rbp)
  1027a5:	85 c9                	test   %ecx,%ecx
  1027a7:	7e 2e                	jle    1027d7 <cbvprintf+0x8cc>
					OUTC(pad);
  1027a9:	31 c0                	xor    %eax,%eax
  1027ab:	44 88 8d 77 ff ff ff 	mov    %r9b,-0x89(%rbp)
  1027b2:	4c 89 fe             	mov    %r15,%rsi
  1027b5:	89 d7                	mov    %edx,%edi
  1027b7:	89 55 88             	mov    %edx,-0x78(%rbp)
  1027ba:	41 ff d6             	callq  *%r14
  1027bd:	85 c0                	test   %eax,%eax
  1027bf:	0f 88 e0 00 00 00    	js     1028a5 <cbvprintf+0x99a>
				while (width-- > 0) {
  1027c5:	8b 4d 8c             	mov    -0x74(%rbp),%ecx
  1027c8:	8b 55 88             	mov    -0x78(%rbp),%edx
					OUTC(pad);
  1027cb:	48 ff c3             	inc    %rbx
  1027ce:	44 8a 8d 77 ff ff ff 	mov    -0x89(%rbp),%r9b
  1027d5:	eb cb                	jmp    1027a2 <cbvprintf+0x897>
		}

		/* If we have a sign that hasn't been emitted, now's the
		 * time....
		 */
		if (sign != 0) {
  1027d7:	45 84 c9             	test   %r9b,%r9b
  1027da:	74 17                	je     1027f3 <cbvprintf+0x8e8>
			OUTC(sign);
  1027dc:	31 c0                	xor    %eax,%eax
  1027de:	41 0f be f9          	movsbl %r9b,%edi
  1027e2:	4c 89 fe             	mov    %r15,%rsi
  1027e5:	41 ff d6             	callq  *%r14
  1027e8:	85 c0                	test   %eax,%eax
  1027ea:	0f 88 b5 00 00 00    	js     1028a5 <cbvprintf+0x99a>
  1027f0:	48 ff c3             	inc    %rbx
				OUTC('0');
			}

			OUTS(cp, bpe);
		} else {
			if (conv->altform_0c | conv->altform_0) {
  1027f3:	8a 45 c2             	mov    -0x3e(%rbp),%al
  1027f6:	a8 10                	test   $0x10,%al
  1027f8:	75 04                	jne    1027fe <cbvprintf+0x8f3>
  1027fa:	a8 08                	test   $0x8,%al
  1027fc:	74 18                	je     102816 <cbvprintf+0x90b>
				OUTC('0');
  1027fe:	31 c0                	xor    %eax,%eax
  102800:	4c 89 fe             	mov    %r15,%rsi
  102803:	bf 30 00 00 00       	mov    $0x30,%edi
  102808:	41 ff d6             	callq  *%r14
  10280b:	85 c0                	test   %eax,%eax
  10280d:	0f 88 92 00 00 00    	js     1028a5 <cbvprintf+0x99a>
  102813:	48 ff c3             	inc    %rbx
			}

			if (conv->altform_0c) {
  102816:	f6 45 c2 10          	testb  $0x10,-0x3e(%rbp)
  10281a:	74 13                	je     10282f <cbvprintf+0x924>
				OUTC(conv->specifier);
  10281c:	31 c0                	xor    %eax,%eax
  10281e:	0f b6 7d c3          	movzbl -0x3d(%rbp),%edi
  102822:	4c 89 fe             	mov    %r15,%rsi
  102825:	41 ff d6             	callq  *%r14
  102828:	85 c0                	test   %eax,%eax
  10282a:	78 79                	js     1028a5 <cbvprintf+0x99a>
  10282c:	48 ff c3             	inc    %rbx
			}

			pad_len = conv->pad0_value;
			while (pad_len-- > 0) {
  10282f:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  102832:	01 d8                	add    %ebx,%eax
  102834:	89 45 88             	mov    %eax,-0x78(%rbp)
  102837:	8b 45 88             	mov    -0x78(%rbp),%eax
  10283a:	29 d8                	sub    %ebx,%eax
  10283c:	85 c0                	test   %eax,%eax
  10283e:	7e 16                	jle    102856 <cbvprintf+0x94b>
				OUTC('0');
  102840:	31 c0                	xor    %eax,%eax
  102842:	4c 89 fe             	mov    %r15,%rsi
  102845:	bf 30 00 00 00       	mov    $0x30,%edi
  10284a:	41 ff d6             	callq  *%r14
  10284d:	85 c0                	test   %eax,%eax
  10284f:	78 54                	js     1028a5 <cbvprintf+0x99a>
  102851:	48 ff c3             	inc    %rbx
  102854:	eb e1                	jmp    102837 <cbvprintf+0x92c>
			}

			OUTS(bps, bpe);
  102856:	48 8b 8d 78 ff ff ff 	mov    -0x88(%rbp),%rcx
  10285d:	4c 89 ea             	mov    %r13,%rdx
  102860:	4c 89 fe             	mov    %r15,%rsi
  102863:	4c 89 f7             	mov    %r14,%rdi
  102866:	e8 46 f6 ff ff       	callq  101eb1 <outs>
  10286b:	85 c0                	test   %eax,%eax
  10286d:	78 36                	js     1028a5 <cbvprintf+0x99a>
  10286f:	44 8b 6d 8c          	mov    -0x74(%rbp),%r13d
  102873:	48 98                	cltq   
  102875:	48 01 c3             	add    %rax,%rbx
  102878:	41 01 dd             	add    %ebx,%r13d
		}

		/* Finish left justification */
		while (width > 0) {
  10287b:	44 89 e8             	mov    %r13d,%eax
  10287e:	29 d8                	sub    %ebx,%eax
  102880:	85 c0                	test   %eax,%eax
  102882:	7e 16                	jle    10289a <cbvprintf+0x98f>
			OUTC(' ');
  102884:	31 c0                	xor    %eax,%eax
  102886:	4c 89 fe             	mov    %r15,%rsi
  102889:	bf 20 00 00 00       	mov    $0x20,%edi
  10288e:	41 ff d6             	callq  *%r14
  102891:	85 c0                	test   %eax,%eax
  102893:	78 10                	js     1028a5 <cbvprintf+0x99a>
  102895:	48 ff c3             	inc    %rbx
			--width;
  102898:	eb e1                	jmp    10287b <cbvprintf+0x970>
			OUTS(bps, bpe);
  10289a:	48 8b 55 80          	mov    -0x80(%rbp),%rdx
  10289e:	e9 84 f6 ff ff       	jmpq   101f27 <cbvprintf+0x1c>
		}
	}

	return count;
  1028a3:	89 d8                	mov    %ebx,%eax
#undef OUTS
#undef OUTC
}
  1028a5:	48 83 c4 68          	add    $0x68,%rsp
  1028a9:	5b                   	pop    %rbx
  1028aa:	41 5c                	pop    %r12
  1028ac:	41 5d                	pop    %r13
  1028ae:	41 5e                	pop    %r14
  1028b0:	41 5f                	pop    %r15
  1028b2:	5d                   	pop    %rbp
  1028b3:	c3                   	retq   

00000000001028b4 <ring_buf_get_rewind_threshold>:
 * rewinding earlier.
 */
uint32_t __weak ring_buf_get_rewind_threshold(void)
{
	return RING_BUFFER_MAX_SIZE;
}
  1028b4:	b8 00 00 00 80       	mov    $0x80000000,%eax
  1028b9:	c3                   	retq   

00000000001028ba <ring_buf_is_empty>:
{
	return buf_size * (threshold / buf_size);
}

int ring_buf_is_empty(struct ring_buf *buf)
{
  1028ba:	55                   	push   %rbp
  1028bb:	48 89 e5             	mov    %rsp,%rbp
  1028be:	41 55                	push   %r13
  1028c0:	41 54                	push   %r12
  1028c2:	53                   	push   %rbx
  1028c3:	51                   	push   %rcx
	uint32_t tail = buf->tail;
  1028c4:	44 8b 67 04          	mov    0x4(%rdi),%r12d
	uint32_t head = buf->head;
  1028c8:	44 8b 2f             	mov    (%rdi),%r13d

	if (tail < head) {
  1028cb:	45 39 ec             	cmp    %r13d,%r12d
  1028ce:	73 15                	jae    1028e5 <ring_buf_is_empty+0x2b>
  1028d0:	48 89 fb             	mov    %rdi,%rbx
		tail += get_rewind_value(buf->size,
  1028d3:	e8 dc ff ff ff       	callq  1028b4 <ring_buf_get_rewind_threshold>
  1028d8:	8b 4b 10             	mov    0x10(%rbx),%ecx
	return buf_size * (threshold / buf_size);
  1028db:	31 d2                	xor    %edx,%edx
  1028dd:	f7 f1                	div    %ecx
  1028df:	0f af c1             	imul   %ecx,%eax
		tail += get_rewind_value(buf->size,
  1028e2:	41 01 c4             	add    %eax,%r12d
					 ring_buf_get_rewind_threshold());
	}

	return (head == tail);
  1028e5:	31 c0                	xor    %eax,%eax
  1028e7:	45 39 ec             	cmp    %r13d,%r12d
}
  1028ea:	5a                   	pop    %rdx
  1028eb:	5b                   	pop    %rbx
	return (head == tail);
  1028ec:	0f 94 c0             	sete   %al
}
  1028ef:	41 5c                	pop    %r12
  1028f1:	41 5d                	pop    %r13
  1028f3:	5d                   	pop    %rbp
  1028f4:	c3                   	retq   

00000000001028f5 <ring_buf_put_claim>:
{
	return val >= max ? (val - max) : val;
}

uint32_t ring_buf_put_claim(struct ring_buf *buf, uint8_t **data, uint32_t size)
{
  1028f5:	41 89 d1             	mov    %edx,%r9d
  1028f8:	8b 57 20             	mov    0x20(%rdi),%edx
  1028fb:	49 89 f0             	mov    %rsi,%r8
	uint32_t space, trail_size, allocated, tmp_trail_mod;

	tmp_trail_mod = mod(buf, buf->misc.byte_mode.tmp_tail);
  1028fe:	8b 4f 08             	mov    0x8(%rdi),%ecx
	return likely(buf->mask) ? val & buf->mask : val % buf->size;
  102901:	8b 77 10             	mov    0x10(%rdi),%esi
  102904:	85 d2                	test   %edx,%edx
  102906:	74 04                	je     10290c <ring_buf_put_claim+0x17>
  102908:	21 ca                	and    %ecx,%edx
  10290a:	eb 06                	jmp    102912 <ring_buf_put_claim+0x1d>
  10290c:	89 c8                	mov    %ecx,%eax
  10290e:	31 d2                	xor    %edx,%edx
  102910:	f7 f6                	div    %esi
	space = (buf->head + buf->size) - buf->misc.byte_mode.tmp_tail;
  102912:	8b 07                	mov    (%rdi),%eax
  102914:	01 f0                	add    %esi,%eax
  102916:	29 c8                	sub    %ecx,%eax
	trail_size = buf->size - tmp_trail_mod;

	/* Limit requested size to available size. */
	size = MIN(size, space);
  102918:	44 39 c8             	cmp    %r9d,%eax
  10291b:	41 0f 47 c1          	cmova  %r9d,%eax
	trail_size = buf->size - tmp_trail_mod;
  10291f:	29 d6                	sub    %edx,%esi

	trail_size = buf->size - (tmp_trail_mod);

	/* Limit allocated size to trail size. */
	allocated = MIN(trail_size, size);
	*data = &buf->buf.buf8[tmp_trail_mod];
  102921:	89 d2                	mov    %edx,%edx
	allocated = MIN(trail_size, size);
  102923:	39 f0                	cmp    %esi,%eax
  102925:	0f 47 c6             	cmova  %esi,%eax
	*data = &buf->buf.buf8[tmp_trail_mod];
  102928:	48 03 57 18          	add    0x18(%rdi),%rdx
  10292c:	49 89 10             	mov    %rdx,(%r8)

	buf->misc.byte_mode.tmp_tail =
		buf->misc.byte_mode.tmp_tail + allocated;
  10292f:	01 c1                	add    %eax,%ecx
  102931:	89 4f 08             	mov    %ecx,0x8(%rdi)

	return allocated;
}
  102934:	c3                   	retq   

0000000000102935 <ring_buf_put_finish>:

int ring_buf_put_finish(struct ring_buf *buf, uint32_t size)
{
  102935:	55                   	push   %rbp
  102936:	48 89 e5             	mov    %rsp,%rbp
  102939:	41 54                	push   %r12
  10293b:	49 89 fc             	mov    %rdi,%r12
  10293e:	53                   	push   %rbx
  10293f:	89 f3                	mov    %esi,%ebx
	uint32_t rew;
	uint32_t threshold = ring_buf_get_rewind_threshold();
  102941:	e8 6e ff ff ff       	callq  1028b4 <ring_buf_get_rewind_threshold>

	if ((buf->tail + size) > (buf->head + buf->size)) {
  102946:	41 8b 7c 24 04       	mov    0x4(%r12),%edi
  10294b:	41 8b 4c 24 10       	mov    0x10(%r12),%ecx
  102950:	41 b8 ea ff ff ff    	mov    $0xffffffea,%r8d
  102956:	41 8b 14 24          	mov    (%r12),%edx
  10295a:	8d 34 1f             	lea    (%rdi,%rbx,1),%esi
  10295d:	01 ca                	add    %ecx,%edx
  10295f:	39 d6                	cmp    %edx,%esi
  102961:	77 1e                	ja     102981 <ring_buf_put_finish+0x4c>

	/* Check if indexes shall be rewind. */
	if (buf->tail > threshold) {
		rew = get_rewind_value(buf->size, threshold);
	} else {
		rew = 0;
  102963:	31 d2                	xor    %edx,%edx
	if (buf->tail > threshold) {
  102965:	39 c7                	cmp    %eax,%edi
  102967:	76 09                	jbe    102972 <ring_buf_put_finish+0x3d>
	return buf_size * (threshold / buf_size);
  102969:	31 d2                	xor    %edx,%edx
  10296b:	f7 f1                	div    %ecx
  10296d:	0f af c1             	imul   %ecx,%eax
  102970:	89 c2                	mov    %eax,%edx
	}

	buf->tail += (size - rew);
  102972:	29 d6                	sub    %edx,%esi
	buf->misc.byte_mode.tmp_tail = buf->tail;

	return 0;
  102974:	45 31 c0             	xor    %r8d,%r8d
	buf->tail += (size - rew);
  102977:	41 89 74 24 04       	mov    %esi,0x4(%r12)
	buf->misc.byte_mode.tmp_tail = buf->tail;
  10297c:	41 89 74 24 08       	mov    %esi,0x8(%r12)
}
  102981:	5b                   	pop    %rbx
  102982:	44 89 c0             	mov    %r8d,%eax
  102985:	41 5c                	pop    %r12
  102987:	5d                   	pop    %rbp
  102988:	c3                   	retq   

0000000000102989 <ring_buf_put>:

uint32_t ring_buf_put(struct ring_buf *buf, const uint8_t *data, uint32_t size)
{
  102989:	55                   	push   %rbp
  10298a:	48 89 e5             	mov    %rsp,%rbp
  10298d:	41 57                	push   %r15
  10298f:	49 89 ff             	mov    %rdi,%r15
  102992:	41 56                	push   %r14
	uint8_t *dst;
	uint32_t partial_size;
	uint32_t total_size = 0U;
  102994:	45 31 f6             	xor    %r14d,%r14d
{
  102997:	41 55                	push   %r13
  102999:	49 89 f5             	mov    %rsi,%r13
  10299c:	41 54                	push   %r12
  10299e:	41 89 d4             	mov    %edx,%r12d
  1029a1:	53                   	push   %rbx
  1029a2:	48 83 ec 28          	sub    $0x28,%rsp
	int err;

	do {
		partial_size = ring_buf_put_claim(buf, &dst, size);
  1029a6:	44 89 e2             	mov    %r12d,%edx
  1029a9:	48 8d 75 c8          	lea    -0x38(%rbp),%rsi
  1029ad:	4c 89 ff             	mov    %r15,%rdi
  1029b0:	e8 40 ff ff ff       	callq  1028f5 <ring_buf_put_claim>
		memcpy(dst, data, partial_size);
  1029b5:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
  1029b9:	4c 89 ee             	mov    %r13,%rsi
		partial_size = ring_buf_put_claim(buf, &dst, size);
  1029bc:	89 c2                	mov    %eax,%edx
  1029be:	48 89 d3             	mov    %rdx,%rbx
		memcpy(dst, data, partial_size);
  1029c1:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  1029c5:	e8 ce 76 00 00       	callq  10a098 <memcpy>
		total_size += partial_size;
		size -= partial_size;
		data += partial_size;
  1029ca:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
		total_size += partial_size;
  1029ce:	41 01 de             	add    %ebx,%r14d
		data += partial_size;
  1029d1:	49 01 d5             	add    %rdx,%r13
	} while (size && partial_size);
  1029d4:	41 29 dc             	sub    %ebx,%r12d
  1029d7:	74 04                	je     1029dd <ring_buf_put+0x54>
  1029d9:	85 db                	test   %ebx,%ebx
  1029db:	75 c9                	jne    1029a6 <ring_buf_put+0x1d>

	err = ring_buf_put_finish(buf, total_size);
  1029dd:	44 89 f6             	mov    %r14d,%esi
  1029e0:	4c 89 ff             	mov    %r15,%rdi
  1029e3:	e8 4d ff ff ff       	callq  102935 <ring_buf_put_finish>
	__ASSERT_NO_MSG(err == 0);
  1029e8:	85 c0                	test   %eax,%eax
  1029ea:	74 2a                	je     102a16 <ring_buf_put+0x8d>
  1029ec:	be 9b d2 11 00       	mov    $0x11d29b,%esi
  1029f1:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  1029f6:	b9 f4 00 00 00       	mov    $0xf4,%ecx
  1029fb:	31 c0                	xor    %eax,%eax
  1029fd:	ba 73 d2 11 00       	mov    $0x11d273,%edx
  102a02:	e8 f1 db ff ff       	callq  1005f8 <printk>
  102a07:	be f4 00 00 00       	mov    $0xf4,%esi
  102a0c:	bf 73 d2 11 00       	mov    $0x11d273,%edi
  102a11:	e8 82 01 00 00       	callq  102b98 <assert_post_action>

	return total_size;
}
  102a16:	48 83 c4 28          	add    $0x28,%rsp
  102a1a:	44 89 f0             	mov    %r14d,%eax
  102a1d:	5b                   	pop    %rbx
  102a1e:	41 5c                	pop    %r12
  102a20:	41 5d                	pop    %r13
  102a22:	41 5e                	pop    %r14
  102a24:	41 5f                	pop    %r15
  102a26:	5d                   	pop    %rbp
  102a27:	c3                   	retq   

0000000000102a28 <ring_buf_get_claim>:

uint32_t ring_buf_get_claim(struct ring_buf *buf, uint8_t **data, uint32_t size)
{
  102a28:	55                   	push   %rbp
  102a29:	48 89 e5             	mov    %rsp,%rbp
  102a2c:	41 56                	push   %r14
  102a2e:	41 89 d6             	mov    %edx,%r14d
  102a31:	41 55                	push   %r13
  102a33:	49 89 f5             	mov    %rsi,%r13
  102a36:	41 54                	push   %r12
	uint32_t space, granted_size, trail_size, tmp_head_mod;
	uint32_t tail = buf->tail;
  102a38:	44 8b 67 04          	mov    0x4(%rdi),%r12d
{
  102a3c:	53                   	push   %rbx
  102a3d:	48 89 fb             	mov    %rdi,%rbx

	/* Tail is always ahead, if it is not, it's only because it got rewinded. */
	if (tail < buf->misc.byte_mode.tmp_head) {
  102a40:	44 39 67 0c          	cmp    %r12d,0xc(%rdi)
  102a44:	76 12                	jbe    102a58 <ring_buf_get_claim+0x30>
		/* Locally, increment it to pre-rewind value */
		tail += get_rewind_value(buf->size,
  102a46:	e8 69 fe ff ff       	callq  1028b4 <ring_buf_get_rewind_threshold>
  102a4b:	8b 4b 10             	mov    0x10(%rbx),%ecx
	return buf_size * (threshold / buf_size);
  102a4e:	31 d2                	xor    %edx,%edx
  102a50:	f7 f1                	div    %ecx
  102a52:	0f af c1             	imul   %ecx,%eax
		tail += get_rewind_value(buf->size,
  102a55:	41 01 c4             	add    %eax,%r12d
					 ring_buf_get_rewind_threshold());
	}

	tmp_head_mod = mod(buf, buf->misc.byte_mode.tmp_head);
  102a58:	8b 53 20             	mov    0x20(%rbx),%edx
  102a5b:	8b 73 0c             	mov    0xc(%rbx),%esi
	return likely(buf->mask) ? val & buf->mask : val % buf->size;
  102a5e:	8b 4b 10             	mov    0x10(%rbx),%ecx
  102a61:	85 d2                	test   %edx,%edx
  102a63:	74 04                	je     102a69 <ring_buf_get_claim+0x41>
  102a65:	21 f2                	and    %esi,%edx
  102a67:	eb 06                	jmp    102a6f <ring_buf_get_claim+0x47>
  102a69:	89 f0                	mov    %esi,%eax
  102a6b:	31 d2                	xor    %edx,%edx
  102a6d:	f7 f1                	div    %ecx
	space = tail - buf->misc.byte_mode.tmp_head;
  102a6f:	41 29 f4             	sub    %esi,%r12d
	trail_size = buf->size - tmp_head_mod;

	/* Limit requested size to available size. */
	granted_size = MIN(size, space);
  102a72:	45 39 f4             	cmp    %r14d,%r12d
  102a75:	45 0f 47 e6          	cmova  %r14d,%r12d
	trail_size = buf->size - tmp_head_mod;
  102a79:	29 d1                	sub    %edx,%ecx

	/* Limit allocated size to trail size. */
	granted_size = MIN(trail_size, granted_size);

	*data = &buf->buf.buf8[tmp_head_mod];
  102a7b:	89 d2                	mov    %edx,%edx
	granted_size = MIN(trail_size, granted_size);
  102a7d:	44 39 e1             	cmp    %r12d,%ecx
  102a80:	44 89 e0             	mov    %r12d,%eax
  102a83:	0f 46 c1             	cmovbe %ecx,%eax
	*data = &buf->buf.buf8[tmp_head_mod];
  102a86:	48 03 53 18          	add    0x18(%rbx),%rdx
  102a8a:	49 89 55 00          	mov    %rdx,0x0(%r13)
	buf->misc.byte_mode.tmp_head += granted_size;
  102a8e:	01 c6                	add    %eax,%esi
  102a90:	89 73 0c             	mov    %esi,0xc(%rbx)

	return granted_size;
}
  102a93:	5b                   	pop    %rbx
  102a94:	41 5c                	pop    %r12
  102a96:	41 5d                	pop    %r13
  102a98:	41 5e                	pop    %r14
  102a9a:	5d                   	pop    %rbp
  102a9b:	c3                   	retq   

0000000000102a9c <ring_buf_get_finish>:

int ring_buf_get_finish(struct ring_buf *buf, uint32_t size)
{
  102a9c:	55                   	push   %rbp
  102a9d:	31 c0                	xor    %eax,%eax
  102a9f:	48 89 e5             	mov    %rsp,%rbp
  102aa2:	41 55                	push   %r13
  102aa4:	41 54                	push   %r12
  102aa6:	49 89 fc             	mov    %rdi,%r12
  102aa9:	53                   	push   %rbx
  102aaa:	89 f3                	mov    %esi,%ebx
  102aac:	51                   	push   %rcx
	uint32_t tail = buf->tail;
  102aad:	44 8b 6f 04          	mov    0x4(%rdi),%r13d
	uint32_t rew;

	/* Tail is always ahead, if it is not, it's only because it got rewinded. */
	if (tail < buf->misc.byte_mode.tmp_head) {
  102ab1:	44 39 6f 0c          	cmp    %r13d,0xc(%rdi)
  102ab5:	76 14                	jbe    102acb <ring_buf_get_finish+0x2f>
		/* tail was rewinded. Locally, increment it to pre-rewind value */
		rew = get_rewind_value(buf->size,
  102ab7:	e8 f8 fd ff ff       	callq  1028b4 <ring_buf_get_rewind_threshold>
  102abc:	41 8b 4c 24 10       	mov    0x10(%r12),%ecx
	return buf_size * (threshold / buf_size);
  102ac1:	31 d2                	xor    %edx,%edx
  102ac3:	f7 f1                	div    %ecx
  102ac5:	0f af c1             	imul   %ecx,%eax
				       ring_buf_get_rewind_threshold());
		tail += rew;
  102ac8:	41 01 c5             	add    %eax,%r13d
	} else {
		rew = 0;
	}

	if ((buf->head + size) > tail) {
  102acb:	41 03 1c 24          	add    (%r12),%ebx
		return -EINVAL;
  102acf:	41 b8 ea ff ff ff    	mov    $0xffffffea,%r8d
	if ((buf->head + size) > tail) {
  102ad5:	89 de                	mov    %ebx,%esi
  102ad7:	44 39 eb             	cmp    %r13d,%ebx
  102ada:	77 0e                	ja     102aea <ring_buf_get_finish+0x4e>
	}

	/* Include potential rewinding. */
	buf->head += (size - rew);
  102adc:	29 c6                	sub    %eax,%esi
	buf->misc.byte_mode.tmp_head = buf->head;

	return 0;
  102ade:	45 31 c0             	xor    %r8d,%r8d
	buf->head += (size - rew);
  102ae1:	41 89 34 24          	mov    %esi,(%r12)
	buf->misc.byte_mode.tmp_head = buf->head;
  102ae5:	41 89 74 24 0c       	mov    %esi,0xc(%r12)
}
  102aea:	5a                   	pop    %rdx
  102aeb:	44 89 c0             	mov    %r8d,%eax
  102aee:	5b                   	pop    %rbx
  102aef:	41 5c                	pop    %r12
  102af1:	41 5d                	pop    %r13
  102af3:	5d                   	pop    %rbp
  102af4:	c3                   	retq   

0000000000102af5 <ring_buf_get>:

uint32_t ring_buf_get(struct ring_buf *buf, uint8_t *data, uint32_t size)
{
  102af5:	55                   	push   %rbp
  102af6:	48 89 e5             	mov    %rsp,%rbp
  102af9:	41 57                	push   %r15
  102afb:	49 89 f7             	mov    %rsi,%r15
  102afe:	41 56                	push   %r14
  102b00:	49 89 fe             	mov    %rdi,%r14
  102b03:	41 55                	push   %r13
	uint8_t *src;
	uint32_t partial_size;
	uint32_t total_size = 0U;
  102b05:	45 31 ed             	xor    %r13d,%r13d
{
  102b08:	41 54                	push   %r12
  102b0a:	41 89 d4             	mov    %edx,%r12d
  102b0d:	53                   	push   %rbx
  102b0e:	48 83 ec 28          	sub    $0x28,%rsp
	int err;

	do {
		partial_size = ring_buf_get_claim(buf, &src, size);
  102b12:	44 89 e2             	mov    %r12d,%edx
  102b15:	48 8d 75 c8          	lea    -0x38(%rbp),%rsi
  102b19:	4c 89 f7             	mov    %r14,%rdi
  102b1c:	e8 07 ff ff ff       	callq  102a28 <ring_buf_get_claim>
  102b21:	89 c3                	mov    %eax,%ebx
		if (data) {
  102b23:	4d 85 ff             	test   %r15,%r15
  102b26:	74 19                	je     102b41 <ring_buf_get+0x4c>
			memcpy(data, src, partial_size);
  102b28:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
  102b2c:	89 c2                	mov    %eax,%edx
  102b2e:	4c 89 ff             	mov    %r15,%rdi
  102b31:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  102b35:	e8 5e 75 00 00       	callq  10a098 <memcpy>
			data += partial_size;
  102b3a:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  102b3e:	49 01 d7             	add    %rdx,%r15
		}
		total_size += partial_size;
  102b41:	41 01 dd             	add    %ebx,%r13d
		size -= partial_size;
	} while (size && partial_size);
  102b44:	41 29 dc             	sub    %ebx,%r12d
  102b47:	74 04                	je     102b4d <ring_buf_get+0x58>
  102b49:	85 db                	test   %ebx,%ebx
  102b4b:	75 c5                	jne    102b12 <ring_buf_get+0x1d>

	err = ring_buf_get_finish(buf, total_size);
  102b4d:	44 89 ee             	mov    %r13d,%esi
  102b50:	4c 89 f7             	mov    %r14,%rdi
  102b53:	e8 44 ff ff ff       	callq  102a9c <ring_buf_get_finish>
	__ASSERT_NO_MSG(err == 0);
  102b58:	85 c0                	test   %eax,%eax
  102b5a:	74 2a                	je     102b86 <ring_buf_get+0x91>
  102b5c:	be 9b d2 11 00       	mov    $0x11d29b,%esi
  102b61:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  102b66:	b9 41 01 00 00       	mov    $0x141,%ecx
  102b6b:	31 c0                	xor    %eax,%eax
  102b6d:	ba 73 d2 11 00       	mov    $0x11d273,%edx
  102b72:	e8 81 da ff ff       	callq  1005f8 <printk>
  102b77:	be 41 01 00 00       	mov    $0x141,%esi
  102b7c:	bf 73 d2 11 00       	mov    $0x11d273,%edi
  102b81:	e8 12 00 00 00       	callq  102b98 <assert_post_action>

	return total_size;
}
  102b86:	48 83 c4 28          	add    $0x28,%rsp
  102b8a:	44 89 e8             	mov    %r13d,%eax
  102b8d:	5b                   	pop    %rbx
  102b8e:	41 5c                	pop    %r12
  102b90:	41 5d                	pop    %r13
  102b92:	41 5e                	pop    %r14
  102b94:	41 5f                	pop    %r15
  102b96:	5d                   	pop    %rbp
  102b97:	c3                   	retq   

0000000000102b98 <assert_post_action>:
	__asm__ volatile ("mov %%cs, %[cs_val]" : [cs_val] "=r" (cs));
  102b98:	8c c8                	mov    %cs,%eax

#ifdef CONFIG_USERSPACE
	/* User threads aren't allowed to induce kernel panics; generate
	 * an oops instead.
	 */
	if (k_is_user_context()) {
  102b9a:	a8 03                	test   $0x3,%al
  102b9c:	74 09                	je     102ba7 <assert_post_action+0xf>
		k_oops();
  102b9e:	48 c7 c0 03 00 00 00 	mov    $0x3,%rax
  102ba5:	cd 20                	int    $0x20
	}
#endif

	k_panic();
  102ba7:	48 c7 c0 04 00 00 00 	mov    $0x4,%rax
  102bae:	cd 20                	int    $0x20

0000000000102bb0 <check_sys_mutex_addr>:

	return obj->data.mutex;
}

static bool check_sys_mutex_addr(struct sys_mutex *addr)
{
  102bb0:	55                   	push   %rbp
	/* sys_mutex memory is never touched, just used to lookup the
	 * underlying k_mutex, but we don't want threads using mutexes
	 * that are outside their memory domain
	 */
	return Z_SYSCALL_MEMORY_WRITE(addr, sizeof(struct sys_mutex));
  102bb1:	ba 01 00 00 00       	mov    $0x1,%edx
  102bb6:	be 04 00 00 00       	mov    $0x4,%esi
{
  102bbb:	48 89 e5             	mov    %rsp,%rbp
  102bbe:	41 55                	push   %r13
  102bc0:	41 54                	push   %r12
  102bc2:	49 89 fc             	mov    %rdi,%r12
	return Z_SYSCALL_MEMORY_WRITE(addr, sizeof(struct sys_mutex));
  102bc5:	e8 f2 67 00 00       	callq  1093bc <arch_buffer_validate>
  102bca:	85 c0                	test   %eax,%eax
  102bcc:	41 0f 95 c5          	setne  %r13b
  102bd0:	74 25                	je     102bf7 <check_sys_mutex_addr+0x47>
  102bd2:	41 b9 a4 d2 11 00    	mov    $0x11d2a4,%r9d
  102bd8:	4c 89 e1             	mov    %r12,%rcx
  102bdb:	ba 50 be 11 00       	mov    $0x11be50,%edx
  102be0:	31 c0                	xor    %eax,%eax
  102be2:	41 b8 04 00 00 00    	mov    $0x4,%r8d
  102be8:	be 45 00 00 00       	mov    $0x45,%esi
  102bed:	bf 1e cf 11 00       	mov    $0x11cf1e,%edi
  102bf2:	e8 cf 04 00 00       	callq  1030c6 <z_log_minimal_printk>
}
  102bf7:	44 89 e8             	mov    %r13d,%eax
  102bfa:	41 5c                	pop    %r12
  102bfc:	41 5d                	pop    %r13
  102bfe:	5d                   	pop    %rbp
  102bff:	c3                   	retq   

0000000000102c00 <z_impl_z_sys_mutex_kernel_lock>:

int z_impl_z_sys_mutex_kernel_lock(struct sys_mutex *mutex, k_timeout_t timeout)
{
  102c00:	55                   	push   %rbp
  102c01:	48 89 e5             	mov    %rsp,%rbp
  102c04:	48 83 ec 10          	sub    $0x10,%rsp
  102c08:	48 89 75 f8          	mov    %rsi,-0x8(%rbp)
	obj = z_object_find(mutex);
  102c0c:	e8 c3 3e 01 00       	callq  116ad4 <z_object_find>
	if (obj == NULL || obj->type != K_OBJ_SYS_MUTEX) {
  102c11:	48 85 c0             	test   %rax,%rax
  102c14:	74 28                	je     102c3e <z_impl_z_sys_mutex_kernel_lock+0x3e>
  102c16:	80 78 0c 0e          	cmpb   $0xe,0xc(%rax)
  102c1a:	75 22                	jne    102c3e <z_impl_z_sys_mutex_kernel_lock+0x3e>
	return obj->data.mutex;
  102c1c:	48 8b 78 0e          	mov    0xe(%rax),%rdi
	struct k_mutex *kernel_mutex = get_k_mutex(mutex);

	if (kernel_mutex == NULL) {
  102c20:	48 85 ff             	test   %rdi,%rdi
  102c23:	74 19                	je     102c3e <z_impl_z_sys_mutex_kernel_lock+0x3e>
  102c25:	8c c8                	mov    %cs,%eax
	if (z_syscall_trap()) {
  102c27:	a8 03                	test   $0x3,%al
  102c29:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  102c2d:	74 09                	je     102c38 <z_impl_z_sys_mutex_kernel_lock+0x38>
	register uintptr_t rax __asm__("%rax") = call_id;
  102c2f:	b8 95 00 00 00       	mov    $0x95,%eax
	__asm__ volatile("syscall\n\t"
  102c34:	0f 05                	syscall 
		return (int) arch_syscall_invoke2(*(uintptr_t *)&mutex, *(uintptr_t *)&timeout, K_SYSCALL_K_MUTEX_LOCK);
  102c36:	eb 0b                	jmp    102c43 <z_impl_z_sys_mutex_kernel_lock+0x43>
		return -EINVAL;
	}

	return k_mutex_lock(kernel_mutex, timeout);
}
  102c38:	c9                   	leaveq 
	return z_impl_k_mutex_lock(mutex, timeout);
  102c39:	e9 e8 c6 00 00       	jmpq   10f326 <z_impl_k_mutex_lock>
		return -EINVAL;
  102c3e:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
}
  102c43:	c9                   	leaveq 
  102c44:	c3                   	retq   

0000000000102c45 <z_mrsh_z_sys_mutex_kernel_lock>:
#include <syscalls/mutex.h>

extern int z_vrfy_z_sys_mutex_kernel_lock(struct sys_mutex * mutex, k_timeout_t timeout);
uintptr_t z_mrsh_z_sys_mutex_kernel_lock(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
  102c45:	55                   	push   %rbp
  102c46:	48 89 e5             	mov    %rsp,%rbp
  102c49:	41 55                	push   %r13
  102c4b:	49 89 f5             	mov    %rsi,%r13
  102c4e:	48 83 ec 18          	sub    $0x18,%rsp
	_current->syscall_frame = ssf;
  102c52:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  102c56:	48 8b 05 f3 5a 02 00 	mov    0x25af3(%rip),%rax        # 128750 <_kernel+0x10>
{
  102c5d:	48 89 75 e8          	mov    %rsi,-0x18(%rbp)

static inline int z_vrfy_z_sys_mutex_kernel_lock(struct sys_mutex *mutex,
						 k_timeout_t timeout)
{
	if (check_sys_mutex_addr(mutex)) {
  102c61:	48 89 7d e0          	mov    %rdi,-0x20(%rbp)
	_current->syscall_frame = ssf;
  102c65:	48 89 90 40 01 00 00 	mov    %rdx,0x140(%rax)
  102c6c:	e8 3f ff ff ff       	callq  102bb0 <check_sys_mutex_addr>
  102c71:	41 89 c0             	mov    %eax,%r8d
  102c74:	b8 f3 ff ff ff       	mov    $0xfffffff3,%eax
  102c79:	45 84 c0             	test   %r8b,%r8b
  102c7c:	75 0c                	jne    102c8a <z_mrsh_z_sys_mutex_kernel_lock+0x45>
		return -EACCES;
	}

	return z_impl_z_sys_mutex_kernel_lock(mutex, timeout);
  102c7e:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
  102c82:	4c 89 ee             	mov    %r13,%rsi
  102c85:	e8 76 ff ff ff       	callq  102c00 <z_impl_z_sys_mutex_kernel_lock>
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	int ret = z_vrfy_z_sys_mutex_kernel_lock(*(struct sys_mutex **)&arg0, *(k_timeout_t*)&arg1)
;
	_current->syscall_frame = NULL;
  102c8a:	48 8b 15 bf 5a 02 00 	mov    0x25abf(%rip),%rdx        # 128750 <_kernel+0x10>
	return (uintptr_t) ret;
  102c91:	48 98                	cltq   
	_current->syscall_frame = NULL;
  102c93:	48 c7 82 40 01 00 00 	movq   $0x0,0x140(%rdx)
  102c9a:	00 00 00 00 
}
  102c9e:	48 83 c4 18          	add    $0x18,%rsp
  102ca2:	41 5d                	pop    %r13
  102ca4:	5d                   	pop    %rbp
  102ca5:	c3                   	retq   

0000000000102ca6 <z_impl_z_sys_mutex_kernel_unlock>:
}
#include <syscalls/z_sys_mutex_kernel_lock_mrsh.c>

int z_impl_z_sys_mutex_kernel_unlock(struct sys_mutex *mutex)
{
  102ca6:	55                   	push   %rbp
  102ca7:	48 89 e5             	mov    %rsp,%rbp
	obj = z_object_find(mutex);
  102caa:	e8 25 3e 01 00       	callq  116ad4 <z_object_find>
	if (obj == NULL || obj->type != K_OBJ_SYS_MUTEX) {
  102caf:	48 85 c0             	test   %rax,%rax
  102cb2:	74 2a                	je     102cde <z_impl_z_sys_mutex_kernel_unlock+0x38>
  102cb4:	80 78 0c 0e          	cmpb   $0xe,0xc(%rax)
  102cb8:	75 24                	jne    102cde <z_impl_z_sys_mutex_kernel_unlock+0x38>
	return obj->data.mutex;
  102cba:	48 8b 78 0e          	mov    0xe(%rax),%rdi
	struct k_mutex *kernel_mutex = get_k_mutex(mutex);

	if (kernel_mutex == NULL || kernel_mutex->lock_count == 0) {
  102cbe:	48 85 ff             	test   %rdi,%rdi
  102cc1:	74 1b                	je     102cde <z_impl_z_sys_mutex_kernel_unlock+0x38>
  102cc3:	83 7f 18 00          	cmpl   $0x0,0x18(%rdi)
  102cc7:	74 15                	je     102cde <z_impl_z_sys_mutex_kernel_unlock+0x38>
	__asm__ volatile ("mov %%cs, %[cs_val]" : [cs_val] "=r" (cs));
  102cc9:	8c c8                	mov    %cs,%eax
	if (z_syscall_trap()) {
  102ccb:	a8 03                	test   $0x3,%al
  102ccd:	74 09                	je     102cd8 <z_impl_z_sys_mutex_kernel_unlock+0x32>
	register uintptr_t rax __asm__("%rax") = call_id;
  102ccf:	b8 96 00 00 00       	mov    $0x96,%eax
	__asm__ volatile("syscall\n\t"
  102cd4:	0f 05                	syscall 
		return (int) arch_syscall_invoke1(*(uintptr_t *)&mutex, K_SYSCALL_K_MUTEX_UNLOCK);
  102cd6:	eb 0b                	jmp    102ce3 <z_impl_z_sys_mutex_kernel_unlock+0x3d>
		return -EINVAL;
	}

	return k_mutex_unlock(kernel_mutex);
}
  102cd8:	5d                   	pop    %rbp
	return z_impl_k_mutex_unlock(mutex);
  102cd9:	e9 9a c9 00 00       	jmpq   10f678 <z_impl_k_mutex_unlock>
		return -EINVAL;
  102cde:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
}
  102ce3:	5d                   	pop    %rbp
  102ce4:	c3                   	retq   

0000000000102ce5 <z_mrsh_z_sys_mutex_kernel_unlock>:
#include <syscalls/mutex.h>

extern int z_vrfy_z_sys_mutex_kernel_unlock(struct sys_mutex * mutex);
uintptr_t z_mrsh_z_sys_mutex_kernel_unlock(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
  102ce5:	55                   	push   %rbp
  102ce6:	48 89 e5             	mov    %rsp,%rbp
  102ce9:	48 83 ec 10          	sub    $0x10,%rsp
	_current->syscall_frame = ssf;
  102ced:	48 8b 05 5c 5a 02 00 	mov    0x25a5c(%rip),%rax        # 128750 <_kernel+0x10>
  102cf4:	48 8b 55 10          	mov    0x10(%rbp),%rdx

static inline int z_vrfy_z_sys_mutex_kernel_unlock(struct sys_mutex *mutex)
{
	if (check_sys_mutex_addr(mutex)) {
  102cf8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  102cfc:	48 89 90 40 01 00 00 	mov    %rdx,0x140(%rax)
  102d03:	e8 a8 fe ff ff       	callq  102bb0 <check_sys_mutex_addr>
  102d08:	41 89 c0             	mov    %eax,%r8d
  102d0b:	b8 f3 ff ff ff       	mov    $0xfffffff3,%eax
  102d10:	45 84 c0             	test   %r8b,%r8b
  102d13:	75 09                	jne    102d1e <z_mrsh_z_sys_mutex_kernel_unlock+0x39>
		return -EACCES;
	}

	return z_impl_z_sys_mutex_kernel_unlock(mutex);
  102d15:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
  102d19:	e8 88 ff ff ff       	callq  102ca6 <z_impl_z_sys_mutex_kernel_unlock>
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	int ret = z_vrfy_z_sys_mutex_kernel_unlock(*(struct sys_mutex **)&arg0)
;
	_current->syscall_frame = NULL;
  102d1e:	48 8b 15 2b 5a 02 00 	mov    0x25a2b(%rip),%rdx        # 128750 <_kernel+0x10>
	return (uintptr_t) ret;
  102d25:	48 98                	cltq   
	_current->syscall_frame = NULL;
  102d27:	48 c7 82 40 01 00 00 	movq   $0x0,0x140(%rdx)
  102d2e:	00 00 00 00 
}
  102d32:	c9                   	leaveq 
  102d33:	c3                   	retq   

0000000000102d34 <foldcase>:
#define EOS    '\0'

static inline int foldcase(int ch, int flags)
{

    if ((flags & FNM_CASEFOLD) != 0 && isupper(ch))
  102d34:	40 80 e6 08          	and    $0x8,%sil
{
  102d38:	89 f8                	mov    %edi,%eax
    if ((flags & FNM_CASEFOLD) != 0 && isupper(ch))
  102d3a:	74 0b                	je     102d47 <foldcase+0x13>
	return (int)(((unsigned)(a)-(unsigned)'A') < 26U);
  102d3c:	8d 57 bf             	lea    -0x41(%rdi),%edx
  102d3f:	83 fa 19             	cmp    $0x19,%edx
  102d42:	77 03                	ja     102d47 <foldcase+0x13>
			((ua | 32U) - (unsigned)'a' < 6U));
}

static inline int tolower(int chr)
{
	return (chr >= (int)'A' && chr <= (int)'Z') ? (chr + 32) : (chr);
  102d44:	83 c0 20             	add    $0x20,%eax
        return tolower(ch);
    return ch;
}
  102d47:	c3                   	retq   

0000000000102d48 <fnmatchx>:
    return ok == negate ? NULL : pattern;
}


static int fnmatchx(const char *pattern, const char *string, int flags, size_t recursion)
{
  102d48:	55                   	push   %rbp
  102d49:	48 89 e5             	mov    %rsp,%rbp
  102d4c:	41 57                	push   %r15
  102d4e:	41 56                	push   %r14
  102d50:	41 55                	push   %r13
  102d52:	41 54                	push   %r12
  102d54:	53                   	push   %rbx
  102d55:	48 83 ec 28          	sub    $0x28,%rsp
  102d59:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
    const char *stringstart, *r;
    char c, test;

    if ((pattern == NULL) || (string == NULL))
  102d5d:	48 85 ff             	test   %rdi,%rdi
  102d60:	74 08                	je     102d6a <fnmatchx+0x22>
  102d62:	49 89 f6             	mov    %rsi,%r14
  102d65:	48 85 f6             	test   %rsi,%rsi
  102d68:	75 0a                	jne    102d74 <fnmatchx+0x2c>
    {
        return FNM_NOMATCH;
  102d6a:	b8 01 00 00 00       	mov    $0x1,%eax
  102d6f:	e9 38 03 00 00       	jmpq   1030ac <_binary_pagetables_bin_size+0xac>
    }

    if (recursion-- == 0)
  102d74:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
        return FNM_NORES;
  102d79:	b8 03 00 00 00       	mov    $0x3,%eax
    if (recursion-- == 0)
  102d7e:	0f 84 28 03 00 00    	je     1030ac <_binary_pagetables_bin_size+0xac>
        case '?':
            if (*string == EOS)
                return FNM_NOMATCH;
            if (*string == '/' && (flags & FNM_PATHNAME))
                return FNM_NOMATCH;
            if (*string == '.' && (flags & FNM_PERIOD) &&
  102d84:	89 d0                	mov    %edx,%eax
  102d86:	49 89 f8             	mov    %rdi,%r8
  102d89:	89 d3                	mov    %edx,%ebx
  102d8b:	49 89 f4             	mov    %rsi,%r12
  102d8e:	83 e0 04             	and    $0x4,%eax
  102d91:	89 45 bc             	mov    %eax,-0x44(%rbp)
        switch (c = FOLDCASE(*pattern++, flags)) {
  102d94:	41 0f b6 38          	movzbl (%r8),%edi
  102d98:	89 de                	mov    %ebx,%esi
  102d9a:	4d 8d 68 01          	lea    0x1(%r8),%r13
  102d9e:	e8 91 ff ff ff       	callq  102d34 <foldcase>
            if ((flags & FNM_LEADING_DIR) && *string == '/')
  102da3:	41 8a 0c 24          	mov    (%r12),%cl
        switch (c = FOLDCASE(*pattern++, flags)) {
  102da7:	44 0f be c8          	movsbl %al,%r9d
  102dab:	3c 3f                	cmp    $0x3f,%al
  102dad:	74 41                	je     102df0 <fnmatchx+0xa8>
  102daf:	7f 13                	jg     102dc4 <fnmatchx+0x7c>
  102db1:	84 c0                	test   %al,%al
  102db3:	74 24                	je     102dd9 <fnmatchx+0x91>
  102db5:	3c 2a                	cmp    $0x2a,%al
  102db7:	0f 85 d4 02 00 00    	jne    103091 <_binary_pagetables_bin_size+0x91>
                ((flags & FNM_PATHNAME) && *(string - 1) == '/')))
                return FNM_NOMATCH;
            ++string;
            break;
        case '*':
            c = FOLDCASE(*pattern, flags);
  102dbd:	41 0f b6 78 01       	movzbl 0x1(%r8),%edi
  102dc2:	eb 73                	jmp    102e37 <fnmatchx+0xef>
        switch (c = FOLDCASE(*pattern++, flags)) {
  102dc4:	3c 5b                	cmp    $0x5b,%al
  102dc6:	0f 84 5b 01 00 00    	je     102f27 <fnmatchx+0x1df>
  102dcc:	3c 5c                	cmp    $0x5c,%al
  102dce:	0f 84 a0 02 00 00    	je     103074 <_binary_pagetables_bin_size+0x74>
  102dd4:	e9 b8 02 00 00       	jmpq   103091 <_binary_pagetables_bin_size+0x91>
            if ((flags & FNM_LEADING_DIR) && *string == '/')
  102dd9:	80 e3 10             	and    $0x10,%bl
  102ddc:	74 0b                	je     102de9 <fnmatchx+0xa1>
                return 0;
  102dde:	31 c0                	xor    %eax,%eax
            if ((flags & FNM_LEADING_DIR) && *string == '/')
  102de0:	80 f9 2f             	cmp    $0x2f,%cl
  102de3:	0f 84 c3 02 00 00    	je     1030ac <_binary_pagetables_bin_size+0xac>
            return *string == EOS ? 0 : FNM_NOMATCH;
  102de9:	84 c9                	test   %cl,%cl
  102deb:	e9 ab 00 00 00       	jmpq   102e9b <fnmatchx+0x153>
            if (*string == EOS)
  102df0:	84 c9                	test   %cl,%cl
  102df2:	0f 84 72 ff ff ff    	je     102d6a <fnmatchx+0x22>
            if (*string == '/' && (flags & FNM_PATHNAME))
  102df8:	80 f9 2f             	cmp    $0x2f,%cl
  102dfb:	75 0a                	jne    102e07 <fnmatchx+0xbf>
  102dfd:	f6 c3 02             	test   $0x2,%bl
  102e00:	74 2a                	je     102e2c <fnmatchx+0xe4>
  102e02:	e9 63 ff ff ff       	jmpq   102d6a <fnmatchx+0x22>
            if (*string == '.' && (flags & FNM_PERIOD) &&
  102e07:	80 f9 2e             	cmp    $0x2e,%cl
  102e0a:	75 20                	jne    102e2c <fnmatchx+0xe4>
  102e0c:	83 7d bc 00          	cmpl   $0x0,-0x44(%rbp)
  102e10:	74 1a                	je     102e2c <fnmatchx+0xe4>
  102e12:	4d 39 f4             	cmp    %r14,%r12
  102e15:	0f 84 4f ff ff ff    	je     102d6a <fnmatchx+0x22>
                (string == stringstart ||
  102e1b:	f6 c3 02             	test   $0x2,%bl
  102e1e:	74 0c                	je     102e2c <fnmatchx+0xe4>
                ((flags & FNM_PATHNAME) && *(string - 1) == '/')))
  102e20:	41 80 7c 24 ff 2f    	cmpb   $0x2f,-0x1(%r12)
  102e26:	0f 84 3e ff ff ff    	je     102d6a <fnmatchx+0x22>
            ++string;
  102e2c:	49 ff c4             	inc    %r12
                if (*string != '[')
                    return FNM_NOMATCH;
            } else
                pattern = r;
            ++string;
            break;
  102e2f:	4d 89 e8             	mov    %r13,%r8
  102e32:	e9 5d ff ff ff       	jmpq   102d94 <fnmatchx+0x4c>
                c = FOLDCASE(*++pattern, flags);
  102e37:	89 de                	mov    %ebx,%esi
  102e39:	e8 f6 fe ff ff       	callq  102d34 <foldcase>
            while (c == '*')
  102e3e:	3c 2a                	cmp    $0x2a,%al
  102e40:	75 0a                	jne    102e4c <fnmatchx+0x104>
                c = FOLDCASE(*++pattern, flags);
  102e42:	49 ff c5             	inc    %r13
  102e45:	41 0f b6 7d 00       	movzbl 0x0(%r13),%edi
  102e4a:	eb eb                	jmp    102e37 <fnmatchx+0xef>
            if (*string == '.' && (flags & FNM_PERIOD) &&
  102e4c:	80 f9 2e             	cmp    $0x2e,%cl
  102e4f:	75 20                	jne    102e71 <fnmatchx+0x129>
  102e51:	83 7d bc 00          	cmpl   $0x0,-0x44(%rbp)
  102e55:	74 1a                	je     102e71 <fnmatchx+0x129>
  102e57:	4d 39 f4             	cmp    %r14,%r12
  102e5a:	0f 84 0a ff ff ff    	je     102d6a <fnmatchx+0x22>
                (string == stringstart ||
  102e60:	f6 c3 02             	test   $0x2,%bl
  102e63:	74 0c                	je     102e71 <fnmatchx+0x129>
                ((flags & FNM_PATHNAME) && *(string - 1) == '/')))
  102e65:	41 80 7c 24 ff 2f    	cmpb   $0x2f,-0x1(%r12)
  102e6b:	0f 84 f9 fe ff ff    	je     102d6a <fnmatchx+0x22>
            if (c == EOS) {
  102e71:	84 c0                	test   %al,%al
  102e73:	75 31                	jne    102ea6 <fnmatchx+0x15e>
                if (flags & FNM_PATHNAME)
  102e75:	89 d8                	mov    %ebx,%eax
  102e77:	83 e0 02             	and    $0x2,%eax
  102e7a:	0f 84 2c 02 00 00    	je     1030ac <_binary_pagetables_bin_size+0xac>
                return 0;
  102e80:	31 c0                	xor    %eax,%eax
                        0 : FNM_NOMATCH;
  102e82:	80 e3 10             	and    $0x10,%bl
  102e85:	0f 85 21 02 00 00    	jne    1030ac <_binary_pagetables_bin_size+0xac>
                        strchr(string, '/') == NULL ?
  102e8b:	be 2f 00 00 00       	mov    $0x2f,%esi
  102e90:	4c 89 e7             	mov    %r12,%rdi
  102e93:	e8 23 71 00 00       	callq  109fbb <strchr>
                        0 : FNM_NOMATCH;
  102e98:	48 85 c0             	test   %rax,%rax
  102e9b:	0f 95 c0             	setne  %al
  102e9e:	0f b6 c0             	movzbl %al,%eax
  102ea1:	e9 06 02 00 00       	jmpq   1030ac <_binary_pagetables_bin_size+0xac>
            } else if (c == '/' && flags & FNM_PATHNAME) {
  102ea6:	3c 2f                	cmp    $0x2f,%al
  102ea8:	75 05                	jne    102eaf <fnmatchx+0x167>
  102eaa:	f6 c3 02             	test   $0x2,%bl
  102ead:	75 14                	jne    102ec3 <fnmatchx+0x17b>
    if (recursion-- == 0)
  102eaf:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
                switch ((e = fnmatchx(pattern, string,
  102eb3:	41 89 df             	mov    %ebx,%r15d
  102eb6:	41 83 e7 fb          	and    $0xfffffffb,%r15d
    if (recursion-- == 0)
  102eba:	48 ff c8             	dec    %rax
  102ebd:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  102ec1:	eb 42                	jmp    102f05 <fnmatchx+0x1bd>
                if ((string = strchr(string, '/')) == NULL)
  102ec3:	4c 89 e7             	mov    %r12,%rdi
  102ec6:	be 2f 00 00 00       	mov    $0x2f,%esi
  102ecb:	e8 eb 70 00 00       	callq  109fbb <strchr>
  102ed0:	49 89 c4             	mov    %rax,%r12
  102ed3:	48 85 c0             	test   %rax,%rax
  102ed6:	0f 85 53 ff ff ff    	jne    102e2f <fnmatchx+0xe7>
  102edc:	e9 89 fe ff ff       	jmpq   102d6a <fnmatchx+0x22>
                switch ((e = fnmatchx(pattern, string,
  102ee1:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  102ee5:	44 89 fa             	mov    %r15d,%edx
  102ee8:	4c 89 e6             	mov    %r12,%rsi
  102eeb:	4c 89 ef             	mov    %r13,%rdi
  102eee:	e8 55 fe ff ff       	callq  102d48 <fnmatchx>
  102ef3:	83 f8 01             	cmp    $0x1,%eax
  102ef6:	0f 85 b0 01 00 00    	jne    1030ac <_binary_pagetables_bin_size+0xac>
                if (test == '/' && flags & FNM_PATHNAME)
  102efc:	41 80 fe 2f          	cmp    $0x2f,%r14b
  102f00:	74 1b                	je     102f1d <fnmatchx+0x1d5>
                ++string;
  102f02:	49 ff c4             	inc    %r12
            while ((test = FOLDCASE(*string, flags)) != EOS) {
  102f05:	41 0f b6 3c 24       	movzbl (%r12),%edi
  102f0a:	89 de                	mov    %ebx,%esi
  102f0c:	e8 23 fe ff ff       	callq  102d34 <foldcase>
  102f11:	41 89 c6             	mov    %eax,%r14d
  102f14:	84 c0                	test   %al,%al
  102f16:	75 c9                	jne    102ee1 <fnmatchx+0x199>
  102f18:	e9 4d fe ff ff       	jmpq   102d6a <fnmatchx+0x22>
                if (test == '/' && flags & FNM_PATHNAME)
  102f1d:	f6 c3 02             	test   $0x2,%bl
  102f20:	74 e0                	je     102f02 <fnmatchx+0x1ba>
  102f22:	e9 43 fe ff ff       	jmpq   102d6a <fnmatchx+0x22>
            if (*string == EOS)
  102f27:	84 c9                	test   %cl,%cl
  102f29:	0f 84 3b fe ff ff    	je     102d6a <fnmatchx+0x22>
            if (*string == '/' && flags & FNM_PATHNAME)
  102f2f:	80 f9 2f             	cmp    $0x2f,%cl
  102f32:	75 09                	jne    102f3d <fnmatchx+0x1f5>
  102f34:	f6 c3 02             	test   $0x2,%bl
  102f37:	0f 85 2d fe ff ff    	jne    102d6a <fnmatchx+0x22>
            if ((r = rangematch(pattern,
  102f3d:	0f b6 f9             	movzbl %cl,%edi
  102f40:	89 de                	mov    %ebx,%esi
  102f42:	e8 ed fd ff ff       	callq  102d34 <foldcase>
  102f47:	89 45 c8             	mov    %eax,-0x38(%rbp)
    if (pattern == NULL)
  102f4a:	4d 85 ed             	test   %r13,%r13
  102f4d:	0f 84 17 fe ff ff    	je     102d6a <fnmatchx+0x22>
    if ((negate = (*pattern == '!' || *pattern == '^')) != 0)
  102f53:	41 8a 40 01          	mov    0x1(%r8),%al
  102f57:	4d 89 ea             	mov    %r13,%r10
  102f5a:	3c 21                	cmp    $0x21,%al
  102f5c:	0f 94 c2             	sete   %dl
  102f5f:	3c 5e                	cmp    $0x5e,%al
  102f61:	0f 94 c0             	sete   %al
  102f64:	08 c2                	or     %al,%dl
  102f66:	88 55 bb             	mov    %dl,-0x45(%rbp)
  102f69:	74 04                	je     102f6f <fnmatchx+0x227>
        ++pattern;
  102f6b:	4d 8d 50 02          	lea    0x2(%r8),%r10
        if (c == '\\' && !(flags & FNM_NOESCAPE))
  102f6f:	41 89 df             	mov    %ebx,%r15d
            ok = 1;
  102f72:	ba 01 00 00 00       	mov    $0x1,%edx
  102f77:	45 31 db             	xor    %r11d,%r11d
        if (c == '\\' && !(flags & FNM_NOESCAPE))
  102f7a:	41 83 e7 01          	and    $0x1,%r15d
    for (ok = 0; (c = FOLDCASE(*pattern++, flags)) != ']' || need;) {
  102f7e:	41 0f b6 3a          	movzbl (%r10),%edi
  102f82:	89 de                	mov    %ebx,%esi
  102f84:	89 55 b4             	mov    %edx,-0x4c(%rbp)
  102f87:	4d 8d 42 01          	lea    0x1(%r10),%r8
  102f8b:	e8 a4 fd ff ff       	callq  102d34 <foldcase>
  102f90:	8b 55 b4             	mov    -0x4c(%rbp),%edx
  102f93:	3c 5d                	cmp    $0x5d,%al
  102f95:	44 0f be c8          	movsbl %al,%r9d
  102f99:	0f 84 9e 00 00 00    	je     10303d <_binary_pagetables_bin_size+0x3d>
        if (c == '/')
  102f9f:	3c 2f                	cmp    $0x2f,%al
  102fa1:	0f 84 b6 00 00 00    	je     10305d <_binary_pagetables_bin_size+0x5d>
        if (c == '\\' && !(flags & FNM_NOESCAPE))
  102fa7:	3c 5c                	cmp    $0x5c,%al
  102fa9:	75 19                	jne    102fc4 <fnmatchx+0x27c>
  102fab:	45 85 ff             	test   %r15d,%r15d
  102fae:	75 1d                	jne    102fcd <fnmatchx+0x285>
            c = FOLDCASE(*pattern++, flags);
  102fb0:	41 0f b6 7a 01       	movzbl 0x1(%r10),%edi
  102fb5:	89 de                	mov    %ebx,%esi
  102fb7:	4d 8d 42 02          	lea    0x2(%r10),%r8
  102fbb:	e8 74 fd ff ff       	callq  102d34 <foldcase>
  102fc0:	44 0f be c8          	movsbl %al,%r9d
        if (c == EOS)
  102fc4:	45 84 c9             	test   %r9b,%r9b
  102fc7:	0f 84 9d fd ff ff    	je     102d6a <fnmatchx+0x22>
        if (*pattern == '-' 
  102fcd:	41 80 38 2d          	cmpb   $0x2d,(%r8)
  102fd1:	75 53                	jne    103026 <_binary_pagetables_bin_size+0x26>
            && (c2 = FOLDCASE(*(pattern + 1), flags)) != EOS &&
  102fd3:	41 0f b6 78 01       	movzbl 0x1(%r8),%edi
  102fd8:	89 de                	mov    %ebx,%esi
  102fda:	e8 55 fd ff ff       	callq  102d34 <foldcase>
  102fdf:	0f be d0             	movsbl %al,%edx
  102fe2:	3c 5d                	cmp    $0x5d,%al
  102fe4:	74 40                	je     103026 <_binary_pagetables_bin_size+0x26>
  102fe6:	84 c0                	test   %al,%al
  102fe8:	74 3c                	je     103026 <_binary_pagetables_bin_size+0x26>
            pattern += 2;
  102fea:	4d 8d 50 02          	lea    0x2(%r8),%r10
            if (c2 == '\\' && !(flags & FNM_NOESCAPE))
  102fee:	3c 5c                	cmp    $0x5c,%al
  102ff0:	75 20                	jne    103012 <_binary_pagetables_bin_size+0x12>
  102ff2:	45 85 ff             	test   %r15d,%r15d
  102ff5:	75 1b                	jne    103012 <_binary_pagetables_bin_size+0x12>
                c2 = FOLDCASE(*pattern++, flags);
  102ff7:	41 0f b6 78 02       	movzbl 0x2(%r8),%edi
  102ffc:	89 de                	mov    %ebx,%esi
  102ffe:	4d 8d 50 03          	lea    0x3(%r8),%r10
  103002:	e8 2d fd ff ff       	callq  102d34 <foldcase>
  103007:	0f be d0             	movsbl %al,%edx
            if (c2 == EOS)
  10300a:	84 c0                	test   %al,%al
  10300c:	0f 84 58 fd ff ff    	je     102d6a <fnmatchx+0x22>
            if (c <= test && test <= c2)
  103012:	44 39 4d c8          	cmp    %r9d,-0x38(%rbp)
  103016:	7c 1e                	jl     103036 <_binary_pagetables_bin_size+0x36>
                ok = 1;
  103018:	39 55 c8             	cmp    %edx,-0x38(%rbp)
  10301b:	b8 01 00 00 00       	mov    $0x1,%eax
  103020:	44 0f 4e d8          	cmovle %eax,%r11d
  103024:	eb 10                	jmp    103036 <_binary_pagetables_bin_size+0x36>
        } else if (c == test)
  103026:	44 39 4d c8          	cmp    %r9d,-0x38(%rbp)
  10302a:	b8 01 00 00 00       	mov    $0x1,%eax
  10302f:	4d 89 c2             	mov    %r8,%r10
  103032:	44 0f 44 d8          	cmove  %eax,%r11d
            ok = 1;
  103036:	31 d2                	xor    %edx,%edx
  103038:	e9 41 ff ff ff       	jmpq   102f7e <fnmatchx+0x236>
    for (ok = 0; (c = FOLDCASE(*pattern++, flags)) != ']' || need;) {
  10303d:	85 d2                	test   %edx,%edx
  10303f:	75 8c                	jne    102fcd <fnmatchx+0x285>
    if ((negate = (*pattern == '!' || *pattern == '^')) != 0)
  103041:	0f b6 45 bb          	movzbl -0x45(%rbp),%eax
            if ((r = rangematch(pattern,
  103045:	44 39 d8             	cmp    %r11d,%eax
  103048:	0f 84 1c fd ff ff    	je     102d6a <fnmatchx+0x22>
  10304e:	4d 85 c0             	test   %r8,%r8
  103051:	0f 84 13 fd ff ff    	je     102d6a <fnmatchx+0x22>
            if (r == (void *)-1) {
  103057:	49 83 f8 ff          	cmp    $0xffffffffffffffff,%r8
  10305b:	75 0c                	jne    103069 <_binary_pagetables_bin_size+0x69>
                if (*string != '[')
  10305d:	80 f9 5b             	cmp    $0x5b,%cl
  103060:	0f 85 04 fd ff ff    	jne    102d6a <fnmatchx+0x22>
  103066:	4d 89 e8             	mov    %r13,%r8
            ++string;
  103069:	49 ff c4             	inc    %r12
            break;
  10306c:	4d 89 c5             	mov    %r8,%r13
  10306f:	e9 bb fd ff ff       	jmpq   102e2f <fnmatchx+0xe7>
        case '\\':
            if (!(flags & FNM_NOESCAPE)) {
  103074:	f6 c3 01             	test   $0x1,%bl
  103077:	75 18                	jne    103091 <_binary_pagetables_bin_size+0x91>
                if ((c = FOLDCASE(*pattern++, flags)) == EOS) {
  103079:	41 0f b6 78 01       	movzbl 0x1(%r8),%edi
  10307e:	89 de                	mov    %ebx,%esi
  103080:	e8 af fc ff ff       	callq  102d34 <foldcase>
  103085:	44 0f be c8          	movsbl %al,%r9d
  103089:	84 c0                	test   %al,%al
  10308b:	74 04                	je     103091 <_binary_pagetables_bin_size+0x91>
  10308d:	4d 8d 68 02          	lea    0x2(%r8),%r13
                    --pattern;
                }
            }
            /* FALLTHROUGH */
        default:
            if (c != FOLDCASE(*string++, flags))
  103091:	0f b6 f9             	movzbl %cl,%edi
  103094:	89 de                	mov    %ebx,%esi
  103096:	49 ff c4             	inc    %r12
  103099:	e8 96 fc ff ff       	callq  102d34 <foldcase>
  10309e:	41 39 c1             	cmp    %eax,%r9d
  1030a1:	0f 84 88 fd ff ff    	je     102e2f <fnmatchx+0xe7>
  1030a7:	e9 be fc ff ff       	jmpq   102d6a <fnmatchx+0x22>
                return FNM_NOMATCH;
            break;
        }
    }
    /* NOTREACHED */
}
  1030ac:	48 83 c4 28          	add    $0x28,%rsp
  1030b0:	5b                   	pop    %rbx
  1030b1:	41 5c                	pop    %r12
  1030b3:	41 5d                	pop    %r13
  1030b5:	41 5e                	pop    %r14
  1030b7:	41 5f                	pop    %r15
  1030b9:	5d                   	pop    %rbp
  1030ba:	c3                   	retq   

00000000001030bb <fnmatch>:

int fnmatch(const char *pattern, const char *string, int flags)
{
    return fnmatchx(pattern, string, flags, 64);
  1030bb:	b9 40 00 00 00       	mov    $0x40,%ecx
  1030c0:	e9 83 fc ff ff       	jmpq   102d48 <fnmatchx>

00000000001030c5 <_ConfigAbsSyms>:
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_BUILD_NO_GAP_FILL, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_BUILD_OUTPUT_BIN, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_APPLICATION_DEFINED_SYSCALL, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_COMPAT_INCLUDES, 1);

GEN_ABS_SYM_END
  1030c5:	c3                   	retq   

00000000001030c6 <z_log_minimal_printk>:
#include <sys/printk.h>

#define HEXDUMP_BYTES_IN_LINE 8U

void z_log_minimal_printk(const char *fmt, ...)
{
  1030c6:	55                   	push   %rbp
  1030c7:	48 89 e5             	mov    %rsp,%rbp
  1030ca:	48 81 ec d0 00 00 00 	sub    $0xd0,%rsp
  1030d1:	48 89 b5 58 ff ff ff 	mov    %rsi,-0xa8(%rbp)
  1030d8:	48 89 95 60 ff ff ff 	mov    %rdx,-0xa0(%rbp)
  1030df:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  1030e6:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  1030ed:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  1030f4:	84 c0                	test   %al,%al
  1030f6:	74 20                	je     103118 <z_log_minimal_printk+0x52>
  1030f8:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  1030fc:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  103100:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  103104:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  103108:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  10310c:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  103110:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  103114:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
	va_list ap;

	va_start(ap, fmt);
  103118:	48 8d 45 10          	lea    0x10(%rbp),%rax
	vprintk(fmt, ap);
  10311c:	48 8d b5 38 ff ff ff 	lea    -0xc8(%rbp),%rsi
	va_start(ap, fmt);
  103123:	c7 85 38 ff ff ff 08 	movl   $0x8,-0xc8(%rbp)
  10312a:	00 00 00 
  10312d:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  103134:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  10313b:	c7 85 3c ff ff ff 30 	movl   $0x30,-0xc4(%rbp)
  103142:	00 00 00 
  103145:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
	vprintk(fmt, ap);
  10314c:	e8 8b d3 ff ff       	callq  1004dc <vprintk>
	va_end(ap);
}
  103151:	c9                   	leaveq 
  103152:	c3                   	retq   

0000000000103153 <z_log_minimal_hexdump_print>:
	}
	printk("\n");
}

void z_log_minimal_hexdump_print(int level, const void *data, size_t size)
{
  103153:	55                   	push   %rbp
  103154:	48 8d 04 16          	lea    (%rsi,%rdx,1),%rax
  103158:	48 89 e5             	mov    %rsp,%rbp
  10315b:	41 57                	push   %r15
  10315d:	41 56                	push   %r14
  10315f:	41 55                	push   %r13
  103161:	41 89 fd             	mov    %edi,%r13d
  103164:	41 54                	push   %r12
  103166:	53                   	push   %rbx
  103167:	48 89 d3             	mov    %rdx,%rbx
  10316a:	48 83 ec 18          	sub    $0x18,%rsp
  10316e:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  103172:	4c 8b 75 c8          	mov    -0x38(%rbp),%r14
  103176:	49 29 de             	sub    %rbx,%r14
	const char *data_buffer = (const char *)data;
	while (size > 0U) {
  103179:	48 85 db             	test   %rbx,%rbx
  10317c:	0f 84 ba 00 00 00    	je     10323c <z_log_minimal_hexdump_print+0xe9>
	z_log_minimal_printk("\n"); \
} while (false)

static inline char z_log_minimal_level_to_char(int level)
{
	switch (level) {
  103182:	41 8d 45 ff          	lea    -0x1(%r13),%eax
  103186:	be 3f 00 00 00       	mov    $0x3f,%esi
  10318b:	83 f8 03             	cmp    $0x3,%eax
  10318e:	77 07                	ja     103197 <z_log_minimal_hexdump_print+0x44>
  103190:	0f be b0 bb d2 11 00 	movsbl 0x11d2bb(%rax),%esi
		printk("%c: ", z_log_minimal_level_to_char(level));
  103197:	bf aa d2 11 00       	mov    $0x11d2aa,%edi
  10319c:	31 c0                	xor    %eax,%eax
	for (size_t i = 0U; i < HEXDUMP_BYTES_IN_LINE; i++) {
  10319e:	45 31 ff             	xor    %r15d,%r15d
		printk("%c: ", z_log_minimal_level_to_char(level));
  1031a1:	e8 52 d4 ff ff       	callq  1005f8 <printk>
		if (i < length) {
  1031a6:	4c 39 fb             	cmp    %r15,%rbx
  1031a9:	76 13                	jbe    1031be <z_log_minimal_hexdump_print+0x6b>
			printk("%02x ", (unsigned char)data[i] & 0xFFu);
  1031ab:	43 0f b6 34 3e       	movzbl (%r14,%r15,1),%esi
  1031b0:	bf af d2 11 00       	mov    $0x11d2af,%edi
  1031b5:	31 c0                	xor    %eax,%eax
  1031b7:	e8 3c d4 ff ff       	callq  1005f8 <printk>
  1031bc:	eb 0c                	jmp    1031ca <z_log_minimal_hexdump_print+0x77>
			printk("   ");
  1031be:	bf b5 d2 11 00       	mov    $0x11d2b5,%edi
  1031c3:	31 c0                	xor    %eax,%eax
  1031c5:	e8 2e d4 ff ff       	callq  1005f8 <printk>
	for (size_t i = 0U; i < HEXDUMP_BYTES_IN_LINE; i++) {
  1031ca:	49 ff c7             	inc    %r15
  1031cd:	49 83 ff 08          	cmp    $0x8,%r15
  1031d1:	75 d3                	jne    1031a6 <z_log_minimal_hexdump_print+0x53>
	printk("|");
  1031d3:	bf b9 d2 11 00       	mov    $0x11d2b9,%edi
  1031d8:	31 c0                	xor    %eax,%eax
	for (size_t i = 0U; i < HEXDUMP_BYTES_IN_LINE; i++) {
  1031da:	45 31 e4             	xor    %r12d,%r12d
  1031dd:	41 bf 2e 00 00 00    	mov    $0x2e,%r15d
	printk("|");
  1031e3:	e8 10 d4 ff ff       	callq  1005f8 <printk>
		if (i < length) {
  1031e8:	4c 39 e3             	cmp    %r12,%rbx
  1031eb:	76 1f                	jbe    10320c <z_log_minimal_hexdump_print+0xb9>
			unsigned char c = data[i];
  1031ed:	43 0f b6 04 26       	movzbl (%r14,%r12,1),%eax
			printk("%c", isprint((int)c) != 0 ? c : '.');
  1031f2:	bf 34 dd 11 00       	mov    $0x11dd34,%edi
			unsigned char c = data[i];
  1031f7:	89 c6                	mov    %eax,%esi
	return (int)((((unsigned)c) >= ' ') &&
  1031f9:	83 e8 20             	sub    $0x20,%eax
  1031fc:	83 f8 5f             	cmp    $0x5f,%eax
  1031ff:	41 0f 43 f7          	cmovae %r15d,%esi
			printk("%c", isprint((int)c) != 0 ? c : '.');
  103203:	31 c0                	xor    %eax,%eax
  103205:	e8 ee d3 ff ff       	callq  1005f8 <printk>
  10320a:	eb 0c                	jmp    103218 <z_log_minimal_hexdump_print+0xc5>
			printk(" ");
  10320c:	bf b7 d2 11 00       	mov    $0x11d2b7,%edi
  103211:	31 c0                	xor    %eax,%eax
  103213:	e8 e0 d3 ff ff       	callq  1005f8 <printk>
	for (size_t i = 0U; i < HEXDUMP_BYTES_IN_LINE; i++) {
  103218:	49 ff c4             	inc    %r12
  10321b:	49 83 fc 08          	cmp    $0x8,%r12
  10321f:	75 c7                	jne    1031e8 <z_log_minimal_hexdump_print+0x95>
	printk("\n");
  103221:	31 c0                	xor    %eax,%eax
  103223:	bf 23 fc 11 00       	mov    $0x11fc23,%edi
  103228:	e8 cb d3 ff ff       	callq  1005f8 <printk>
		minimal_hexdump_line_print(data_buffer, size);

		if (size < HEXDUMP_BYTES_IN_LINE) {
  10322d:	48 83 fb 07          	cmp    $0x7,%rbx
  103231:	76 09                	jbe    10323c <z_log_minimal_hexdump_print+0xe9>
			break;
		}

		size -= HEXDUMP_BYTES_IN_LINE;
  103233:	48 83 eb 08          	sub    $0x8,%rbx
		data_buffer += HEXDUMP_BYTES_IN_LINE;
  103237:	e9 36 ff ff ff       	jmpq   103172 <z_log_minimal_hexdump_print+0x1f>
	}
}
  10323c:	48 83 c4 18          	add    $0x18,%rsp
  103240:	5b                   	pop    %rbx
  103241:	41 5c                	pop    %r12
  103243:	41 5d                	pop    %r13
  103245:	41 5e                	pop    %r14
  103247:	41 5f                	pop    %r15
  103249:	5d                   	pop    %rbp
  10324a:	c3                   	retq   

000000000010324b <cmd_kernel_version>:
#include <drivers/timer/system_timer.h>
#include <kernel.h>

static int cmd_kernel_version(const struct shell *shell,
			      size_t argc, char **argv)
{
  10324b:	55                   	push   %rbp
  10324c:	48 89 e5             	mov    %rsp,%rbp
  10324f:	48 83 ec 10          	sub    $0x10,%rsp
  103253:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	uint32_t version = sys_kernel_version_get();
  103257:	e8 d9 b3 00 00       	callq  10e635 <sys_kernel_version_get>

	ARG_UNUSED(argc);
	ARG_UNUSED(argv);

	shell_print(shell, "Zephyr version %d.%d.%d",
  10325c:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
  103260:	31 f6                	xor    %esi,%esi
  103262:	41 89 c0             	mov    %eax,%r8d
  103265:	0f b6 d4             	movzbl %ah,%edx
  103268:	c1 e8 18             	shr    $0x18,%eax
  10326b:	41 c1 e8 10          	shr    $0x10,%r8d
  10326f:	41 89 d1             	mov    %edx,%r9d
  103272:	89 c1                	mov    %eax,%ecx
  103274:	ba bf d2 11 00       	mov    $0x11d2bf,%edx
  103279:	31 c0                	xor    %eax,%eax
  10327b:	45 0f b6 c0          	movzbl %r8b,%r8d
  10327f:	e8 0f 29 00 00       	callq  105b93 <shell_fprintf>
		      SYS_KERNEL_VER_MAJOR(version),
		      SYS_KERNEL_VER_MINOR(version),
		      SYS_KERNEL_VER_PATCHLEVEL(version));
	return 0;
}
  103284:	31 c0                	xor    %eax,%eax
  103286:	c9                   	leaveq 
  103287:	c3                   	retq   

0000000000103288 <cmd_kernel_threads>:

}

static int cmd_kernel_threads(const struct shell *shell,
			      size_t argc, char **argv)
{
  103288:	55                   	push   %rbp
  103289:	48 89 e5             	mov    %rsp,%rbp
  10328c:	41 54                	push   %r12
  10328e:	49 89 fc             	mov    %rdi,%r12
  103291:	50                   	push   %rax
	ARG_UNUSED(argc);
	ARG_UNUSED(argv);

	shell_print(shell, "Scheduler: %u since last call", sys_clock_elapsed());
  103292:	e8 f0 98 00 00       	callq  10cb87 <sys_clock_elapsed>
  103297:	4c 89 e7             	mov    %r12,%rdi
  10329a:	ba d8 d2 11 00       	mov    $0x11d2d8,%edx
  10329f:	31 f6                	xor    %esi,%esi
  1032a1:	89 c1                	mov    %eax,%ecx
  1032a3:	31 c0                	xor    %eax,%eax
  1032a5:	e8 e9 28 00 00       	callq  105b93 <shell_fprintf>
	shell_print(shell, "Threads:");
  1032aa:	ba f7 d2 11 00       	mov    $0x11d2f7,%edx
  1032af:	4c 89 e7             	mov    %r12,%rdi
  1032b2:	31 c0                	xor    %eax,%eax
  1032b4:	31 f6                	xor    %esi,%esi
  1032b6:	e8 d8 28 00 00       	callq  105b93 <shell_fprintf>
	k_thread_foreach(shell_tdata_dump, (void *)shell);
  1032bb:	4c 89 e6             	mov    %r12,%rsi
  1032be:	bf 4c 34 10 00       	mov    $0x10344c,%edi
  1032c3:	e8 07 a6 00 00       	callq  10d8cf <k_thread_foreach>
	return 0;
}
  1032c8:	5a                   	pop    %rdx
  1032c9:	31 c0                	xor    %eax,%eax
  1032cb:	41 5c                	pop    %r12
  1032cd:	5d                   	pop    %rbp
  1032ce:	c3                   	retq   

00000000001032cf <cmd_kernel_stacks>:
extern K_KERNEL_STACK_ARRAY_DEFINE(z_interrupt_stacks, CONFIG_MP_NUM_CPUS,
				   CONFIG_ISR_STACK_SIZE);

static int cmd_kernel_stacks(const struct shell *shell,
			     size_t argc, char **argv)
{
  1032cf:	55                   	push   %rbp
	uint8_t *buf;
	size_t size, unused;

	ARG_UNUSED(argc);
	ARG_UNUSED(argv);
	k_thread_foreach(shell_stack_dump, (void *)shell);
  1032d0:	48 89 fe             	mov    %rdi,%rsi
{
  1032d3:	48 89 e5             	mov    %rsp,%rbp
  1032d6:	41 54                	push   %r12
  1032d8:	49 89 fc             	mov    %rdi,%r12
	k_thread_foreach(shell_stack_dump, (void *)shell);
  1032db:	bf bd 33 10 00       	mov    $0x1033bd,%edi
{
  1032e0:	50                   	push   %rax
	k_thread_foreach(shell_stack_dump, (void *)shell);
  1032e1:	e8 e9 a5 00 00       	callq  10d8cf <k_thread_foreach>
	 */
	for (int i = 0; i < CONFIG_MP_NUM_CPUS; i++) {
		buf = Z_KERNEL_STACK_BUFFER(z_interrupt_stacks[i]);
		size = K_KERNEL_STACK_SIZEOF(z_interrupt_stacks[i]);

		unused = 0;
  1032e6:	31 c0                	xor    %eax,%eax
		for (size_t i = 0; i < size; i++) {
			if (buf[i] == 0xAAU) {
  1032e8:	80 b8 00 c0 5c 00 aa 	cmpb   $0xaa,0x5cc000(%rax)
  1032ef:	75 0b                	jne    1032fc <cmd_kernel_stacks+0x2d>
				unused++;
  1032f1:	48 ff c0             	inc    %rax
		for (size_t i = 0; i < size; i++) {
  1032f4:	48 3d 00 40 00 00    	cmp    $0x4000,%rax
  1032fa:	75 ec                	jne    1032e8 <cmd_kernel_stacks+0x19>
			} else {
				break;
			}
		}

		shell_print(shell,
  1032fc:	ba 00 40 00 00       	mov    $0x4000,%edx
  103301:	4c 89 e7             	mov    %r12,%rdi
  103304:	41 b9 00 40 00 00    	mov    $0x4000,%r9d
  10330a:	31 f6                	xor    %esi,%esi
  10330c:	48 29 c2             	sub    %rax,%rdx
  10330f:	45 31 c0             	xor    %r8d,%r8d
  103312:	48 6b ca 64          	imul   $0x64,%rdx,%rcx
  103316:	48 c1 e9 0e          	shr    $0xe,%rcx
  10331a:	51                   	push   %rcx
  10331b:	b9 00 b0 5c 00       	mov    $0x5cb000,%ecx
  103320:	68 00 40 00 00       	pushq  $0x4000
  103325:	52                   	push   %rdx
  103326:	ba 01 d3 11 00       	mov    $0x11d301,%edx
  10332b:	50                   	push   %rax
  10332c:	31 c0                	xor    %eax,%eax
  10332e:	e8 60 28 00 00       	callq  105b93 <shell_fprintf>
			      size - unused, size,
			      ((size - unused) * 100U) / size);
	}

	return 0;
}
  103333:	4c 8b 65 f8          	mov    -0x8(%rbp),%r12
		shell_print(shell,
  103337:	48 83 c4 20          	add    $0x20,%rsp
}
  10333b:	31 c0                	xor    %eax,%eax
  10333d:	c9                   	leaveq 
  10333e:	c3                   	retq   

000000000010333f <cmd_kernel_cycles>:
{
  10333f:	55                   	push   %rbp
  103340:	48 89 e5             	mov    %rsp,%rbp
  103343:	48 83 ec 10          	sub    $0x10,%rsp
  103347:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
extern uint32_t sys_clock_cycle_get_32(void);

__pinned_func
static inline uint32_t arch_k_cycle_get_32(void)
{
	return sys_clock_cycle_get_32();
  10334b:	e8 08 99 00 00       	callq  10cc58 <sys_clock_cycle_get_32>
	shell_print(shell, "cycles: %u hw cycles", k_cycle_get_32());
  103350:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
  103354:	ba 47 d3 11 00       	mov    $0x11d347,%edx
  103359:	31 f6                	xor    %esi,%esi
  10335b:	89 c1                	mov    %eax,%ecx
  10335d:	31 c0                	xor    %eax,%eax
  10335f:	e8 2f 28 00 00       	callq  105b93 <shell_fprintf>
}
  103364:	31 c0                	xor    %eax,%eax
  103366:	c9                   	leaveq 
  103367:	c3                   	retq   

0000000000103368 <cmd_kernel_uptime>:
{
  103368:	55                   	push   %rbp
  103369:	48 89 e5             	mov    %rsp,%rbp
  10336c:	48 83 ec 10          	sub    $0x10,%rsp
	__asm__ volatile ("mov %%cs, %[cs_val]" : [cs_val] "=r" (cs));
  103370:	8c c8                	mov    %cs,%eax
	if (z_syscall_trap()) {
  103372:	a8 03                	test   $0x3,%al
  103374:	74 09                	je     10337f <cmd_kernel_uptime+0x17>
	register uintptr_t rax __asm__("%rax") = call_id;
  103376:	b8 ce 00 00 00       	mov    $0xce,%eax
	__asm__ volatile("syscall\n\t"
  10337b:	0f 05                	syscall 
		return (int64_t) arch_syscall_invoke0(K_SYSCALL_K_UPTIME_TICKS);
  10337d:	eb 0d                	jmp    10338c <cmd_kernel_uptime+0x24>
  10337f:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return z_impl_k_uptime_ticks();
  103383:	e8 4f 02 01 00       	callq  1135d7 <z_impl_k_uptime_ticks>
  103388:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
	if (div_ratio) {
		t += off;
		if (result32 && (t < BIT64(32))) {
			return ((uint32_t)t) / (from_hz / to_hz);
		} else {
			return t / ((uint64_t)from_hz / to_hz);
  10338c:	b9 0a 00 00 00       	mov    $0xa,%ecx
  103391:	31 d2                	xor    %edx,%edx
	shell_print(shell, "Uptime: %u ms", k_uptime_get_32());
  103393:	31 f6                	xor    %esi,%esi
  103395:	48 f7 f1             	div    %rcx
  103398:	ba 5d d3 11 00       	mov    $0x11d35d,%edx
  10339d:	89 c1                	mov    %eax,%ecx
  10339f:	31 c0                	xor    %eax,%eax
  1033a1:	e8 ed 27 00 00       	callq  105b93 <shell_fprintf>
}
  1033a6:	31 c0                	xor    %eax,%eax
  1033a8:	c9                   	leaveq 
  1033a9:	c3                   	retq   

00000000001033aa <k_thread_stack_space_get>:
	__asm__ volatile ("mov %%cs, %[cs_val]" : [cs_val] "=r" (cs));
  1033aa:	8c c8                	mov    %cs,%eax
	if (z_syscall_trap()) {
  1033ac:	a8 03                	test   $0x3,%al
  1033ae:	75 05                	jne    1033b5 <k_thread_stack_space_get+0xb>
	return z_impl_k_thread_stack_space_get(thread, unused_ptr);
  1033b0:	e9 08 b0 00 00       	jmpq   10e3bd <z_impl_k_thread_stack_space_get>
	register uintptr_t rax __asm__("%rax") = call_id;
  1033b5:	b8 c1 00 00 00       	mov    $0xc1,%eax
	__asm__ volatile("syscall\n\t"
  1033ba:	0f 05                	syscall 
}
  1033bc:	c3                   	retq   

00000000001033bd <shell_stack_dump>:
{
  1033bd:	55                   	push   %rbp
  1033be:	48 89 e5             	mov    %rsp,%rbp
  1033c1:	41 55                	push   %r13
  1033c3:	49 89 f5             	mov    %rsi,%r13
  1033c6:	41 54                	push   %r12
	ret = k_thread_stack_space_get(thread, &unused);
  1033c8:	48 8d 75 d8          	lea    -0x28(%rbp),%rsi
{
  1033cc:	49 89 fc             	mov    %rdi,%r12
  1033cf:	53                   	push   %rbx
  1033d0:	48 83 ec 18          	sub    $0x18,%rsp
	size_t size = thread->stack_info.size;
  1033d4:	48 8b 9f 10 01 00 00 	mov    0x110(%rdi),%rbx
	ret = k_thread_stack_space_get(thread, &unused);
  1033db:	e8 ca ff ff ff       	callq  1033aa <k_thread_stack_space_get>
	if (ret) {
  1033e0:	85 c0                	test   %eax,%eax
  1033e2:	74 15                	je     1033f9 <shell_stack_dump+0x3c>
  1033e4:	89 c1                	mov    %eax,%ecx
		shell_print(shell,
  1033e6:	ba 6f d3 11 00       	mov    $0x11d36f,%edx
  1033eb:	31 f6                	xor    %esi,%esi
  1033ed:	4c 89 ef             	mov    %r13,%rdi
  1033f0:	31 c0                	xor    %eax,%eax
  1033f2:	e8 9c 27 00 00       	callq  105b93 <shell_fprintf>
		return;
  1033f7:	eb 48                	jmp    103441 <shell_stack_dump+0x84>
	tname = k_thread_name_get((struct k_thread *)thread);
  1033f9:	4c 89 e7             	mov    %r12,%rdi
  1033fc:	e8 bd a2 00 00       	callq  10d6be <k_thread_name_get>
	pcnt = ((size - unused) * 100U) / size;
  103401:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  103405:	48 89 de             	mov    %rbx,%rsi
  103408:	31 d2                	xor    %edx,%edx
	tname = k_thread_name_get((struct k_thread *)thread);
  10340a:	49 89 c0             	mov    %rax,%r8
	pcnt = ((size - unused) * 100U) / size;
  10340d:	48 29 ce             	sub    %rcx,%rsi
  103410:	48 6b c6 64          	imul   $0x64,%rsi,%rax
  103414:	48 f7 f3             	div    %rbx
	shell_print((const struct shell *)user_data,
  103417:	4d 85 c0             	test   %r8,%r8
  10341a:	75 06                	jne    103422 <shell_stack_dump+0x65>
  10341c:	41 b8 6c d3 11 00    	mov    $0x11d36c,%r8d
  103422:	50                   	push   %rax
  103423:	49 89 d9             	mov    %rbx,%r9
  103426:	ba 9c d3 11 00       	mov    $0x11d39c,%edx
  10342b:	4c 89 ef             	mov    %r13,%rdi
  10342e:	53                   	push   %rbx
  10342f:	31 c0                	xor    %eax,%eax
  103431:	56                   	push   %rsi
  103432:	31 f6                	xor    %esi,%esi
  103434:	51                   	push   %rcx
  103435:	4c 89 e1             	mov    %r12,%rcx
  103438:	e8 56 27 00 00       	callq  105b93 <shell_fprintf>
  10343d:	48 83 c4 20          	add    $0x20,%rsp
}
  103441:	48 8d 65 e8          	lea    -0x18(%rbp),%rsp
  103445:	5b                   	pop    %rbx
  103446:	41 5c                	pop    %r12
  103448:	41 5d                	pop    %r13
  10344a:	5d                   	pop    %rbp
  10344b:	c3                   	retq   

000000000010344c <shell_tdata_dump>:
{
  10344c:	55                   	push   %rbp
  10344d:	48 89 e5             	mov    %rsp,%rbp
  103450:	41 56                	push   %r14
  103452:	41 55                	push   %r13
  103454:	49 89 f5             	mov    %rsi,%r13
  103457:	41 54                	push   %r12
  103459:	49 89 fc             	mov    %rdi,%r12
  10345c:	53                   	push   %rbx
  10345d:	48 83 ec 30          	sub    $0x30,%rsp
	size_t size = thread->stack_info.size;
  103461:	4c 8b b7 10 01 00 00 	mov    0x110(%rdi),%r14
	tname = k_thread_name_get(thread);
  103468:	e8 51 a2 00 00       	callq  10d6be <k_thread_name_get>
	shell_print(shell, "%s%p %-10s",
  10346d:	41 b9 6c d3 11 00    	mov    $0x11d36c,%r9d
  103473:	48 85 c0             	test   %rax,%rax
  103476:	74 03                	je     10347b <shell_tdata_dump+0x2f>
  103478:	49 89 c1             	mov    %rax,%r9
	__asm__ volatile ("mov %%cs, %[cs_val]" : [cs_val] "=r" (cs));
  10347b:	8c c8                	mov    %cs,%eax
	if (z_syscall_trap()) {
  10347d:	a8 03                	test   $0x3,%al
  10347f:	74 09                	je     10348a <shell_tdata_dump+0x3e>
	register uintptr_t rax __asm__("%rax") = call_id;
  103481:	b8 48 01 00 00       	mov    $0x148,%eax
	__asm__ volatile("syscall\n\t"
  103486:	0f 05                	syscall 
		return (k_tid_t) arch_syscall_invoke0(K_SYSCALL_Z_CURRENT_GET);
  103488:	eb 0d                	jmp    103497 <shell_tdata_dump+0x4b>
  10348a:	4c 89 4d b8          	mov    %r9,-0x48(%rbp)
	return z_impl_z_current_get();
  10348e:	e8 bb f2 00 00       	callq  11274e <z_impl_z_current_get>
  103493:	4c 8b 4d b8          	mov    -0x48(%rbp),%r9
  103497:	49 39 c4             	cmp    %rax,%r12
  10349a:	b9 d6 d3 11 00       	mov    $0x11d3d6,%ecx
  10349f:	b8 b7 d2 11 00       	mov    $0x11d2b7,%eax
  1034a4:	4d 89 e0             	mov    %r12,%r8
  1034a7:	48 0f 45 c8          	cmovne %rax,%rcx
  1034ab:	ba d8 d3 11 00       	mov    $0x11d3d8,%edx
  1034b0:	31 f6                	xor    %esi,%esi
  1034b2:	31 c0                	xor    %eax,%eax
  1034b4:	4c 89 ef             	mov    %r13,%rdi
  1034b7:	e8 d7 26 00 00       	callq  105b93 <shell_fprintf>
	shell_print(shell, "\toptions: 0x%x, priority: %d timeout: %d",
  1034bc:	4d 8b 4c 24 40       	mov    0x40(%r12),%r9
  1034c1:	31 f6                	xor    %esi,%esi
  1034c3:	31 c0                	xor    %eax,%eax
  1034c5:	45 0f be 44 24 1a    	movsbl 0x1a(%r12),%r8d
  1034cb:	41 0f b6 4c 24 18    	movzbl 0x18(%r12),%ecx
  1034d1:	ba e4 d3 11 00       	mov    $0x11d3e4,%edx
  1034d6:	4c 89 ef             	mov    %r13,%rdi
  1034d9:	e8 b5 26 00 00       	callq  105b93 <shell_fprintf>
	shell_print(shell, "\tstate: %s, entry: %p", k_thread_state_str(thread),
  1034de:	4c 89 e7             	mov    %r12,%rdi
  1034e1:	e8 e0 a1 00 00       	callq  10d6c6 <k_thread_state_str>
  1034e6:	ba 0e d4 11 00       	mov    $0x11d40e,%edx
  1034eb:	31 f6                	xor    %esi,%esi
  1034ed:	4c 89 ef             	mov    %r13,%rdi
  1034f0:	41 ff b4 24 c8 00 00 	pushq  0xc8(%r12)
  1034f7:	00 
  1034f8:	48 89 c1             	mov    %rax,%rcx
  1034fb:	31 c0                	xor    %eax,%eax
  1034fd:	41 ff b4 24 c0 00 00 	pushq  0xc0(%r12)
  103504:	00 
  103505:	41 ff b4 24 b8 00 00 	pushq  0xb8(%r12)
  10350c:	00 
  10350d:	41 ff b4 24 b0 00 00 	pushq  0xb0(%r12)
  103514:	00 
  103515:	e8 79 26 00 00       	callq  105b93 <shell_fprintf>
  10351a:	48 83 c4 20          	add    $0x20,%rsp
	if (k_thread_runtime_stats_get(thread, &rt_stats_thread) != 0) {
  10351e:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  103522:	4c 89 e7             	mov    %r12,%rdi
  103525:	e8 ba b0 00 00       	callq  10e5e4 <k_thread_runtime_stats_get>
	if (k_thread_runtime_stats_all_get(&rt_stats_all) != 0) {
  10352a:	48 8d 7d d8          	lea    -0x28(%rbp),%rdi
	if (k_thread_runtime_stats_get(thread, &rt_stats_thread) != 0) {
  10352e:	89 c3                	mov    %eax,%ebx
	if (k_thread_runtime_stats_all_get(&rt_stats_all) != 0) {
  103530:	e8 de b0 00 00       	callq  10e613 <k_thread_runtime_stats_all_get>
	if (k_thread_runtime_stats_get(thread, &rt_stats_thread) != 0) {
  103535:	31 d2                	xor    %edx,%edx
  103537:	85 db                	test   %ebx,%ebx
  103539:	0f 95 c2             	setne  %dl
	if (ret == 0) {
  10353c:	09 c2                	or     %eax,%edx
  10353e:	75 24                	jne    103564 <shell_tdata_dump+0x118>
		pcnt = (rt_stats_thread.execution_cycles * 100U) /
  103540:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
  103544:	31 d2                	xor    %edx,%edx
		shell_print(shell, "\tTotal execution cycles: %llu (%u %%)",
  103546:	31 f6                	xor    %esi,%esi
  103548:	4c 89 ef             	mov    %r13,%rdi
		pcnt = (rt_stats_thread.execution_cycles * 100U) /
  10354b:	48 6b c1 64          	imul   $0x64,%rcx,%rax
  10354f:	48 f7 75 d8          	divq   -0x28(%rbp)
		shell_print(shell, "\tTotal execution cycles: %llu (%u %%)",
  103553:	ba 25 d4 11 00       	mov    $0x11d425,%edx
  103558:	41 89 c0             	mov    %eax,%r8d
  10355b:	31 c0                	xor    %eax,%eax
  10355d:	e8 31 26 00 00       	callq  105b93 <shell_fprintf>
  103562:	eb 11                	jmp    103575 <shell_tdata_dump+0x129>
		shell_print(shell, "\tTotal execution cycles: ? (? %%)");
  103564:	ba 4c d4 11 00       	mov    $0x11d44c,%edx
  103569:	31 f6                	xor    %esi,%esi
  10356b:	4c 89 ef             	mov    %r13,%rdi
  10356e:	31 c0                	xor    %eax,%eax
  103570:	e8 1e 26 00 00       	callq  105b93 <shell_fprintf>
	ret = k_thread_stack_space_get(thread, &unused);
  103575:	48 8d 75 c8          	lea    -0x38(%rbp),%rsi
  103579:	4c 89 e7             	mov    %r12,%rdi
  10357c:	e8 29 fe ff ff       	callq  1033aa <k_thread_stack_space_get>
  103581:	89 c1                	mov    %eax,%ecx
	if (ret) {
  103583:	85 c0                	test   %eax,%eax
  103585:	74 13                	je     10359a <shell_tdata_dump+0x14e>
		shell_print(shell,
  103587:	ba 6f d3 11 00       	mov    $0x11d36f,%edx
  10358c:	31 f6                	xor    %esi,%esi
  10358e:	4c 89 ef             	mov    %r13,%rdi
  103591:	31 c0                	xor    %eax,%eax
  103593:	e8 fb 25 00 00       	callq  105b93 <shell_fprintf>
  103598:	eb 2d                	jmp    1035c7 <shell_tdata_dump+0x17b>
		pcnt = ((size - unused) * 100U) / size;
  10359a:	4d 89 f1             	mov    %r14,%r9
  10359d:	4c 2b 4d c8          	sub    -0x38(%rbp),%r9
  1035a1:	31 d2                	xor    %edx,%edx
		shell_print(shell,
  1035a3:	4c 8b 45 c8          	mov    -0x38(%rbp),%r8
		pcnt = ((size - unused) * 100U) / size;
  1035a7:	49 6b c1 64          	imul   $0x64,%r9,%rax
		shell_print(shell,
  1035ab:	4c 89 f1             	mov    %r14,%rcx
  1035ae:	31 f6                	xor    %esi,%esi
  1035b0:	4c 89 ef             	mov    %r13,%rdi
		pcnt = ((size - unused) * 100U) / size;
  1035b3:	49 f7 f6             	div    %r14
		shell_print(shell,
  1035b6:	ba 6f d4 11 00       	mov    $0x11d46f,%edx
  1035bb:	50                   	push   %rax
  1035bc:	31 c0                	xor    %eax,%eax
  1035be:	41 56                	push   %r14
  1035c0:	e8 ce 25 00 00       	callq  105b93 <shell_fprintf>
  1035c5:	58                   	pop    %rax
  1035c6:	5a                   	pop    %rdx
}
  1035c7:	48 8d 65 e0          	lea    -0x20(%rbp),%rsp
  1035cb:	5b                   	pop    %rbx
  1035cc:	41 5c                	pop    %r12
  1035ce:	41 5d                	pop    %r13
  1035d0:	41 5e                	pop    %r14
  1035d2:	5d                   	pop    %rbp
  1035d3:	c3                   	retq   

00000000001035d4 <get_device_name>:
};

static const char *get_device_name(const struct device *dev,
				   char *buf,
				   size_t len)
{
  1035d4:	55                   	push   %rbp
  1035d5:	48 89 e5             	mov    %rsp,%rbp
  1035d8:	53                   	push   %rbx
  1035d9:	48 89 f3             	mov    %rsi,%rbx
  1035dc:	48 89 d6             	mov    %rdx,%rsi
  1035df:	51                   	push   %rcx
	const char *name = dev->name;
  1035e0:	48 8b 07             	mov    (%rdi),%rax
{
  1035e3:	48 89 f9             	mov    %rdi,%rcx

	if ((name == NULL) || (name[0] == 0)) {
  1035e6:	48 85 c0             	test   %rax,%rax
  1035e9:	74 05                	je     1035f0 <get_device_name+0x1c>
  1035eb:	80 38 00             	cmpb   $0x0,(%rax)
  1035ee:	75 12                	jne    103602 <get_device_name+0x2e>
		snprintf(buf, len, "[%p]", dev);
  1035f0:	ba 3f d5 11 00       	mov    $0x11d53f,%edx
  1035f5:	48 89 df             	mov    %rbx,%rdi
  1035f8:	31 c0                	xor    %eax,%eax
  1035fa:	e8 60 6c 00 00       	callq  10a25f <snprintf>
		name = buf;
  1035ff:	48 89 d8             	mov    %rbx,%rax
	}

	return name;
}
  103602:	5a                   	pop    %rdx
  103603:	5b                   	pop    %rbx
  103604:	5d                   	pop    %rbp
  103605:	c3                   	retq   

0000000000103606 <cmd_device_list_visitor>:
	size_t buf_size;
};

static int cmd_device_list_visitor(const struct device *dev,
				   void *context)
{
  103606:	55                   	push   %rbp
  103607:	48 89 e5             	mov    %rsp,%rbp
  10360a:	53                   	push   %rbx
  10360b:	48 89 f3             	mov    %rsi,%rbx
  10360e:	50                   	push   %rax
	const struct cmd_device_list_visitor_context *ctx = context;

	shell_fprintf(ctx->shell, SHELL_NORMAL, "  requires: %s\n",
  10360f:	48 8b 56 10          	mov    0x10(%rsi),%rdx
  103613:	48 8b 76 08          	mov    0x8(%rsi),%rsi
  103617:	e8 b8 ff ff ff       	callq  1035d4 <get_device_name>
  10361c:	48 8b 3b             	mov    (%rbx),%rdi
  10361f:	ba 44 d5 11 00       	mov    $0x11d544,%edx
  103624:	31 f6                	xor    %esi,%esi
  103626:	48 89 c1             	mov    %rax,%rcx
  103629:	31 c0                	xor    %eax,%eax
  10362b:	e8 63 25 00 00       	callq  105b93 <shell_fprintf>
		      get_device_name(dev, ctx->buf, ctx->buf_size));

	return 0;
}
  103630:	5a                   	pop    %rdx
  103631:	31 c0                	xor    %eax,%eax
  103633:	5b                   	pop    %rbx
  103634:	5d                   	pop    %rbp
  103635:	c3                   	retq   

0000000000103636 <device_usable_check>:

extern int z_impl_device_usable_check(const struct device * dev);

__pinned_func
static inline int device_usable_check(const struct device * dev)
{
  103636:	55                   	push   %rbp
  103637:	48 89 e5             	mov    %rsp,%rbp
  10363a:	41 54                	push   %r12
  10363c:	51                   	push   %rcx
	__asm__ volatile ("mov %%cs, %[cs_val]" : [cs_val] "=r" (cs));
  10363d:	41 8c cc             	mov    %cs,%r12d
#ifdef CONFIG_USERSPACE
	if (z_syscall_trap()) {
  103640:	41 83 e4 03          	and    $0x3,%r12d
  103644:	74 0c                	je     103652 <device_usable_check+0x1c>
	register uintptr_t rax __asm__("%rax") = call_id;
  103646:	b8 2f 00 00 00       	mov    $0x2f,%eax
	__asm__ volatile("syscall\n\t"
  10364b:	0f 05                	syscall 
		/* coverity[OVERRUN] */
		return (int) arch_syscall_invoke1(*(uintptr_t *)&dev, K_SYSCALL_DEVICE_USABLE_CHECK);
  10364d:	41 89 c4             	mov    %eax,%r12d
  103650:	eb 10                	jmp    103662 <device_usable_check+0x2c>
 *
 * @return a non-positive integer as documented in device_usable_check().
 */
static inline int z_device_usable_check(const struct device *dev)
{
	return z_device_ready(dev) ? 0 : -ENODEV;
  103652:	e8 fe 97 00 00       	callq  10ce55 <z_device_ready>
  103657:	84 c0                	test   %al,%al
  103659:	b8 ed ff ff ff       	mov    $0xffffffed,%eax
  10365e:	44 0f 44 e0          	cmove  %eax,%r12d
	}
#endif
	compiler_barrier();
	return z_impl_device_usable_check(dev);
}
  103662:	44 89 e0             	mov    %r12d,%eax
  103665:	5a                   	pop    %rdx
  103666:	41 5c                	pop    %r12
  103668:	5d                   	pop    %rbp
  103669:	c3                   	retq   

000000000010366a <device_get_config_level>:
{
  10366a:	55                   	push   %rbp
	for (dev = levels[level]; dev < levels[level+1]; dev++) {
  10366b:	48 63 c6             	movslq %esi,%rax
  10366e:	ff c6                	inc    %esi
{
  103670:	48 89 e5             	mov    %rsp,%rbp
  103673:	41 56                	push   %r14
	bool devices = false;
  103675:	45 31 f6             	xor    %r14d,%r14d
{
  103678:	41 55                	push   %r13
  10367a:	41 54                	push   %r12
  10367c:	49 89 fc             	mov    %rdi,%r12
  10367f:	53                   	push   %rbx
	for (dev = levels[level]; dev < levels[level+1]; dev++) {
  103680:	48 63 de             	movslq %esi,%rbx
{
  103683:	48 83 ec 20          	sub    $0x20,%rsp
	for (dev = levels[level]; dev < levels[level+1]; dev++) {
  103687:	4c 8b 2c c5 60 a6 11 	mov    0x11a660(,%rax,8),%r13
  10368e:	00 
  10368f:	4c 39 2c dd 60 a6 11 	cmp    %r13,0x11a660(,%rbx,8)
  103696:	00 
  103697:	76 3a                	jbe    1036d3 <device_get_config_level+0x69>
 * @retval false if the device is not ready for use or if a NULL device pointer
 * is passed as argument.
 */
static inline bool device_is_ready(const struct device *dev)
{
	return device_usable_check(dev) == 0;
  103699:	4c 89 ef             	mov    %r13,%rdi
  10369c:	e8 95 ff ff ff       	callq  103636 <device_usable_check>
		if (device_is_ready(dev)) {
  1036a1:	85 c0                	test   %eax,%eax
  1036a3:	75 28                	jne    1036cd <device_get_config_level+0x63>
			shell_fprintf(shell, SHELL_NORMAL, "- %s\n",
  1036a5:	ba 14 00 00 00       	mov    $0x14,%edx
  1036aa:	48 8d 75 cc          	lea    -0x34(%rbp),%rsi
  1036ae:	4c 89 ef             	mov    %r13,%rdi
			devices = true;
  1036b1:	41 b6 01             	mov    $0x1,%r14b
			shell_fprintf(shell, SHELL_NORMAL, "- %s\n",
  1036b4:	e8 1b ff ff ff       	callq  1035d4 <get_device_name>
  1036b9:	ba 54 d5 11 00       	mov    $0x11d554,%edx
  1036be:	31 f6                	xor    %esi,%esi
  1036c0:	4c 89 e7             	mov    %r12,%rdi
  1036c3:	48 89 c1             	mov    %rax,%rcx
  1036c6:	31 c0                	xor    %eax,%eax
  1036c8:	e8 c6 24 00 00       	callq  105b93 <shell_fprintf>
	for (dev = levels[level]; dev < levels[level+1]; dev++) {
  1036cd:	49 83 c5 30          	add    $0x30,%r13
  1036d1:	eb bc                	jmp    10368f <device_get_config_level+0x25>
}
  1036d3:	48 83 c4 20          	add    $0x20,%rsp
  1036d7:	44 89 f0             	mov    %r14d,%eax
  1036da:	5b                   	pop    %rbx
  1036db:	41 5c                	pop    %r12
  1036dd:	41 5d                	pop    %r13
  1036df:	41 5e                	pop    %r14
  1036e1:	5d                   	pop    %rbp
  1036e2:	c3                   	retq   

00000000001036e3 <cmd_device_levels>:
{
  1036e3:	55                   	push   %rbp
	shell_fprintf(shell, SHELL_NORMAL, "PRE KERNEL 1:\n");
  1036e4:	31 f6                	xor    %esi,%esi
  1036e6:	31 c0                	xor    %eax,%eax
  1036e8:	ba 5a d5 11 00       	mov    $0x11d55a,%edx
{
  1036ed:	48 89 e5             	mov    %rsp,%rbp
  1036f0:	41 54                	push   %r12
  1036f2:	49 89 fc             	mov    %rdi,%r12
  1036f5:	51                   	push   %rcx
	shell_fprintf(shell, SHELL_NORMAL, "PRE KERNEL 1:\n");
  1036f6:	e8 98 24 00 00       	callq  105b93 <shell_fprintf>
	ret = device_get_config_level(shell, _SYS_INIT_LEVEL_PRE_KERNEL_1);
  1036fb:	31 f6                	xor    %esi,%esi
  1036fd:	4c 89 e7             	mov    %r12,%rdi
  103700:	e8 65 ff ff ff       	callq  10366a <device_get_config_level>
	if (ret == false) {
  103705:	84 c0                	test   %al,%al
  103707:	75 0f                	jne    103718 <cmd_device_levels+0x35>
		shell_fprintf(shell, SHELL_NORMAL, "- None\n");
  103709:	ba 69 d5 11 00       	mov    $0x11d569,%edx
  10370e:	31 f6                	xor    %esi,%esi
  103710:	4c 89 e7             	mov    %r12,%rdi
  103713:	e8 7b 24 00 00       	callq  105b93 <shell_fprintf>
	shell_fprintf(shell, SHELL_NORMAL, "PRE KERNEL 2:\n");
  103718:	31 f6                	xor    %esi,%esi
  10371a:	4c 89 e7             	mov    %r12,%rdi
  10371d:	31 c0                	xor    %eax,%eax
  10371f:	ba 71 d5 11 00       	mov    $0x11d571,%edx
  103724:	e8 6a 24 00 00       	callq  105b93 <shell_fprintf>
	ret = device_get_config_level(shell, _SYS_INIT_LEVEL_PRE_KERNEL_2);
  103729:	be 01 00 00 00       	mov    $0x1,%esi
  10372e:	4c 89 e7             	mov    %r12,%rdi
  103731:	e8 34 ff ff ff       	callq  10366a <device_get_config_level>
	if (ret == false) {
  103736:	84 c0                	test   %al,%al
  103738:	75 0f                	jne    103749 <cmd_device_levels+0x66>
		shell_fprintf(shell, SHELL_NORMAL, "- None\n");
  10373a:	ba 69 d5 11 00       	mov    $0x11d569,%edx
  10373f:	31 f6                	xor    %esi,%esi
  103741:	4c 89 e7             	mov    %r12,%rdi
  103744:	e8 4a 24 00 00       	callq  105b93 <shell_fprintf>
	shell_fprintf(shell, SHELL_NORMAL, "POST_KERNEL:\n");
  103749:	31 f6                	xor    %esi,%esi
  10374b:	4c 89 e7             	mov    %r12,%rdi
  10374e:	31 c0                	xor    %eax,%eax
  103750:	ba 80 d5 11 00       	mov    $0x11d580,%edx
  103755:	e8 39 24 00 00       	callq  105b93 <shell_fprintf>
	ret = device_get_config_level(shell, _SYS_INIT_LEVEL_POST_KERNEL);
  10375a:	be 02 00 00 00       	mov    $0x2,%esi
  10375f:	4c 89 e7             	mov    %r12,%rdi
  103762:	e8 03 ff ff ff       	callq  10366a <device_get_config_level>
	if (ret == false) {
  103767:	84 c0                	test   %al,%al
  103769:	75 0f                	jne    10377a <cmd_device_levels+0x97>
		shell_fprintf(shell, SHELL_NORMAL, "- None\n");
  10376b:	ba 69 d5 11 00       	mov    $0x11d569,%edx
  103770:	31 f6                	xor    %esi,%esi
  103772:	4c 89 e7             	mov    %r12,%rdi
  103775:	e8 19 24 00 00       	callq  105b93 <shell_fprintf>
	shell_fprintf(shell, SHELL_NORMAL, "APPLICATION:\n");
  10377a:	31 f6                	xor    %esi,%esi
  10377c:	4c 89 e7             	mov    %r12,%rdi
  10377f:	31 c0                	xor    %eax,%eax
  103781:	ba 8e d5 11 00       	mov    $0x11d58e,%edx
  103786:	e8 08 24 00 00       	callq  105b93 <shell_fprintf>
	ret = device_get_config_level(shell, _SYS_INIT_LEVEL_APPLICATION);
  10378b:	be 03 00 00 00       	mov    $0x3,%esi
  103790:	4c 89 e7             	mov    %r12,%rdi
  103793:	e8 d2 fe ff ff       	callq  10366a <device_get_config_level>
	if (ret == false) {
  103798:	84 c0                	test   %al,%al
  10379a:	75 0f                	jne    1037ab <cmd_device_levels+0xc8>
		shell_fprintf(shell, SHELL_NORMAL, "- None\n");
  10379c:	ba 69 d5 11 00       	mov    $0x11d569,%edx
  1037a1:	31 f6                	xor    %esi,%esi
  1037a3:	4c 89 e7             	mov    %r12,%rdi
  1037a6:	e8 e8 23 00 00       	callq  105b93 <shell_fprintf>
}
  1037ab:	5a                   	pop    %rdx
  1037ac:	31 c0                	xor    %eax,%eax
  1037ae:	41 5c                	pop    %r12
  1037b0:	5d                   	pop    %rbp
  1037b1:	c3                   	retq   

00000000001037b2 <cmd_device_list>:

static int cmd_device_list(const struct shell *shell,
			   size_t argc, char **argv)
{
  1037b2:	55                   	push   %rbp
  1037b3:	48 89 e5             	mov    %rsp,%rbp
  1037b6:	41 56                	push   %r14
  1037b8:	41 55                	push   %r13

	shell_fprintf(shell, SHELL_NORMAL, "devices:\n");

	for (dev = devlist; dev < devlist_end; dev++) {
		char buf[20];
		const char *name = get_device_name(dev, buf, sizeof(buf));
  1037ba:	4c 8d 75 b4          	lea    -0x4c(%rbp),%r14
{
  1037be:	41 54                	push   %r12
  1037c0:	49 89 fc             	mov    %rdi,%r12
	size_t devcnt = z_device_get_all_static(&devlist);
  1037c3:	48 8d 7d a8          	lea    -0x58(%rbp),%rdi
{
  1037c7:	53                   	push   %rbx
  1037c8:	48 83 ec 40          	sub    $0x40,%rsp
	size_t devcnt = z_device_get_all_static(&devlist);
  1037cc:	e8 5f 96 00 00       	callq  10ce30 <z_device_get_all_static>
	shell_fprintf(shell, SHELL_NORMAL, "devices:\n");
  1037d1:	ba ab d5 11 00       	mov    $0x11d5ab,%edx
  1037d6:	31 f6                	xor    %esi,%esi
  1037d8:	4c 89 e7             	mov    %r12,%rdi
	const struct device *devlist_end = devlist + devcnt;
  1037db:	4c 6b e8 30          	imul   $0x30,%rax,%r13
	shell_fprintf(shell, SHELL_NORMAL, "devices:\n");
  1037df:	31 c0                	xor    %eax,%eax
	const struct device *devlist_end = devlist + devcnt;
  1037e1:	4c 03 6d a8          	add    -0x58(%rbp),%r13
	shell_fprintf(shell, SHELL_NORMAL, "devices:\n");
  1037e5:	e8 a9 23 00 00       	callq  105b93 <shell_fprintf>
	for (dev = devlist; dev < devlist_end; dev++) {
  1037ea:	48 8b 5d a8          	mov    -0x58(%rbp),%rbx
  1037ee:	4c 39 eb             	cmp    %r13,%rbx
  1037f1:	73 7a                	jae    10386d <cmd_device_list+0xbb>
		const char *name = get_device_name(dev, buf, sizeof(buf));
  1037f3:	4c 89 f6             	mov    %r14,%rsi
  1037f6:	48 89 df             	mov    %rbx,%rdi
  1037f9:	ba 14 00 00 00       	mov    $0x14,%edx
  1037fe:	e8 d1 fd ff ff       	callq  1035d4 <get_device_name>
		const char *state = "READY";

		shell_fprintf(shell, SHELL_NORMAL, "- %s", name);
  103803:	31 f6                	xor    %esi,%esi
  103805:	ba b5 d5 11 00       	mov    $0x11d5b5,%edx
  10380a:	4c 89 e7             	mov    %r12,%rdi
		const char *name = get_device_name(dev, buf, sizeof(buf));
  10380d:	48 89 c1             	mov    %rax,%rcx
		shell_fprintf(shell, SHELL_NORMAL, "- %s", name);
  103810:	31 c0                	xor    %eax,%eax
  103812:	e8 7c 23 00 00       	callq  105b93 <shell_fprintf>
  103817:	48 89 df             	mov    %rbx,%rdi
  10381a:	e8 17 fe ff ff       	callq  103636 <device_usable_check>
		if (!device_is_ready(dev)) {
			state = "DISABLED";
  10381f:	b9 9c d5 11 00       	mov    $0x11d59c,%ecx
				state = pm_device_state_str(st);
			}
#endif /* CONFIG_PM_DEVICE */
		}

		shell_fprintf(shell, SHELL_NORMAL, " (%s)\n", state);
  103824:	ba 56 f5 11 00       	mov    $0x11f556,%edx
  103829:	4c 89 e7             	mov    %r12,%rdi
			state = "DISABLED";
  10382c:	85 c0                	test   %eax,%eax
  10382e:	b8 a2 d5 11 00       	mov    $0x11d5a2,%eax
  103833:	48 0f 45 c8          	cmovne %rax,%rcx
		shell_fprintf(shell, SHELL_NORMAL, " (%s)\n", state);
  103837:	31 f6                	xor    %esi,%esi
  103839:	31 c0                	xor    %eax,%eax
  10383b:	e8 53 23 00 00       	callq  105b93 <shell_fprintf>
	__asm__ volatile ("mov %%cs, %[cs_val]" : [cs_val] "=r" (cs));
  103840:	8c c8                	mov    %cs,%eax
		if (!k_is_user_context()) {
  103842:	a8 03                	test   $0x3,%al
  103844:	75 21                	jne    103867 <cmd_device_list+0xb5>
				.shell = shell,
				.buf = buf,
				.buf_size = sizeof(buf),
			};

			(void)device_required_foreach(dev, cmd_device_list_visitor, &ctx);
  103846:	48 8d 55 c8          	lea    -0x38(%rbp),%rdx
  10384a:	be 06 36 10 00       	mov    $0x103606,%esi
  10384f:	48 89 df             	mov    %rbx,%rdi
			struct cmd_device_list_visitor_context ctx = {
  103852:	4c 89 65 c8          	mov    %r12,-0x38(%rbp)
  103856:	4c 89 75 d0          	mov    %r14,-0x30(%rbp)
  10385a:	48 c7 45 d8 14 00 00 	movq   $0x14,-0x28(%rbp)
  103861:	00 
			(void)device_required_foreach(dev, cmd_device_list_visitor, &ctx);
  103862:	e8 71 97 00 00       	callq  10cfd8 <device_required_foreach>
	for (dev = devlist; dev < devlist_end; dev++) {
  103867:	48 83 c3 30          	add    $0x30,%rbx
  10386b:	eb 81                	jmp    1037ee <cmd_device_list+0x3c>
		}
	}

	return 0;
}
  10386d:	48 83 c4 40          	add    $0x40,%rsp
  103871:	31 c0                	xor    %eax,%eax
  103873:	5b                   	pop    %rbx
  103874:	41 5c                	pop    %r12
  103876:	41 5d                	pop    %r13
  103878:	41 5e                	pop    %r14
  10387a:	5d                   	pop    %rbp
  10387b:	c3                   	retq   

000000000010387c <date_print>:

#define HELP_NONE      "[none]"
#define HELP_DATE_SET  "[Y-m-d] <H:M:S>"

static void date_print(const struct shell *shell, struct tm *tm)
{
  10387c:	55                   	push   %rbp
	shell_print(shell,
  10387d:	8b 46 10             	mov    0x10(%rsi),%eax
  103880:	8b 4e 14             	mov    0x14(%rsi),%ecx
  103883:	44 8d 40 01          	lea    0x1(%rax),%r8d
  103887:	31 c0                	xor    %eax,%eax
{
  103889:	48 89 e5             	mov    %rsp,%rbp
	shell_print(shell,
  10388c:	52                   	push   %rdx
  10388d:	8b 16                	mov    (%rsi),%edx
  10388f:	81 c1 6c 07 00 00    	add    $0x76c,%ecx
  103895:	52                   	push   %rdx
  103896:	8b 56 04             	mov    0x4(%rsi),%edx
  103899:	52                   	push   %rdx
  10389a:	8b 56 08             	mov    0x8(%rsi),%edx
  10389d:	52                   	push   %rdx
  10389e:	44 8b 4e 0c          	mov    0xc(%rsi),%r9d
  1038a2:	ba 10 d6 11 00       	mov    $0x11d610,%edx
  1038a7:	31 f6                	xor    %esi,%esi
  1038a9:	e8 e5 22 00 00       	callq  105b93 <shell_fprintf>
  1038ae:	48 83 c4 20          	add    $0x20,%rsp
		    tm->tm_mon + 1,
		    tm->tm_mday,
		    tm->tm_hour,
		    tm->tm_min,
		    tm->tm_sec);
}
  1038b2:	c9                   	leaveq 
  1038b3:	c3                   	retq   

00000000001038b4 <get_h_m_s>:
 * For user convenience of small adjustments to time the time argument will
 * accept H:M:S, :M:S or ::S where the missing field(s) will be filled in by
 * the previous time state.
 */
static int get_h_m_s(const struct shell *shell, struct tm *tm, char *time_str)
{
  1038b4:	55                   	push   %rbp
  1038b5:	48 89 e5             	mov    %rsp,%rbp
  1038b8:	41 56                	push   %r14
  1038ba:	49 89 d6             	mov    %rdx,%r14
  1038bd:	41 55                	push   %r13
  1038bf:	49 89 f5             	mov    %rsi,%r13
  1038c2:	41 54                	push   %r12
  1038c4:	49 89 fc             	mov    %rdi,%r12
  1038c7:	53                   	push   %rbx
	char *endptr;

	if (*time_str == ':') {
		time_str++;
  1038c8:	48 8d 5a 01          	lea    0x1(%rdx),%rbx
{
  1038cc:	48 83 ec 10          	sub    $0x10,%rsp
	if (*time_str == ':') {
  1038d0:	80 3a 3a             	cmpb   $0x3a,(%rdx)
  1038d3:	74 40                	je     103915 <get_h_m_s+0x61>
	} else {
		endptr = NULL;
		tm->tm_hour = strtol(time_str, &endptr, 10);
  1038d5:	ba 0a 00 00 00       	mov    $0xa,%edx
  1038da:	48 8d 75 d8          	lea    -0x28(%rbp),%rsi
  1038de:	4c 89 f7             	mov    %r14,%rdi
		endptr = NULL;
  1038e1:	48 c7 45 d8 00 00 00 	movq   $0x0,-0x28(%rbp)
  1038e8:	00 
		tm->tm_hour = strtol(time_str, &endptr, 10);
  1038e9:	e8 43 63 00 00       	callq  109c31 <strtol>
		if (endptr == time_str) {
  1038ee:	48 8b 5d d8          	mov    -0x28(%rbp),%rbx
		tm->tm_hour = strtol(time_str, &endptr, 10);
  1038f2:	41 89 45 08          	mov    %eax,0x8(%r13)
		if (endptr == time_str) {
  1038f6:	4c 39 f3             	cmp    %r14,%rbx
  1038f9:	0f 84 ac 00 00 00    	je     1039ab <get_h_m_s+0xf7>
			return -EINVAL;
		} else if (*endptr == ':') {
  1038ff:	80 3b 3a             	cmpb   $0x3a,(%rbx)
  103902:	0f 85 a3 00 00 00    	jne    1039ab <get_h_m_s+0xf7>
			if ((tm->tm_hour < 0) || (tm->tm_hour > 23)) {
				shell_error(shell, "Invalid hour");
				return -EINVAL;
			}

			time_str = endptr + 1;
  103908:	48 ff c3             	inc    %rbx
				shell_error(shell, "Invalid hour");
  10390b:	ba 31 d6 11 00       	mov    $0x11d631,%edx
			if ((tm->tm_hour < 0) || (tm->tm_hour > 23)) {
  103910:	83 f8 17             	cmp    $0x17,%eax
  103913:	77 43                	ja     103958 <get_h_m_s+0xa4>
		} else {
			return -EINVAL;
		}
	}

	if (*time_str == ':') {
  103915:	80 3b 3a             	cmpb   $0x3a,(%rbx)
  103918:	75 05                	jne    10391f <get_h_m_s+0x6b>
		time_str++;
  10391a:	48 ff c3             	inc    %rbx
  10391d:	eb 45                	jmp    103964 <get_h_m_s+0xb0>
	} else {
		endptr = NULL;
		tm->tm_min = strtol(time_str, &endptr, 10);
  10391f:	ba 0a 00 00 00       	mov    $0xa,%edx
  103924:	48 8d 75 d8          	lea    -0x28(%rbp),%rsi
  103928:	48 89 df             	mov    %rbx,%rdi
		endptr = NULL;
  10392b:	48 c7 45 d8 00 00 00 	movq   $0x0,-0x28(%rbp)
  103932:	00 
		tm->tm_min = strtol(time_str, &endptr, 10);
  103933:	e8 f9 62 00 00       	callq  109c31 <strtol>
		if (endptr == time_str) {
  103938:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
		tm->tm_min = strtol(time_str, &endptr, 10);
  10393c:	41 89 45 04          	mov    %eax,0x4(%r13)
		if (endptr == time_str) {
  103940:	48 39 da             	cmp    %rbx,%rdx
  103943:	74 66                	je     1039ab <get_h_m_s+0xf7>
			return -EINVAL;
		} else if (*endptr == ':') {
  103945:	80 3a 3a             	cmpb   $0x3a,(%rdx)
  103948:	75 61                	jne    1039ab <get_h_m_s+0xf7>
			if ((tm->tm_min < 0) || (tm->tm_min > 59)) {
				shell_error(shell, "Invalid minute");
				return -EINVAL;
			}

			time_str = endptr + 1;
  10394a:	48 8d 5a 01          	lea    0x1(%rdx),%rbx
			if ((tm->tm_min < 0) || (tm->tm_min > 59)) {
  10394e:	83 f8 3b             	cmp    $0x3b,%eax
  103951:	76 11                	jbe    103964 <get_h_m_s+0xb0>
				shell_error(shell, "Invalid minute");
  103953:	ba 3f d6 11 00       	mov    $0x11d63f,%edx
  103958:	be 02 00 00 00       	mov    $0x2,%esi
  10395d:	4c 89 e7             	mov    %r12,%rdi
  103960:	31 c0                	xor    %eax,%eax
  103962:	eb 42                	jmp    1039a6 <get_h_m_s+0xf2>
			return -EINVAL;
		}
	}

	endptr = NULL;
	tm->tm_sec = strtol(time_str, &endptr, 10);
  103964:	ba 0a 00 00 00       	mov    $0xa,%edx
  103969:	48 8d 75 d8          	lea    -0x28(%rbp),%rsi
  10396d:	48 89 df             	mov    %rbx,%rdi
	endptr = NULL;
  103970:	48 c7 45 d8 00 00 00 	movq   $0x0,-0x28(%rbp)
  103977:	00 
	tm->tm_sec = strtol(time_str, &endptr, 10);
  103978:	e8 b4 62 00 00       	callq  109c31 <strtol>
  10397d:	41 89 45 00          	mov    %eax,0x0(%r13)
  103981:	48 89 c2             	mov    %rax,%rdx
	if ((endptr == time_str) || (*endptr != '\0')) {
  103984:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  103988:	48 39 d8             	cmp    %rbx,%rax
  10398b:	74 1e                	je     1039ab <get_h_m_s+0xf7>
  10398d:	80 38 00             	cmpb   $0x0,(%rax)
  103990:	75 19                	jne    1039ab <get_h_m_s+0xf7>
	if ((tm->tm_sec < 0) || (tm->tm_sec > 60)) {
		shell_error(shell, "Invalid second");
		return -EINVAL;
	}

	return 0;
  103992:	31 c0                	xor    %eax,%eax
	if ((tm->tm_sec < 0) || (tm->tm_sec > 60)) {
  103994:	83 fa 3c             	cmp    $0x3c,%edx
  103997:	76 17                	jbe    1039b0 <get_h_m_s+0xfc>
		shell_error(shell, "Invalid second");
  103999:	ba 4f d6 11 00       	mov    $0x11d64f,%edx
  10399e:	be 02 00 00 00       	mov    $0x2,%esi
  1039a3:	4c 89 e7             	mov    %r12,%rdi
  1039a6:	e8 e8 21 00 00       	callq  105b93 <shell_fprintf>
		return -EINVAL;
  1039ab:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
}
  1039b0:	5a                   	pop    %rdx
  1039b1:	59                   	pop    %rcx
  1039b2:	5b                   	pop    %rbx
  1039b3:	41 5c                	pop    %r12
  1039b5:	41 5d                	pop    %r13
  1039b7:	41 5e                	pop    %r14
  1039b9:	5d                   	pop    %rbp
  1039ba:	c3                   	retq   

00000000001039bb <clock_gettime.constprop.0.isra.0>:
#endif

extern int z_impl_clock_gettime(clockid_t clock_id, struct timespec * ts);

__pinned_func
static inline int clock_gettime(clockid_t clock_id, struct timespec * ts)
  1039bb:	55                   	push   %rbp
  1039bc:	48 89 fe             	mov    %rdi,%rsi
  1039bf:	48 89 e5             	mov    %rsp,%rbp
  1039c2:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%rbp)
  1039c9:	8c c8                	mov    %cs,%eax
{
#ifdef CONFIG_USERSPACE
	if (z_syscall_trap()) {
  1039cb:	a8 03                	test   $0x3,%al
  1039cd:	74 0d                	je     1039dc <clock_gettime.constprop.0.isra.0+0x21>
	register uintptr_t rdi __asm__("%rdi") = arg1;
  1039cf:	48 8b 7d fc          	mov    -0x4(%rbp),%rdi
	register uintptr_t rax __asm__("%rax") = call_id;
  1039d3:	b8 1b 00 00 00       	mov    $0x1b,%eax
	__asm__ volatile("syscall\n\t"
  1039d8:	0f 05                	syscall 
		return (int) arch_syscall_invoke2(*(uintptr_t *)&clock_id, *(uintptr_t *)&ts, K_SYSCALL_CLOCK_GETTIME);
	}
#endif
	compiler_barrier();
	return z_impl_clock_gettime(clock_id, ts);
}
  1039da:	5d                   	pop    %rbp
  1039db:	c3                   	retq   
	return z_impl_clock_gettime(clock_id, ts);
  1039dc:	8b 7d fc             	mov    -0x4(%rbp),%edi
}
  1039df:	5d                   	pop    %rbp
	return z_impl_clock_gettime(clock_id, ts);
  1039e0:	e9 3d 6b 00 00       	jmpq   10a522 <z_impl_clock_gettime>

00000000001039e5 <cmd_date_get>:

	return 0;
}

static int cmd_date_get(const struct shell *shell, size_t argc, char **argv)
{
  1039e5:	55                   	push   %rbp
  1039e6:	48 89 e5             	mov    %rsp,%rbp
  1039e9:	41 54                	push   %r12
  1039eb:	49 89 fc             	mov    %rdi,%r12
	struct timespec tp;
	struct tm tm;

	clock_gettime(CLOCK_REALTIME, &tp);
  1039ee:	48 8d 7d b8          	lea    -0x48(%rbp),%rdi
{
  1039f2:	48 83 ec 48          	sub    $0x48,%rsp
	clock_gettime(CLOCK_REALTIME, &tp);
  1039f6:	e8 c0 ff ff ff       	callq  1039bb <clock_gettime.constprop.0.isra.0>

	gmtime_r(&tp.tv_sec, &tm);
  1039fb:	48 8d 75 cc          	lea    -0x34(%rbp),%rsi
  1039ff:	48 8d 7d b8          	lea    -0x48(%rbp),%rdi
  103a03:	e8 05 69 00 00       	callq  10a30d <gmtime_r>

	date_print(shell, &tm);
  103a08:	48 8d 75 cc          	lea    -0x34(%rbp),%rsi
  103a0c:	4c 89 e7             	mov    %r12,%rdi
  103a0f:	e8 68 fe ff ff       	callq  10387c <date_print>

	return 0;
}
  103a14:	48 83 c4 48          	add    $0x48,%rsp
  103a18:	31 c0                	xor    %eax,%eax
  103a1a:	41 5c                	pop    %r12
  103a1c:	5d                   	pop    %rbp
  103a1d:	c3                   	retq   

0000000000103a1e <cmd_date_set>:
{
  103a1e:	55                   	push   %rbp
  103a1f:	48 89 e5             	mov    %rsp,%rbp
  103a22:	41 57                	push   %r15
  103a24:	41 56                	push   %r14
  103a26:	41 55                	push   %r13
  103a28:	49 89 f5             	mov    %rsi,%r13
  103a2b:	41 54                	push   %r12
  103a2d:	49 89 fc             	mov    %rdi,%r12
	clock_gettime(CLOCK_REALTIME, &tp);
  103a30:	48 8d 7d 98          	lea    -0x68(%rbp),%rdi
{
  103a34:	53                   	push   %rbx
  103a35:	48 89 d3             	mov    %rdx,%rbx
  103a38:	48 83 ec 58          	sub    $0x58,%rsp
	clock_gettime(CLOCK_REALTIME, &tp);
  103a3c:	e8 7a ff ff ff       	callq  1039bb <clock_gettime.constprop.0.isra.0>
	gmtime_r(&tp.tv_sec, &tm);
  103a41:	48 8d 75 ac          	lea    -0x54(%rbp),%rsi
  103a45:	48 8d 7d 98          	lea    -0x68(%rbp),%rdi
  103a49:	e8 bf 68 00 00       	callq  10a30d <gmtime_r>
	if (argc == 3) {
  103a4e:	49 83 fd 03          	cmp    $0x3,%r13
  103a52:	0f 85 f3 00 00 00    	jne    103b4b <cmd_date_set+0x12d>
		ret = get_y_m_d(shell, &tm, argv[1]);
  103a58:	4c 8b 6b 08          	mov    0x8(%rbx),%r13
	year = strtol(date_str, &endptr, 10);
  103a5c:	ba 0a 00 00 00       	mov    $0xa,%edx
  103a61:	48 8d 75 90          	lea    -0x70(%rbp),%rsi
	endptr = NULL;
  103a65:	48 c7 45 90 00 00 00 	movq   $0x0,-0x70(%rbp)
  103a6c:	00 
	year = strtol(date_str, &endptr, 10);
  103a6d:	4c 89 ef             	mov    %r13,%rdi
  103a70:	e8 bc 61 00 00       	callq  109c31 <strtol>
  103a75:	49 89 c6             	mov    %rax,%r14
	if ((endptr == date_str) || (*endptr != '-')) {
  103a78:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  103a7c:	49 39 c5             	cmp    %rax,%r13
  103a7f:	0f 84 bc 00 00 00    	je     103b41 <cmd_date_set+0x123>
  103a85:	80 38 2d             	cmpb   $0x2d,(%rax)
  103a88:	0f 85 b3 00 00 00    	jne    103b41 <cmd_date_set+0x123>
	date_str = endptr + 1;
  103a8e:	4c 8d 78 01          	lea    0x1(%rax),%r15
	month = strtol(date_str, &endptr, 10);
  103a92:	ba 0a 00 00 00       	mov    $0xa,%edx
  103a97:	48 8d 75 90          	lea    -0x70(%rbp),%rsi
	endptr = NULL;
  103a9b:	48 c7 45 90 00 00 00 	movq   $0x0,-0x70(%rbp)
  103aa2:	00 
	month = strtol(date_str, &endptr, 10);
  103aa3:	4c 89 ff             	mov    %r15,%rdi
  103aa6:	e8 86 61 00 00       	callq  109c31 <strtol>
	if ((endptr == date_str) || (*endptr != '-')) {
  103aab:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  103aaf:	49 39 d7             	cmp    %rdx,%r15
  103ab2:	0f 84 89 00 00 00    	je     103b41 <cmd_date_set+0x123>
  103ab8:	80 3a 2d             	cmpb   $0x2d,(%rdx)
  103abb:	0f 85 80 00 00 00    	jne    103b41 <cmd_date_set+0x123>
	if ((month < 1) || (month > 12)) {
  103ac1:	44 8d 68 ff          	lea    -0x1(%rax),%r13d
  103ac5:	41 83 fd 0b          	cmp    $0xb,%r13d
  103ac9:	76 07                	jbe    103ad2 <cmd_date_set+0xb4>
		shell_error(shell, "Invalid month");
  103acb:	ba 5f d6 11 00       	mov    $0x11d65f,%edx
  103ad0:	eb 38                	jmp    103b0a <cmd_date_set+0xec>
	date_str = endptr + 1;
  103ad2:	4c 8d 7a 01          	lea    0x1(%rdx),%r15
	day = strtol(date_str, &endptr, 10);
  103ad6:	48 8d 75 90          	lea    -0x70(%rbp),%rsi
  103ada:	ba 0a 00 00 00       	mov    $0xa,%edx
	endptr = NULL;
  103adf:	48 c7 45 90 00 00 00 	movq   $0x0,-0x70(%rbp)
  103ae6:	00 
	day = strtol(date_str, &endptr, 10);
  103ae7:	4c 89 ff             	mov    %r15,%rdi
  103aea:	e8 42 61 00 00       	callq  109c31 <strtol>
	if ((endptr == date_str) || (*endptr != '\0')) {
  103aef:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  103af3:	49 39 d7             	cmp    %rdx,%r15
  103af6:	74 49                	je     103b41 <cmd_date_set+0x123>
  103af8:	80 3a 00             	cmpb   $0x0,(%rdx)
  103afb:	75 44                	jne    103b41 <cmd_date_set+0x123>
	if ((day < 1) || (day > 31)) {
  103afd:	8d 50 ff             	lea    -0x1(%rax),%edx
  103b00:	83 fa 1e             	cmp    $0x1e,%edx
  103b03:	76 16                	jbe    103b1b <cmd_date_set+0xfd>
		shell_error(shell, "Invalid day");
  103b05:	ba 6e d6 11 00       	mov    $0x11d66e,%edx
  103b0a:	be 02 00 00 00       	mov    $0x2,%esi
  103b0f:	4c 89 e7             	mov    %r12,%rdi
  103b12:	31 c0                	xor    %eax,%eax
  103b14:	e8 7a 20 00 00       	callq  105b93 <shell_fprintf>
		if (ret != 0) {
  103b19:	eb 26                	jmp    103b41 <cmd_date_set+0x123>
	tm->tm_year = year - 1900;
  103b1b:	41 81 ee 6c 07 00 00 	sub    $0x76c,%r14d
	tm->tm_mon = month - 1;
  103b22:	44 89 6d bc          	mov    %r13d,-0x44(%rbp)
		ret = get_h_m_s(shell, &tm, argv[2]);
  103b26:	48 8b 53 10          	mov    0x10(%rbx),%rdx
	tm->tm_year = year - 1900;
  103b2a:	44 89 75 c0          	mov    %r14d,-0x40(%rbp)
	tm->tm_mday = day;
  103b2e:	89 45 b8             	mov    %eax,-0x48(%rbp)
		ret = get_h_m_s(shell, &tm, argv[2]);
  103b31:	48 8d 75 ac          	lea    -0x54(%rbp),%rsi
  103b35:	4c 89 e7             	mov    %r12,%rdi
  103b38:	e8 77 fd ff ff       	callq  1038b4 <get_h_m_s>
		if (ret != 0) {
  103b3d:	85 c0                	test   %eax,%eax
  103b3f:	74 16                	je     103b57 <cmd_date_set+0x139>
			shell_help(shell);
  103b41:	4c 89 e7             	mov    %r12,%rdi
  103b44:	e8 8e 22 00 00       	callq  105dd7 <shell_help>
			return -EINVAL;
  103b49:	eb 64                	jmp    103baf <cmd_date_set+0x191>
	} else if (argc == 2) {
  103b4b:	49 83 fd 02          	cmp    $0x2,%r13
  103b4f:	75 f0                	jne    103b41 <cmd_date_set+0x123>
		ret = get_h_m_s(shell, &tm, argv[1]);
  103b51:	48 8b 53 08          	mov    0x8(%rbx),%rdx
  103b55:	eb da                	jmp    103b31 <cmd_date_set+0x113>
	tp.tv_sec = timeutil_timegm(&tm);
  103b57:	48 8d 7d ac          	lea    -0x54(%rbp),%rdi
  103b5b:	e8 42 d5 ff ff       	callq  1010a2 <timeutil_timegm>
  103b60:	48 89 45 98          	mov    %rax,-0x68(%rbp)
	if (tp.tv_sec == -1) {
  103b64:	48 ff c0             	inc    %rax
  103b67:	75 16                	jne    103b7f <cmd_date_set+0x161>
		shell_error(shell, "Failed to calculate seconds since Epoch");
  103b69:	ba 7b d6 11 00       	mov    $0x11d67b,%edx
  103b6e:	be 02 00 00 00       	mov    $0x2,%esi
  103b73:	4c 89 e7             	mov    %r12,%rdi
  103b76:	31 c0                	xor    %eax,%eax
  103b78:	e8 16 20 00 00       	callq  105b93 <shell_fprintf>
		return -EINVAL;
  103b7d:	eb 30                	jmp    103baf <cmd_date_set+0x191>
	ret = clock_settime(CLOCK_REALTIME, &tp);
  103b7f:	48 8d 75 98          	lea    -0x68(%rbp),%rsi
  103b83:	bf 01 00 00 00       	mov    $0x1,%edi
	tp.tv_nsec = 0;
  103b88:	48 c7 45 a0 00 00 00 	movq   $0x0,-0x60(%rbp)
  103b8f:	00 
	ret = clock_settime(CLOCK_REALTIME, &tp);
  103b90:	e8 62 6b 00 00       	callq  10a6f7 <clock_settime>
	if (ret != 0) {
  103b95:	85 c0                	test   %eax,%eax
  103b97:	74 1d                	je     103bb6 <cmd_date_set+0x198>
		shell_error(shell, "Could not set date %d", ret);
  103b99:	89 c1                	mov    %eax,%ecx
  103b9b:	ba a4 d6 11 00       	mov    $0x11d6a4,%edx
  103ba0:	be 02 00 00 00       	mov    $0x2,%esi
  103ba5:	4c 89 e7             	mov    %r12,%rdi
  103ba8:	31 c0                	xor    %eax,%eax
  103baa:	e8 e4 1f 00 00       	callq  105b93 <shell_fprintf>
		return -EINVAL;
  103baf:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
  103bb4:	eb 12                	jmp    103bc8 <cmd_date_set+0x1aa>
	date_print(shell, &tm);
  103bb6:	48 8d 75 ac          	lea    -0x54(%rbp),%rsi
  103bba:	4c 89 e7             	mov    %r12,%rdi
  103bbd:	89 45 8c             	mov    %eax,-0x74(%rbp)
  103bc0:	e8 b7 fc ff ff       	callq  10387c <date_print>
  103bc5:	8b 45 8c             	mov    -0x74(%rbp),%eax
}
  103bc8:	48 83 c4 58          	add    $0x58,%rsp
  103bcc:	5b                   	pop    %rbx
  103bcd:	41 5c                	pop    %r12
  103bcf:	41 5d                	pop    %r13
  103bd1:	41 5e                	pop    %r14
  103bd3:	41 5f                	pop    %r15
  103bd5:	5d                   	pop    %rbp
  103bd6:	c3                   	retq   

0000000000103bd7 <cmd_devmem>:
	return err;
}

/* The syntax of the command is similar to busybox's devmem */
static int cmd_devmem(const struct shell *sh, size_t argc, char **argv)
{
  103bd7:	55                   	push   %rbp
	mem_addr_t phys_addr, addr;
	uint32_t value = 0;
	uint8_t width;

	if (argc < 2 || argc > 4) {
		return -EINVAL;
  103bd8:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
{
  103bdd:	48 89 e5             	mov    %rsp,%rbp
  103be0:	41 57                	push   %r15
  103be2:	41 56                	push   %r14
  103be4:	41 55                	push   %r13
  103be6:	49 89 d5             	mov    %rdx,%r13
	if (argc < 2 || argc > 4) {
  103be9:	48 8d 56 fe          	lea    -0x2(%rsi),%rdx
{
  103bed:	41 54                	push   %r12
  103bef:	53                   	push   %rbx
  103bf0:	48 83 ec 18          	sub    $0x18,%rsp
	if (argc < 2 || argc > 4) {
  103bf4:	48 83 fa 02          	cmp    $0x2,%rdx
  103bf8:	0f 87 18 01 00 00    	ja     103d16 <cmd_devmem+0x13f>
  103bfe:	49 89 fc             	mov    %rdi,%r12
	}

	phys_addr = strtoul(argv[1], NULL, 16);
  103c01:	49 8b 7d 08          	mov    0x8(%r13),%rdi
  103c05:	ba 10 00 00 00       	mov    $0x10,%edx
  103c0a:	49 89 f6             	mov    %rsi,%r14
  103c0d:	31 f6                	xor    %esi,%esi
#else
	addr = phys_addr;
#endif /* defined(CONFIG_MMU) || defined(CONFIG_PCIE) */

	if (argc < 3) {
		width = 32;
  103c0f:	b3 20                	mov    $0x20,%bl
	phys_addr = strtoul(argv[1], NULL, 16);
  103c11:	e8 8c 61 00 00       	callq  109da2 <strtoul>
{
#ifdef CONFIG_MMU
	/* Pass along flags and add that we want supervisor mode
	 * read-write access.
	 */
	z_phys_map((uint8_t **)virt_addr, phys_addr, size,
  103c16:	b9 0a 00 00 00       	mov    $0xa,%ecx
  103c1b:	ba 00 01 00 00       	mov    $0x100,%edx
  103c20:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  103c24:	48 89 c6             	mov    %rax,%rsi
  103c27:	49 89 c7             	mov    %rax,%r15
  103c2a:	e8 d1 06 01 00       	callq  114300 <z_phys_map>
	shell_print(sh, "Mapped 0x%lx to 0x%lx\n", phys_addr, addr);
  103c2f:	4c 8b 45 c8          	mov    -0x38(%rbp),%r8
  103c33:	4c 89 f9             	mov    %r15,%rcx
  103c36:	31 f6                	xor    %esi,%esi
  103c38:	ba e5 d6 11 00       	mov    $0x11d6e5,%edx
  103c3d:	4c 89 e7             	mov    %r12,%rdi
  103c40:	31 c0                	xor    %eax,%eax
  103c42:	e8 4c 1f 00 00       	callq  105b93 <shell_fprintf>
	if (argc < 3) {
  103c47:	49 83 fe 02          	cmp    $0x2,%r14
  103c4b:	74 12                	je     103c5f <cmd_devmem+0x88>
	} else {
		width = strtoul(argv[2], NULL, 10);
  103c4d:	49 8b 7d 10          	mov    0x10(%r13),%rdi
  103c51:	ba 0a 00 00 00       	mov    $0xa,%edx
  103c56:	31 f6                	xor    %esi,%esi
  103c58:	e8 45 61 00 00       	callq  109da2 <strtoul>
  103c5d:	89 c3                	mov    %eax,%ebx
	}

	shell_fprintf(sh, SHELL_NORMAL, "Using data width %d\n", width);
  103c5f:	31 f6                	xor    %esi,%esi
  103c61:	31 c0                	xor    %eax,%eax
  103c63:	0f b6 cb             	movzbl %bl,%ecx
  103c66:	ba fd d6 11 00       	mov    $0x11d6fd,%edx
  103c6b:	4c 89 e7             	mov    %r12,%rdi
  103c6e:	e8 20 1f 00 00       	callq  105b93 <shell_fprintf>

	if (argc <= 3) {
  103c73:	49 83 fe 04          	cmp    $0x4,%r14
  103c77:	74 53                	je     103ccc <cmd_devmem+0xf5>
		return memory_read(sh, addr, width);
  103c79:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
	switch (width) {
  103c7d:	80 fb 10             	cmp    $0x10,%bl
  103c80:	74 11                	je     103c93 <cmd_devmem+0xbc>
  103c82:	80 fb 20             	cmp    $0x20,%bl
  103c85:	74 14                	je     103c9b <cmd_devmem+0xc4>
  103c87:	80 fb 08             	cmp    $0x8,%bl
  103c8a:	75 15                	jne    103ca1 <cmd_devmem+0xca>
	__asm__ volatile("movb %1, %0"
  103c8c:	8a 08                	mov    (%rax),%cl
		value = sys_read8(addr);
  103c8e:	0f b6 c9             	movzbl %cl,%ecx
	if (err == 0) {
  103c91:	eb 26                	jmp    103cb9 <cmd_devmem+0xe2>
	__asm__ volatile("movw %1, %0"
  103c93:	66 8b 08             	mov    (%rax),%cx
		value = sys_read16(addr);
  103c96:	0f b7 c9             	movzwl %cx,%ecx
	if (err == 0) {
  103c99:	eb 1e                	jmp    103cb9 <cmd_devmem+0xe2>
	__asm__ volatile("movl %1, %0"
  103c9b:	8b 08                	mov    (%rax),%ecx
		value = sys_read32(addr);
  103c9d:	89 c9                	mov    %ecx,%ecx
	if (err == 0) {
  103c9f:	eb 18                	jmp    103cb9 <cmd_devmem+0xe2>
		shell_fprintf(sh, SHELL_NORMAL, "Incorrect data width\n");
  103ca1:	31 c0                	xor    %eax,%eax
  103ca3:	ba 12 d7 11 00       	mov    $0x11d712,%edx
  103ca8:	31 f6                	xor    %esi,%esi
  103caa:	4c 89 e7             	mov    %r12,%rdi
  103cad:	e8 e1 1e 00 00       	callq  105b93 <shell_fprintf>
		err = -EINVAL;
  103cb2:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
  103cb7:	eb 5d                	jmp    103d16 <cmd_devmem+0x13f>
		shell_fprintf(sh, SHELL_NORMAL, "Read value 0x%lx\n", value);
  103cb9:	ba 28 d7 11 00       	mov    $0x11d728,%edx
  103cbe:	31 f6                	xor    %esi,%esi
  103cc0:	4c 89 e7             	mov    %r12,%rdi
  103cc3:	31 c0                	xor    %eax,%eax
  103cc5:	e8 c9 1e 00 00       	callq  105b93 <shell_fprintf>
  103cca:	eb 48                	jmp    103d14 <cmd_devmem+0x13d>

	/* If there are more then 3 arguments, that means we are going to write
	 * this value at the address provided
	 */

	value = strtoul(argv[3], NULL, 16);
  103ccc:	49 8b 7d 18          	mov    0x18(%r13),%rdi
  103cd0:	ba 10 00 00 00       	mov    $0x10,%edx
  103cd5:	31 f6                	xor    %esi,%esi
  103cd7:	e8 c6 60 00 00       	callq  109da2 <strtoul>

	shell_fprintf(sh, SHELL_NORMAL, "Writing value 0x%lx\n", value);
  103cdc:	ba 3a d7 11 00       	mov    $0x11d73a,%edx
  103ce1:	31 f6                	xor    %esi,%esi
  103ce3:	4c 89 e7             	mov    %r12,%rdi
	value = strtoul(argv[3], NULL, 16);
  103ce6:	49 89 c5             	mov    %rax,%r13
	shell_fprintf(sh, SHELL_NORMAL, "Writing value 0x%lx\n", value);
  103ce9:	89 c1                	mov    %eax,%ecx
  103ceb:	31 c0                	xor    %eax,%eax
  103ced:	e8 a1 1e 00 00       	callq  105b93 <shell_fprintf>

	return memory_write(sh, addr, width, value);
  103cf2:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
	switch (width) {
  103cf6:	44 89 ea             	mov    %r13d,%edx
  103cf9:	80 fb 10             	cmp    $0x10,%bl
  103cfc:	74 0e                	je     103d0c <cmd_devmem+0x135>
  103cfe:	80 fb 20             	cmp    $0x20,%bl
  103d01:	74 0e                	je     103d11 <cmd_devmem+0x13a>
  103d03:	80 fb 08             	cmp    $0x8,%bl
  103d06:	75 99                	jne    103ca1 <cmd_devmem+0xca>
	__asm__ volatile("movb %0, %1"
  103d08:	88 10                	mov    %dl,(%rax)
  103d0a:	eb 08                	jmp    103d14 <cmd_devmem+0x13d>
	__asm__ volatile("movw %0, %1"
  103d0c:	66 89 10             	mov    %dx,(%rax)
  103d0f:	eb 03                	jmp    103d14 <cmd_devmem+0x13d>
	__asm__ volatile("movl %0, %1"
  103d11:	44 89 28             	mov    %r13d,(%rax)
	int err = 0;
  103d14:	31 c0                	xor    %eax,%eax
}
  103d16:	48 83 c4 18          	add    $0x18,%rsp
  103d1a:	5b                   	pop    %rbx
  103d1b:	41 5c                	pop    %r12
  103d1d:	41 5d                	pop    %r13
  103d1f:	41 5e                	pop    %r14
  103d21:	41 5f                	pop    %r15
  103d23:	5d                   	pop    %rbp
  103d24:	c3                   	retq   

0000000000103d25 <set_bypass.isra.0>:
static int set_bypass(const struct shell *sh, shell_bypass_cb_t bypass)
  103d25:	55                   	push   %rbp
  103d26:	48 89 e5             	mov    %rsp,%rbp
  103d29:	41 54                	push   %r12
  103d2b:	49 89 f4             	mov    %rsi,%r12
  103d2e:	48 83 ec 18          	sub    $0x18,%rsp
	if (bypass && in_use) {
  103d32:	8a 05 0c 91 0b 00    	mov    0xb910c(%rip),%al        # 1bce44 <in_use.0>
  103d38:	48 85 f6             	test   %rsi,%rsi
  103d3b:	74 1c                	je     103d59 <set_bypass.isra.0+0x34>
  103d3d:	84 c0                	test   %al,%al
  103d3f:	74 18                	je     103d59 <set_bypass.isra.0+0x34>
}
  103d41:	48 83 c4 18          	add    $0x18,%rsp
		shell_error(sh, "devmem load supports setting bypass on a single instance.");
  103d45:	ba 4f d7 11 00       	mov    $0x11d74f,%edx
  103d4a:	be 02 00 00 00       	mov    $0x2,%esi
  103d4f:	31 c0                	xor    %eax,%eax
}
  103d51:	41 5c                	pop    %r12
  103d53:	5d                   	pop    %rbp
		shell_error(sh, "devmem load supports setting bypass on a single instance.");
  103d54:	e9 3a 1e 00 00       	jmpq   105b93 <shell_fprintf>
	in_use = !in_use;
  103d59:	83 f0 01             	xor    $0x1,%eax
  103d5c:	88 05 e2 90 0b 00    	mov    %al,0xb90e2(%rip)        # 1bce44 <in_use.0>
	if (in_use) {
  103d62:	84 c0                	test   %al,%al
  103d64:	74 1d                	je     103d83 <set_bypass.isra.0+0x5e>
		shell_print(sh, "Loading...\npress ctrl-x ctrl-q to escape");
  103d66:	ba 8a d7 11 00       	mov    $0x11d78a,%edx
  103d6b:	31 f6                	xor    %esi,%esi
  103d6d:	31 c0                	xor    %eax,%eax
  103d6f:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  103d73:	e8 1b 1e 00 00       	callq  105b93 <shell_fprintf>
		in_use = true;
  103d78:	c6 05 c5 90 0b 00 01 	movb   $0x1,0xb90c5(%rip)        # 1bce44 <in_use.0>
  103d7f:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
}
  103d83:	48 83 c4 18          	add    $0x18,%rsp
	shell_set_bypass(sh, bypass);
  103d87:	4c 89 e6             	mov    %r12,%rsi
}
  103d8a:	41 5c                	pop    %r12
  103d8c:	5d                   	pop    %rbp
	shell_set_bypass(sh, bypass);
  103d8d:	e9 7d 20 00 00       	jmpq   105e0f <shell_set_bypass>

0000000000103d92 <bypass_cb>:
{
  103d92:	55                   	push   %rbp
  103d93:	31 c0                	xor    %eax,%eax
  103d95:	48 89 e5             	mov    %rsp,%rbp
  103d98:	48 83 ec 10          	sub    $0x10,%rsp
	if (tail == CHAR_CAN && recv[0] == CHAR_DC1) {
  103d9c:	80 3d a2 90 0b 00 18 	cmpb   $0x18,0xb90a2(%rip)        # 1bce45 <tail.1>
  103da3:	75 05                	jne    103daa <bypass_cb+0x18>
  103da5:	80 3e 11             	cmpb   $0x11,(%rsi)
  103da8:	74 20                	je     103dca <bypass_cb+0x38>
		for (int i = 0; i < (len - 1); i++) {
  103daa:	48 ff ca             	dec    %rdx
  103dad:	48 63 c8             	movslq %eax,%rcx
  103db0:	48 39 d1             	cmp    %rdx,%rcx
  103db3:	0f 83 de 00 00 00    	jae    103e97 <bypass_cb+0x105>
			if (recv[i] == CHAR_CAN && recv[i + 1] == CHAR_DC1) {
  103db9:	ff c0                	inc    %eax
  103dbb:	80 3c 0e 18          	cmpb   $0x18,(%rsi,%rcx,1)
  103dbf:	75 ec                	jne    103dad <bypass_cb+0x1b>
  103dc1:	48 63 c8             	movslq %eax,%rcx
  103dc4:	80 3c 0e 11          	cmpb   $0x11,(%rsi,%rcx,1)
  103dc8:	75 e3                	jne    103dad <bypass_cb+0x1b>
		shell_print(sh, "Number of bytes read: %d", sum);
  103dca:	8b 0d 54 90 0b 00    	mov    0xb9054(%rip),%ecx        # 1bce24 <sum>
  103dd0:	ba b4 d7 11 00       	mov    $0x11d7b4,%edx
  103dd5:	31 f6                	xor    %esi,%esi
  103dd7:	31 c0                	xor    %eax,%eax
  103dd9:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  103ddd:	e8 b1 1d 00 00       	callq  105b93 <shell_fprintf>
		set_bypass(sh, NULL);
  103de2:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
  103de6:	31 f6                	xor    %esi,%esi
  103de8:	e8 38 ff ff ff       	callq  103d25 <set_bypass.isra.0>
		if (!littleendian) {
  103ded:	8a 0d 53 90 0b 00    	mov    0xb9053(%rip),%cl        # 1bce46 <littleendian>
  103df3:	84 c9                	test   %cl,%cl
  103df5:	0f 85 10 01 00 00    	jne    103f0b <bypass_cb+0x179>
  103dfb:	48 8b 15 4e 8f 0b 00 	mov    0xb8f4e(%rip),%rdx        # 1bcd50 <data>
  103e02:	8b 05 1c 90 0b 00    	mov    0xb901c(%rip),%eax        # 1bce24 <sum>
			while (sum > 4) {
  103e08:	83 f8 04             	cmp    $0x4,%eax
  103e0b:	7e 12                	jle    103e1f <bypass_cb+0x8d>
				*data = __bswap_32(*data);
  103e0d:	8b 0a                	mov    (%rdx),%ecx
				sum = sum - 4;
  103e0f:	83 e8 04             	sub    $0x4,%eax
				data++;
  103e12:	48 83 c2 04          	add    $0x4,%rdx
  103e16:	0f c9                	bswap  %ecx
				*data = __bswap_32(*data);
  103e18:	89 4a fc             	mov    %ecx,-0x4(%rdx)
				sum = sum - 4;
  103e1b:	b1 01                	mov    $0x1,%cl
  103e1d:	eb e9                	jmp    103e08 <bypass_cb+0x76>
  103e1f:	84 c9                	test   %cl,%cl
  103e21:	74 0d                	je     103e30 <bypass_cb+0x9e>
  103e23:	48 89 15 26 8f 0b 00 	mov    %rdx,0xb8f26(%rip)        # 1bcd50 <data>
  103e2a:	89 05 f4 8f 0b 00    	mov    %eax,0xb8ff4(%rip)        # 1bce24 <sum>
			if (sum % 4 == 0) {
  103e30:	a8 03                	test   $0x3,%al
  103e32:	75 0d                	jne    103e41 <bypass_cb+0xaf>
				*data = __bswap_32(*data);
  103e34:	48 8b 15 15 8f 0b 00 	mov    0xb8f15(%rip),%rdx        # 1bcd50 <data>
  103e3b:	8b 02                	mov    (%rdx),%eax
  103e3d:	0f c8                	bswap  %eax
  103e3f:	eb 1c                	jmp    103e5d <bypass_cb+0xcb>
			} else if (sum % 4 == 2) {
  103e41:	b9 04 00 00 00       	mov    $0x4,%ecx
  103e46:	99                   	cltd   
  103e47:	f7 f9                	idiv   %ecx
  103e49:	83 fa 02             	cmp    $0x2,%edx
  103e4c:	75 16                	jne    103e64 <bypass_cb+0xd2>
				*data = __bswap_16(*data);
  103e4e:	48 8b 15 fb 8e 0b 00 	mov    0xb8efb(%rip),%rdx        # 1bcd50 <data>
  103e55:	66 8b 02             	mov    (%rdx),%ax
  103e58:	86 e0                	xchg   %ah,%al
  103e5a:	0f b7 c0             	movzwl %ax,%eax
  103e5d:	89 02                	mov    %eax,(%rdx)
  103e5f:	e9 a7 00 00 00       	jmpq   103f0b <bypass_cb+0x179>
			} else if (sum % 4 == 3) {
  103e64:	83 fa 03             	cmp    $0x3,%edx
  103e67:	0f 85 9e 00 00 00    	jne    103f0b <bypass_cb+0x179>
				*data = __bswap_24(*data);
  103e6d:	48 8b 35 dc 8e 0b 00 	mov    0xb8edc(%rip),%rsi        # 1bcd50 <data>
  103e74:	8b 16                	mov    (%rsi),%edx
  103e76:	89 d0                	mov    %edx,%eax
  103e78:	89 d1                	mov    %edx,%ecx
  103e7a:	81 e2 00 ff 00 00    	and    $0xff00,%edx
  103e80:	c1 e8 10             	shr    $0x10,%eax
  103e83:	c1 e1 10             	shl    $0x10,%ecx
  103e86:	0f b6 c0             	movzbl %al,%eax
  103e89:	81 e1 00 00 ff 00    	and    $0xff0000,%ecx
  103e8f:	09 c8                	or     %ecx,%eax
  103e91:	09 d0                	or     %edx,%eax
  103e93:	89 06                	mov    %eax,(%rsi)
  103e95:	eb 74                	jmp    103f0b <bypass_cb+0x179>
	tail = recv[len - 1];
  103e97:	8a 04 16             	mov    (%rsi,%rdx,1),%al
	if (is_ascii(*recv)) {
  103e9a:	8a 16                	mov    (%rsi),%dl
	tail = recv[len - 1];
  103e9c:	88 05 a3 8f 0b 00    	mov    %al,0xb8fa3(%rip)        # 1bce45 <tail.1>
	return (data >= 0x30 && data <= 0x39) || (data >= 0x61 && data <= 0x66) ||
  103ea2:	8d 42 d0             	lea    -0x30(%rdx),%eax
  103ea5:	3c 09                	cmp    $0x9,%al
  103ea7:	76 0c                	jbe    103eb5 <bypass_cb+0x123>
	if (is_ascii(*recv)) {
  103ea9:	89 d0                	mov    %edx,%eax
  103eab:	83 e0 df             	and    $0xffffffdf,%eax
  103eae:	83 e8 41             	sub    $0x41,%eax
  103eb1:	3c 05                	cmp    $0x5,%al
  103eb3:	77 18                	ja     103ecd <bypass_cb+0x13b>
		chunk[chunk_element] = *recv;
  103eb5:	48 63 0d 64 8f 0b 00 	movslq 0xb8f64(%rip),%rcx        # 1bce20 <chunk_element>
  103ebc:	48 89 c8             	mov    %rcx,%rax
  103ebf:	88 91 47 ce 1b 00    	mov    %dl,0x1bce47(%rcx)
		chunk_element++;
  103ec5:	ff c0                	inc    %eax
  103ec7:	89 05 53 8f 0b 00    	mov    %eax,0xb8f53(%rip)        # 1bce20 <chunk_element>
	if (chunk_element == 2) {
  103ecd:	83 3d 4c 8f 0b 00 02 	cmpl   $0x2,0xb8f4c(%rip)        # 1bce20 <chunk_element>
  103ed4:	75 35                	jne    103f0b <bypass_cb+0x179>
		byte = (uint8_t)strtoul(chunk, NULL, 16);
  103ed6:	ba 10 00 00 00       	mov    $0x10,%edx
  103edb:	31 f6                	xor    %esi,%esi
  103edd:	bf 47 ce 1b 00       	mov    $0x1bce47,%edi
  103ee2:	e8 bb 5e 00 00       	callq  109da2 <strtoul>
		*bytes = byte;
  103ee7:	48 8b 15 6a 8e 0b 00 	mov    0xb8e6a(%rip),%rdx        # 1bcd58 <bytes>
		sum++;
  103eee:	ff 05 30 8f 0b 00    	incl   0xb8f30(%rip)        # 1bce24 <sum>
		chunk_element = 0;
  103ef4:	c7 05 22 8f 0b 00 00 	movl   $0x0,0xb8f22(%rip)        # 1bce20 <chunk_element>
  103efb:	00 00 00 
		byte = (uint8_t)strtoul(chunk, NULL, 16);
  103efe:	88 02                	mov    %al,(%rdx)
		bytes++;
  103f00:	48 8d 42 01          	lea    0x1(%rdx),%rax
  103f04:	48 89 05 4d 8e 0b 00 	mov    %rax,0xb8e4d(%rip)        # 1bcd58 <bytes>
}
  103f0b:	c9                   	leaveq 
  103f0c:	c3                   	retq   

0000000000103f0d <cmd_load>:
{
  103f0d:	55                   	push   %rbp
	littleendian = false;
  103f0e:	c6 05 31 8f 0b 00 00 	movb   $0x0,0xb8f31(%rip)        # 1bce46 <littleendian>
	chunk_element = 0;
  103f15:	c7 05 01 8f 0b 00 00 	movl   $0x0,0xb8f01(%rip)        # 1bce20 <chunk_element>
  103f1c:	00 00 00 
	sum = 0;
  103f1f:	c7 05 fb 8e 0b 00 00 	movl   $0x0,0xb8efb(%rip)        # 1bce24 <sum>
  103f26:	00 00 00 
{
  103f29:	48 89 e5             	mov    %rsp,%rbp
  103f2c:	41 56                	push   %r14
  103f2e:	49 89 fe             	mov    %rdi,%r14
  103f31:	41 55                	push   %r13
  103f33:	49 89 f5             	mov    %rsi,%r13
  103f36:	41 54                	push   %r12
  103f38:	53                   	push   %rbx
  103f39:	48 89 d3             	mov    %rdx,%rbx
		arg = argv[1] + (!strncmp(argv[1], "--", 2) && argv[1][2]);
  103f3c:	4c 8b 63 08          	mov    0x8(%rbx),%r12
	while (argc >= 2) {
  103f40:	49 83 fd 01          	cmp    $0x1,%r13
  103f44:	0f 86 8d 00 00 00    	jbe    103fd7 <cmd_load+0xca>
		arg = argv[1] + (!strncmp(argv[1], "--", 2) && argv[1][2]);
  103f4a:	ba 02 00 00 00       	mov    $0x2,%edx
  103f4f:	be ce d7 11 00       	mov    $0x11d7ce,%esi
  103f54:	4c 89 e7             	mov    %r12,%rdi
  103f57:	e8 b9 60 00 00       	callq  10a015 <strncmp>
  103f5c:	31 c9                	xor    %ecx,%ecx
  103f5e:	85 c0                	test   %eax,%eax
  103f60:	75 0d                	jne    103f6f <cmd_load+0x62>
  103f62:	48 8b 43 08          	mov    0x8(%rbx),%rax
  103f66:	31 c9                	xor    %ecx,%ecx
  103f68:	80 78 02 00          	cmpb   $0x0,0x2(%rax)
  103f6c:	0f 95 c1             	setne  %cl
  103f6f:	49 01 cc             	add    %rcx,%r12
		if (!strncmp(arg, "-e", 2)) {
  103f72:	ba 02 00 00 00       	mov    $0x2,%edx
  103f77:	be d1 d7 11 00       	mov    $0x11d7d1,%esi
  103f7c:	4c 89 e7             	mov    %r12,%rdi
  103f7f:	e8 91 60 00 00       	callq  10a015 <strncmp>
  103f84:	85 c0                	test   %eax,%eax
  103f86:	75 09                	jne    103f91 <cmd_load+0x84>
			littleendian = true;
  103f88:	c6 05 b7 8e 0b 00 01 	movb   $0x1,0xb8eb7(%rip)        # 1bce46 <littleendian>
  103f8f:	eb 3a                	jmp    103fcb <cmd_load+0xbe>
		} else if (!strcmp(arg, "--")) {
  103f91:	be ce d7 11 00       	mov    $0x11d7ce,%esi
  103f96:	4c 89 e7             	mov    %r12,%rdi
  103f99:	e8 5f 60 00 00       	callq  109ffd <strcmp>
  103f9e:	85 c0                	test   %eax,%eax
  103fa0:	75 06                	jne    103fa8 <cmd_load+0x9b>
			argv++;
  103fa2:	48 83 c3 08          	add    $0x8,%rbx
			break;
  103fa6:	eb 2f                	jmp    103fd7 <cmd_load+0xca>
		} else if (arg[0] == '-' && arg[1]) {
  103fa8:	41 80 3c 24 2d       	cmpb   $0x2d,(%r12)
  103fad:	75 28                	jne    103fd7 <cmd_load+0xca>
  103faf:	41 80 7c 24 01 00    	cmpb   $0x0,0x1(%r12)
  103fb5:	74 20                	je     103fd7 <cmd_load+0xca>
			shell_print(sh, "Unknown option \"%s\"", arg);
  103fb7:	4c 89 e1             	mov    %r12,%rcx
  103fba:	ba d4 d7 11 00       	mov    $0x11d7d4,%edx
  103fbf:	31 f6                	xor    %esi,%esi
  103fc1:	4c 89 f7             	mov    %r14,%rdi
  103fc4:	31 c0                	xor    %eax,%eax
  103fc6:	e8 c8 1b 00 00       	callq  105b93 <shell_fprintf>
		argv++;
  103fcb:	48 83 c3 08          	add    $0x8,%rbx
		argc--;
  103fcf:	49 ff cd             	dec    %r13
  103fd2:	e9 65 ff ff ff       	jmpq   103f3c <cmd_load+0x2f>
	bytes = (unsigned char *)strtol(argv[1], NULL, 0);
  103fd7:	48 8b 7b 08          	mov    0x8(%rbx),%rdi
  103fdb:	31 d2                	xor    %edx,%edx
  103fdd:	31 f6                	xor    %esi,%esi
  103fdf:	e8 4d 5c 00 00       	callq  109c31 <strtol>
	data = (uint32_t *)strtol(argv[1], NULL, 0);
  103fe4:	48 8b 7b 08          	mov    0x8(%rbx),%rdi
  103fe8:	31 d2                	xor    %edx,%edx
  103fea:	31 f6                	xor    %esi,%esi
	bytes = (unsigned char *)strtol(argv[1], NULL, 0);
  103fec:	48 89 05 65 8d 0b 00 	mov    %rax,0xb8d65(%rip)        # 1bcd58 <bytes>
	data = (uint32_t *)strtol(argv[1], NULL, 0);
  103ff3:	e8 39 5c 00 00       	callq  109c31 <strtol>
	set_bypass(sh, bypass_cb);
  103ff8:	4c 89 f7             	mov    %r14,%rdi
  103ffb:	be 92 3d 10 00       	mov    $0x103d92,%esi
	data = (uint32_t *)strtol(argv[1], NULL, 0);
  104000:	48 89 05 49 8d 0b 00 	mov    %rax,0xb8d49(%rip)        # 1bcd50 <data>
	set_bypass(sh, bypass_cb);
  104007:	e8 19 fd ff ff       	callq  103d25 <set_bypass.isra.0>
}
  10400c:	5b                   	pop    %rbx
  10400d:	31 c0                	xor    %eax,%eax
  10400f:	41 5c                	pop    %r12
  104011:	41 5d                	pop    %r13
  104013:	41 5e                	pop    %r14
  104015:	5d                   	pop    %rbp
  104016:	c3                   	retq   

0000000000104017 <arch_is_user_context>:
	__asm__ volatile ("mov %%cs, %[cs_val]" : [cs_val] "=r" (cs));
  104017:	8c c8                	mov    %cs,%eax
	return (cs & 0x3) != 0;
  104019:	a8 03                	test   $0x3,%al
  10401b:	0f 95 c0             	setne  %al
}
  10401e:	c3                   	retq   

000000000010401f <atomic_or>:
 *
 * @return Previous value of @a target.
 */
static inline atomic_val_t atomic_or(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
  10401f:	8b 07                	mov    (%rdi),%eax
  104021:	89 c2                	mov    %eax,%edx
  104023:	41 89 c0             	mov    %eax,%r8d
  104026:	09 f2                	or     %esi,%edx
  104028:	f0 0f b1 17          	lock cmpxchg %edx,(%rdi)
  10402c:	75 f3                	jne    104021 <atomic_or+0x2>
}
  10402e:	44 89 c0             	mov    %r8d,%eax
  104031:	c3                   	retq   

0000000000104032 <atomic_and>:
 *
 * @return Previous value of @a target.
 */
static inline atomic_val_t atomic_and(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
  104032:	8b 07                	mov    (%rdi),%eax
  104034:	89 c2                	mov    %eax,%edx
  104036:	41 89 c0             	mov    %eax,%r8d
  104039:	21 f2                	and    %esi,%edx
  10403b:	f0 0f b1 17          	lock cmpxchg %edx,(%rdi)
  10403f:	75 f3                	jne    104034 <atomic_and+0x2>
}
  104041:	44 89 c0             	mov    %r8d,%eax
  104044:	c3                   	retq   

0000000000104045 <z_shell_strlen>:
void z_shell_multiline_data_calc(struct shell_multiline_cons *cons,
				 uint16_t buff_pos, uint16_t buff_len);

static inline uint16_t z_shell_strlen(const char *str)
{
	return str == NULL ? 0U : (uint16_t)strlen(str);
  104045:	48 85 ff             	test   %rdi,%rdi
  104048:	74 0b                	je     104055 <z_shell_strlen+0x10>
{
  10404a:	55                   	push   %rbp
  10404b:	48 89 e5             	mov    %rsp,%rbp
	return str == NULL ? 0U : (uint16_t)strlen(str);
  10404e:	e8 89 5f 00 00       	callq  109fdc <strlen>
}
  104053:	5d                   	pop    %rbp
  104054:	c3                   	retq   
  104055:	31 c0                	xor    %eax,%eax
  104057:	c3                   	retq   

0000000000104058 <z_shell_raw_fprintf>:
extern "C" {
#endif

static inline void z_shell_raw_fprintf(const struct shell_fprintf *const ctx,
				       const char *fmt, ...)
{
  104058:	55                   	push   %rbp
  104059:	48 89 e5             	mov    %rsp,%rbp
  10405c:	48 81 ec d0 00 00 00 	sub    $0xd0,%rsp
  104063:	48 89 95 60 ff ff ff 	mov    %rdx,-0xa0(%rbp)
  10406a:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  104071:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  104078:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  10407f:	84 c0                	test   %al,%al
  104081:	74 20                	je     1040a3 <z_shell_raw_fprintf+0x4b>
  104083:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  104087:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  10408b:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  10408f:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  104093:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  104097:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  10409b:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  10409f:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
	va_list args;

	va_start(args, fmt);
  1040a3:	48 8d 45 10          	lea    0x10(%rbp),%rax
	z_shell_fprintf_fmt(ctx, fmt, args);
  1040a7:	48 8d 95 38 ff ff ff 	lea    -0xc8(%rbp),%rdx
	va_start(args, fmt);
  1040ae:	c7 85 38 ff ff ff 10 	movl   $0x10,-0xc8(%rbp)
  1040b5:	00 00 00 
  1040b8:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  1040bf:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  1040c6:	c7 85 3c ff ff ff 30 	movl   $0x30,-0xc4(%rbp)
  1040cd:	00 00 00 
  1040d0:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
	z_shell_fprintf_fmt(ctx, fmt, args);
  1040d7:	e8 65 1d 00 00       	callq  105e41 <z_shell_fprintf_fmt>
	va_end(args);
}
  1040dc:	c9                   	leaveq 
  1040dd:	c3                   	retq   

00000000001040de <shell_internal_help_print>:
	shell->ctx->cmd_buff_pos = 0;
	shell->ctx->cmd_buff_len = 0;
}

static void shell_internal_help_print(const struct shell *shell)
{
  1040de:	55                   	push   %rbp
  1040df:	48 89 e5             	mov    %rsp,%rbp
  1040e2:	48 83 ec 10          	sub    $0x10,%rsp
	if (!IS_ENABLED(CONFIG_SHELL_HELP)) {
		return;
	}

	z_shell_help_cmd_print(shell, &shell->ctx->active_cmd);
  1040e6:	48 8b 47 10          	mov    0x10(%rdi),%rax
  1040ea:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  1040ee:	48 8d 70 10          	lea    0x10(%rax),%rsi
  1040f2:	e8 01 36 00 00       	callq  1076f8 <z_shell_help_cmd_print>
	z_shell_help_subcmd_print(shell, &shell->ctx->active_cmd,
  1040f7:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
  1040fb:	ba 76 d8 11 00       	mov    $0x11d876,%edx
  104100:	48 8b 47 10          	mov    0x10(%rdi),%rax
				  "Subcommands:\n");
}
  104104:	c9                   	leaveq 
	z_shell_help_subcmd_print(shell, &shell->ctx->active_cmd,
  104105:	48 8d 70 10          	lea    0x10(%rax),%rsi
  104109:	e9 da 34 00 00       	jmpq   1075e8 <z_shell_help_subcmd_print>

000000000010410e <z_current_get>:
{
  10410e:	55                   	push   %rbp
  10410f:	48 89 e5             	mov    %rsp,%rbp
  104112:	e8 00 ff ff ff       	callq  104017 <arch_is_user_context>
	if (z_syscall_trap()) {
  104117:	84 c0                	test   %al,%al
  104119:	75 06                	jne    104121 <z_current_get+0x13>
}
  10411b:	5d                   	pop    %rbp
	return z_impl_z_current_get();
  10411c:	e9 2d e6 00 00       	jmpq   11274e <z_impl_z_current_get>
	register uintptr_t rax __asm__("%rax") = call_id;
  104121:	b8 48 01 00 00       	mov    $0x148,%eax
	__asm__ volatile("syscall\n\t"
  104126:	0f 05                	syscall 
}
  104128:	5d                   	pop    %rbp
  104129:	c3                   	retq   

000000000010412a <z_flag_print_noinit_set.isra.0>:

static inline bool z_flag_print_noinit_set(const struct shell *shell, bool val)
{
	bool ret;

	Z_SHELL_SET_FLAG_ATOMIC(shell, print_noinit, val, ret);
  10412a:	48 81 c7 94 02 00 00 	add    $0x294,%rdi
  104131:	40 84 f6             	test   %sil,%sil
  104134:	74 0a                	je     104140 <z_flag_print_noinit_set.isra.0+0x16>
  104136:	be 00 00 02 00       	mov    $0x20000,%esi
  10413b:	e9 df fe ff ff       	jmpq   10401f <atomic_or>
  104140:	be ff ff fd ff       	mov    $0xfffdffff,%esi
  104145:	e9 e8 fe ff ff       	jmpq   104032 <atomic_and>

000000000010414a <z_flag_cmd_ctx_set.isra.0>:
	Z_SHELL_SET_FLAG_ATOMIC(shell, cmd_ctx, val, ret);
  10414a:	48 81 c7 94 02 00 00 	add    $0x294,%rdi
  104151:	40 84 f6             	test   %sil,%sil
  104154:	74 0a                	je     104160 <z_flag_cmd_ctx_set.isra.0+0x16>
  104156:	be 00 00 01 00       	mov    $0x10000,%esi
  10415b:	e9 bf fe ff ff       	jmpq   10401f <atomic_or>
  104160:	be ff ff fe ff       	mov    $0xfffeffff,%esi
  104165:	e9 c8 fe ff ff       	jmpq   104032 <atomic_and>

000000000010416a <z_flag_history_exit_set.isra.0>:
	Z_SHELL_SET_FLAG_ATOMIC(shell, history_exit, val, ret);
  10416a:	48 81 c7 94 02 00 00 	add    $0x294,%rdi
  104171:	40 84 f6             	test   %sil,%sil
  104174:	74 0a                	je     104180 <z_flag_history_exit_set.isra.0+0x16>
  104176:	be 80 00 00 00       	mov    $0x80,%esi
  10417b:	e9 9f fe ff ff       	jmpq   10401f <atomic_or>
  104180:	be 7f ff ff ff       	mov    $0xffffff7f,%esi
  104185:	e9 a8 fe ff ff       	jmpq   104032 <atomic_and>

000000000010418a <z_flag_mode_delete_set.isra.0>:
static inline bool z_flag_mode_delete_set(const struct shell *shell, bool val)
  10418a:	55                   	push   %rbp
	Z_SHELL_SET_FLAG_ATOMIC(shell, mode_delete, val, ret);
  10418b:	48 81 c7 94 02 00 00 	add    $0x294,%rdi
static inline bool z_flag_mode_delete_set(const struct shell *shell, bool val)
  104192:	48 89 e5             	mov    %rsp,%rbp
	Z_SHELL_SET_FLAG_ATOMIC(shell, mode_delete, val, ret);
  104195:	40 84 f6             	test   %sil,%sil
  104198:	74 0c                	je     1041a6 <z_flag_mode_delete_set.isra.0+0x1c>
  10419a:	be 40 00 00 00       	mov    $0x40,%esi
  10419f:	e8 7b fe ff ff       	callq  10401f <atomic_or>
  1041a4:	eb 0a                	jmp    1041b0 <z_flag_mode_delete_set.isra.0+0x26>
  1041a6:	be bf ff ff ff       	mov    $0xffffffbf,%esi
  1041ab:	e8 82 fe ff ff       	callq  104032 <atomic_and>
  1041b0:	c0 e8 06             	shr    $0x6,%al
}
  1041b3:	5d                   	pop    %rbp
	Z_SHELL_SET_FLAG_ATOMIC(shell, mode_delete, val, ret);
  1041b4:	83 e0 01             	and    $0x1,%eax
}
  1041b7:	c3                   	retq   

00000000001041b8 <z_flag_processing_set.isra.0>:
	Z_SHELL_SET_FLAG_ATOMIC(shell, processing, val, ret);
  1041b8:	48 81 c7 94 02 00 00 	add    $0x294,%rdi
  1041bf:	40 84 f6             	test   %sil,%sil
  1041c2:	74 0a                	je     1041ce <z_flag_processing_set.isra.0+0x16>
  1041c4:	be 10 00 00 00       	mov    $0x10,%esi
  1041c9:	e9 51 fe ff ff       	jmpq   10401f <atomic_or>
  1041ce:	be ef ff ff ff       	mov    $0xffffffef,%esi
  1041d3:	e9 5a fe ff ff       	jmpq   104032 <atomic_and>

00000000001041d8 <z_flag_obscure_set.isra.0>:
static inline bool z_flag_obscure_set(const struct shell *shell, bool val)
  1041d8:	55                   	push   %rbp
	Z_SHELL_SET_FLAG_ATOMIC(shell, obscure, val, ret);
  1041d9:	48 81 c7 94 02 00 00 	add    $0x294,%rdi
static inline bool z_flag_obscure_set(const struct shell *shell, bool val)
  1041e0:	48 89 e5             	mov    %rsp,%rbp
	Z_SHELL_SET_FLAG_ATOMIC(shell, obscure, val, ret);
  1041e3:	40 84 f6             	test   %sil,%sil
  1041e6:	74 0c                	je     1041f4 <z_flag_obscure_set.isra.0+0x1c>
  1041e8:	be 08 00 00 00       	mov    $0x8,%esi
  1041ed:	e8 2d fe ff ff       	callq  10401f <atomic_or>
  1041f2:	eb 0a                	jmp    1041fe <z_flag_obscure_set.isra.0+0x26>
  1041f4:	be f7 ff ff ff       	mov    $0xfffffff7,%esi
  1041f9:	e8 34 fe ff ff       	callq  104032 <atomic_and>
  1041fe:	c0 e8 03             	shr    $0x3,%al
}
  104201:	5d                   	pop    %rbp
	Z_SHELL_SET_FLAG_ATOMIC(shell, obscure, val, ret);
  104202:	83 e0 01             	and    $0x1,%eax
}
  104205:	c3                   	retq   

0000000000104206 <z_flag_echo_set.isra.0>:
static inline bool z_flag_echo_set(const struct shell *shell, bool val)
  104206:	55                   	push   %rbp
	Z_SHELL_SET_FLAG_ATOMIC(shell, echo, val, ret);
  104207:	48 81 c7 94 02 00 00 	add    $0x294,%rdi
static inline bool z_flag_echo_set(const struct shell *shell, bool val)
  10420e:	48 89 e5             	mov    %rsp,%rbp
	Z_SHELL_SET_FLAG_ATOMIC(shell, echo, val, ret);
  104211:	40 84 f6             	test   %sil,%sil
  104214:	74 0c                	je     104222 <z_flag_echo_set.isra.0+0x1c>
  104216:	be 04 00 00 00       	mov    $0x4,%esi
  10421b:	e8 ff fd ff ff       	callq  10401f <atomic_or>
  104220:	eb 0a                	jmp    10422c <z_flag_echo_set.isra.0+0x26>
  104222:	be fb ff ff ff       	mov    $0xfffffffb,%esi
  104227:	e8 06 fe ff ff       	callq  104032 <atomic_and>
  10422c:	c0 e8 02             	shr    $0x2,%al
}
  10422f:	5d                   	pop    %rbp
	Z_SHELL_SET_FLAG_ATOMIC(shell, echo, val, ret);
  104230:	83 e0 01             	and    $0x1,%eax
}
  104233:	c3                   	retq   

0000000000104234 <z_flag_use_colors_set.isra.0>:
static inline bool z_flag_use_colors_set(const struct shell *shell, bool val)
  104234:	55                   	push   %rbp
	Z_SHELL_SET_FLAG_ATOMIC(shell, use_colors, val, ret);
  104235:	48 81 c7 94 02 00 00 	add    $0x294,%rdi
static inline bool z_flag_use_colors_set(const struct shell *shell, bool val)
  10423c:	48 89 e5             	mov    %rsp,%rbp
	Z_SHELL_SET_FLAG_ATOMIC(shell, use_colors, val, ret);
  10423f:	40 84 f6             	test   %sil,%sil
  104242:	74 0c                	je     104250 <z_flag_use_colors_set.isra.0+0x1c>
  104244:	be 02 00 00 00       	mov    $0x2,%esi
  104249:	e8 d1 fd ff ff       	callq  10401f <atomic_or>
  10424e:	eb 0a                	jmp    10425a <z_flag_use_colors_set.isra.0+0x26>
  104250:	be fd ff ff ff       	mov    $0xfffffffd,%esi
  104255:	e8 d8 fd ff ff       	callq  104032 <atomic_and>
  10425a:	d0 e8                	shr    %al
}
  10425c:	5d                   	pop    %rbp
	Z_SHELL_SET_FLAG_ATOMIC(shell, use_colors, val, ret);
  10425d:	83 e0 01             	and    $0x1,%eax
}
  104260:	c3                   	retq   

0000000000104261 <z_flag_insert_mode_set.isra.0>:
static inline bool z_flag_insert_mode_set(const struct shell *shell, bool val)
  104261:	55                   	push   %rbp
	Z_SHELL_SET_FLAG_ATOMIC(shell, insert_mode, val, ret);
  104262:	48 81 c7 94 02 00 00 	add    $0x294,%rdi
static inline bool z_flag_insert_mode_set(const struct shell *shell, bool val)
  104269:	48 89 e5             	mov    %rsp,%rbp
	Z_SHELL_SET_FLAG_ATOMIC(shell, insert_mode, val, ret);
  10426c:	40 84 f6             	test   %sil,%sil
  10426f:	74 0c                	je     10427d <z_flag_insert_mode_set.isra.0+0x1c>
  104271:	be 01 00 00 00       	mov    $0x1,%esi
  104276:	e8 a4 fd ff ff       	callq  10401f <atomic_or>
  10427b:	eb 0a                	jmp    104287 <z_flag_insert_mode_set.isra.0+0x26>
  10427d:	be fe ff ff ff       	mov    $0xfffffffe,%esi
  104282:	e8 ab fd ff ff       	callq  104032 <atomic_and>
  104287:	83 e0 01             	and    $0x1,%eax
}
  10428a:	5d                   	pop    %rbp
  10428b:	c3                   	retq   

000000000010428c <z_cursor_next_line_move.isra.0>:
	z_shell_raw_fprintf(shell->fprintf_ctx, "\n");
  10428c:	be 23 fc 11 00       	mov    $0x11fc23,%esi
  104291:	31 c0                	xor    %eax,%eax
  104293:	e9 c0 fd ff ff       	jmpq   104058 <z_shell_raw_fprintf>

0000000000104298 <history_handle>:

	z_shell_history_put(shell->history, line, length);
}

static void history_handle(const struct shell *shell, bool up)
{
  104298:	55                   	push   %rbp
  104299:	48 89 e5             	mov    %rsp,%rbp
  10429c:	41 54                	push   %r12
  10429e:	49 89 fc             	mov    %rdi,%r12
  1042a1:	53                   	push   %rbx
  1042a2:	89 f3                	mov    %esi,%ebx
  1042a4:	48 83 ec 10          	sub    $0x10,%rsp
	return shell->ctx->internal.flags.history_exit == 1;
  1042a8:	48 8b 7f 10          	mov    0x10(%rdi),%rdi
  1042ac:	48 8b 87 90 02 00 00 	mov    0x290(%rdi),%rax
	if (!IS_ENABLED(CONFIG_SHELL_HISTORY)) {
		return;
	}

	/* Checking if history process has been stopped */
	if (z_flag_history_exit_get(shell)) {
  1042b3:	48 0f ba e0 27       	bt     $0x27,%rax
  1042b8:	73 11                	jae    1042cb <history_handle+0x33>
		z_flag_history_exit_set(shell, false);
  1042ba:	31 f6                	xor    %esi,%esi
  1042bc:	e8 a9 fe ff ff       	callq  10416a <z_flag_history_exit_set.isra.0>
		z_shell_history_mode_exit(shell->history);
  1042c1:	49 8b 7c 24 18       	mov    0x18(%r12),%rdi
  1042c6:	e8 ca 39 00 00       	callq  107c95 <z_shell_history_mode_exit>
 *
 * @return True if in browsing mode.
 */
static inline bool z_shell_history_active(struct shell_history *history)
{
	return (history->current) ? true : false;
  1042cb:	49 8b 44 24 18       	mov    0x18(%r12),%rax
	}

	/* Backup command if history is entered */
	if (!z_shell_history_active(shell->history)) {
  1042d0:	48 83 78 18 00       	cmpq   $0x0,0x18(%rax)
  1042d5:	75 39                	jne    104310 <history_handle+0x78>
		if (up) {
  1042d7:	84 db                	test   %bl,%bl
  1042d9:	0f 84 b5 00 00 00    	je     104394 <history_handle+0xfc>
			uint16_t cmd_len = z_shell_strlen(shell->ctx->cmd_buff);
  1042df:	49 8b 44 24 10       	mov    0x10(%r12),%rax
  1042e4:	48 8d 78 76          	lea    0x76(%rax),%rdi
  1042e8:	e8 58 fd ff ff       	callq  104045 <z_shell_strlen>

			if (cmd_len) {
  1042ed:	49 8b 7c 24 10       	mov    0x10(%r12),%rdi
  1042f2:	66 85 c0             	test   %ax,%ax
  1042f5:	74 12                	je     104309 <history_handle+0x71>
				strcpy(shell->ctx->temp_buff,
				       shell->ctx->cmd_buff);
  1042f7:	48 8d 77 76          	lea    0x76(%rdi),%rsi
				strcpy(shell->ctx->temp_buff,
  1042fb:	48 81 c7 76 01 00 00 	add    $0x176,%rdi
  104302:	e8 61 5c 00 00       	callq  109f68 <strcpy>
  104307:	eb 07                	jmp    104310 <history_handle+0x78>
			} else {
				shell->ctx->temp_buff[0] = '\0';
  104309:	c6 87 76 01 00 00 00 	movb   $0x0,0x176(%rdi)
		}
	}

	/* Start by checking if history is not empty. */
	history_mode = z_shell_history_get(shell->history, up,
					   shell->ctx->cmd_buff, &len);
  104310:	49 8b 44 24 10       	mov    0x10(%r12),%rax
	history_mode = z_shell_history_get(shell->history, up,
  104315:	49 8b 7c 24 18       	mov    0x18(%r12),%rdi
  10431a:	0f b6 f3             	movzbl %bl,%esi
  10431d:	48 8d 4d ee          	lea    -0x12(%rbp),%rcx
					   shell->ctx->cmd_buff, &len);
  104321:	48 8d 50 76          	lea    0x76(%rax),%rdx
	history_mode = z_shell_history_get(shell->history, up,
  104325:	e8 74 39 00 00       	callq  107c9e <z_shell_history_get>

	/* On exiting history mode print backed up command. */
	if (!history_mode) {
  10432a:	84 c0                	test   %al,%al
  10432c:	75 27                	jne    104355 <history_handle+0xbd>
		strcpy(shell->ctx->cmd_buff, shell->ctx->temp_buff);
  10432e:	49 8b 7c 24 10       	mov    0x10(%r12),%rdi
  104333:	48 8d b7 76 01 00 00 	lea    0x176(%rdi),%rsi
  10433a:	48 83 c7 76          	add    $0x76,%rdi
  10433e:	e8 25 5c 00 00       	callq  109f68 <strcpy>
		len = z_shell_strlen(shell->ctx->cmd_buff);
  104343:	49 8b 44 24 10       	mov    0x10(%r12),%rax
  104348:	48 8d 78 76          	lea    0x76(%rax),%rdi
  10434c:	e8 f4 fc ff ff       	callq  104045 <z_shell_strlen>
  104351:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
	}

	z_shell_op_cursor_home_move(shell);
  104355:	4c 89 e7             	mov    %r12,%rdi
  104358:	e8 1a 25 00 00       	callq  106877 <z_shell_op_cursor_home_move>
	Z_SHELL_VT100_CMD(shell, SHELL_VT100_CLEAREOS);
  10435d:	49 8b 7c 24 28       	mov    0x28(%r12),%rdi
  104362:	ba c8 dc 11 00       	mov    $0x11dcc8,%edx
  104367:	31 c0                	xor    %eax,%eax
  104369:	be b7 d5 11 00       	mov    $0x11d5b7,%esi
  10436e:	e8 e5 fc ff ff       	callq  104058 <z_shell_raw_fprintf>
	z_clear_eos(shell);
	z_shell_print_cmd(shell);
  104373:	4c 89 e7             	mov    %r12,%rdi
  104376:	e8 ba 25 00 00       	callq  106935 <z_shell_print_cmd>
	shell->ctx->cmd_buff_pos = len;
  10437b:	49 8b 44 24 10       	mov    0x10(%r12),%rax
  104380:	66 8b 55 ee          	mov    -0x12(%rbp),%dx
	shell->ctx->cmd_buff_len = len;
	z_shell_op_cond_next_line(shell);
  104384:	4c 89 e7             	mov    %r12,%rdi
	shell->ctx->cmd_buff_pos = len;
  104387:	66 89 50 72          	mov    %dx,0x72(%rax)
	shell->ctx->cmd_buff_len = len;
  10438b:	66 89 50 70          	mov    %dx,0x70(%rax)
	z_shell_op_cond_next_line(shell);
  10438f:	e8 13 23 00 00       	callq  1066a7 <z_shell_op_cond_next_line>
}
  104394:	58                   	pop    %rax
  104395:	5a                   	pop    %rdx
  104396:	5b                   	pop    %rbx
  104397:	41 5c                	pop    %r12
  104399:	5d                   	pop    %rbp
  10439a:	c3                   	retq   

000000000010439b <k_mutex_lock.constprop.0.isra.0>:
static inline int k_mutex_lock(struct k_mutex * mutex, k_timeout_t timeout)
  10439b:	55                   	push   %rbp
  10439c:	48 89 e5             	mov    %rsp,%rbp
  10439f:	e8 73 fc ff ff       	callq  104017 <arch_is_user_context>
	if (z_syscall_trap()) {
  1043a4:	84 c0                	test   %al,%al
  1043a6:	74 0d                	je     1043b5 <k_mutex_lock.constprop.0.isra.0+0x1a>
	register uintptr_t rax __asm__("%rax") = call_id;
  1043a8:	b8 95 00 00 00       	mov    $0x95,%eax
	register uintptr_t rsi __asm__("%rsi") = arg2;
  1043ad:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
	__asm__ volatile("syscall\n\t"
  1043b1:	0f 05                	syscall 
}
  1043b3:	5d                   	pop    %rbp
  1043b4:	c3                   	retq   
  1043b5:	5d                   	pop    %rbp
	return z_impl_k_mutex_lock(mutex, timeout);
  1043b6:	e9 6b af 00 00       	jmpq   10f326 <z_impl_k_mutex_lock>

00000000001043bb <k_poll_signal_raise.constprop.0.isra.0>:
static inline int k_poll_signal_raise(struct k_poll_signal * sig, int result)
  1043bb:	55                   	push   %rbp
  1043bc:	48 89 e5             	mov    %rsp,%rbp
  1043bf:	48 83 ec 10          	sub    $0x10,%rsp
  1043c3:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  1043ca:	e8 48 fc ff ff       	callq  104017 <arch_is_user_context>
	if (z_syscall_trap()) {
  1043cf:	84 c0                	test   %al,%al
  1043d1:	74 0d                	je     1043e0 <k_poll_signal_raise.constprop.0.isra.0+0x25>
	register uintptr_t rsi __asm__("%rsi") = arg2;
  1043d3:	48 8b 75 fc          	mov    -0x4(%rbp),%rsi
	register uintptr_t rax __asm__("%rax") = call_id;
  1043d7:	b8 a2 00 00 00       	mov    $0xa2,%eax
	__asm__ volatile("syscall\n\t"
  1043dc:	0f 05                	syscall 
}
  1043de:	c9                   	leaveq 
  1043df:	c3                   	retq   
	return z_impl_k_poll_signal_raise(sig, result);
  1043e0:	8b 75 fc             	mov    -0x4(%rbp),%esi
}
  1043e3:	c9                   	leaveq 
	return z_impl_k_poll_signal_raise(sig, result);
  1043e4:	e9 d6 13 01 00       	jmpq   1157bf <z_impl_k_poll_signal_raise>

00000000001043e9 <transport_evt_handler>:
{
	struct shell *shell = (struct shell *)ctx;
	struct k_poll_signal *signal;

	signal = (evt_type == SHELL_TRANSPORT_EVT_RX_RDY) ?
			&shell->ctx->signals[SHELL_SIGNAL_RXRDY] :
  1043e9:	48 8b 46 10          	mov    0x10(%rsi),%rax
{
  1043ed:	41 89 f8             	mov    %edi,%r8d
			&shell->ctx->signals[SHELL_SIGNAL_RXRDY] :
  1043f0:	48 8d b8 e0 02 00 00 	lea    0x2e0(%rax),%rdi
  1043f7:	45 85 c0             	test   %r8d,%r8d
  1043fa:	75 07                	jne    104403 <transport_evt_handler+0x1a>
  1043fc:	48 8d b8 98 02 00 00 	lea    0x298(%rax),%rdi
			&shell->ctx->signals[SHELL_SIGNAL_TXDONE];
	k_poll_signal_raise(signal, 0);
  104403:	e9 b3 ff ff ff       	jmpq   1043bb <k_poll_signal_raise.constprop.0.isra.0>

0000000000104408 <kill_handler>:
		handler(shell);
	}
}

static void kill_handler(const struct shell *shell)
{
  104408:	55                   	push   %rbp
  104409:	48 89 e5             	mov    %rsp,%rbp
  10440c:	41 54                	push   %r12
  10440e:	53                   	push   %rbx
  10440f:	48 89 fb             	mov    %rdi,%rbx
	__ASSERT_NO_MSG(shell);
  104412:	48 85 ff             	test   %rdi,%rdi
  104415:	75 2a                	jne    104441 <kill_handler+0x39>
  104417:	be ac d8 11 00       	mov    $0x11d8ac,%esi
  10441c:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  104421:	b9 cf 04 00 00       	mov    $0x4cf,%ecx
  104426:	31 c0                	xor    %eax,%eax
  104428:	ba 84 d8 11 00       	mov    $0x11d884,%edx
  10442d:	e8 c6 c1 ff ff       	callq  1005f8 <printk>
  104432:	be cf 04 00 00       	mov    $0x4cf,%esi
  104437:	bf 84 d8 11 00       	mov    $0x11d884,%edi
  10443c:	e8 57 e7 ff ff       	callq  102b98 <assert_post_action>
	__ASSERT_NO_MSG(shell->ctx && shell->iface);
  104441:	48 83 7b 10 00       	cmpq   $0x0,0x10(%rbx)
  104446:	74 07                	je     10444f <kill_handler+0x47>
  104448:	48 83 7b 08 00       	cmpq   $0x0,0x8(%rbx)
  10444d:	75 2a                	jne    104479 <kill_handler+0x71>
  10444f:	be b2 d8 11 00       	mov    $0x11d8b2,%esi
  104454:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  104459:	b9 d0 04 00 00       	mov    $0x4d0,%ecx
  10445e:	31 c0                	xor    %eax,%eax
  104460:	ba 84 d8 11 00       	mov    $0x11d884,%edx
  104465:	e8 8e c1 ff ff       	callq  1005f8 <printk>
  10446a:	be d0 04 00 00       	mov    $0x4d0,%esi
  10446f:	bf 84 d8 11 00       	mov    $0x11d884,%edi
  104474:	e8 1f e7 ff ff       	callq  102b98 <assert_post_action>
	return shell->ctx->internal.flags.processing == 1;
  104479:	48 8b 43 10          	mov    0x10(%rbx),%rax
		return -EBUSY;
  10447d:	41 bc f0 ff ff ff    	mov    $0xfffffff0,%r12d
  104483:	48 8b 80 90 02 00 00 	mov    0x290(%rax),%rax
	if (z_flag_processing_get(shell)) {
  10448a:	48 0f ba e0 24       	bt     $0x24,%rax
  10448f:	72 25                	jb     1044b6 <kill_handler+0xae>
	err = shell->iface->api->uninit(shell->iface);
  104491:	48 8b 7b 08          	mov    0x8(%rbx),%rdi
  104495:	48 8b 07             	mov    (%rdi),%rax
  104498:	ff 50 08             	callq  *0x8(%rax)
  10449b:	41 89 c4             	mov    %eax,%r12d
	if (err != 0) {
  10449e:	85 c0                	test   %eax,%eax
  1044a0:	75 14                	jne    1044b6 <kill_handler+0xae>
	z_shell_history_purge(shell->history);
  1044a2:	48 8b 7b 18          	mov    0x18(%rbx),%rdi
  1044a6:	e8 7e 38 00 00       	callq  107d29 <z_shell_history_purge>
	shell->ctx->state = state;
  1044ab:	48 8b 43 10          	mov    0x10(%rbx),%rax
  1044af:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%rax)
	int err = instance_uninit(shell);

	if (shell->ctx->uninit_cb) {
  1044b6:	48 8b 43 10          	mov    0x10(%rbx),%rax
  1044ba:	48 8b 40 60          	mov    0x60(%rax),%rax
  1044be:	48 85 c0             	test   %rax,%rax
  1044c1:	74 08                	je     1044cb <kill_handler+0xc3>
		shell->ctx->uninit_cb(shell, err);
  1044c3:	44 89 e6             	mov    %r12d,%esi
  1044c6:	48 89 df             	mov    %rbx,%rdi
  1044c9:	ff d0                	callq  *%rax
	}

	shell->ctx->tid = NULL;
  1044cb:	48 8b 43 10          	mov    0x10(%rbx),%rax
  1044cf:	48 c7 80 b8 03 00 00 	movq   $0x0,0x3b8(%rax)
  1044d6:	00 00 00 00 
static inline k_tid_t k_current_get(void)
{
#ifdef CONFIG_THREAD_LOCAL_STORAGE
	return z_tls_current;
#else
	return z_current_get();
  1044da:	e8 2f fc ff ff       	callq  10410e <z_current_get>
  1044df:	48 89 c7             	mov    %rax,%rdi
  1044e2:	e8 30 fb ff ff       	callq  104017 <arch_is_user_context>
	if (z_syscall_trap()) {
  1044e7:	84 c0                	test   %al,%al
  1044e9:	74 0c                	je     1044f7 <kill_handler+0xef>
	register uintptr_t rax __asm__("%rax") = call_id;
  1044eb:	b8 b6 00 00 00       	mov    $0xb6,%eax
	__asm__ volatile("syscall\n\t"
  1044f0:	0f 05                	syscall 
	k_thread_abort(k_current_get());
}
  1044f2:	5b                   	pop    %rbx
  1044f3:	41 5c                	pop    %r12
  1044f5:	5d                   	pop    %rbp
  1044f6:	c3                   	retq   
  1044f7:	5b                   	pop    %rbx
  1044f8:	41 5c                	pop    %r12
  1044fa:	5d                   	pop    %rbp
	z_impl_k_thread_abort(thread);
  1044fb:	e9 7d e4 00 00       	jmpq   11297d <z_impl_k_thread_abort>

0000000000104500 <shell_signal_handle>:
{
  104500:	55                   	push   %rbp
	struct k_poll_signal *signal = &shell->ctx->signals[sig_idx];
  104501:	89 f6                	mov    %esi,%esi
  104503:	48 6b f6 18          	imul   $0x18,%rsi,%rsi
{
  104507:	48 89 e5             	mov    %rsp,%rbp
  10450a:	41 55                	push   %r13
  10450c:	41 54                	push   %r12
  10450e:	49 89 fc             	mov    %rdi,%r12
  104511:	53                   	push   %rbx
  104512:	48 89 d3             	mov    %rdx,%rbx
  104515:	48 83 ec 18          	sub    $0x18,%rsp
	struct k_poll_signal *signal = &shell->ctx->signals[sig_idx];
  104519:	48 8b 47 10          	mov    0x10(%rdi),%rax
  10451d:	4c 8d ac 30 98 02 00 	lea    0x298(%rax,%rsi,1),%r13
  104524:	00 
  104525:	e8 ed fa ff ff       	callq  104017 <arch_is_user_context>
	if (z_syscall_trap()) {
  10452a:	84 c0                	test   %al,%al
  10452c:	74 14                	je     104542 <shell_signal_handle+0x42>
	register uintptr_t rax __asm__("%rax") = call_id;
  10452e:	b8 a0 00 00 00       	mov    $0xa0,%eax
	register uintptr_t rsi __asm__("%rsi") = arg2;
  104533:	48 8d 75 d8          	lea    -0x28(%rbp),%rsi
	register uintptr_t rdx __asm__("%rdx") = arg3;
  104537:	48 8d 55 dc          	lea    -0x24(%rbp),%rdx
	register uintptr_t rdi __asm__("%rdi") = arg1;
  10453b:	4c 89 ef             	mov    %r13,%rdi
	__asm__ volatile("syscall\n\t"
  10453e:	0f 05                	syscall 
	return rax;
  104540:	eb 10                	jmp    104552 <shell_signal_handle+0x52>
	z_impl_k_poll_signal_check(sig, signaled, result);
  104542:	48 8d 55 dc          	lea    -0x24(%rbp),%rdx
  104546:	48 8d 75 d8          	lea    -0x28(%rbp),%rsi
  10454a:	4c 89 ef             	mov    %r13,%rdi
  10454d:	e8 60 11 01 00       	callq  1156b2 <z_impl_k_poll_signal_check>
	if (set) {
  104552:	83 7d d8 00          	cmpl   $0x0,-0x28(%rbp)
  104556:	74 22                	je     10457a <shell_signal_handle+0x7a>
  104558:	e8 ba fa ff ff       	callq  104017 <arch_is_user_context>
	if (z_syscall_trap()) {
  10455d:	84 c0                	test   %al,%al
  10455f:	74 0c                	je     10456d <shell_signal_handle+0x6d>
	register uintptr_t rax __asm__("%rax") = call_id;
  104561:	b8 a3 00 00 00       	mov    $0xa3,%eax
	register uintptr_t rdi __asm__("%rdi") = arg1;
  104566:	4c 89 ef             	mov    %r13,%rdi
	__asm__ volatile("syscall\n\t"
  104569:	0f 05                	syscall 
	return rax;
  10456b:	eb 08                	jmp    104575 <shell_signal_handle+0x75>
	z_impl_k_poll_signal_reset(sig);
  10456d:	4c 89 ef             	mov    %r13,%rdi
  104570:	e8 35 11 01 00       	callq  1156aa <z_impl_k_poll_signal_reset>
		handler(shell);
  104575:	4c 89 e7             	mov    %r12,%rdi
  104578:	ff d3                	callq  *%rbx
}
  10457a:	48 83 c4 18          	add    $0x18,%rsp
  10457e:	5b                   	pop    %rbx
  10457f:	41 5c                	pop    %r12
  104581:	41 5d                	pop    %r13
  104583:	5d                   	pop    %rbp
  104584:	c3                   	retq   

0000000000104585 <k_mutex_unlock.isra.0>:
static inline int k_mutex_unlock(struct k_mutex * mutex)
  104585:	55                   	push   %rbp
  104586:	48 89 e5             	mov    %rsp,%rbp
  104589:	e8 89 fa ff ff       	callq  104017 <arch_is_user_context>
	if (z_syscall_trap()) {
  10458e:	84 c0                	test   %al,%al
  104590:	74 09                	je     10459b <k_mutex_unlock.isra.0+0x16>
	register uintptr_t rax __asm__("%rax") = call_id;
  104592:	b8 96 00 00 00       	mov    $0x96,%eax
	__asm__ volatile("syscall\n\t"
  104597:	0f 05                	syscall 
}
  104599:	5d                   	pop    %rbp
  10459a:	c3                   	retq   
  10459b:	5d                   	pop    %rbp
	return z_impl_k_mutex_unlock(mutex);
  10459c:	e9 d7 b0 00 00       	jmpq   10f678 <z_impl_k_mutex_unlock>

00000000001045a1 <execute>:
{
  1045a1:	55                   	push   %rbp
  1045a2:	48 89 e5             	mov    %rsp,%rbp
  1045a5:	41 57                	push   %r15
  1045a7:	49 89 ff             	mov    %rdi,%r15
  1045aa:	41 56                	push   %r14
  1045ac:	41 55                	push   %r13
  1045ae:	41 54                	push   %r12
  1045b0:	53                   	push   %rbx
  1045b1:	48 81 ec 08 01 00 00 	sub    $0x108,%rsp
	char *cmd_buf = shell->ctx->cmd_buff;
  1045b8:	48 8b 47 10          	mov    0x10(%rdi),%rax
	size_t cmd_lvl = 0;
  1045bc:	48 c7 85 08 ff ff ff 	movq   $0x0,-0xf8(%rbp)
  1045c3:	00 00 00 00 
	size_t argc = 0, args_left = SIZE_MAX;
  1045c7:	48 c7 85 10 ff ff ff 	movq   $0x0,-0xf0(%rbp)
  1045ce:	00 00 00 00 
	char *cmd_buf = shell->ctx->cmd_buff;
  1045d2:	48 83 c0 76          	add    $0x76,%rax
  1045d6:	48 89 85 d8 fe ff ff 	mov    %rax,-0x128(%rbp)
	z_shell_op_cursor_end_move(shell);
  1045dd:	e8 a7 22 00 00       	callq  106889 <z_shell_op_cursor_end_move>
	if (!z_shell_cursor_in_empty_line(shell)) {
  1045e2:	4c 89 ff             	mov    %r15,%rdi
  1045e5:	e8 80 20 00 00       	callq  10666a <z_shell_cursor_in_empty_line>
  1045ea:	84 c0                	test   %al,%al
  1045ec:	75 09                	jne    1045f7 <execute+0x56>
		z_cursor_next_line_move(shell);
  1045ee:	49 8b 7f 28          	mov    0x28(%r15),%rdi
  1045f2:	e8 95 fc ff ff       	callq  10428c <z_cursor_next_line_move.isra.0>
	memset(&shell->ctx->active_cmd, 0, sizeof(shell->ctx->active_cmd));
  1045f7:	49 8b 47 10          	mov    0x10(%r15),%rax
  1045fb:	ba 28 00 00 00       	mov    $0x28,%edx
  104600:	31 f6                	xor    %esi,%esi
		help_entry.help = NULL;
  104602:	45 31 f6             	xor    %r14d,%r14d
	size_t argc = 0, args_left = SIZE_MAX;
  104605:	48 83 cb ff          	or     $0xffffffffffffffff,%rbx
		z_shell_wildcard_prepare(shell);
  104609:	45 31 ed             	xor    %r13d,%r13d
	memset(&shell->ctx->active_cmd, 0, sizeof(shell->ctx->active_cmd));
  10460c:	48 8d 78 10          	lea    0x10(%rax),%rdi
  104610:	e8 9d 5a 00 00       	callq  10a0b2 <memset>
		z_shell_cmd_trim(shell);
  104615:	4c 89 ff             	mov    %r15,%rdi
  104618:	e8 7f 1e 00 00       	callq  10649c <z_shell_cmd_trim>
			    shell->ctx->cmd_buff_len);
  10461d:	49 8b 77 10          	mov    0x10(%r15),%rsi
	z_shell_history_put(shell->history, line, length);
  104621:	49 8b 7f 18          	mov    0x18(%r15),%rdi
		history_put(shell, shell->ctx->cmd_buff,
  104625:	0f b7 56 70          	movzwl 0x70(%rsi),%edx
  104629:	48 83 c6 76          	add    $0x76,%rsi
	z_shell_history_put(shell->history, line, length);
  10462d:	e8 1c 37 00 00       	callq  107d4e <z_shell_history_put>
		z_shell_wildcard_prepare(shell);
  104632:	4c 89 ff             	mov    %r15,%rdi
  104635:	e8 10 39 00 00       	callq  107f4a <z_shell_wildcard_prepare>
  10463a:	48 8d 85 68 ff ff ff 	lea    -0x98(%rbp),%rax
	size_t cmd_with_handler_lvl = 0;
  104641:	48 c7 85 e8 fe ff ff 	movq   $0x0,-0x118(%rbp)
  104648:	00 00 00 00 
		z_shell_wildcard_prepare(shell);
  10464c:	c6 85 f7 fe ff ff 00 	movb   $0x0,-0x109(%rbp)
  104653:	48 89 85 f8 fe ff ff 	mov    %rax,-0x108(%rbp)
  10465a:	c6 85 f6 fe ff ff 00 	movb   $0x0,-0x10a(%rbp)
  104661:	48 c7 85 e0 fe ff ff 	movq   $0x0,-0x120(%rbp)
  104668:	00 00 00 00 
	while ((argc != 1) && (cmd_lvl < CONFIG_SHELL_ARGC_MAX)
  10466c:	48 83 bd 10 ff ff ff 	cmpq   $0x1,-0xf0(%rbp)
  104673:	01 
  104674:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  10467b:	75 13                	jne    104690 <execute+0xef>
	if ((cmd_lvl >= CONFIG_SHELL_ARGC_MAX) && (argc == 2)) {
  10467d:	48 83 bd 08 ff ff ff 	cmpq   $0xb,-0xf8(%rbp)
  104684:	0b 
  104685:	0f 87 5c 02 00 00    	ja     1048e7 <execute+0x346>
  10468b:	e9 7f 02 00 00       	jmpq   10490f <execute+0x36e>
	while ((argc != 1) && (cmd_lvl < CONFIG_SHELL_ARGC_MAX)
  104690:	48 83 f8 0b          	cmp    $0xb,%rax
  104694:	41 0f 96 c4          	setbe  %r12b
		&& args_left > 0) {
  104698:	48 85 db             	test   %rbx,%rbx
  10469b:	0f 95 c0             	setne  %al
  10469e:	41 20 c4             	and    %al,%r12b
  1046a1:	74 da                	je     10467d <execute+0xdc>
		quote = z_shell_make_argv(&argc, argvp, cmd_buf, 2);
  1046a3:	48 8b 95 d8 fe ff ff 	mov    -0x128(%rbp),%rdx
  1046aa:	48 8b b5 f8 fe ff ff 	mov    -0x108(%rbp),%rsi
  1046b1:	b9 02 00 00 00       	mov    $0x2,%ecx
  1046b6:	48 8d bd 10 ff ff ff 	lea    -0xf0(%rbp),%rdi
  1046bd:	e8 a0 18 00 00       	callq  105f62 <z_shell_make_argv>
		cmd_buf = (char *)argvp[1];
  1046c2:	48 8b 8d f8 fe ff ff 	mov    -0x108(%rbp),%rcx
  1046c9:	48 8b 51 08          	mov    0x8(%rcx),%rdx
  1046cd:	48 89 95 d8 fe ff ff 	mov    %rdx,-0x128(%rbp)
		if (argc == 0) {
  1046d4:	48 8b 95 10 ff ff ff 	mov    -0xf0(%rbp),%rdx
  1046db:	48 85 d2             	test   %rdx,%rdx
  1046de:	74 20                	je     104700 <execute+0x15f>
		} else if ((argc == 1) && (quote != 0)) {
  1046e0:	84 c0                	test   %al,%al
  1046e2:	74 26                	je     10470a <execute+0x169>
  1046e4:	48 ff ca             	dec    %rdx
  1046e7:	75 21                	jne    10470a <execute+0x169>
			z_shell_fprintf(shell, SHELL_ERROR,
  1046e9:	0f be c8             	movsbl %al,%ecx
  1046ec:	ba cd d8 11 00       	mov    $0x11d8cd,%edx
  1046f1:	be 02 00 00 00       	mov    $0x2,%esi
  1046f6:	4c 89 ff             	mov    %r15,%rdi
  1046f9:	31 c0                	xor    %eax,%eax
  1046fb:	e8 2b 25 00 00       	callq  106c2b <z_shell_fprintf>
			return -ENOEXEC;
  104700:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
  104705:	e9 44 03 00 00       	jmpq   104a4e <execute+0x4ad>
		if (IS_ENABLED(CONFIG_SHELL_HELP) && (cmd_lvl > 0) &&
  10470a:	48 83 bd 08 ff ff ff 	cmpq   $0x0,-0xf8(%rbp)
  104711:	00 
  104712:	74 7d                	je     104791 <execute+0x1f0>
		    z_shell_help_request(argvp[0])) {
  104714:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
  10471b:	48 8b 38             	mov    (%rax),%rdi
  10471e:	e8 34 30 00 00       	callq  107757 <z_shell_help_request>
		if (IS_ENABLED(CONFIG_SHELL_HELP) && (cmd_lvl > 0) &&
  104723:	84 c0                	test   %al,%al
  104725:	74 23                	je     10474a <execute+0x1a9>
			if (help_entry.help) {
  104727:	4d 85 f6             	test   %r14,%r14
  10472a:	74 14                	je     104740 <execute+0x19f>
				shell->ctx->active_cmd = help_entry;
  10472c:	49 8b 47 10          	mov    0x10(%r15),%rax
  104730:	4c 89 b5 48 ff ff ff 	mov    %r14,-0xb8(%rbp)
  104737:	48 8d 78 10          	lea    0x10(%rax),%rdi
  10473b:	e9 38 02 00 00       	jmpq   104978 <execute+0x3d7>
			z_shell_fprintf(shell, SHELL_ERROR,
  104740:	ba e1 d8 11 00       	mov    $0x11d8e1,%edx
  104745:	e9 a9 00 00 00       	jmpq   1047f3 <execute+0x252>
		if (IS_ENABLED(CONFIG_SHELL_WILDCARD) && (cmd_lvl > 0)) {
  10474a:	48 83 bd 08 ff ff ff 	cmpq   $0x0,-0xf8(%rbp)
  104751:	00 
  104752:	74 3d                	je     104791 <execute+0x1f0>
			status = z_shell_wildcard_process(shell, entry,
  104754:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
  10475b:	4c 89 ee             	mov    %r13,%rsi
  10475e:	4c 89 ff             	mov    %r15,%rdi
  104761:	48 8b 10             	mov    (%rax),%rdx
  104764:	e8 4d 38 00 00       	callq  107fb6 <z_shell_wildcard_process>
			if (status == SHELL_WILDCARD_CMD_NO_MATCH_FOUND) {
  104769:	83 f8 02             	cmp    $0x2,%eax
  10476c:	0f 84 0b ff ff ff    	je     10467d <execute+0xdc>
			if (status != SHELL_WILDCARD_NOT_FOUND) {
  104772:	83 f8 03             	cmp    $0x3,%eax
  104775:	74 1a                	je     104791 <execute+0x1f0>
				wildcard_found = true;
  104777:	44 88 a5 f6 fe ff ff 	mov    %r12b,-0x10a(%rbp)
				continue;
  10477e:	44 8a a5 f7 fe ff ff 	mov    -0x109(%rbp),%r12b
				++cmd_lvl;
  104785:	48 ff 85 08 ff ff ff 	incq   -0xf8(%rbp)
				continue;
  10478c:	e9 4a 01 00 00       	jmpq   1048db <execute+0x33a>
		if (has_last_handler == false) {
  104791:	80 bd f7 fe ff ff 00 	cmpb   $0x0,-0x109(%rbp)
  104798:	75 20                	jne    1047ba <execute+0x219>
			entry = z_shell_find_cmd(parent, argvp[0], &dloc);
  10479a:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
  1047a1:	48 8b bd e0 fe ff ff 	mov    -0x120(%rbp),%rdi
  1047a8:	48 8d 95 18 ff ff ff 	lea    -0xe8(%rbp),%rdx
  1047af:	48 8b 30             	mov    (%rax),%rsi
  1047b2:	e8 33 1b 00 00       	callq  1062ea <z_shell_find_cmd>
  1047b7:	49 89 c5             	mov    %rax,%r13
		argvp++;
  1047ba:	48 83 85 f8 fe ff ff 	addq   $0x8,-0x108(%rbp)
  1047c1:	08 
		args_left--;
  1047c2:	48 ff cb             	dec    %rbx
		if (entry) {
  1047c5:	4d 85 ed             	test   %r13,%r13
  1047c8:	0f 84 a8 00 00 00    	je     104876 <execute+0x2d5>
	if (IS_ENABLED(CONFIG_SHELL_WILDCARD) && found && entry->handler) {
  1047ce:	80 bd f6 fe ff ff 00 	cmpb   $0x0,-0x10a(%rbp)
  1047d5:	74 30                	je     104807 <execute+0x266>
  1047d7:	49 83 7d 18 00       	cmpq   $0x0,0x18(%r13)
  1047dc:	74 79                	je     104857 <execute+0x2b6>
		z_shell_op_cursor_end_move(shell);
  1047de:	4c 89 ff             	mov    %r15,%rdi
  1047e1:	e8 a3 20 00 00       	callq  106889 <z_shell_op_cursor_end_move>
		z_shell_op_cond_next_line(shell);
  1047e6:	4c 89 ff             	mov    %r15,%rdi
  1047e9:	e8 b9 1e 00 00       	callq  1066a7 <z_shell_op_cond_next_line>
		z_shell_fprintf(shell, SHELL_ERROR,
  1047ee:	ba ff d8 11 00       	mov    $0x11d8ff,%edx
  1047f3:	be 02 00 00 00       	mov    $0x2,%esi
  1047f8:	4c 89 ff             	mov    %r15,%rdi
  1047fb:	31 c0                	xor    %eax,%eax
  1047fd:	e8 29 24 00 00       	callq  106c2b <z_shell_fprintf>
		return false;
  104802:	e9 f9 fe ff ff       	jmpq   104700 <execute+0x15f>
	if (entry->handler) {
  104807:	49 83 7d 18 00       	cmpq   $0x0,0x18(%r13)
  10480c:	74 49                	je     104857 <execute+0x2b6>
		*handler_lvl = *lvl;
  10480e:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
		*active_cmd = *entry;
  104815:	b9 0a 00 00 00       	mov    $0xa,%ecx
  10481a:	4c 89 ee             	mov    %r13,%rsi
		*handler_lvl = *lvl;
  10481d:	48 89 85 e8 fe ff ff 	mov    %rax,-0x118(%rbp)
		*active_cmd = *entry;
  104824:	49 8b 47 10          	mov    0x10(%r15),%rax
  104828:	48 8d 78 10          	lea    0x10(%rax),%rdi
  10482c:	f3 a5                	rep movsl %ds:(%rsi),%es:(%rdi)
		if ((entry->subcmd == NULL)
  10482e:	49 83 7d 10 00       	cmpq   $0x0,0x10(%r13)
  104833:	75 22                	jne    104857 <execute+0x2b6>
		    && entry->args.optional == SHELL_OPT_ARG_RAW) {
  104835:	41 80 7d 21 fe       	cmpb   $0xfe,0x21(%r13)
  10483a:	75 1b                	jne    104857 <execute+0x2b6>
			*lvl = *lvl + 1;
  10483c:	48 8b 85 e8 fe ff ff 	mov    -0x118(%rbp),%rax
			*args_left = entry->args.mandatory - 1;
  104843:	41 0f b6 5d 20       	movzbl 0x20(%r13),%ebx
			*lvl = *lvl + 1;
  104848:	48 ff c0             	inc    %rax
			*args_left = entry->args.mandatory - 1;
  10484b:	ff cb                	dec    %ebx
			*lvl = *lvl + 1;
  10484d:	48 89 85 08 ff ff ff 	mov    %rax,-0xf8(%rbp)
			*args_left = entry->args.mandatory - 1;
  104854:	48 63 db             	movslq %ebx,%rbx
	if (entry->help) {
  104857:	49 8b 45 08          	mov    0x8(%r13),%rax
  10485b:	48 85 c0             	test   %rax,%rax
  10485e:	74 57                	je     1048b7 <execute+0x316>
		*help_entry = *entry;
  104860:	48 8d bd 40 ff ff ff 	lea    -0xc0(%rbp),%rdi
  104867:	b9 0a 00 00 00       	mov    $0xa,%ecx
  10486c:	4c 89 ee             	mov    %r13,%rsi
  10486f:	49 89 c6             	mov    %rax,%r14
  104872:	f3 a5                	rep movsl %ds:(%rsi),%es:(%rdi)
  104874:	eb 41                	jmp    1048b7 <execute+0x316>
			if (cmd_lvl == 0 &&
  104876:	48 83 bd 08 ff ff ff 	cmpq   $0x0,-0xf8(%rbp)
  10487d:	00 
  10487e:	75 45                	jne    1048c5 <execute+0x324>
	z_shell_fprintf_buffer_flush(shell->fprintf_ctx);
}

static inline bool z_shell_in_select_mode(const struct shell *shell)
{
	return shell->ctx->selected_cmd == NULL ? false : true;
  104880:	49 8b 47 10          	mov    0x10(%r15),%rax
  104884:	48 8b 40 38          	mov    0x38(%rax),%rax
  104888:	48 85 c0             	test   %rax,%rax
  10488b:	74 07                	je     104894 <execute+0x2f3>
				(!z_shell_in_select_mode(shell) ||
  10488d:	48 83 78 18 00       	cmpq   $0x0,0x18(%rax)
  104892:	75 31                	jne    1048c5 <execute+0x324>
				z_shell_fprintf(shell, SHELL_ERROR,
  104894:	41 b8 2e d9 11 00    	mov    $0x11d92e,%r8d
  10489a:	ba 5c de 11 00       	mov    $0x11de5c,%edx
  10489f:	4c 89 ff             	mov    %r15,%rdi
  1048a2:	31 c0                	xor    %eax,%eax
  1048a4:	48 8b 8d 68 ff ff ff 	mov    -0x98(%rbp),%rcx
  1048ab:	be 02 00 00 00       	mov    $0x2,%esi
  1048b0:	e8 76 23 00 00       	callq  106c2b <z_shell_fprintf>
  1048b5:	eb 0e                	jmp    1048c5 <execute+0x324>
  1048b7:	4c 89 ad e0 fe ff ff 	mov    %r13,-0x120(%rbp)
  1048be:	44 8a a5 f7 fe ff ff 	mov    -0x109(%rbp),%r12b
		if (args_left || (argc == 2)) {
  1048c5:	48 85 db             	test   %rbx,%rbx
  1048c8:	75 0a                	jne    1048d4 <execute+0x333>
  1048ca:	48 83 bd 10 ff ff ff 	cmpq   $0x2,-0xf0(%rbp)
  1048d1:	02 
  1048d2:	75 07                	jne    1048db <execute+0x33a>
			cmd_lvl++;
  1048d4:	48 ff 85 08 ff ff ff 	incq   -0xf8(%rbp)
				continue;
  1048db:	44 88 a5 f7 fe ff ff 	mov    %r12b,-0x109(%rbp)
  1048e2:	e9 85 fd ff ff       	jmpq   10466c <execute+0xcb>
	if ((cmd_lvl >= CONFIG_SHELL_ARGC_MAX) && (argc == 2)) {
  1048e7:	48 83 bd 10 ff ff ff 	cmpq   $0x2,-0xf0(%rbp)
  1048ee:	02 
  1048ef:	75 1e                	jne    10490f <execute+0x36e>
		z_shell_fprintf(shell, SHELL_ERROR, "%s\n",
  1048f1:	b9 42 d9 11 00       	mov    $0x11d942,%ecx
  1048f6:	ba 56 d5 11 00       	mov    $0x11d556,%edx
  1048fb:	4c 89 ff             	mov    %r15,%rdi
  1048fe:	31 c0                	xor    %eax,%eax
  104900:	be 02 00 00 00       	mov    $0x2,%esi
  104905:	e8 21 23 00 00       	callq  106c2b <z_shell_fprintf>
		return -ENOEXEC;
  10490a:	e9 f1 fd ff ff       	jmpq   104700 <execute+0x15f>
	if (IS_ENABLED(CONFIG_SHELL_WILDCARD) && wildcard_found) {
  10490f:	80 bd f6 fe ff ff 00 	cmpb   $0x0,-0x10a(%rbp)
  104916:	74 28                	je     104940 <execute+0x39f>
		z_shell_wildcard_finalize(shell);
  104918:	4c 89 ff             	mov    %r15,%rdi
  10491b:	e8 1c 38 00 00       	callq  10813c <z_shell_wildcard_finalize>
					shell->ctx->cmd_buff,
  104920:	49 8b 47 10          	mov    0x10(%r15),%rax
		(void)z_shell_make_argv(&cmd_lvl,
  104924:	b9 0c 00 00 00       	mov    $0xc,%ecx
  104929:	48 8d b5 68 ff ff ff 	lea    -0x98(%rbp),%rsi
  104930:	48 8d bd 08 ff ff ff 	lea    -0xf8(%rbp),%rdi
					shell->ctx->cmd_buff,
  104937:	48 8d 50 76          	lea    0x76(%rax),%rdx
		(void)z_shell_make_argv(&cmd_lvl,
  10493b:	e8 22 16 00 00       	callq  105f62 <z_shell_make_argv>
	if (shell->ctx->active_cmd.handler == NULL) {
  104940:	49 8b 7f 10          	mov    0x10(%r15),%rdi
	argv[cmd_lvl] = NULL;
  104944:	4c 8b a5 08 ff ff ff 	mov    -0xf8(%rbp),%r12
	if (shell->ctx->active_cmd.handler == NULL) {
  10494b:	48 83 7f 28 00       	cmpq   $0x0,0x28(%rdi)
	argv[cmd_lvl] = NULL;
  104950:	4a c7 84 e5 68 ff ff 	movq   $0x0,-0x98(%rbp,%r12,8)
  104957:	ff 00 00 00 00 
	if (shell->ctx->active_cmd.handler == NULL) {
  10495c:	75 3a                	jne    104998 <execute+0x3f7>
			if (help_entry->help == NULL) {
  10495e:	4d 85 f6             	test   %r14,%r14
  104961:	0f 84 99 fd ff ff    	je     104700 <execute+0x15f>
			if (help_entry->help != shell->ctx->active_cmd.help) {
  104967:	4c 3b 77 18          	cmp    0x18(%rdi),%r14
  10496b:	74 19                	je     104986 <execute+0x3e5>
				shell->ctx->active_cmd = *help_entry;
  10496d:	4c 89 b5 48 ff ff ff 	mov    %r14,-0xb8(%rbp)
  104974:	48 83 c7 10          	add    $0x10,%rdi
  104978:	48 8d b5 40 ff ff ff 	lea    -0xc0(%rbp),%rsi
  10497f:	b9 0a 00 00 00       	mov    $0xa,%ecx
  104984:	f3 a5                	rep movsl %ds:(%rsi),%es:(%rdi)
			shell_internal_help_print(shell);
  104986:	4c 89 ff             	mov    %r15,%rdi
  104989:	e8 50 f7 ff ff       	callq  1040de <shell_internal_help_print>
			return SHELL_CMD_HELP_PRINTED;
  10498e:	b8 01 00 00 00       	mov    $0x1,%eax
  104993:	e9 b6 00 00 00       	jmpq   104a4e <execute+0x4ad>
	if (shell->ctx->active_cmd.args.mandatory) {
  104998:	0f b6 47 30          	movzbl 0x30(%rdi),%eax
	return exec_cmd(shell, cmd_lvl - cmd_with_handler_lvl,
  10499c:	4c 2b a5 e8 fe ff ff 	sub    -0x118(%rbp),%r12
	if (shell->ctx->active_cmd.args.mandatory) {
  1049a3:	84 c0                	test   %al,%al
  1049a5:	74 46                	je     1049ed <execute+0x44c>
		uint8_t opt8 = shell->ctx->active_cmd.args.optional;
  1049a7:	8a 4f 31             	mov    0x31(%rdi),%cl
				UINT16_MAX : opt8;
  1049aa:	ba ff ff 00 00       	mov    $0xffff,%edx
  1049af:	80 f9 ff             	cmp    $0xff,%cl
  1049b2:	74 03                	je     1049b7 <execute+0x416>
  1049b4:	0f b6 d1             	movzbl %cl,%edx
		bool in_range = (argc >= mand) && (argc <= (mand + opt));
  1049b7:	0f b6 c8             	movzbl %al,%ecx
  1049ba:	49 39 cc             	cmp    %rcx,%r12
  1049bd:	72 07                	jb     1049c6 <execute+0x425>
  1049bf:	01 d0                	add    %edx,%eax
	if (!arg_cnt_ok) {
  1049c1:	49 39 c4             	cmp    %rax,%r12
  1049c4:	76 27                	jbe    1049ed <execute+0x44c>
		z_shell_fprintf(shell, SHELL_ERROR,
  1049c6:	48 8b 4f 10          	mov    0x10(%rdi),%rcx
  1049ca:	31 c0                	xor    %eax,%eax
  1049cc:	ba 66 d9 11 00       	mov    $0x11d966,%edx
  1049d1:	be 02 00 00 00       	mov    $0x2,%esi
  1049d6:	4c 89 ff             	mov    %r15,%rdi
  1049d9:	e8 4d 22 00 00       	callq  106c2b <z_shell_fprintf>
			shell_internal_help_print(shell);
  1049de:	4c 89 ff             	mov    %r15,%rdi
  1049e1:	e8 f8 f6 ff ff       	callq  1040de <shell_internal_help_print>
		return -EINVAL;
  1049e6:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
  1049eb:	eb 61                	jmp    104a4e <execute+0x4ad>
		z_flag_cmd_ctx_set(shell, true);
  1049ed:	be 01 00 00 00       	mov    $0x1,%esi
  1049f2:	e8 53 f7 ff ff       	callq  10414a <z_flag_cmd_ctx_set.isra.0>
		k_mutex_unlock(&shell->ctx->wr_mtx);
  1049f7:	49 8b 47 10          	mov    0x10(%r15),%rax
  1049fb:	48 8d b8 98 03 00 00 	lea    0x398(%rax),%rdi
  104a02:	e8 7e fb ff ff       	callq  104585 <k_mutex_unlock.isra.0>
	return exec_cmd(shell, cmd_lvl - cmd_with_handler_lvl,
  104a07:	48 8b 85 e8 fe ff ff 	mov    -0x118(%rbp),%rax
		ret_val = shell->ctx->active_cmd.handler(shell, argc,
  104a0e:	4c 89 e6             	mov    %r12,%rsi
  104a11:	4c 89 ff             	mov    %r15,%rdi
	return exec_cmd(shell, cmd_lvl - cmd_with_handler_lvl,
  104a14:	48 8d 94 c5 68 ff ff 	lea    -0x98(%rbp,%rax,8),%rdx
  104a1b:	ff 
		ret_val = shell->ctx->active_cmd.handler(shell, argc,
  104a1c:	49 8b 47 10          	mov    0x10(%r15),%rax
  104a20:	ff 50 28             	callq  *0x28(%rax)
		k_mutex_lock(&shell->ctx->wr_mtx, K_FOREVER);
  104a23:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
		ret_val = shell->ctx->active_cmd.handler(shell, argc,
  104a27:	89 85 f8 fe ff ff    	mov    %eax,-0x108(%rbp)
		k_mutex_lock(&shell->ctx->wr_mtx, K_FOREVER);
  104a2d:	49 8b 47 10          	mov    0x10(%r15),%rax
  104a31:	48 8d b8 98 03 00 00 	lea    0x398(%rax),%rdi
  104a38:	e8 5e f9 ff ff       	callq  10439b <k_mutex_lock.constprop.0.isra.0>
		z_flag_cmd_ctx_set(shell, false);
  104a3d:	49 8b 7f 10          	mov    0x10(%r15),%rdi
  104a41:	31 f6                	xor    %esi,%esi
  104a43:	e8 02 f7 ff ff       	callq  10414a <z_flag_cmd_ctx_set.isra.0>
  104a48:	8b 85 f8 fe ff ff    	mov    -0x108(%rbp),%eax
}
  104a4e:	48 81 c4 08 01 00 00 	add    $0x108,%rsp
  104a55:	5b                   	pop    %rbx
  104a56:	41 5c                	pop    %r12
  104a58:	41 5d                	pop    %r13
  104a5a:	41 5e                	pop    %r14
  104a5c:	41 5f                	pop    %r15
  104a5e:	5d                   	pop    %rbp
  104a5f:	c3                   	retq   

0000000000104a60 <state_set.constprop.0>:
	shell->ctx->state = state;
  104a60:	48 8b 47 10          	mov    0x10(%rdi),%rax
	if (state == SHELL_STATE_ACTIVE && !shell->ctx->bypass) {
  104a64:	48 83 78 68 00       	cmpq   $0x0,0x68(%rax)
	shell->ctx->state = state;
  104a69:	c7 40 08 02 00 00 00 	movl   $0x2,0x8(%rax)
	if (state == SHELL_STATE_ACTIVE && !shell->ctx->bypass) {
  104a70:	75 51                	jne    104ac3 <state_set.constprop.0+0x63>
static inline void state_set(const struct shell *shell, enum shell_state state)
  104a72:	55                   	push   %rbp
  104a73:	48 89 e5             	mov    %rsp,%rbp
  104a76:	41 54                	push   %r12
  104a78:	49 89 fc             	mov    %rdi,%r12
  104a7b:	52                   	push   %rdx
	shell->ctx->cmd_buff[0] = '\0'; /* clear command buffer */
  104a7c:	c6 40 76 00          	movb   $0x0,0x76(%rax)
	shell->ctx->cmd_buff_len = 0;
  104a80:	c7 40 70 00 00 00 00 	movl   $0x0,0x70(%rax)
	return shell->ctx->internal.flags.print_noinit == 1;
  104a87:	48 8b 80 90 02 00 00 	mov    0x290(%rax),%rax
		if (z_flag_print_noinit_get(shell)) {
  104a8e:	48 0f ba e0 31       	bt     $0x31,%rax
  104a93:	73 22                	jae    104ab7 <state_set.constprop.0+0x57>
			z_shell_fprintf(shell, SHELL_WARNING, "%s",
  104a95:	be 04 00 00 00       	mov    $0x4,%esi
  104a9a:	b9 81 d9 11 00       	mov    $0x11d981,%ecx
  104a9f:	ba b7 d5 11 00       	mov    $0x11d5b7,%edx
  104aa4:	31 c0                	xor    %eax,%eax
  104aa6:	e8 80 21 00 00       	callq  106c2b <z_shell_fprintf>
			z_flag_print_noinit_set(shell, false);
  104aab:	49 8b 7c 24 10       	mov    0x10(%r12),%rdi
  104ab0:	31 f6                	xor    %esi,%esi
  104ab2:	e8 73 f6 ff ff       	callq  10412a <z_flag_print_noinit_set.isra.0>
}
  104ab7:	58                   	pop    %rax
		z_shell_print_prompt_and_cmd(shell);
  104ab8:	4c 89 e7             	mov    %r12,%rdi
}
  104abb:	41 5c                	pop    %r12
  104abd:	5d                   	pop    %rbp
		z_shell_print_prompt_and_cmd(shell);
  104abe:	e9 a6 26 00 00       	jmpq   107169 <z_shell_print_prompt_and_cmd>
  104ac3:	c3                   	retq   

0000000000104ac4 <shell_process>:

	return 0;
}

void shell_process(const struct shell *shell)
{
  104ac4:	55                   	push   %rbp
  104ac5:	48 89 e5             	mov    %rsp,%rbp
  104ac8:	41 57                	push   %r15
  104aca:	41 56                	push   %r14
  104acc:	41 55                	push   %r13
  104ace:	41 54                	push   %r12
  104ad0:	53                   	push   %rbx
  104ad1:	48 89 fb             	mov    %rdi,%rbx
  104ad4:	48 81 ec 58 01 00 00 	sub    $0x158,%rsp
	__ASSERT_NO_MSG(shell);
  104adb:	48 85 ff             	test   %rdi,%rdi
  104ade:	75 2a                	jne    104b0a <shell_process+0x46>
  104ae0:	be ac d8 11 00       	mov    $0x11d8ac,%esi
  104ae5:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  104aea:	b9 9b 05 00 00       	mov    $0x59b,%ecx
  104aef:	31 c0                	xor    %eax,%eax
  104af1:	ba 84 d8 11 00       	mov    $0x11d884,%edx
  104af6:	e8 fd ba ff ff       	callq  1005f8 <printk>
  104afb:	be 9b 05 00 00       	mov    $0x59b,%esi
  104b00:	bf 84 d8 11 00       	mov    $0x11d884,%edi
  104b05:	e8 8e e0 ff ff       	callq  102b98 <assert_post_action>
	__ASSERT_NO_MSG(shell->ctx);
  104b0a:	48 83 7b 10 00       	cmpq   $0x0,0x10(%rbx)
  104b0f:	75 2a                	jne    104b3b <shell_process+0x77>
  104b11:	be c5 d9 11 00       	mov    $0x11d9c5,%esi
  104b16:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  104b1b:	b9 9c 05 00 00       	mov    $0x59c,%ecx
  104b20:	31 c0                	xor    %eax,%eax
  104b22:	ba 84 d8 11 00       	mov    $0x11d884,%edx
  104b27:	e8 cc ba ff ff       	callq  1005f8 <printk>
  104b2c:	be 9c 05 00 00       	mov    $0x59c,%esi
  104b31:	bf 84 d8 11 00       	mov    $0x11d884,%edi
  104b36:	e8 5d e0 ff ff       	callq  102b98 <assert_post_action>

	/* atomically set the processing flag */
	z_flag_processing_set(shell, true);
  104b3b:	48 8b 7b 10          	mov    0x10(%rbx),%rdi
  104b3f:	be 01 00 00 00       	mov    $0x1,%esi
  104b44:	e8 6f f6 ff ff       	callq  1041b8 <z_flag_processing_set.isra.0>

	switch (shell->ctx->state) {
  104b49:	48 8b 43 10          	mov    0x10(%rbx),%rax
  104b4d:	83 78 08 02          	cmpl   $0x2,0x8(%rax)
  104b51:	0f 85 78 09 00 00    	jne    1054cf <shell_process+0xa0b>
	size_t count = 0;
  104b57:	48 c7 85 d8 fe ff ff 	movq   $0x0,-0x128(%rbp)
  104b5e:	00 00 00 00 
		shell_bypass_cb_t bypass = shell->ctx->bypass;
  104b62:	48 8b 43 10          	mov    0x10(%rbx),%rax
			(void)shell->iface->api->read(shell->iface, buf,
  104b66:	48 8b 7b 08          	mov    0x8(%rbx),%rdi
  104b6a:	48 8d 8d d8 fe ff ff 	lea    -0x128(%rbp),%rcx
		shell_bypass_cb_t bypass = shell->ctx->bypass;
  104b71:	4c 8b 60 68          	mov    0x68(%rax),%r12
			(void)shell->iface->api->read(shell->iface, buf,
  104b75:	48 8b 07             	mov    (%rdi),%rax
  104b78:	48 8b 40 20          	mov    0x20(%rax),%rax
		if (bypass) {
  104b7c:	4d 85 e4             	test   %r12,%r12
  104b7f:	74 43                	je     104bc4 <shell_process+0x100>
			(void)shell->iface->api->read(shell->iface, buf,
  104b81:	ba 10 00 00 00       	mov    $0x10,%edx
  104b86:	48 8d b5 68 ff ff ff 	lea    -0x98(%rbp),%rsi
  104b8d:	ff d0                	callq  *%rax
			if (count) {
  104b8f:	48 8b 95 d8 fe ff ff 	mov    -0x128(%rbp),%rdx
  104b96:	48 85 d2             	test   %rdx,%rdx
  104b99:	0f 84 30 09 00 00    	je     1054cf <shell_process+0xa0b>
				bypass(shell, buf, count);
  104b9f:	48 8d b5 68 ff ff ff 	lea    -0x98(%rbp),%rsi
  104ba6:	48 89 df             	mov    %rbx,%rdi
  104ba9:	41 ff d4             	callq  *%r12
				if (!(volatile shell_bypass_cb_t *)shell->ctx->bypass) {
  104bac:	48 8b 43 10          	mov    0x10(%rbx),%rax
  104bb0:	48 83 78 68 00       	cmpq   $0x0,0x68(%rax)
  104bb5:	75 ab                	jne    104b62 <shell_process+0x9e>
					state_set(shell, SHELL_STATE_ACTIVE);
  104bb7:	48 89 df             	mov    %rbx,%rdi
  104bba:	e8 a1 fe ff ff       	callq  104a60 <state_set.constprop.0>
  104bbf:	e9 0b 09 00 00       	jmpq   1054cf <shell_process+0xa0b>
		(void)shell->iface->api->read(shell->iface, &data,
  104bc4:	ba 01 00 00 00       	mov    $0x1,%edx
  104bc9:	48 8d b5 d7 fe ff ff 	lea    -0x129(%rbp),%rsi
  104bd0:	ff d0                	callq  *%rax
		if (count == 0) {
  104bd2:	48 83 bd d8 fe ff ff 	cmpq   $0x0,-0x128(%rbp)
  104bd9:	00 
  104bda:	0f 84 ef 08 00 00    	je     1054cf <shell_process+0xa0b>
		if (ascii_filter(data) != 0) {
  104be0:	8a 85 d7 fe ff ff    	mov    -0x129(%rbp),%al
		switch (shell->ctx->receive_state) {
  104be6:	48 8b 7b 10          	mov    0x10(%rbx),%rdi
	return (uint8_t) data > SHELL_ASCII_MAX_CHAR ? -EINVAL : 0;
  104bea:	84 c0                	test   %al,%al
  104bec:	0f 88 70 ff ff ff    	js     104b62 <shell_process+0x9e>
		switch (shell->ctx->receive_state) {
  104bf2:	8b 57 0c             	mov    0xc(%rdi),%edx
  104bf5:	83 fa 02             	cmp    $0x2,%edx
  104bf8:	0f 84 7d 08 00 00    	je     10547b <shell_process+0x9b7>
  104bfe:	77 0a                	ja     104c0a <shell_process+0x146>
  104c00:	85 d2                	test   %edx,%edx
  104c02:	0f 85 2d 08 00 00    	jne    105435 <shell_process+0x971>
  104c08:	eb 0c                	jmp    104c16 <shell_process+0x152>
	shell->ctx->receive_state = state;
  104c0a:	c7 47 0c 00 00 00 00 	movl   $0x0,0xc(%rdi)
  104c11:	e9 4c ff ff ff       	jmpq   104b62 <shell_process+0x9e>
	if ((data != '\r') && (data != '\n')) {
  104c16:	3c 0d                	cmp    $0xd,%al
  104c18:	74 0d                	je     104c27 <shell_process+0x163>
  104c1a:	3c 0a                	cmp    $0xa,%al
  104c1c:	74 09                	je     104c27 <shell_process+0x163>
	shell->ctx->internal.flags.last_nl = val;
  104c1e:	c6 87 95 02 00 00 00 	movb   $0x0,0x295(%rdi)
		return false;
  104c25:	eb 4c                	jmp    104c73 <shell_process+0x1af>
	return shell->ctx->internal.flags.last_nl;
  104c27:	8a 97 95 02 00 00    	mov    0x295(%rdi),%dl
	if ((z_flag_last_nl_get(shell) == 0U) ||
  104c2d:	84 d2                	test   %dl,%dl
  104c2f:	74 0a                	je     104c3b <shell_process+0x177>
  104c31:	8a 97 95 02 00 00    	mov    0x295(%rdi),%dl
  104c37:	38 d0                	cmp    %dl,%al
  104c39:	75 38                	jne    104c73 <shell_process+0x1af>
				if (!shell->ctx->cmd_buff_len) {
  104c3b:	66 83 7f 70 00       	cmpw   $0x0,0x70(%rdi)
	shell->ctx->internal.flags.last_nl = val;
  104c40:	88 87 95 02 00 00    	mov    %al,0x295(%rdi)
  104c46:	75 1e                	jne    104c66 <shell_process+0x1a2>
	z_flag_history_exit_set(shell, false);
  104c48:	31 f6                	xor    %esi,%esi
  104c4a:	e8 1b f5 ff ff       	callq  10416a <z_flag_history_exit_set.isra.0>
	z_shell_history_mode_exit(shell->history);
  104c4f:	48 8b 7b 18          	mov    0x18(%rbx),%rdi
  104c53:	e8 3d 30 00 00       	callq  107c95 <z_shell_history_mode_exit>
					z_cursor_next_line_move(shell);
  104c58:	48 8b 7b 28          	mov    0x28(%rbx),%rdi
  104c5c:	e8 2b f6 ff ff       	callq  10428c <z_cursor_next_line_move.isra.0>
  104c61:	e9 cb 06 00 00       	jmpq   105331 <shell_process+0x86d>
					(void)execute(shell);
  104c66:	48 89 df             	mov    %rbx,%rdi
  104c69:	e8 33 f9 ff ff       	callq  1045a1 <execute>
				state_set(shell, SHELL_STATE_ACTIVE);
  104c6e:	e9 be 06 00 00       	jmpq   105331 <shell_process+0x86d>
			switch (data) {
  104c73:	3c 09                	cmp    $0x9,%al
  104c75:	74 34                	je     104cab <shell_process+0x1e7>
  104c77:	7f 15                	jg     104c8e <shell_process+0x1ca>
  104c79:	84 c0                	test   %al,%al
  104c7b:	0f 84 e1 fe ff ff    	je     104b62 <shell_process+0x9e>
  104c81:	3c 08                	cmp    $0x8,%al
  104c83:	0f 84 b0 05 00 00    	je     105239 <shell_process+0x775>
  104c89:	e9 08 06 00 00       	jmpq   105296 <shell_process+0x7d2>
  104c8e:	3c 1b                	cmp    $0x1b,%al
  104c90:	74 0d                	je     104c9f <shell_process+0x1db>
  104c92:	3c 7f                	cmp    $0x7f,%al
  104c94:	0f 84 bd 05 00 00    	je     105257 <shell_process+0x793>
  104c9a:	e9 f7 05 00 00       	jmpq   105296 <shell_process+0x7d2>
	shell->ctx->receive_state = state;
  104c9f:	c7 47 0c 01 00 00 00 	movl   $0x1,0xc(%rdi)
}
  104ca6:	e9 b7 fe ff ff       	jmpq   104b62 <shell_process+0x9e>
	return shell->ctx->internal.flags.echo == 1;
  104cab:	48 8b 87 90 02 00 00 	mov    0x290(%rdi),%rax
				if (z_flag_echo_get(shell) &&
  104cb2:	48 0f ba e0 22       	bt     $0x22,%rax
  104cb7:	0f 83 a5 fe ff ff    	jae    104b62 <shell_process+0x9e>
					z_flag_history_exit_set(shell, true);
  104cbd:	be 01 00 00 00       	mov    $0x1,%esi
  104cc2:	e8 a3 f4 ff ff       	callq  10416a <z_flag_history_exit_set.isra.0>
			shell->ctx->cmd_buff_len;
  104cc7:	48 8b 7b 10          	mov    0x10(%rbx),%rdi
	if (compl_space == 0U) {
  104ccb:	66 81 7f 70 ff 00    	cmpw   $0xff,0x70(%rdi)
  104cd1:	0f 84 8b fe ff ff    	je     104b62 <shell_process+0x9e>
	memcpy(shell->ctx->temp_buff, shell->ctx->cmd_buff,
  104cd7:	0f b7 57 72          	movzwl 0x72(%rdi),%edx
  104cdb:	48 8d 77 76          	lea    0x76(%rdi),%rsi
  104cdf:	48 81 c7 76 01 00 00 	add    $0x176,%rdi
  104ce6:	e8 ad 53 00 00       	callq  10a098 <memcpy>
	shell->ctx->temp_buff[shell->ctx->cmd_buff_pos] = '\0';
  104ceb:	48 8b 53 10          	mov    0x10(%rbx),%rdx
	(void)z_shell_make_argv(argc, *argv, shell->ctx->temp_buff,
  104cef:	48 8d b5 68 ff ff ff 	lea    -0x98(%rbp),%rsi
  104cf6:	b9 0c 00 00 00       	mov    $0xc,%ecx
  104cfb:	48 8d bd e8 fe ff ff 	lea    -0x118(%rbp),%rdi
	shell->ctx->temp_buff[shell->ctx->cmd_buff_pos] = '\0';
  104d02:	0f b7 42 72          	movzwl 0x72(%rdx),%eax
	(void)z_shell_make_argv(argc, *argv, shell->ctx->temp_buff,
  104d06:	48 81 c2 76 01 00 00 	add    $0x176,%rdx
	shell->ctx->temp_buff[shell->ctx->cmd_buff_pos] = '\0';
  104d0d:	c6 04 02 00          	movb   $0x0,(%rdx,%rax,1)
	(void)z_shell_make_argv(argc, *argv, shell->ctx->temp_buff,
  104d11:	e8 4c 12 00 00       	callq  105f62 <z_shell_make_argv>
	if (*argc > CONFIG_SHELL_ARGC_MAX) {
  104d16:	48 8b b5 e8 fe ff ff 	mov    -0x118(%rbp),%rsi
  104d1d:	48 83 fe 0c          	cmp    $0xc,%rsi
  104d21:	0f 87 3b fe ff ff    	ja     104b62 <shell_process+0x9e>
	(*argv)[*argc] = NULL;
  104d27:	48 c7 84 f5 68 ff ff 	movq   $0x0,-0x98(%rbp,%rsi,8)
  104d2e:	ff 00 00 00 00 
	if ((*argc == 0) || ((space == 0) && (*argc == 1))) {
  104d33:	48 85 f6             	test   %rsi,%rsi
  104d36:	74 26                	je     104d5e <shell_process+0x29a>
	int space = isspace((int)shell->ctx->cmd_buff[
  104d38:	48 8b 53 10          	mov    0x10(%rbx),%rdx
						shell->ctx->cmd_buff_pos - 1]);
  104d3c:	0f b7 42 72          	movzwl 0x72(%rdx),%eax
  104d40:	ff c8                	dec    %eax
	int space = isspace((int)shell->ctx->cmd_buff[
  104d42:	48 98                	cltq   
  104d44:	0f be 44 02 76       	movsbl 0x76(%rdx,%rax,1),%eax
  104d49:	89 c2                	mov    %eax,%edx
	return (int)(c == (int)' ' || ((unsigned)c-(unsigned)'\t') < 5U);
  104d4b:	83 e8 09             	sub    $0x9,%eax
	if ((*argc == 0) || ((space == 0) && (*argc == 1))) {
  104d4e:	83 f8 04             	cmp    $0x4,%eax
  104d51:	76 1e                	jbe    104d71 <shell_process+0x2ad>
  104d53:	80 fa 20             	cmp    $0x20,%dl
  104d56:	74 19                	je     104d71 <shell_process+0x2ad>
  104d58:	48 83 fe 01          	cmp    $0x1,%rsi
  104d5c:	75 10                	jne    104d6e <shell_process+0x2aa>
		*complete_arg_idx = Z_SHELL_CMD_ROOT_LVL;
  104d5e:	48 c7 85 e0 fe ff ff 	movq   $0x0,-0x120(%rbp)
  104d65:	00 00 00 00 
		*cmd = selected_cmd_get(shell);
  104d69:	45 31 ff             	xor    %r15d,%r15d
  104d6c:	eb 2e                	jmp    104d9c <shell_process+0x2d8>
	search_argc = space ? *argc : *argc - 1;
  104d6e:	48 ff ce             	dec    %rsi
	*cmd = z_shell_get_last_command(selected_cmd_get(shell), search_argc,
  104d71:	45 31 c9             	xor    %r9d,%r9d
  104d74:	4c 8d 85 f0 fe ff ff 	lea    -0x110(%rbp),%r8
  104d7b:	48 8d 8d e0 fe ff ff 	lea    -0x120(%rbp),%rcx
  104d82:	31 ff                	xor    %edi,%edi
  104d84:	48 8d 95 68 ff ff ff 	lea    -0x98(%rbp),%rdx
  104d8b:	e8 cc 15 00 00       	callq  10635c <z_shell_get_last_command>
  104d90:	49 89 c7             	mov    %rax,%r15
	if ((*cmd == NULL) && (search_argc != 0)) {
  104d93:	48 85 c0             	test   %rax,%rax
  104d96:	0f 84 c6 fd ff ff    	je     104b62 <shell_process+0x9e>
	find_completion_candidates(shell, cmd, argv[arg_idx], &first, &cnt,
  104d9c:	48 8b 85 e0 fe ff ff 	mov    -0x120(%rbp),%rax
	size_t first = 0;
  104da3:	45 31 f6             	xor    %r14d,%r14d
	size_t idx = 0;
  104da6:	45 31 e4             	xor    %r12d,%r12d
	find_completion_candidates(shell, cmd, argv[arg_idx], &first, &cnt,
  104da9:	4c 8b ac c5 68 ff ff 	mov    -0x98(%rbp,%rax,8),%r13
  104db0:	ff 
	incompl_cmd_len = z_shell_strlen(incompl_cmd);
  104db1:	4c 89 ef             	mov    %r13,%rdi
  104db4:	e8 8c f2 ff ff       	callq  104045 <z_shell_strlen>
	*cnt = 0;
  104db9:	48 c7 85 c8 fe ff ff 	movq   $0x0,-0x138(%rbp)
  104dc0:	00 00 00 00 
	*longest = 0U;
  104dc4:	66 c7 85 c0 fe ff ff 	movw   $0x0,-0x140(%rbp)
  104dcb:	00 00 
	incompl_cmd_len = z_shell_strlen(incompl_cmd);
  104dcd:	0f b7 c0             	movzwl %ax,%eax
  104dd0:	48 89 85 b8 fe ff ff 	mov    %rax,-0x148(%rbp)
	while ((candidate = z_shell_cmd_get(cmd, idx, &dloc)) != NULL) {
  104dd7:	48 8d 95 40 ff ff ff 	lea    -0xc0(%rbp),%rdx
  104dde:	4c 89 e6             	mov    %r12,%rsi
  104de1:	4c 89 ff             	mov    %r15,%rdi
  104de4:	e8 58 14 00 00       	callq  106241 <z_shell_cmd_get>
  104de9:	48 89 c1             	mov    %rax,%rcx
  104dec:	48 85 c0             	test   %rax,%rax
  104def:	74 59                	je     104e4a <shell_process+0x386>
	return (strncmp(candidate, str, len) == 0) ? true : false;
  104df1:	48 8b 39             	mov    (%rcx),%rdi
  104df4:	48 8b 95 b8 fe ff ff 	mov    -0x148(%rbp),%rdx
  104dfb:	4c 89 ee             	mov    %r13,%rsi
  104dfe:	48 89 8d b0 fe ff ff 	mov    %rcx,-0x150(%rbp)
  104e05:	e8 0b 52 00 00       	callq  10a015 <strncmp>
		if (is_candidate) {
  104e0a:	48 8b 8d b0 fe ff ff 	mov    -0x150(%rbp),%rcx
  104e11:	85 c0                	test   %eax,%eax
  104e13:	75 30                	jne    104e45 <shell_process+0x381>
			*longest = Z_MAX(strlen(candidate->syntax), *longest);
  104e15:	48 8b 39             	mov    (%rcx),%rdi
  104e18:	e8 bf 51 00 00       	callq  109fdc <strlen>
  104e1d:	0f b7 95 c0 fe ff ff 	movzwl -0x140(%rbp),%edx
  104e24:	48 39 c2             	cmp    %rax,%rdx
  104e27:	48 0f 43 c2          	cmovae %rdx,%rax
				*first_idx = idx;
  104e2b:	48 83 bd c8 fe ff ff 	cmpq   $0x0,-0x138(%rbp)
  104e32:	00 
  104e33:	4d 0f 44 f4          	cmove  %r12,%r14
			(*cnt)++;
  104e37:	48 ff 85 c8 fe ff ff 	incq   -0x138(%rbp)
			*longest = Z_MAX(strlen(candidate->syntax), *longest);
  104e3e:	48 89 85 c0 fe ff ff 	mov    %rax,-0x140(%rbp)
		idx++;
  104e45:	49 ff c4             	inc    %r12
  104e48:	eb 8d                	jmp    104dd7 <shell_process+0x313>
	if (cnt == 1) {
  104e4a:	48 83 bd c8 fe ff ff 	cmpq   $0x1,-0x138(%rbp)
  104e51:	01 
  104e52:	0f 85 e9 00 00 00    	jne    104f41 <shell_process+0x47d>
		autocomplete(shell, cmd, argv[arg_idx], first);
  104e58:	48 8b 85 e0 fe ff ff 	mov    -0x120(%rbp),%rax
	uint16_t arg_len = z_shell_strlen(arg);
  104e5f:	48 8b bc c5 68 ff ff 	mov    -0x98(%rbp,%rax,8),%rdi
  104e66:	ff 
  104e67:	e8 d9 f1 ff ff       	callq  104045 <z_shell_strlen>
	match = z_shell_cmd_get(cmd, subcmd_idx, &shell->ctx->active_cmd);
  104e6c:	4c 89 f6             	mov    %r14,%rsi
  104e6f:	4c 89 ff             	mov    %r15,%rdi
	uint16_t arg_len = z_shell_strlen(arg);
  104e72:	41 89 c4             	mov    %eax,%r12d
	match = z_shell_cmd_get(cmd, subcmd_idx, &shell->ctx->active_cmd);
  104e75:	48 8b 43 10          	mov    0x10(%rbx),%rax
  104e79:	48 8d 50 10          	lea    0x10(%rax),%rdx
  104e7d:	e8 bf 13 00 00       	callq  106241 <z_shell_cmd_get>
  104e82:	49 89 c5             	mov    %rax,%r13
	__ASSERT_NO_MSG(match != NULL);
  104e85:	48 85 c0             	test   %rax,%rax
  104e88:	75 2a                	jne    104eb4 <shell_process+0x3f0>
  104e8a:	be d0 d9 11 00       	mov    $0x11d9d0,%esi
  104e8f:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  104e94:	b9 6f 01 00 00       	mov    $0x16f,%ecx
  104e99:	31 c0                	xor    %eax,%eax
  104e9b:	ba 84 d8 11 00       	mov    $0x11d884,%edx
  104ea0:	e8 53 b7 ff ff       	callq  1005f8 <printk>
  104ea5:	be 6f 01 00 00       	mov    $0x16f,%esi
  104eaa:	bf 84 d8 11 00       	mov    $0x11d884,%edi
  104eaf:	e8 e4 dc ff ff       	callq  102b98 <assert_post_action>
	cmd_len = z_shell_strlen(match->syntax);
  104eb4:	49 8b 7d 00          	mov    0x0(%r13),%rdi
  104eb8:	e8 88 f1 ff ff       	callq  104045 <z_shell_strlen>
	if (cmd_len != arg_len) {
  104ebd:	66 41 39 c4          	cmp    %ax,%r12w
  104ec1:	74 16                	je     104ed9 <shell_process+0x415>
					     cmd_len - arg_len);
  104ec3:	44 29 e0             	sub    %r12d,%eax
		z_shell_op_completion_insert(shell,
  104ec6:	41 0f b7 f4          	movzwl %r12w,%esi
  104eca:	48 89 df             	mov    %rbx,%rdi
  104ecd:	49 03 75 00          	add    0x0(%r13),%rsi
  104ed1:	0f b7 d0             	movzwl %ax,%edx
  104ed4:	e8 07 22 00 00       	callq  1070e0 <z_shell_op_completion_insert>
	if (!isspace((int) shell->ctx->cmd_buff[
  104ed9:	48 8b 7b 10          	mov    0x10(%rbx),%rdi
  104edd:	0f b7 47 72          	movzwl 0x72(%rdi),%eax
  104ee1:	0f be 44 07 76       	movsbl 0x76(%rdi,%rax,1),%eax
  104ee6:	89 c2                	mov    %eax,%edx
  104ee8:	83 e8 09             	sub    $0x9,%eax
  104eeb:	83 f8 04             	cmp    $0x4,%eax
  104eee:	76 3f                	jbe    104f2f <shell_process+0x46b>
  104ef0:	80 fa 20             	cmp    $0x20,%dl
  104ef3:	74 3a                	je     104f2f <shell_process+0x46b>
	return shell->ctx->internal.flags.insert_mode == 1;
  104ef5:	48 8b 87 90 02 00 00 	mov    0x290(%rdi),%rax
		if (z_flag_insert_mode_get(shell)) {
  104efc:	48 0f ba e0 20       	bt     $0x20,%rax
  104f01:	73 22                	jae    104f25 <shell_process+0x461>
			z_flag_insert_mode_set(shell, false);
  104f03:	31 f6                	xor    %esi,%esi
  104f05:	e8 57 f3 ff ff       	callq  104261 <z_flag_insert_mode_set.isra.0>
			z_shell_op_char_insert(shell, ' ');
  104f0a:	be 20 00 00 00       	mov    $0x20,%esi
  104f0f:	48 89 df             	mov    %rbx,%rdi
  104f12:	e8 27 21 00 00       	callq  10703e <z_shell_op_char_insert>
			z_flag_insert_mode_set(shell, true);
  104f17:	48 8b 7b 10          	mov    0x10(%rbx),%rdi
  104f1b:	be 01 00 00 00       	mov    $0x1,%esi
  104f20:	e9 a0 05 00 00       	jmpq   1054c5 <shell_process+0xa01>
			z_shell_op_char_insert(shell, ' ');
  104f25:	be 20 00 00 00       	mov    $0x20,%esi
  104f2a:	e9 83 03 00 00       	jmpq   1052b2 <shell_process+0x7ee>
		z_shell_op_cursor_move(shell, 1);
  104f2f:	be 01 00 00 00       	mov    $0x1,%esi
  104f34:	48 89 df             	mov    %rbx,%rdi
  104f37:	e8 0e 18 00 00       	callq  10674a <z_shell_op_cursor_move>
  104f3c:	e9 21 fc ff ff       	jmpq   104b62 <shell_process+0x9e>
	} else if (cnt > 1) {
  104f41:	0f 86 1b fc ff ff    	jbe    104b62 <shell_process+0x9e>
		tab_options_print(shell, cmd, argv[arg_idx], first, cnt,
  104f47:	48 8b 85 e0 fe ff ff 	mov    -0x120(%rbp),%rax
  104f4e:	4c 8b a4 c5 68 ff ff 	mov    -0x98(%rbp,%rax,8),%r12
  104f55:	ff 
	size_t str_len = z_shell_strlen(str);
  104f56:	4c 89 e7             	mov    %r12,%rdi
  104f59:	e8 e7 f0 ff ff       	callq  104045 <z_shell_strlen>
		shell->ctx->vt100_ctx.printed_cmd = 0;
  104f5e:	4c 89 b5 b0 fe ff ff 	mov    %r14,-0x150(%rbp)
	size_t str_len = z_shell_strlen(str);
  104f65:	0f b7 c0             	movzwl %ax,%eax
  104f68:	48 89 85 a0 fe ff ff 	mov    %rax,-0x160(%rbp)
		shell->ctx->vt100_ctx.printed_cmd = 0;
  104f6f:	48 8b 43 10          	mov    0x10(%rbx),%rax
  104f73:	66 c7 40 58 00 00    	movw   $0x0,0x58(%rax)
  104f79:	48 8b 85 c8 fe ff ff 	mov    -0x138(%rbp),%rax
  104f80:	48 89 85 a8 fe ff ff 	mov    %rax,-0x158(%rbp)
		match = z_shell_cmd_get(cmd, idx, &shell->ctx->active_cmd);
  104f87:	48 8b 43 10          	mov    0x10(%rbx),%rax
  104f8b:	48 8b b5 b0 fe ff ff 	mov    -0x150(%rbp),%rsi
  104f92:	4c 89 ff             	mov    %r15,%rdi
  104f95:	48 8d 50 10          	lea    0x10(%rax),%rdx
  104f99:	e8 a3 12 00 00       	callq  106241 <z_shell_cmd_get>
  104f9e:	49 89 c5             	mov    %rax,%r13
		__ASSERT_NO_MSG(match != NULL);
  104fa1:	48 85 c0             	test   %rax,%rax
  104fa4:	75 2a                	jne    104fd0 <shell_process+0x50c>
  104fa6:	be d0 d9 11 00       	mov    $0x11d9d0,%esi
  104fab:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  104fb0:	b9 b8 01 00 00       	mov    $0x1b8,%ecx
  104fb5:	31 c0                	xor    %eax,%eax
  104fb7:	ba 84 d8 11 00       	mov    $0x11d884,%edx
  104fbc:	e8 37 b6 ff ff       	callq  1005f8 <printk>
  104fc1:	be b8 01 00 00       	mov    $0x1b8,%esi
  104fc6:	bf 84 d8 11 00       	mov    $0x11d884,%edi
  104fcb:	e8 c8 db ff ff       	callq  102b98 <assert_post_action>
		idx++;
  104fd0:	48 ff 85 b0 fe ff ff 	incq   -0x150(%rbp)
		if (str && match->syntax &&
  104fd7:	49 8b 7d 00          	mov    0x0(%r13),%rdi
  104fdb:	4d 85 e4             	test   %r12,%r12
  104fde:	75 18                	jne    104ff8 <shell_process+0x534>
		tab_item_print(shell, match->syntax, longest);
  104fe0:	4d 8b 45 00          	mov    0x0(%r13),%r8
	if (option == NULL) {
  104fe4:	4d 85 c0             	test   %r8,%r8
  104fe7:	75 2c                	jne    105015 <shell_process+0x551>
		shell->ctx->vt100_ctx.printed_cmd = 0;
  104fe9:	48 8b 43 10          	mov    0x10(%rbx),%rax
  104fed:	66 c7 40 58 00 00    	movw   $0x0,0x58(%rax)
		return;
  104ff3:	e9 f5 00 00 00       	jmpq   1050ed <shell_process+0x629>
		if (str && match->syntax &&
  104ff8:	48 85 ff             	test   %rdi,%rdi
  104ffb:	74 e3                	je     104fe0 <shell_process+0x51c>
	return (strncmp(candidate, str, len) == 0) ? true : false;
  104ffd:	48 8b 95 a0 fe ff ff 	mov    -0x160(%rbp),%rdx
  105004:	4c 89 e6             	mov    %r12,%rsi
  105007:	e8 09 50 00 00       	callq  10a015 <strncmp>
		if (str && match->syntax &&
  10500c:	85 c0                	test   %eax,%eax
  10500e:	74 d0                	je     104fe0 <shell_process+0x51c>
  105010:	e9 72 ff ff ff       	jmpq   104f87 <shell_process+0x4c3>
	longest_option += z_shell_strlen(tab);
  105015:	bf b6 d2 11 00       	mov    $0x11d2b6,%edi
  10501a:	4c 89 85 90 fe ff ff 	mov    %r8,-0x170(%rbp)
  105021:	e8 1f f0 ff ff       	callq  104045 <z_shell_strlen>
  105026:	03 85 c0 fe ff ff    	add    -0x140(%rbp),%eax
			- z_shell_strlen(tab)) / longest_option;
  10502c:	bf b6 d2 11 00       	mov    $0x11d2b6,%edi
	longest_option += z_shell_strlen(tab);
  105031:	66 89 85 b8 fe ff ff 	mov    %ax,-0x148(%rbp)
	columns = (shell->ctx->vt100_ctx.cons.terminal_wid
  105038:	48 8b 43 10          	mov    0x10(%rbx),%rax
  10503c:	0f b7 40 4a          	movzwl 0x4a(%rax),%eax
  105040:	89 85 9c fe ff ff    	mov    %eax,-0x164(%rbp)
			- z_shell_strlen(tab)) / longest_option;
  105046:	e8 fa ef ff ff       	callq  104045 <z_shell_strlen>
	diff = longest_option - z_shell_strlen(option);
  10504b:	4c 8b 85 90 fe ff ff 	mov    -0x170(%rbp),%r8
			- z_shell_strlen(tab)) / longest_option;
  105052:	44 0f b7 e8          	movzwl %ax,%r13d
	diff = longest_option - z_shell_strlen(option);
  105056:	4c 89 c7             	mov    %r8,%rdi
  105059:	4c 89 85 88 fe ff ff 	mov    %r8,-0x178(%rbp)
  105060:	e8 e0 ef ff ff       	callq  104045 <z_shell_strlen>
  105065:	8b 8d b8 fe ff ff    	mov    -0x148(%rbp),%ecx
			- z_shell_strlen(tab)) / longest_option;
  10506b:	8b b5 9c fe ff ff    	mov    -0x164(%rbp),%esi
  105071:	0f b7 bd b8 fe ff ff 	movzwl -0x148(%rbp),%edi
	if (shell->ctx->vt100_ctx.printed_cmd++ % columns == 0U) {
  105078:	4c 8b 85 88 fe ff ff 	mov    -0x178(%rbp),%r8
	diff = longest_option - z_shell_strlen(option);
  10507f:	29 c1                	sub    %eax,%ecx
	if (shell->ctx->vt100_ctx.printed_cmd++ % columns == 0U) {
  105081:	48 8b 43 10          	mov    0x10(%rbx),%rax
			- z_shell_strlen(tab)) / longest_option;
  105085:	44 29 ee             	sub    %r13d,%esi
	diff = longest_option - z_shell_strlen(option);
  105088:	66 89 8d 90 fe ff ff 	mov    %cx,-0x170(%rbp)
	if (shell->ctx->vt100_ctx.printed_cmd++ % columns == 0U) {
  10508f:	8b 48 58             	mov    0x58(%rax),%ecx
  105092:	8d 51 01             	lea    0x1(%rcx),%edx
  105095:	66 89 50 58          	mov    %dx,0x58(%rax)
			- z_shell_strlen(tab)) / longest_option;
  105099:	89 f0                	mov    %esi,%eax
  10509b:	99                   	cltd   
  10509c:	f7 ff                	idiv   %edi
	if (shell->ctx->vt100_ctx.printed_cmd++ % columns == 0U) {
  10509e:	31 d2                	xor    %edx,%edx
			- z_shell_strlen(tab)) / longest_option;
  1050a0:	89 c6                	mov    %eax,%esi
	if (shell->ctx->vt100_ctx.printed_cmd++ % columns == 0U) {
  1050a2:	89 c8                	mov    %ecx,%eax
  1050a4:	66 f7 f6             	div    %si
  1050a7:	66 85 d2             	test   %dx,%dx
  1050aa:	75 1b                	jne    1050c7 <shell_process+0x603>
		z_shell_fprintf(shell, SHELL_OPTION, "\n%s%s", tab, option);
  1050ac:	b9 b6 d2 11 00       	mov    $0x11d2b6,%ecx
  1050b1:	ba e5 d9 11 00       	mov    $0x11d9e5,%edx
  1050b6:	48 89 df             	mov    %rbx,%rdi
  1050b9:	31 c0                	xor    %eax,%eax
  1050bb:	be 07 00 00 00       	mov    $0x7,%esi
  1050c0:	e8 66 1b 00 00       	callq  106c2b <z_shell_fprintf>
  1050c5:	eb 17                	jmp    1050de <shell_process+0x61a>
		z_shell_fprintf(shell, SHELL_OPTION, "%s", option);
  1050c7:	4c 89 c1             	mov    %r8,%rcx
  1050ca:	ba b7 d5 11 00       	mov    $0x11d5b7,%edx
  1050cf:	be 07 00 00 00       	mov    $0x7,%esi
  1050d4:	48 89 df             	mov    %rbx,%rdi
  1050d7:	31 c0                	xor    %eax,%eax
  1050d9:	e8 4d 1b 00 00       	callq  106c2b <z_shell_fprintf>
	z_shell_op_cursor_horiz_move(shell, diff);
  1050de:	0f b7 b5 90 fe ff ff 	movzwl -0x170(%rbp),%esi
  1050e5:	48 89 df             	mov    %rbx,%rdi
  1050e8:	e8 54 15 00 00       	callq  106641 <z_shell_op_cursor_horiz_move>
	while (cnt) {
  1050ed:	48 ff 8d a8 fe ff ff 	decq   -0x158(%rbp)
  1050f4:	0f 85 8d fe ff ff    	jne    104f87 <shell_process+0x4c3>
	z_cursor_next_line_move(shell);
  1050fa:	48 8b 7b 28          	mov    0x28(%rbx),%rdi
	size_t idx = first + 1;
  1050fe:	4d 8d 6e 01          	lea    0x1(%r14),%r13
	z_cursor_next_line_move(shell);
  105102:	e8 85 f1 ff ff       	callq  10428c <z_cursor_next_line_move.isra.0>
	z_shell_print_prompt_and_cmd(shell);
  105107:	48 89 df             	mov    %rbx,%rdi
  10510a:	e8 5a 20 00 00       	callq  107169 <z_shell_print_prompt_and_cmd>
		partial_autocomplete(shell, cmd, argv[arg_idx], first, cnt);
  10510f:	48 8b 85 e0 fe ff ff 	mov    -0x120(%rbp),%rax
	uint16_t arg_len = z_shell_strlen(arg);
  105116:	48 8b bc c5 68 ff ff 	mov    -0x98(%rbp,%rax,8),%rdi
  10511d:	ff 
  10511e:	e8 22 ef ff ff       	callq  104045 <z_shell_strlen>
	match = z_shell_cmd_get(cmd, first, &dynamic_entry);
  105123:	4c 89 f6             	mov    %r14,%rsi
  105126:	48 8d 95 18 ff ff ff 	lea    -0xe8(%rbp),%rdx
  10512d:	4c 89 ff             	mov    %r15,%rdi
	uint16_t arg_len = z_shell_strlen(arg);
  105130:	44 0f b7 e0          	movzwl %ax,%r12d
	uint16_t common = common_beginning_find(shell, cmd, &completion, first,
  105134:	41 0f b7 c4          	movzwl %r12w,%eax
  105138:	89 85 c0 fe ff ff    	mov    %eax,-0x140(%rbp)
	match = z_shell_cmd_get(cmd, first, &dynamic_entry);
  10513e:	e8 fe 10 00 00       	callq  106241 <z_shell_cmd_get>
  105143:	49 89 c6             	mov    %rax,%r14
	__ASSERT_NO_MSG(match);
  105146:	48 85 c0             	test   %rax,%rax
  105149:	75 2a                	jne    105175 <shell_process+0x6b1>
  10514b:	be eb d9 11 00       	mov    $0x11d9eb,%esi
  105150:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  105155:	b9 d4 01 00 00       	mov    $0x1d4,%ecx
  10515a:	31 c0                	xor    %eax,%eax
  10515c:	ba 84 d8 11 00       	mov    $0x11d884,%edx
  105161:	e8 92 b4 ff ff       	callq  1005f8 <printk>
  105166:	be d4 01 00 00       	mov    $0x1d4,%esi
  10516b:	bf 84 d8 11 00       	mov    $0x11d884,%edi
  105170:	e8 23 da ff ff       	callq  102b98 <assert_post_action>
	strncpy(shell->ctx->temp_buff, match->syntax,
  105175:	48 8b 43 10          	mov    0x10(%rbx),%rax
  105179:	49 8b 36             	mov    (%r14),%rsi
  10517c:	ba ff 00 00 00       	mov    $0xff,%edx
  105181:	48 8d b8 76 01 00 00 	lea    0x176(%rax),%rdi
  105188:	e8 f7 4d 00 00       	callq  109f84 <strncpy>
	*str = match->syntax;
  10518d:	49 8b 06             	mov    (%r14),%rax
	uint16_t common = UINT16_MAX;
  105190:	83 c9 ff             	or     $0xffffffff,%ecx
	*str = match->syntax;
  105193:	48 89 85 b8 fe ff ff 	mov    %rax,-0x148(%rbp)
		match2 = z_shell_cmd_get(cmd, idx++, &dynamic_entry2);
  10519a:	4c 89 ee             	mov    %r13,%rsi
  10519d:	4c 89 ff             	mov    %r15,%rdi
  1051a0:	89 8d b0 fe ff ff    	mov    %ecx,-0x150(%rbp)
  1051a6:	4d 8d 75 01          	lea    0x1(%r13),%r14
  1051aa:	48 8d 95 40 ff ff ff 	lea    -0xc0(%rbp),%rdx
  1051b1:	e8 8b 10 00 00       	callq  106241 <z_shell_cmd_get>
		if (match2 == NULL) {
  1051b6:	8b 8d b0 fe ff ff    	mov    -0x150(%rbp),%ecx
  1051bc:	48 85 c0             	test   %rax,%rax
  1051bf:	74 52                	je     105213 <shell_process+0x74f>
		curr_common = str_common(shell->ctx->temp_buff, match2->syntax,
  1051c1:	48 8b 7b 10          	mov    0x10(%rbx),%rdi
  1051c5:	48 8b 30             	mov    (%rax),%rsi
	size_t common = 0;
  1051c8:	31 c0                	xor    %eax,%eax
	while ((n > 0) && (*s1 == *s2) && (*s1 != '\0')) {
  1051ca:	8a 94 07 76 01 00 00 	mov    0x176(%rdi,%rax,1),%dl
  1051d1:	38 14 06             	cmp    %dl,(%rsi,%rax,1)
  1051d4:	75 0f                	jne    1051e5 <shell_process+0x721>
  1051d6:	84 d2                	test   %dl,%dl
  1051d8:	74 0b                	je     1051e5 <shell_process+0x721>
		common++;
  1051da:	48 ff c0             	inc    %rax
	while ((n > 0) && (*s1 == *s2) && (*s1 != '\0')) {
  1051dd:	48 3d ff ff 00 00    	cmp    $0xffff,%rax
  1051e3:	75 e5                	jne    1051ca <shell_process+0x706>
		curr_common = str_common(shell->ctx->temp_buff, match2->syntax,
  1051e5:	89 c6                	mov    %eax,%esi
		if ((arg_len == 0U) || (curr_common >= arg_len)) {
  1051e7:	66 45 85 e4          	test   %r12w,%r12w
  1051eb:	74 08                	je     1051f5 <shell_process+0x731>
  1051ed:	39 85 c0 fe ff ff    	cmp    %eax,-0x140(%rbp)
  1051f3:	7f 19                	jg     10520e <shell_process+0x74a>
			common = (curr_common < common) ? curr_common : common;
  1051f5:	0f b7 c9             	movzwl %cx,%ecx
			--cnt;
  1051f8:	48 ff 8d c8 fe ff ff 	decq   -0x138(%rbp)
			common = (curr_common < common) ? curr_common : common;
  1051ff:	39 f1                	cmp    %esi,%ecx
  105201:	0f 4f ce             	cmovg  %esi,%ecx
	while (cnt > 1) {
  105204:	48 83 bd c8 fe ff ff 	cmpq   $0x1,-0x138(%rbp)
  10520b:	01 
  10520c:	74 05                	je     105213 <shell_process+0x74f>
		match2 = z_shell_cmd_get(cmd, idx++, &dynamic_entry2);
  10520e:	4d 89 f5             	mov    %r14,%r13
  105211:	eb 87                	jmp    10519a <shell_process+0x6d6>
	if (common) {
  105213:	66 85 c9             	test   %cx,%cx
  105216:	0f 84 46 f9 ff ff    	je     104b62 <shell_process+0x9e>
		z_shell_op_completion_insert(shell, &completion[arg_len],
  10521c:	48 8b b5 b8 fe ff ff 	mov    -0x148(%rbp),%rsi
					     common - arg_len);
  105223:	44 29 e1             	sub    %r12d,%ecx
		z_shell_op_completion_insert(shell, &completion[arg_len],
  105226:	48 89 df             	mov    %rbx,%rdi
  105229:	0f b7 d1             	movzwl %cx,%edx
  10522c:	4c 01 e6             	add    %r12,%rsi
  10522f:	e8 ac 1e 00 00       	callq  1070e0 <z_shell_op_completion_insert>
  105234:	e9 29 f9 ff ff       	jmpq   104b62 <shell_process+0x9e>
	return shell->ctx->internal.flags.echo == 1;
  105239:	48 8b 87 90 02 00 00 	mov    0x290(%rdi),%rax
				if (z_flag_echo_get(shell)) {
  105240:	48 0f ba e0 22       	bt     $0x22,%rax
  105245:	0f 83 17 f9 ff ff    	jae    104b62 <shell_process+0x9e>
					z_flag_history_exit_set(shell, true);
  10524b:	be 01 00 00 00       	mov    $0x1,%esi
  105250:	e8 15 ef ff ff       	callq  10416a <z_flag_history_exit_set.isra.0>
					z_shell_op_char_backspace(shell);
  105255:	eb 32                	jmp    105289 <shell_process+0x7c5>
  105257:	48 8b 87 90 02 00 00 	mov    0x290(%rdi),%rax
				if (z_flag_echo_get(shell)) {
  10525e:	48 0f ba e0 22       	bt     $0x22,%rax
  105263:	0f 83 f9 f8 ff ff    	jae    104b62 <shell_process+0x9e>
					z_flag_history_exit_set(shell, true);
  105269:	be 01 00 00 00       	mov    $0x1,%esi
  10526e:	e8 f7 ee ff ff       	callq  10416a <z_flag_history_exit_set.isra.0>
	return shell->ctx->internal.flags.mode_delete == 1;
  105273:	48 8b 43 10          	mov    0x10(%rbx),%rax
  105277:	48 8b 80 90 02 00 00 	mov    0x290(%rax),%rax
					if (z_flag_mode_delete_get(shell)) {
  10527e:	48 0f ba e0 26       	bt     $0x26,%rax
  105283:	0f 83 ce 00 00 00    	jae    105357 <shell_process+0x893>
						z_shell_op_char_backspace(shell);
  105289:	48 89 df             	mov    %rbx,%rdi
  10528c:	e8 a7 1e 00 00       	callq  107138 <z_shell_op_char_backspace>
  105291:	e9 cc f8 ff ff       	jmpq   104b62 <shell_process+0x9e>
	return (int)((((unsigned)c) >= ' ') &&
  105296:	0f be d0             	movsbl %al,%edx
  105299:	83 ea 20             	sub    $0x20,%edx
				if (isprint((int) data)) {
  10529c:	83 fa 5e             	cmp    $0x5e,%edx
  10529f:	77 1e                	ja     1052bf <shell_process+0x7fb>
					z_flag_history_exit_set(shell, true);
  1052a1:	be 01 00 00 00       	mov    $0x1,%esi
  1052a6:	e8 bf ee ff ff       	callq  10416a <z_flag_history_exit_set.isra.0>
					z_shell_op_char_insert(shell, data);
  1052ab:	0f be b5 d7 fe ff ff 	movsbl -0x129(%rbp),%esi
  1052b2:	48 89 df             	mov    %rbx,%rdi
  1052b5:	e8 84 1d 00 00       	callq  10703e <z_shell_op_char_insert>
  1052ba:	e9 a3 f8 ff ff       	jmpq   104b62 <shell_process+0x9e>
	return shell->ctx->internal.flags.echo == 1;
  1052bf:	48 8b 97 90 02 00 00 	mov    0x290(%rdi),%rdx
				} else if (z_flag_echo_get(shell)) {
  1052c6:	48 0f ba e2 22       	bt     $0x22,%rdx
  1052cb:	0f 83 91 f8 ff ff    	jae    104b62 <shell_process+0x9e>
	switch (data) {
  1052d1:	ff c8                	dec    %eax
  1052d3:	3c 16                	cmp    $0x16,%al
  1052d5:	0f 87 87 f8 ff ff    	ja     104b62 <shell_process+0x9e>
  1052db:	0f b6 c0             	movzbl %al,%eax
  1052de:	ff 24 c5 58 ca 11 00 	jmpq   *0x11ca58(,%rax,8)
	shell->ctx->receive_state = state;
  1052e5:	c7 47 0c 03 00 00 00 	movl   $0x3,0xc(%rdi)
		z_shell_op_cursor_home_move(shell);
  1052ec:	48 89 df             	mov    %rbx,%rdi
  1052ef:	e8 83 15 00 00       	callq  106877 <z_shell_op_cursor_home_move>
		break;
  1052f4:	e9 69 f8 ff ff       	jmpq   104b62 <shell_process+0x9e>
		z_shell_op_left_arrow(shell);
  1052f9:	48 89 df             	mov    %rbx,%rdi
  1052fc:	e8 9b 15 00 00       	callq  10689c <z_shell_op_left_arrow>
		break;
  105301:	e9 5c f8 ff ff       	jmpq   104b62 <shell_process+0x9e>
		z_shell_op_cursor_end_move(shell);
  105306:	48 89 df             	mov    %rbx,%rdi
  105309:	e8 7b 15 00 00       	callq  106889 <z_shell_op_cursor_end_move>
		if (!z_shell_cursor_in_empty_line(shell)) {
  10530e:	48 89 df             	mov    %rbx,%rdi
  105311:	e8 54 13 00 00       	callq  10666a <z_shell_cursor_in_empty_line>
  105316:	84 c0                	test   %al,%al
  105318:	75 09                	jne    105323 <shell_process+0x85f>
			z_cursor_next_line_move(shell);
  10531a:	48 8b 7b 28          	mov    0x28(%rbx),%rdi
  10531e:	e8 69 ef ff ff       	callq  10428c <z_cursor_next_line_move.isra.0>
		z_flag_history_exit_set(shell, true);
  105323:	48 8b 7b 10          	mov    0x10(%rbx),%rdi
  105327:	be 01 00 00 00       	mov    $0x1,%esi
  10532c:	e8 39 ee ff ff       	callq  10416a <z_flag_history_exit_set.isra.0>
		state_set(shell, SHELL_STATE_ACTIVE);
  105331:	48 89 df             	mov    %rbx,%rdi
  105334:	e8 27 f7 ff ff       	callq  104a60 <state_set.constprop.0>
		break;
  105339:	e9 24 f8 ff ff       	jmpq   104b62 <shell_process+0x9e>
  10533e:	48 8b 87 90 02 00 00 	mov    0x290(%rdi),%rax
	shell->ctx->receive_state = state;
  105345:	c7 47 0c 03 00 00 00 	movl   $0x3,0xc(%rdi)
				if (z_flag_echo_get(shell)) {
  10534c:	48 0f ba e0 22       	bt     $0x22,%rax
  105351:	0f 83 0b f8 ff ff    	jae    104b62 <shell_process+0x9e>
		z_shell_op_char_delete(shell);
  105357:	48 89 df             	mov    %rbx,%rdi
  10535a:	e8 89 1d 00 00       	callq  1070e8 <z_shell_op_char_delete>
		break;
  10535f:	e9 fe f7 ff ff       	jmpq   104b62 <shell_process+0x9e>
	shell->ctx->receive_state = state;
  105364:	c7 47 0c 03 00 00 00 	movl   $0x3,0xc(%rdi)
		z_shell_op_cursor_end_move(shell);
  10536b:	48 89 df             	mov    %rbx,%rdi
  10536e:	e8 16 15 00 00       	callq  106889 <z_shell_op_cursor_end_move>
		break;
  105373:	e9 ea f7 ff ff       	jmpq   104b62 <shell_process+0x9e>
		z_shell_op_right_arrow(shell);
  105378:	48 89 df             	mov    %rbx,%rdi
  10537b:	e8 30 15 00 00       	callq  1068b0 <z_shell_op_right_arrow>
		break;
  105380:	e9 dd f7 ff ff       	jmpq   104b62 <shell_process+0x9e>
		z_shell_op_delete_from_cursor(shell);
  105385:	48 89 df             	mov    %rbx,%rdi
  105388:	e8 3b 15 00 00       	callq  1068c8 <z_shell_op_delete_from_cursor>
		break;
  10538d:	e9 d0 f7 ff ff       	jmpq   104b62 <shell_process+0x9e>
		Z_SHELL_VT100_CMD(shell, SHELL_VT100_CURSORHOME);
  105392:	48 8b 7b 28          	mov    0x28(%rbx),%rdi
  105396:	31 c0                	xor    %eax,%eax
  105398:	ba d1 dc 11 00       	mov    $0x11dcd1,%edx
  10539d:	be b7 d5 11 00       	mov    $0x11d5b7,%esi
  1053a2:	e8 b1 ec ff ff       	callq  104058 <z_shell_raw_fprintf>
		Z_SHELL_VT100_CMD(shell, SHELL_VT100_CLEARSCREEN);
  1053a7:	48 8b 7b 28          	mov    0x28(%rbx),%rdi
  1053ab:	ba cc dc 11 00       	mov    $0x11dccc,%edx
  1053b0:	31 c0                	xor    %eax,%eax
  1053b2:	be b7 d5 11 00       	mov    $0x11d5b7,%esi
  1053b7:	e8 9c ec ff ff       	callq  104058 <z_shell_raw_fprintf>
		z_shell_print_prompt_and_cmd(shell);
  1053bc:	48 89 df             	mov    %rbx,%rdi
  1053bf:	e8 a5 1d 00 00       	callq  107169 <z_shell_print_prompt_and_cmd>
		break;
  1053c4:	e9 99 f7 ff ff       	jmpq   104b62 <shell_process+0x9e>
		history_handle(shell, false);
  1053c9:	31 f6                	xor    %esi,%esi
  1053cb:	eb 05                	jmp    1053d2 <shell_process+0x90e>
		history_handle(shell, true);
  1053cd:	be 01 00 00 00       	mov    $0x1,%esi
  1053d2:	48 89 df             	mov    %rbx,%rdi
  1053d5:	e8 be ee ff ff       	callq  104298 <history_handle>
		break;
  1053da:	e9 83 f7 ff ff       	jmpq   104b62 <shell_process+0x9e>
		z_shell_op_cursor_home_move(shell);
  1053df:	48 89 df             	mov    %rbx,%rdi
  1053e2:	e8 90 14 00 00       	callq  106877 <z_shell_op_cursor_home_move>
		cmd_buffer_clear(shell);
  1053e7:	48 8b 7b 10          	mov    0x10(%rbx),%rdi
		z_flag_history_exit_set(shell, true);
  1053eb:	be 01 00 00 00       	mov    $0x1,%esi
	shell->ctx->cmd_buff[0] = '\0'; /* clear command buffer */
  1053f0:	c6 47 76 00          	movb   $0x0,0x76(%rdi)
	shell->ctx->cmd_buff_len = 0;
  1053f4:	c7 47 70 00 00 00 00 	movl   $0x0,0x70(%rdi)
		z_flag_history_exit_set(shell, true);
  1053fb:	e8 6a ed ff ff       	callq  10416a <z_flag_history_exit_set.isra.0>
	Z_SHELL_VT100_CMD(shell, SHELL_VT100_CLEAREOS);
  105400:	48 8b 7b 28          	mov    0x28(%rbx),%rdi
  105404:	ba c8 dc 11 00       	mov    $0x11dcc8,%edx
  105409:	31 c0                	xor    %eax,%eax
  10540b:	be b7 d5 11 00       	mov    $0x11d5b7,%esi
  105410:	e8 43 ec ff ff       	callq  104058 <z_shell_raw_fprintf>
}
  105415:	e9 48 f7 ff ff       	jmpq   104b62 <shell_process+0x9e>
		z_shell_op_word_remove(shell);
  10541a:	48 89 df             	mov    %rbx,%rdi
  10541d:	e8 c7 19 00 00       	callq  106de9 <z_shell_op_word_remove>
		z_flag_history_exit_set(shell, true);
  105422:	48 8b 7b 10          	mov    0x10(%rbx),%rdi
  105426:	be 01 00 00 00       	mov    $0x1,%esi
  10542b:	e8 3a ed ff ff       	callq  10416a <z_flag_history_exit_set.isra.0>
		break;
  105430:	e9 2d f7 ff ff       	jmpq   104b62 <shell_process+0x9e>
			if (data == '[') {
  105435:	3c 5b                	cmp    $0x5b,%al
  105437:	75 0c                	jne    105445 <shell_process+0x981>
	shell->ctx->receive_state = state;
  105439:	c7 47 0c 02 00 00 00 	movl   $0x2,0xc(%rdi)
}
  105440:	e9 1d f7 ff ff       	jmpq   104b62 <shell_process+0x9e>
	return shell->ctx->internal.flags.echo == 1;
  105445:	48 8b 97 90 02 00 00 	mov    0x290(%rdi),%rdx
			} else if (z_flag_echo_get(shell)) {
  10544c:	48 0f ba e2 22       	bt     $0x22,%rdx
  105451:	73 18                	jae    10546b <shell_process+0x9a7>
		z_shell_op_cursor_word_move(shell, -1);
  105453:	83 ce ff             	or     $0xffffffff,%esi
	if (data == SHELL_VT100_ASCII_ALT_B) {
  105456:	3c 62                	cmp    $0x62,%al
  105458:	74 09                	je     105463 <shell_process+0x99f>
	} else if (data == SHELL_VT100_ASCII_ALT_F) {
  10545a:	3c 66                	cmp    $0x66,%al
  10545c:	75 0d                	jne    10546b <shell_process+0x9a7>
		z_shell_op_cursor_word_move(shell, 1);
  10545e:	be 01 00 00 00       	mov    $0x1,%esi
  105463:	48 89 df             	mov    %rbx,%rdi
  105466:	e8 65 13 00 00       	callq  1067d0 <z_shell_op_cursor_word_move>
	shell->ctx->receive_state = state;
  10546b:	48 8b 43 10          	mov    0x10(%rbx),%rax
  10546f:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%rax)
}
  105476:	e9 e7 f6 ff ff       	jmpq   104b62 <shell_process+0x9e>
  10547b:	48 8b 97 90 02 00 00 	mov    0x290(%rdi),%rdx
	shell->ctx->receive_state = state;
  105482:	c7 47 0c 00 00 00 00 	movl   $0x0,0xc(%rdi)
			if (!z_flag_echo_get(shell)) {
  105489:	48 0f ba e2 22       	bt     $0x22,%rdx
  10548e:	0f 83 ce f6 ff ff    	jae    104b62 <shell_process+0x9e>
			switch (data) {
  105494:	83 e8 31             	sub    $0x31,%eax
  105497:	3c 1b                	cmp    $0x1b,%al
  105499:	0f 87 c3 f6 ff ff    	ja     104b62 <shell_process+0x9e>
  10549f:	0f b6 c0             	movzbl %al,%eax
  1054a2:	ff 24 c5 10 cb 11 00 	jmpq   *0x11cb10(,%rax,8)
	shell->ctx->receive_state = state;
  1054a9:	c7 47 0c 03 00 00 00 	movl   $0x3,0xc(%rdi)
	return shell->ctx->internal.flags.insert_mode == 1;
  1054b0:	48 8b b7 90 02 00 00 	mov    0x290(%rdi),%rsi
  1054b7:	48 c1 ee 20          	shr    $0x20,%rsi
  1054bb:	83 e6 01             	and    $0x1,%esi
				z_flag_insert_mode_set(shell, !status);
  1054be:	83 f6 01             	xor    $0x1,%esi
  1054c1:	40 0f b6 f6          	movzbl %sil,%esi
  1054c5:	e8 97 ed ff ff       	callq  104261 <z_flag_insert_mode_set.isra.0>
				break;
  1054ca:	e9 93 f6 ff ff       	jmpq   104b62 <shell_process+0x9e>
	default:
		break;
	}

	/* atomically clear the processing flag */
	z_flag_processing_set(shell, false);
  1054cf:	48 8b 7b 10          	mov    0x10(%rbx),%rdi
}
  1054d3:	48 81 c4 58 01 00 00 	add    $0x158,%rsp
	z_flag_processing_set(shell, false);
  1054da:	31 f6                	xor    %esi,%esi
}
  1054dc:	5b                   	pop    %rbx
  1054dd:	41 5c                	pop    %r12
  1054df:	41 5d                	pop    %r13
  1054e1:	41 5e                	pop    %r14
  1054e3:	41 5f                	pop    %r15
  1054e5:	5d                   	pop    %rbp
	z_flag_processing_set(shell, false);
  1054e6:	e9 cd ec ff ff       	jmpq   1041b8 <z_flag_processing_set.isra.0>

00000000001054eb <shell_init>:
{
  1054eb:	55                   	push   %rbp
  1054ec:	48 89 e5             	mov    %rsp,%rbp
  1054ef:	41 57                	push   %r15
  1054f1:	49 89 f7             	mov    %rsi,%r15
  1054f4:	41 56                	push   %r14
  1054f6:	41 55                	push   %r13
  1054f8:	41 89 d5             	mov    %edx,%r13d
  1054fb:	41 54                	push   %r12
  1054fd:	53                   	push   %rbx
  1054fe:	48 89 fb             	mov    %rdi,%rbx
  105501:	48 83 ec 48          	sub    $0x48,%rsp
  105505:	89 4d 9c             	mov    %ecx,-0x64(%rbp)
  105508:	44 89 45 98          	mov    %r8d,-0x68(%rbp)
	__ASSERT_NO_MSG(shell);
  10550c:	48 85 ff             	test   %rdi,%rdi
  10550f:	75 2a                	jne    10553b <shell_init+0x50>
  105511:	be ac d8 11 00       	mov    $0x11d8ac,%esi
  105516:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  10551b:	b9 40 05 00 00       	mov    $0x540,%ecx
  105520:	31 c0                	xor    %eax,%eax
  105522:	ba 84 d8 11 00       	mov    $0x11d884,%edx
  105527:	e8 cc b0 ff ff       	callq  1005f8 <printk>
  10552c:	be 40 05 00 00       	mov    $0x540,%esi
  105531:	bf 84 d8 11 00       	mov    $0x11d884,%edi
  105536:	e8 5d d6 ff ff       	callq  102b98 <assert_post_action>
	__ASSERT_NO_MSG(shell->ctx && shell->iface && shell->default_prompt);
  10553b:	48 83 7b 10 00       	cmpq   $0x0,0x10(%rbx)
  105540:	74 0d                	je     10554f <shell_init+0x64>
  105542:	48 83 7b 08 00       	cmpq   $0x0,0x8(%rbx)
  105547:	74 06                	je     10554f <shell_init+0x64>
  105549:	48 83 3b 00          	cmpq   $0x0,(%rbx)
  10554d:	75 2a                	jne    105579 <shell_init+0x8e>
  10554f:	be f1 d9 11 00       	mov    $0x11d9f1,%esi
  105554:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  105559:	b9 41 05 00 00       	mov    $0x541,%ecx
  10555e:	31 c0                	xor    %eax,%eax
  105560:	ba 84 d8 11 00       	mov    $0x11d884,%edx
  105565:	e8 8e b0 ff ff       	callq  1005f8 <printk>
  10556a:	be 41 05 00 00       	mov    $0x541,%esi
  10556f:	bf 84 d8 11 00       	mov    $0x11d884,%edi
  105574:	e8 1f d6 ff ff       	callq  102b98 <assert_post_action>
	if (shell->ctx->tid) {
  105579:	48 8b 43 10          	mov    0x10(%rbx),%rax
		return -EALREADY;
  10557d:	41 bc 88 ff ff ff    	mov    $0xffffff88,%r12d
	if (shell->ctx->tid) {
  105583:	48 83 b8 b8 03 00 00 	cmpq   $0x0,0x3b8(%rax)
  10558a:	00 
  10558b:	0f 85 12 02 00 00    	jne    1057a3 <shell_init+0x2b8>
	__ASSERT_NO_MSG((shell->shell_flag == SHELL_FLAG_CRLF_DEFAULT) ||
  105591:	8b 43 20             	mov    0x20(%rbx),%eax
	int err = instance_init(shell, transport_config, use_colors);
  105594:	45 0f b6 ed          	movzbl %r13b,%r13d
	__ASSERT_NO_MSG((shell->shell_flag == SHELL_FLAG_CRLF_DEFAULT) ||
  105598:	ff c8                	dec    %eax
  10559a:	83 f8 01             	cmp    $0x1,%eax
  10559d:	76 2a                	jbe    1055c9 <shell_init+0xde>
  10559f:	be 25 da 11 00       	mov    $0x11da25,%esi
  1055a4:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  1055a9:	b9 9e 04 00 00       	mov    $0x49e,%ecx
  1055ae:	31 c0                	xor    %eax,%eax
  1055b0:	ba 84 d8 11 00       	mov    $0x11d884,%edx
  1055b5:	e8 3e b0 ff ff       	callq  1005f8 <printk>
  1055ba:	be 9e 04 00 00       	mov    $0x49e,%esi
  1055bf:	bf 84 d8 11 00       	mov    $0x11d884,%edi
  1055c4:	e8 cf d5 ff ff       	callq  102b98 <assert_post_action>
	memset(shell->ctx, 0, sizeof(*shell->ctx));
  1055c9:	48 8b 7b 10          	mov    0x10(%rbx),%rdi
  1055cd:	31 f6                	xor    %esi,%esi
  1055cf:	ba c0 03 00 00       	mov    $0x3c0,%edx
  1055d4:	e8 d9 4a 00 00       	callq  10a0b2 <memset>
	shell->ctx->prompt = shell->default_prompt;
  1055d9:	48 8b 43 10          	mov    0x10(%rbx),%rax
  1055dd:	48 8b 13             	mov    (%rbx),%rdx
	z_shell_history_init(shell->history);
  1055e0:	48 8b 7b 18          	mov    0x18(%rbx),%rdi
	shell->ctx->prompt = shell->default_prompt;
  1055e4:	48 89 10             	mov    %rdx,(%rax)
	z_shell_history_init(shell->history);
  1055e7:	e8 04 29 00 00       	callq  107ef0 <z_shell_history_init>
	k_mutex_init(&shell->ctx->wr_mtx);
  1055ec:	48 8b 43 10          	mov    0x10(%rbx),%rax
  1055f0:	48 8d b8 98 03 00 00 	lea    0x398(%rax),%rdi
  1055f7:	e8 1b ea ff ff       	callq  104017 <arch_is_user_context>
	if (z_syscall_trap()) {
  1055fc:	84 c0                	test   %al,%al
  1055fe:	74 09                	je     105609 <shell_init+0x11e>
	register uintptr_t rax __asm__("%rax") = call_id;
  105600:	b8 94 00 00 00       	mov    $0x94,%eax
	__asm__ volatile("syscall\n\t"
  105605:	0f 05                	syscall 
		return (int) arch_syscall_invoke1(*(uintptr_t *)&mutex, K_SYSCALL_K_MUTEX_INIT);
  105607:	eb 05                	jmp    10560e <shell_init+0x123>
	return z_impl_k_mutex_init(mutex);
  105609:	e8 76 9c 00 00       	callq  10f284 <z_impl_k_mutex_init>
{
  10560e:	45 31 f6             	xor    %r14d,%r14d
		k_poll_signal_init(&shell->ctx->signals[i]);
  105611:	4d 6b e6 18          	imul   $0x18,%r14,%r12
  105615:	48 8b 7b 10          	mov    0x10(%rbx),%rdi
  105619:	49 81 c4 98 02 00 00 	add    $0x298,%r12
  105620:	4c 01 e7             	add    %r12,%rdi
  105623:	e8 ef e9 ff ff       	callq  104017 <arch_is_user_context>
	if (z_syscall_trap()) {
  105628:	84 c0                	test   %al,%al
  10562a:	74 09                	je     105635 <shell_init+0x14a>
	register uintptr_t rax __asm__("%rax") = call_id;
  10562c:	b8 a1 00 00 00       	mov    $0xa1,%eax
	__asm__ volatile("syscall\n\t"
  105631:	0f 05                	syscall 
	return rax;
  105633:	eb 05                	jmp    10563a <shell_init+0x14f>
	z_impl_k_poll_signal_init(sig);
  105635:	e8 d9 ff 00 00       	callq  115613 <z_impl_k_poll_signal_init>
		k_poll_event_init(&shell->ctx->events[i],
  10563a:	49 6b d6 28          	imul   $0x28,%r14,%rdx
				  &shell->ctx->signals[i]);
  10563e:	48 8b 43 10          	mov    0x10(%rbx),%rax
		k_poll_event_init(&shell->ctx->events[i],
  105642:	be 01 00 00 00       	mov    $0x1,%esi
	for (int i = 0; i < SHELL_SIGNALS; i++) {
  105647:	49 ff c6             	inc    %r14
				  &shell->ctx->signals[i]);
  10564a:	4a 8d 0c 20          	lea    (%rax,%r12,1),%rcx
		k_poll_event_init(&shell->ctx->events[i],
  10564e:	48 8d bc 10 f8 02 00 	lea    0x2f8(%rax,%rdx,1),%rdi
  105655:	00 
  105656:	31 d2                	xor    %edx,%edx
  105658:	e8 ce f7 00 00       	callq  114e2b <k_poll_event_init>
	for (int i = 0; i < SHELL_SIGNALS; i++) {
  10565d:	49 83 fe 04          	cmp    $0x4,%r14
  105661:	75 ae                	jne    105611 <shell_init+0x126>
		shell->stats->log_lost_cnt = 0;
  105663:	48 8b 43 30          	mov    0x30(%rbx),%rax
	Z_SHELL_SET_FLAG_ATOMIC(shell, tx_rdy, val, ret);
  105667:	be 20 00 00 00       	mov    $0x20,%esi
  10566c:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
  105672:	48 8b 43 10          	mov    0x10(%rbx),%rax
  105676:	48 8d b8 94 02 00 00 	lea    0x294(%rax),%rdi
  10567d:	e8 9d e9 ff ff       	callq  10401f <atomic_or>
	z_flag_echo_set(shell, IS_ENABLED(CONFIG_SHELL_ECHO_STATUS));
  105682:	48 8b 7b 10          	mov    0x10(%rbx),%rdi
  105686:	be 01 00 00 00       	mov    $0x1,%esi
  10568b:	e8 76 eb ff ff       	callq  104206 <z_flag_echo_set.isra.0>
	z_flag_obscure_set(shell, IS_ENABLED(CONFIG_SHELL_START_OBSCURED));
  105690:	48 8b 7b 10          	mov    0x10(%rbx),%rdi
  105694:	31 f6                	xor    %esi,%esi
  105696:	e8 3d eb ff ff       	callq  1041d8 <z_flag_obscure_set.isra.0>
	z_flag_mode_delete_set(shell,
  10569b:	48 8b 7b 10          	mov    0x10(%rbx),%rdi
  10569f:	be 01 00 00 00       	mov    $0x1,%esi
  1056a4:	e8 e1 ea ff ff       	callq  10418a <z_flag_mode_delete_set.isra.0>
	shell->ctx->vt100_ctx.cons.terminal_wid =
  1056a9:	48 8b 43 10          	mov    0x10(%rbx),%rax
	shell->ctx->vt100_ctx.cons.terminal_hei =
  1056ad:	c7 40 48 18 00 50 00 	movl   $0x500018,0x48(%rax)
	shell->ctx->vt100_ctx.cons.name_len = z_shell_strlen(shell->ctx->prompt);
  1056b4:	48 8b 38             	mov    (%rax),%rdi
  1056b7:	e8 89 e9 ff ff       	callq  104045 <z_shell_strlen>
  1056bc:	48 8b 7b 10          	mov    0x10(%rbx),%rdi
	z_flag_use_colors_set(shell, IS_ENABLED(CONFIG_SHELL_VT100_COLORS) && use_colors);
  1056c0:	44 89 ee             	mov    %r13d,%esi
	int ret = shell->iface->api->init(shell->iface, p_config,
  1056c3:	48 89 d9             	mov    %rbx,%rcx
	shell->ctx->vt100_ctx.cons.name_len = z_shell_strlen(shell->ctx->prompt);
  1056c6:	88 47 4c             	mov    %al,0x4c(%rdi)
	z_flag_use_colors_set(shell, IS_ENABLED(CONFIG_SHELL_VT100_COLORS) && use_colors);
  1056c9:	e8 66 eb ff ff       	callq  104234 <z_flag_use_colors_set.isra.0>
	int ret = shell->iface->api->init(shell->iface, p_config,
  1056ce:	48 8b 7b 08          	mov    0x8(%rbx),%rdi
  1056d2:	ba e9 43 10 00       	mov    $0x1043e9,%edx
  1056d7:	4c 89 fe             	mov    %r15,%rsi
  1056da:	48 8b 07             	mov    (%rdi),%rax
  1056dd:	ff 10                	callq  *(%rax)
  1056df:	41 89 c4             	mov    %eax,%r12d
	if (ret == 0) {
  1056e2:	85 c0                	test   %eax,%eax
  1056e4:	0f 85 b9 00 00 00    	jne    1057a3 <shell_init+0x2b8>
	shell->ctx->state = state;
  1056ea:	48 8b 43 10          	mov    0x10(%rbx),%rax
				  UINT_TO_POINTER(init_log_level),
  1056ee:	44 8b 45 98          	mov    -0x68(%rbp),%r8d
  1056f2:	c7 45 a0 00 00 00 00 	movl   $0x0,-0x60(%rbp)
	k_tid_t tid = k_thread_create(shell->thread,
  1056f9:	48 8b 73 58          	mov    0x58(%rbx),%rsi
  1056fd:	48 8b 7b 50          	mov    0x50(%rbx),%rdi
  105701:	c7 45 a4 0e 00 00 00 	movl   $0xe,-0x5c(%rbp)
	shell->ctx->state = state;
  105708:	c7 40 08 01 00 00 00 	movl   $0x1,0x8(%rax)
  10570f:	e8 03 e9 ff ff       	callq  104017 <arch_is_user_context>
#endif
#endif
	return ret;
  105714:	44 0f b6 4d 9c       	movzbl -0x64(%rbp),%r9d
	if (z_syscall_trap()) {
  105719:	84 c0                	test   %al,%al
  10571b:	74 3b                	je     105758 <shell_init+0x26d>
			*(uintptr_t *)&p2,
  10571d:	4c 89 4d a8          	mov    %r9,-0x58(%rbp)
		uintptr_t more[] = {
  105721:	48 8b 45 a4          	mov    -0x5c(%rbp),%rax
	register uintptr_t rdx __asm__("%rdx") = arg3;
  105725:	ba 00 08 00 00       	mov    $0x800,%edx
	register uintptr_t r10 __asm__("%r10") = arg4; /* RCX unavailable */
  10572a:	41 ba 82 58 10 00    	mov    $0x105882,%r10d
  105730:	4c 89 45 b0          	mov    %r8,-0x50(%rbp)
	register uintptr_t r9 __asm__("%r9") = arg6;
  105734:	4c 8d 4d a8          	lea    -0x58(%rbp),%r9
	register uintptr_t r8 __asm__("%r8") = arg5;
  105738:	49 89 d8             	mov    %rbx,%r8
  10573b:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
  10573f:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  105743:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
  10574a:	00 
  10574b:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
	register uintptr_t rax __asm__("%rax") = call_id;
  10574f:	b8 b7 00 00 00       	mov    $0xb7,%eax
	__asm__ volatile("syscall\n\t"
  105754:	0f 05                	syscall 
	return rax;
  105756:	eb 22                	jmp    10577a <shell_init+0x28f>
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
  105758:	8b 45 a0             	mov    -0x60(%rbp),%eax
  10575b:	6a 00                	pushq  $0x0
  10575d:	b9 82 58 10 00       	mov    $0x105882,%ecx
  105762:	ba 00 08 00 00       	mov    $0x800,%edx
  105767:	50                   	push   %rax
  105768:	8b 45 a4             	mov    -0x5c(%rbp),%eax
  10576b:	50                   	push   %rax
  10576c:	41 50                	push   %r8
  10576e:	49 89 d8             	mov    %rbx,%r8
  105771:	e8 ff 86 00 00       	callq  10de75 <z_impl_k_thread_create>
  105776:	48 83 c4 20          	add    $0x20,%rsp
  10577a:	48 89 c7             	mov    %rax,%rdi
	shell->ctx->tid = tid;
  10577d:	48 8b 43 10          	mov    0x10(%rbx),%rax
	k_thread_name_set(tid, shell->thread_name);
  105781:	48 8b 73 48          	mov    0x48(%rbx),%rsi
	shell->ctx->tid = tid;
  105785:	48 89 b8 b8 03 00 00 	mov    %rdi,0x3b8(%rax)
	ret = arch_is_user_context();
  10578c:	e8 86 e8 ff ff       	callq  104017 <arch_is_user_context>
	if (z_syscall_trap()) {
  105791:	84 c0                	test   %al,%al
  105793:	74 09                	je     10579e <shell_init+0x2b3>
	register uintptr_t rax __asm__("%rax") = call_id;
  105795:	b8 bd 00 00 00       	mov    $0xbd,%eax
	__asm__ volatile("syscall\n\t"
  10579a:	0f 05                	syscall 
		return (int) arch_syscall_invoke2(*(uintptr_t *)&thread, *(uintptr_t *)&str, K_SYSCALL_K_THREAD_NAME_SET);
  10579c:	eb 05                	jmp    1057a3 <shell_init+0x2b8>
	return z_impl_k_thread_name_set(thread, str);
  10579e:	e8 3f 7e 00 00       	callq  10d5e2 <z_impl_k_thread_name_set>
}
  1057a3:	48 8d 65 d8          	lea    -0x28(%rbp),%rsp
  1057a7:	44 89 e0             	mov    %r12d,%eax
  1057aa:	5b                   	pop    %rbx
  1057ab:	41 5c                	pop    %r12
  1057ad:	41 5d                	pop    %r13
  1057af:	41 5e                	pop    %r14
  1057b1:	41 5f                	pop    %r15
  1057b3:	5d                   	pop    %rbp
  1057b4:	c3                   	retq   

00000000001057b5 <shell_start>:
{
  1057b5:	55                   	push   %rbp
  1057b6:	48 89 e5             	mov    %rsp,%rbp
  1057b9:	53                   	push   %rbx
  1057ba:	48 89 fb             	mov    %rdi,%rbx
  1057bd:	51                   	push   %rcx
	__ASSERT_NO_MSG(shell);
  1057be:	48 85 ff             	test   %rdi,%rdi
  1057c1:	75 2a                	jne    1057ed <shell_start+0x38>
  1057c3:	be ac d8 11 00       	mov    $0x11d8ac,%esi
  1057c8:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  1057cd:	b9 73 05 00 00       	mov    $0x573,%ecx
  1057d2:	31 c0                	xor    %eax,%eax
  1057d4:	ba 84 d8 11 00       	mov    $0x11d884,%edx
  1057d9:	e8 1a ae ff ff       	callq  1005f8 <printk>
  1057de:	be 73 05 00 00       	mov    $0x573,%esi
  1057e3:	bf 84 d8 11 00       	mov    $0x11d884,%edi
  1057e8:	e8 ab d3 ff ff       	callq  102b98 <assert_post_action>
	__ASSERT_NO_MSG(shell->ctx && shell->iface && shell->default_prompt);
  1057ed:	48 83 7b 10 00       	cmpq   $0x0,0x10(%rbx)
  1057f2:	74 0d                	je     105801 <shell_start+0x4c>
  1057f4:	48 83 7b 08 00       	cmpq   $0x0,0x8(%rbx)
  1057f9:	74 06                	je     105801 <shell_start+0x4c>
  1057fb:	48 83 3b 00          	cmpq   $0x0,(%rbx)
  1057ff:	75 2a                	jne    10582b <shell_start+0x76>
  105801:	be f1 d9 11 00       	mov    $0x11d9f1,%esi
  105806:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  10580b:	b9 74 05 00 00       	mov    $0x574,%ecx
  105810:	31 c0                	xor    %eax,%eax
  105812:	ba 84 d8 11 00       	mov    $0x11d884,%edx
  105817:	e8 dc ad ff ff       	callq  1005f8 <printk>
  10581c:	be 74 05 00 00       	mov    $0x574,%esi
  105821:	bf 84 d8 11 00       	mov    $0x11d884,%edi
  105826:	e8 6d d3 ff ff       	callq  102b98 <assert_post_action>
	return shell->ctx->state;
  10582b:	48 8b 7b 10          	mov    0x10(%rbx),%rdi
		return -ENOTSUP;
  10582f:	b8 7a ff ff ff       	mov    $0xffffff7a,%eax
	if (state_get(shell) != SHELL_STATE_INITIALIZED) {
  105834:	83 7f 08 01          	cmpl   $0x1,0x8(%rdi)
  105838:	75 44                	jne    10587e <shell_start+0xc9>
	k_mutex_lock(&shell->ctx->wr_mtx, K_FOREVER);
  10583a:	48 81 c7 98 03 00 00 	add    $0x398,%rdi
  105841:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
  105845:	e8 51 eb ff ff       	callq  10439b <k_mutex_lock.constprop.0.isra.0>
		z_shell_vt100_color_set(shell, SHELL_NORMAL);
  10584a:	31 f6                	xor    %esi,%esi
  10584c:	48 89 df             	mov    %rbx,%rdi
  10584f:	e8 8d 12 00 00       	callq  106ae1 <z_shell_vt100_color_set>
	z_shell_raw_fprintf(shell->fprintf_ctx, "\n\n");
  105854:	48 8b 7b 28          	mov    0x28(%rbx),%rdi
  105858:	31 c0                	xor    %eax,%eax
  10585a:	be a3 d4 11 00       	mov    $0x11d4a3,%esi
  10585f:	e8 f4 e7 ff ff       	callq  104058 <z_shell_raw_fprintf>
	state_set(shell, SHELL_STATE_ACTIVE);
  105864:	48 89 df             	mov    %rbx,%rdi
  105867:	e8 f4 f1 ff ff       	callq  104a60 <state_set.constprop.0>
	k_mutex_unlock(&shell->ctx->wr_mtx);
  10586c:	48 8b 7b 10          	mov    0x10(%rbx),%rdi
  105870:	48 81 c7 98 03 00 00 	add    $0x398,%rdi
  105877:	e8 09 ed ff ff       	callq  104585 <k_mutex_unlock.isra.0>
	return 0;
  10587c:	31 c0                	xor    %eax,%eax
}
  10587e:	5a                   	pop    %rdx
  10587f:	5b                   	pop    %rbx
  105880:	5d                   	pop    %rbp
  105881:	c3                   	retq   

0000000000105882 <shell_thread>:
{
  105882:	55                   	push   %rbp
	err = shell->iface->api->enable(shell->iface, false);
  105883:	31 f6                	xor    %esi,%esi
{
  105885:	48 89 e5             	mov    %rsp,%rbp
  105888:	41 54                	push   %r12
  10588a:	53                   	push   %rbx
  10588b:	48 89 fb             	mov    %rdi,%rbx
  10588e:	48 83 ec 10          	sub    $0x10,%rsp
	err = shell->iface->api->enable(shell->iface, false);
  105892:	48 8b 7f 08          	mov    0x8(%rdi),%rdi
  105896:	48 8b 07             	mov    (%rdi),%rax
  105899:	ff 50 10             	callq  *0x10(%rax)
	if (err != 0) {
  10589c:	85 c0                	test   %eax,%eax
  10589e:	0f 85 de 00 00 00    	jne    105982 <shell_thread+0x100>
	err = shell_start(shell);
  1058a4:	48 89 df             	mov    %rbx,%rdi
  1058a7:	e8 09 ff ff ff       	callq  1057b5 <shell_start>
	if (err != 0) {
  1058ac:	85 c0                	test   %eax,%eax
  1058ae:	0f 85 ce 00 00 00    	jne    105982 <shell_thread+0x100>
		err = k_poll(shell->ctx->events, SHELL_SIGNAL_TXDONE,
  1058b4:	48 8b 43 10          	mov    0x10(%rbx),%rax
  1058b8:	c7 45 ec 03 00 00 00 	movl   $0x3,-0x14(%rbp)
  1058bf:	48 8d b8 f8 02 00 00 	lea    0x2f8(%rax),%rdi
  1058c6:	e8 4c e7 ff ff       	callq  104017 <arch_is_user_context>
	if (z_syscall_trap()) {
  1058cb:	84 c0                	test   %al,%al
  1058cd:	74 11                	je     1058e0 <shell_thread+0x5e>
	register uintptr_t rsi __asm__("%rsi") = arg2;
  1058cf:	48 8b 75 ec          	mov    -0x14(%rbp),%rsi
	register uintptr_t rax __asm__("%rax") = call_id;
  1058d3:	b8 9f 00 00 00       	mov    $0x9f,%eax
	register uintptr_t rdx __asm__("%rdx") = arg3;
  1058d8:	48 83 ca ff          	or     $0xffffffffffffffff,%rdx
	__asm__ volatile("syscall\n\t"
  1058dc:	0f 05                	syscall 
	return rax;
  1058de:	eb 0c                	jmp    1058ec <shell_thread+0x6a>
	return z_impl_k_poll(events, num_events, timeout);
  1058e0:	8b 75 ec             	mov    -0x14(%rbp),%esi
  1058e3:	48 83 ca ff          	or     $0xffffffffffffffff,%rdx
  1058e7:	e8 41 f6 00 00       	callq  114f2d <z_impl_k_poll>
  1058ec:	41 89 c4             	mov    %eax,%r12d
			k_mutex_lock(&shell->ctx->wr_mtx, K_FOREVER);
  1058ef:	48 8b 43 10          	mov    0x10(%rbx),%rax
  1058f3:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
  1058f7:	48 8d b8 98 03 00 00 	lea    0x398(%rax),%rdi
		if (err != 0) {
  1058fe:	45 85 e4             	test   %r12d,%r12d
  105901:	74 32                	je     105935 <shell_thread+0xb3>
			k_mutex_lock(&shell->ctx->wr_mtx, K_FOREVER);
  105903:	e8 93 ea ff ff       	callq  10439b <k_mutex_lock.constprop.0.isra.0>
			z_shell_fprintf(shell, SHELL_ERROR,
  105908:	44 89 e1             	mov    %r12d,%ecx
  10590b:	48 89 df             	mov    %rbx,%rdi
  10590e:	be 02 00 00 00       	mov    $0x2,%esi
  105913:	ba 82 da 11 00       	mov    $0x11da82,%edx
  105918:	31 c0                	xor    %eax,%eax
  10591a:	e8 0c 13 00 00       	callq  106c2b <z_shell_fprintf>
			k_mutex_unlock(&shell->ctx->wr_mtx);
  10591f:	48 8b 7b 10          	mov    0x10(%rbx),%rdi
}
  105923:	59                   	pop    %rcx
  105924:	5e                   	pop    %rsi
  105925:	5b                   	pop    %rbx
			k_mutex_unlock(&shell->ctx->wr_mtx);
  105926:	48 81 c7 98 03 00 00 	add    $0x398,%rdi
}
  10592d:	41 5c                	pop    %r12
  10592f:	5d                   	pop    %rbp
			k_mutex_unlock(&shell->ctx->wr_mtx);
  105930:	e9 50 ec ff ff       	jmpq   104585 <k_mutex_unlock.isra.0>
		k_mutex_lock(&shell->ctx->wr_mtx, K_FOREVER);
  105935:	e8 61 ea ff ff       	callq  10439b <k_mutex_lock.constprop.0.isra.0>
		if (shell->iface->api->update) {
  10593a:	48 8b 7b 08          	mov    0x8(%rbx),%rdi
  10593e:	48 8b 07             	mov    (%rdi),%rax
  105941:	48 8b 40 28          	mov    0x28(%rax),%rax
  105945:	48 85 c0             	test   %rax,%rax
  105948:	74 02                	je     10594c <shell_thread+0xca>
			shell->iface->api->update(shell->iface);
  10594a:	ff d0                	callq  *%rax
		shell_signal_handle(shell, SHELL_SIGNAL_KILL, kill_handler);
  10594c:	48 89 df             	mov    %rbx,%rdi
  10594f:	ba 08 44 10 00       	mov    $0x104408,%edx
  105954:	be 02 00 00 00       	mov    $0x2,%esi
  105959:	e8 a2 eb ff ff       	callq  104500 <shell_signal_handle>
		shell_signal_handle(shell, SHELL_SIGNAL_RXRDY, shell_process);
  10595e:	48 89 df             	mov    %rbx,%rdi
  105961:	ba c4 4a 10 00       	mov    $0x104ac4,%edx
  105966:	31 f6                	xor    %esi,%esi
  105968:	e8 93 eb ff ff       	callq  104500 <shell_signal_handle>
		k_mutex_unlock(&shell->ctx->wr_mtx);
  10596d:	48 8b 43 10          	mov    0x10(%rbx),%rax
  105971:	48 8d b8 98 03 00 00 	lea    0x398(%rax),%rdi
  105978:	e8 08 ec ff ff       	callq  104585 <k_mutex_unlock.isra.0>
  10597d:	e9 32 ff ff ff       	jmpq   1058b4 <shell_thread+0x32>
}
  105982:	58                   	pop    %rax
  105983:	5a                   	pop    %rdx
  105984:	5b                   	pop    %rbx
  105985:	41 5c                	pop    %r12
  105987:	5d                   	pop    %rbp
  105988:	c3                   	retq   

0000000000105989 <shell_vfprintf>:
/* This function mustn't be used from shell context to avoid deadlock.
 * However it can be used in shell command handlers.
 */
void shell_vfprintf(const struct shell *shell, enum shell_vt100_color color,
		   const char *fmt, va_list args)
{
  105989:	55                   	push   %rbp
  10598a:	48 89 e5             	mov    %rsp,%rbp
  10598d:	41 57                	push   %r15
  10598f:	41 56                	push   %r14
  105991:	49 89 ce             	mov    %rcx,%r14
  105994:	41 55                	push   %r13
  105996:	41 89 f5             	mov    %esi,%r13d
  105999:	41 54                	push   %r12
  10599b:	49 89 d4             	mov    %rdx,%r12
  10599e:	53                   	push   %rbx
  10599f:	48 89 fb             	mov    %rdi,%rbx
  1059a2:	41 50                	push   %r8
	__ASSERT_NO_MSG(shell);
  1059a4:	48 85 ff             	test   %rdi,%rdi
  1059a7:	75 2a                	jne    1059d3 <shell_vfprintf+0x4a>
  1059a9:	be ac d8 11 00       	mov    $0x11d8ac,%esi
  1059ae:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  1059b3:	b9 b8 05 00 00       	mov    $0x5b8,%ecx
  1059b8:	31 c0                	xor    %eax,%eax
  1059ba:	ba 84 d8 11 00       	mov    $0x11d884,%edx
  1059bf:	e8 34 ac ff ff       	callq  1005f8 <printk>
  1059c4:	be b8 05 00 00       	mov    $0x5b8,%esi
  1059c9:	bf 84 d8 11 00       	mov    $0x11d884,%edi
  1059ce:	e8 c5 d1 ff ff       	callq  102b98 <assert_post_action>
	__ASSERT(!k_is_in_isr(), "Thread context required.");
  1059d3:	e8 c9 7b 00 00       	callq  10d5a1 <k_is_in_isr>
  1059d8:	84 c0                	test   %al,%al
  1059da:	74 36                	je     105a12 <shell_vfprintf+0x89>
  1059dc:	be bb dd 11 00       	mov    $0x11ddbb,%esi
  1059e1:	b9 b9 05 00 00       	mov    $0x5b9,%ecx
  1059e6:	ba 84 d8 11 00       	mov    $0x11d884,%edx
  1059eb:	31 c0                	xor    %eax,%eax
  1059ed:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  1059f2:	e8 01 ac ff ff       	callq  1005f8 <printk>
  1059f7:	bf 99 da 11 00       	mov    $0x11da99,%edi
  1059fc:	31 c0                	xor    %eax,%eax
  1059fe:	e8 f5 ab ff ff       	callq  1005f8 <printk>
  105a03:	be b9 05 00 00       	mov    $0x5b9,%esi
  105a08:	bf 84 d8 11 00       	mov    $0x11d884,%edi
  105a0d:	e8 86 d1 ff ff       	callq  102b98 <assert_post_action>
	__ASSERT_NO_MSG(shell->ctx);
  105a12:	48 83 7b 10 00       	cmpq   $0x0,0x10(%rbx)
  105a17:	75 2a                	jne    105a43 <shell_vfprintf+0xba>
  105a19:	be c5 d9 11 00       	mov    $0x11d9c5,%esi
  105a1e:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  105a23:	b9 ba 05 00 00       	mov    $0x5ba,%ecx
  105a28:	31 c0                	xor    %eax,%eax
  105a2a:	ba 84 d8 11 00       	mov    $0x11d884,%edx
  105a2f:	e8 c4 ab ff ff       	callq  1005f8 <printk>
  105a34:	be ba 05 00 00       	mov    $0x5ba,%esi
  105a39:	bf 84 d8 11 00       	mov    $0x11d884,%edi
  105a3e:	e8 55 d1 ff ff       	callq  102b98 <assert_post_action>
	__ASSERT_NO_MSG((shell->ctx->internal.flags.cmd_ctx == 1) ||
  105a43:	4c 8b 7b 10          	mov    0x10(%rbx),%r15
  105a47:	49 8b 87 90 02 00 00 	mov    0x290(%r15),%rax
  105a4e:	48 0f ba e0 30       	bt     $0x30,%rax
  105a53:	72 38                	jb     105a8d <shell_vfprintf+0x104>
  105a55:	e8 b4 e6 ff ff       	callq  10410e <z_current_get>
  105a5a:	49 39 87 b8 03 00 00 	cmp    %rax,0x3b8(%r15)
  105a61:	75 2a                	jne    105a8d <shell_vfprintf+0x104>
  105a63:	be b4 da 11 00       	mov    $0x11dab4,%esi
  105a68:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  105a6d:	b9 bb 05 00 00       	mov    $0x5bb,%ecx
  105a72:	31 c0                	xor    %eax,%eax
  105a74:	ba 84 d8 11 00       	mov    $0x11d884,%edx
  105a79:	e8 7a ab ff ff       	callq  1005f8 <printk>
  105a7e:	be bb 05 00 00       	mov    $0x5bb,%esi
  105a83:	bf 84 d8 11 00       	mov    $0x11d884,%edi
  105a88:	e8 0b d1 ff ff       	callq  102b98 <assert_post_action>
			(k_current_get() != shell->ctx->tid));
	__ASSERT_NO_MSG(shell->fprintf_ctx);
  105a8d:	48 83 7b 28 00       	cmpq   $0x0,0x28(%rbx)
  105a92:	75 2a                	jne    105abe <shell_vfprintf+0x135>
  105a94:	be 06 db 11 00       	mov    $0x11db06,%esi
  105a99:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  105a9e:	b9 bd 05 00 00       	mov    $0x5bd,%ecx
  105aa3:	31 c0                	xor    %eax,%eax
  105aa5:	ba 84 d8 11 00       	mov    $0x11d884,%edx
  105aaa:	e8 49 ab ff ff       	callq  1005f8 <printk>
  105aaf:	be bd 05 00 00       	mov    $0x5bd,%esi
  105ab4:	bf 84 d8 11 00       	mov    $0x11d884,%edi
  105ab9:	e8 da d0 ff ff       	callq  102b98 <assert_post_action>
	__ASSERT_NO_MSG(fmt);
  105abe:	4d 85 e4             	test   %r12,%r12
  105ac1:	75 2a                	jne    105aed <shell_vfprintf+0x164>
  105ac3:	be 19 db 11 00       	mov    $0x11db19,%esi
  105ac8:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  105acd:	b9 be 05 00 00       	mov    $0x5be,%ecx
  105ad2:	31 c0                	xor    %eax,%eax
  105ad4:	ba 84 d8 11 00       	mov    $0x11d884,%edx
  105ad9:	e8 1a ab ff ff       	callq  1005f8 <printk>
  105ade:	be be 05 00 00       	mov    $0x5be,%esi
  105ae3:	bf 84 d8 11 00       	mov    $0x11d884,%edi
  105ae8:	e8 ab d0 ff ff       	callq  102b98 <assert_post_action>
	return shell->ctx->state;
  105aed:	48 8b 7b 10          	mov    0x10(%rbx),%rdi

	/* Sending a message to a non-active shell leads to a dead lock. */
	if (state_get(shell) != SHELL_STATE_ACTIVE) {
  105af1:	83 7f 08 02          	cmpl   $0x2,0x8(%rdi)
  105af5:	74 15                	je     105b0c <shell_vfprintf+0x183>
	if (!z_flag_cmd_ctx_get(shell) && !shell->ctx->bypass) {
		z_shell_print_prompt_and_cmd(shell);
	}
	z_transport_buffer_flush(shell);
	k_mutex_unlock(&shell->ctx->wr_mtx);
}
  105af7:	5a                   	pop    %rdx
		z_flag_print_noinit_set(shell, true);
  105af8:	be 01 00 00 00       	mov    $0x1,%esi
}
  105afd:	5b                   	pop    %rbx
  105afe:	41 5c                	pop    %r12
  105b00:	41 5d                	pop    %r13
  105b02:	41 5e                	pop    %r14
  105b04:	41 5f                	pop    %r15
  105b06:	5d                   	pop    %rbp
		z_flag_print_noinit_set(shell, true);
  105b07:	e9 1e e6 ff ff       	jmpq   10412a <z_flag_print_noinit_set.isra.0>
	k_mutex_lock(&shell->ctx->wr_mtx, K_FOREVER);
  105b0c:	48 81 c7 98 03 00 00 	add    $0x398,%rdi
  105b13:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
  105b17:	e8 7f e8 ff ff       	callq  10439b <k_mutex_lock.constprop.0.isra.0>
	return shell->ctx->internal.flags.cmd_ctx == 1;
  105b1c:	48 8b 43 10          	mov    0x10(%rbx),%rax
  105b20:	48 8b 90 90 02 00 00 	mov    0x290(%rax),%rdx
	if (!z_flag_cmd_ctx_get(shell) && !shell->ctx->bypass) {
  105b27:	48 0f ba e2 30       	bt     $0x30,%rdx
  105b2c:	72 0f                	jb     105b3d <shell_vfprintf+0x1b4>
  105b2e:	48 83 78 68 00       	cmpq   $0x0,0x68(%rax)
  105b33:	75 08                	jne    105b3d <shell_vfprintf+0x1b4>
		z_shell_cmd_line_erase(shell);
  105b35:	48 89 df             	mov    %rbx,%rdi
  105b38:	e8 a5 0d 00 00       	callq  1068e2 <z_shell_cmd_line_erase>
	z_shell_vfprintf(shell, color, fmt, args);
  105b3d:	4c 89 e2             	mov    %r12,%rdx
  105b40:	4c 89 f1             	mov    %r14,%rcx
  105b43:	44 89 ee             	mov    %r13d,%esi
  105b46:	48 89 df             	mov    %rbx,%rdi
  105b49:	e8 49 10 00 00       	callq  106b97 <z_shell_vfprintf>
  105b4e:	48 8b 43 10          	mov    0x10(%rbx),%rax
  105b52:	48 8b 90 90 02 00 00 	mov    0x290(%rax),%rdx
	if (!z_flag_cmd_ctx_get(shell) && !shell->ctx->bypass) {
  105b59:	48 0f ba e2 30       	bt     $0x30,%rdx
  105b5e:	72 0f                	jb     105b6f <shell_vfprintf+0x1e6>
  105b60:	48 83 78 68 00       	cmpq   $0x0,0x68(%rax)
  105b65:	75 08                	jne    105b6f <shell_vfprintf+0x1e6>
		z_shell_print_prompt_and_cmd(shell);
  105b67:	48 89 df             	mov    %rbx,%rdi
  105b6a:	e8 fa 15 00 00       	callq  107169 <z_shell_print_prompt_and_cmd>
	z_shell_fprintf_buffer_flush(shell->fprintf_ctx);
  105b6f:	48 8b 7b 28          	mov    0x28(%rbx),%rdi
  105b73:	e8 a0 02 00 00       	callq  105e18 <z_shell_fprintf_buffer_flush>
	k_mutex_unlock(&shell->ctx->wr_mtx);
  105b78:	48 8b 7b 10          	mov    0x10(%rbx),%rdi
}
  105b7c:	58                   	pop    %rax
  105b7d:	5b                   	pop    %rbx
  105b7e:	41 5c                	pop    %r12
	k_mutex_unlock(&shell->ctx->wr_mtx);
  105b80:	48 81 c7 98 03 00 00 	add    $0x398,%rdi
}
  105b87:	41 5d                	pop    %r13
  105b89:	41 5e                	pop    %r14
  105b8b:	41 5f                	pop    %r15
  105b8d:	5d                   	pop    %rbp
	k_mutex_unlock(&shell->ctx->wr_mtx);
  105b8e:	e9 f2 e9 ff ff       	jmpq   104585 <k_mutex_unlock.isra.0>

0000000000105b93 <shell_fprintf>:
/* This function mustn't be used from shell context to avoid deadlock.
 * However it can be used in shell command handlers.
 */
void shell_fprintf(const struct shell *shell, enum shell_vt100_color color,
		   const char *fmt, ...)
{
  105b93:	55                   	push   %rbp
  105b94:	48 89 e5             	mov    %rsp,%rbp
  105b97:	48 81 ec d0 00 00 00 	sub    $0xd0,%rsp
  105b9e:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  105ba5:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  105bac:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  105bb3:	84 c0                	test   %al,%al
  105bb5:	74 20                	je     105bd7 <shell_fprintf+0x44>
  105bb7:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  105bbb:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  105bbf:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  105bc3:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  105bc7:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  105bcb:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  105bcf:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  105bd3:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
	va_list args;

	va_start(args, fmt);
  105bd7:	48 8d 45 10          	lea    0x10(%rbp),%rax
	shell_vfprintf(shell, color, fmt, args);
  105bdb:	48 8d 8d 38 ff ff ff 	lea    -0xc8(%rbp),%rcx
	va_start(args, fmt);
  105be2:	c7 85 38 ff ff ff 18 	movl   $0x18,-0xc8(%rbp)
  105be9:	00 00 00 
  105bec:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  105bf3:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  105bfa:	c7 85 3c ff ff ff 30 	movl   $0x30,-0xc4(%rbp)
  105c01:	00 00 00 
  105c04:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
	shell_vfprintf(shell, color, fmt, args);
  105c0b:	e8 79 fd ff ff       	callq  105989 <shell_vfprintf>
	va_end(args);
}
  105c10:	c9                   	leaveq 
  105c11:	c3                   	retq   

0000000000105c12 <cmd_help>:
{
	sh->ctx->bypass = bypass;
}

static int cmd_help(const struct shell *shell, size_t argc, char **argv)
{
  105c12:	55                   	push   %rbp
	ARG_UNUSED(argc);
	ARG_UNUSED(argv);

#if defined(CONFIG_SHELL_TAB)
	shell_print(shell, "Please press the <Tab> button to see all available "
  105c13:	ba 1d db 11 00       	mov    $0x11db1d,%edx
  105c18:	31 f6                	xor    %esi,%esi
{
  105c1a:	48 89 e5             	mov    %rsp,%rbp
  105c1d:	41 54                	push   %r12
  105c1f:	49 89 fc             	mov    %rdi,%r12
  105c22:	50                   	push   %rax
	shell_print(shell, "Please press the <Tab> button to see all available "
  105c23:	31 c0                	xor    %eax,%eax
  105c25:	e8 69 ff ff ff       	callq  105b93 <shell_fprintf>
			   "commands.");
#endif

#if defined(CONFIG_SHELL_TAB_AUTOCOMPLETION)
	shell_print(shell,
  105c2a:	4c 89 e7             	mov    %r12,%rdi
  105c2d:	ba 5b db 11 00       	mov    $0x11db5b,%edx
  105c32:	31 f6                	xor    %esi,%esi
  105c34:	31 c0                	xor    %eax,%eax
  105c36:	e8 58 ff ff ff       	callq  105b93 <shell_fprintf>
		"You can also use the <Tab> button to prompt or auto-complete"
		" all commands or its subcommands.");
#endif

#if defined(CONFIG_SHELL_HELP)
	shell_print(shell,
  105c3b:	4c 89 e7             	mov    %r12,%rdi
  105c3e:	ba ba db 11 00       	mov    $0x11dbba,%edx
  105c43:	31 f6                	xor    %esi,%esi
  105c45:	31 c0                	xor    %eax,%eax
  105c47:	e8 47 ff ff ff       	callq  105b93 <shell_fprintf>
		"You can try to call commands with <-h> or <--help> parameter"
		" for more information.");
#endif

#if defined(CONFIG_SHELL_METAKEYS)
	shell_print(shell,
  105c4c:	4c 89 e7             	mov    %r12,%rdi
  105c4f:	31 c0                	xor    %eax,%eax
  105c51:	ba 0e dc 11 00       	mov    $0x11dc0e,%edx
  105c56:	31 f6                	xor    %esi,%esi
  105c58:	e8 36 ff ff ff       	callq  105b93 <shell_fprintf>
		"Please refer to shell documentation for more details.");
#endif

	if (IS_ENABLED(CONFIG_SHELL_HELP)) {
		/* For NULL argument function will print all root commands */
		z_shell_help_subcmd_print(shell, NULL,
  105c5d:	ba a8 dc 11 00       	mov    $0x11dca8,%edx
  105c62:	4c 89 e7             	mov    %r12,%rdi
  105c65:	31 f6                	xor    %esi,%esi
  105c67:	e8 7c 19 00 00       	callq  1075e8 <z_shell_help_subcmd_print>
			shell_print(shell, "  %s", entry->syntax);
		}
	}

	return 0;
}
  105c6c:	5a                   	pop    %rdx
  105c6d:	31 c0                	xor    %eax,%eax
  105c6f:	41 5c                	pop    %r12
  105c71:	5d                   	pop    %rbp
  105c72:	c3                   	retq   

0000000000105c73 <shell_hexdump_line>:
{
  105c73:	55                   	push   %rbp
	shell_fprintf(shell, SHELL_NORMAL, "%08X: ", offset);
  105c74:	31 c0                	xor    %eax,%eax
{
  105c76:	48 89 e5             	mov    %rsp,%rbp
  105c79:	41 57                	push   %r15
  105c7b:	41 56                	push   %r14
  105c7d:	49 89 ce             	mov    %rcx,%r14
	shell_fprintf(shell, SHELL_NORMAL, "%08X: ", offset);
  105c80:	89 f1                	mov    %esi,%ecx
  105c82:	31 f6                	xor    %esi,%esi
{
  105c84:	41 55                	push   %r13
  105c86:	49 89 d5             	mov    %rdx,%r13
	shell_fprintf(shell, SHELL_NORMAL, "%08X: ", offset);
  105c89:	ba be dc 11 00       	mov    $0x11dcbe,%edx
{
  105c8e:	41 54                	push   %r12
  105c90:	49 89 fc             	mov    %rdi,%r12
  105c93:	53                   	push   %rbx
	shell_fprintf(shell, SHELL_NORMAL, "%08X: ", offset);
  105c94:	31 db                	xor    %ebx,%ebx
{
  105c96:	41 50                	push   %r8
	shell_fprintf(shell, SHELL_NORMAL, "%08X: ", offset);
  105c98:	e8 f6 fe ff ff       	callq  105b93 <shell_fprintf>
		if (i < len) {
  105c9d:	49 39 de             	cmp    %rbx,%r14
  105ca0:	76 19                	jbe    105cbb <shell_hexdump_line+0x48>
			shell_fprintf(shell, SHELL_NORMAL, "%02x ",
  105ca2:	41 0f b6 4c 1d 00    	movzbl 0x0(%r13,%rbx,1),%ecx
  105ca8:	ba af d2 11 00       	mov    $0x11d2af,%edx
  105cad:	31 f6                	xor    %esi,%esi
  105caf:	4c 89 e7             	mov    %r12,%rdi
  105cb2:	31 c0                	xor    %eax,%eax
  105cb4:	e8 da fe ff ff       	callq  105b93 <shell_fprintf>
  105cb9:	eb 11                	jmp    105ccc <shell_hexdump_line+0x59>
			shell_fprintf(shell, SHELL_NORMAL, "   ");
  105cbb:	ba b5 d2 11 00       	mov    $0x11d2b5,%edx
  105cc0:	31 f6                	xor    %esi,%esi
  105cc2:	4c 89 e7             	mov    %r12,%rdi
  105cc5:	31 c0                	xor    %eax,%eax
  105cc7:	e8 c7 fe ff ff       	callq  105b93 <shell_fprintf>
	for (i = 0; i < SHELL_HEXDUMP_BYTES_IN_LINE; i++) {
  105ccc:	48 83 fb 0f          	cmp    $0xf,%rbx
  105cd0:	74 1d                	je     105cef <shell_hexdump_line+0x7c>
		if (i > 0 && !(i % 8)) {
  105cd2:	8d 43 01             	lea    0x1(%rbx),%eax
  105cd5:	a8 07                	test   $0x7,%al
  105cd7:	75 11                	jne    105cea <shell_hexdump_line+0x77>
			shell_fprintf(shell, SHELL_NORMAL, " ");
  105cd9:	ba b7 d2 11 00       	mov    $0x11d2b7,%edx
  105cde:	31 f6                	xor    %esi,%esi
  105ce0:	4c 89 e7             	mov    %r12,%rdi
  105ce3:	31 c0                	xor    %eax,%eax
  105ce5:	e8 a9 fe ff ff       	callq  105b93 <shell_fprintf>
  105cea:	48 ff c3             	inc    %rbx
  105ced:	eb ae                	jmp    105c9d <shell_hexdump_line+0x2a>
	shell_fprintf(shell, SHELL_NORMAL, "|");
  105cef:	ba b9 d2 11 00       	mov    $0x11d2b9,%edx
  105cf4:	31 f6                	xor    %esi,%esi
  105cf6:	4c 89 e7             	mov    %r12,%rdi
  105cf9:	31 c0                	xor    %eax,%eax
  105cfb:	e8 93 fe ff ff       	callq  105b93 <shell_fprintf>
  105d00:	31 db                	xor    %ebx,%ebx
  105d02:	41 bf 2e 00 00 00    	mov    $0x2e,%r15d
		if (i < len) {
  105d08:	4c 39 f3             	cmp    %r14,%rbx
  105d0b:	73 25                	jae    105d32 <shell_hexdump_line+0xbf>
			char c = data[i];
  105d0d:	41 0f be 44 1d 00    	movsbl 0x0(%r13,%rbx,1),%eax
			shell_fprintf(shell, SHELL_NORMAL, "%c",
  105d13:	ba 34 dd 11 00       	mov    $0x11dd34,%edx
  105d18:	4c 89 e7             	mov    %r12,%rdi
			char c = data[i];
  105d1b:	89 c1                	mov    %eax,%ecx
  105d1d:	83 e8 20             	sub    $0x20,%eax
  105d20:	83 f8 5f             	cmp    $0x5f,%eax
  105d23:	41 0f 43 cf          	cmovae %r15d,%ecx
			shell_fprintf(shell, SHELL_NORMAL, "%c",
  105d27:	31 f6                	xor    %esi,%esi
  105d29:	31 c0                	xor    %eax,%eax
  105d2b:	e8 63 fe ff ff       	callq  105b93 <shell_fprintf>
  105d30:	eb 11                	jmp    105d43 <shell_hexdump_line+0xd0>
			shell_fprintf(shell, SHELL_NORMAL, " ");
  105d32:	ba b7 d2 11 00       	mov    $0x11d2b7,%edx
  105d37:	31 f6                	xor    %esi,%esi
  105d39:	4c 89 e7             	mov    %r12,%rdi
  105d3c:	31 c0                	xor    %eax,%eax
  105d3e:	e8 50 fe ff ff       	callq  105b93 <shell_fprintf>
	for (i = 0; i < SHELL_HEXDUMP_BYTES_IN_LINE; i++) {
  105d43:	48 83 fb 0f          	cmp    $0xf,%rbx
  105d47:	74 1d                	je     105d66 <shell_hexdump_line+0xf3>
		if (i > 0 && !(i % 8)) {
  105d49:	8d 43 01             	lea    0x1(%rbx),%eax
  105d4c:	a8 07                	test   $0x7,%al
  105d4e:	75 11                	jne    105d61 <shell_hexdump_line+0xee>
			shell_fprintf(shell, SHELL_NORMAL, " ");
  105d50:	ba b7 d2 11 00       	mov    $0x11d2b7,%edx
  105d55:	31 f6                	xor    %esi,%esi
  105d57:	4c 89 e7             	mov    %r12,%rdi
  105d5a:	31 c0                	xor    %eax,%eax
  105d5c:	e8 32 fe ff ff       	callq  105b93 <shell_fprintf>
  105d61:	48 ff c3             	inc    %rbx
  105d64:	eb a2                	jmp    105d08 <shell_hexdump_line+0x95>
}
  105d66:	59                   	pop    %rcx
	shell_print(shell, "|");
  105d67:	4c 89 e7             	mov    %r12,%rdi
}
  105d6a:	5b                   	pop    %rbx
	shell_print(shell, "|");
  105d6b:	ba c5 dc 11 00       	mov    $0x11dcc5,%edx
}
  105d70:	41 5c                	pop    %r12
	shell_print(shell, "|");
  105d72:	31 f6                	xor    %esi,%esi
}
  105d74:	41 5d                	pop    %r13
	shell_print(shell, "|");
  105d76:	31 c0                	xor    %eax,%eax
}
  105d78:	41 5e                	pop    %r14
  105d7a:	41 5f                	pop    %r15
  105d7c:	5d                   	pop    %rbp
	shell_print(shell, "|");
  105d7d:	e9 11 fe ff ff       	jmpq   105b93 <shell_fprintf>

0000000000105d82 <shell_hexdump>:
{
  105d82:	55                   	push   %rbp
  105d83:	48 89 e5             	mov    %rsp,%rbp
  105d86:	41 57                	push   %r15
  105d88:	41 56                	push   %r14
  105d8a:	49 89 fe             	mov    %rdi,%r14
  105d8d:	41 55                	push   %r13
  105d8f:	49 89 f5             	mov    %rsi,%r13
  105d92:	41 54                	push   %r12
	const uint8_t *p = data;
  105d94:	49 89 f4             	mov    %rsi,%r12
{
  105d97:	53                   	push   %rbx
  105d98:	48 89 d3             	mov    %rdx,%rbx
  105d9b:	51                   	push   %rcx
	while (len) {
  105d9c:	48 85 db             	test   %rbx,%rbx
  105d9f:	74 2a                	je     105dcb <shell_hexdump+0x49>
		line_len = MIN(len, SHELL_HEXDUMP_BYTES_IN_LINE);
  105da1:	48 83 fb 10          	cmp    $0x10,%rbx
  105da5:	41 bf 10 00 00 00    	mov    $0x10,%r15d
		shell_hexdump_line(shell, p - data, p, line_len);
  105dab:	4c 89 e6             	mov    %r12,%rsi
  105dae:	4c 89 e2             	mov    %r12,%rdx
		line_len = MIN(len, SHELL_HEXDUMP_BYTES_IN_LINE);
  105db1:	4c 0f 46 fb          	cmovbe %rbx,%r15
		shell_hexdump_line(shell, p - data, p, line_len);
  105db5:	4c 89 f7             	mov    %r14,%rdi
  105db8:	4c 29 ee             	sub    %r13,%rsi
  105dbb:	4c 89 f9             	mov    %r15,%rcx
		len -= line_len;
  105dbe:	4c 29 fb             	sub    %r15,%rbx
		p += line_len;
  105dc1:	4d 01 fc             	add    %r15,%r12
		shell_hexdump_line(shell, p - data, p, line_len);
  105dc4:	e8 aa fe ff ff       	callq  105c73 <shell_hexdump_line>
		p += line_len;
  105dc9:	eb d1                	jmp    105d9c <shell_hexdump+0x1a>
}
  105dcb:	58                   	pop    %rax
  105dcc:	5b                   	pop    %rbx
  105dcd:	41 5c                	pop    %r12
  105dcf:	41 5d                	pop    %r13
  105dd1:	41 5e                	pop    %r14
  105dd3:	41 5f                	pop    %r15
  105dd5:	5d                   	pop    %rbp
  105dd6:	c3                   	retq   

0000000000105dd7 <shell_help>:
{
  105dd7:	55                   	push   %rbp
	k_mutex_lock(&shell->ctx->wr_mtx, K_FOREVER);
  105dd8:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
{
  105ddc:	48 89 e5             	mov    %rsp,%rbp
  105ddf:	53                   	push   %rbx
  105de0:	48 89 fb             	mov    %rdi,%rbx
  105de3:	50                   	push   %rax
	k_mutex_lock(&shell->ctx->wr_mtx, K_FOREVER);
  105de4:	48 8b 47 10          	mov    0x10(%rdi),%rax
  105de8:	48 8d b8 98 03 00 00 	lea    0x398(%rax),%rdi
  105def:	e8 a7 e5 ff ff       	callq  10439b <k_mutex_lock.constprop.0.isra.0>
	shell_internal_help_print(shell);
  105df4:	48 89 df             	mov    %rbx,%rdi
  105df7:	e8 e2 e2 ff ff       	callq  1040de <shell_internal_help_print>
	k_mutex_unlock(&shell->ctx->wr_mtx);
  105dfc:	48 8b 7b 10          	mov    0x10(%rbx),%rdi
}
  105e00:	5a                   	pop    %rdx
  105e01:	5b                   	pop    %rbx
  105e02:	5d                   	pop    %rbp
	k_mutex_unlock(&shell->ctx->wr_mtx);
  105e03:	48 81 c7 98 03 00 00 	add    $0x398,%rdi
  105e0a:	e9 76 e7 ff ff       	jmpq   104585 <k_mutex_unlock.isra.0>

0000000000105e0f <shell_set_bypass>:
	sh->ctx->bypass = bypass;
  105e0f:	48 8b 47 10          	mov    0x10(%rdi),%rax
  105e13:	48 89 70 68          	mov    %rsi,0x68(%rax)
}
  105e17:	c3                   	retq   

0000000000105e18 <z_shell_fprintf_buffer_flush>:
	}
}


void z_shell_fprintf_buffer_flush(const struct shell_fprintf *sh_fprintf)
{
  105e18:	55                   	push   %rbp
  105e19:	48 89 e5             	mov    %rsp,%rbp
  105e1c:	53                   	push   %rbx
  105e1d:	48 89 fb             	mov    %rdi,%rbx
  105e20:	50                   	push   %rax
	sh_fprintf->fwrite(sh_fprintf->user_ctx, sh_fprintf->buffer,
  105e21:	48 8b 47 20          	mov    0x20(%rdi),%rax
  105e25:	48 8b 33             	mov    (%rbx),%rsi
  105e28:	48 8b 7f 18          	mov    0x18(%rdi),%rdi
  105e2c:	48 8b 10             	mov    (%rax),%rdx
  105e2f:	ff 53 10             	callq  *0x10(%rbx)
			   sh_fprintf->ctrl_blk->buffer_cnt);
	sh_fprintf->ctrl_blk->buffer_cnt = 0;
  105e32:	48 8b 43 20          	mov    0x20(%rbx),%rax
  105e36:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
}
  105e3d:	5a                   	pop    %rdx
  105e3e:	5b                   	pop    %rbx
  105e3f:	5d                   	pop    %rbp
  105e40:	c3                   	retq   

0000000000105e41 <z_shell_fprintf_fmt>:
{
  105e41:	55                   	push   %rbp
  105e42:	48 89 e5             	mov    %rsp,%rbp
  105e45:	41 54                	push   %r12
  105e47:	49 89 fc             	mov    %rdi,%r12
  105e4a:	51                   	push   %rcx
  105e4b:	48 89 d1             	mov    %rdx,%rcx
	(void)cbvprintf(out_func, (void *)sh_fprintf, fmt, args);
  105e4e:	48 89 f2             	mov    %rsi,%rdx
  105e51:	48 89 fe             	mov    %rdi,%rsi
  105e54:	bf 7a 5e 10 00       	mov    $0x105e7a,%edi
  105e59:	e8 ad c0 ff ff       	callq  101f0b <cbvprintf>
	if (sh_fprintf->ctrl_blk->autoflush) {
  105e5e:	49 8b 44 24 20       	mov    0x20(%r12),%rax
  105e63:	80 78 08 00          	cmpb   $0x0,0x8(%rax)
  105e67:	74 0c                	je     105e75 <z_shell_fprintf_fmt+0x34>
}
  105e69:	5a                   	pop    %rdx
		z_shell_fprintf_buffer_flush(sh_fprintf);
  105e6a:	4c 89 e7             	mov    %r12,%rdi
}
  105e6d:	41 5c                	pop    %r12
  105e6f:	5d                   	pop    %rbp
		z_shell_fprintf_buffer_flush(sh_fprintf);
  105e70:	e9 a3 ff ff ff       	jmpq   105e18 <z_shell_fprintf_buffer_flush>
}
  105e75:	58                   	pop    %rax
  105e76:	41 5c                	pop    %r12
  105e78:	5d                   	pop    %rbp
  105e79:	c3                   	retq   

0000000000105e7a <out_func>:
{
  105e7a:	55                   	push   %rbp
	if ((shell->shell_flag == SHELL_FLAG_OLF_CRLF) && (c == '\n')) {
  105e7b:	48 8b 46 18          	mov    0x18(%rsi),%rax
{
  105e7f:	48 89 e5             	mov    %rsp,%rbp
  105e82:	41 54                	push   %r12
  105e84:	49 89 f4             	mov    %rsi,%r12
  105e87:	53                   	push   %rbx
	if ((shell->shell_flag == SHELL_FLAG_OLF_CRLF) && (c == '\n')) {
  105e88:	83 78 20 02          	cmpl   $0x2,0x20(%rax)
{
  105e8c:	89 fb                	mov    %edi,%ebx
	if ((shell->shell_flag == SHELL_FLAG_OLF_CRLF) && (c == '\n')) {
  105e8e:	75 0f                	jne    105e9f <out_func+0x25>
  105e90:	83 ff 0a             	cmp    $0xa,%edi
  105e93:	75 0a                	jne    105e9f <out_func+0x25>
		(void)out_func('\r', ctx);
  105e95:	bf 0d 00 00 00       	mov    $0xd,%edi
  105e9a:	e8 db ff ff ff       	callq  105e7a <out_func>
	sh_fprintf->buffer[sh_fprintf->ctrl_blk->buffer_cnt] = (uint8_t)c;
  105e9f:	49 8b 44 24 20       	mov    0x20(%r12),%rax
  105ea4:	49 8b 14 24          	mov    (%r12),%rdx
  105ea8:	48 8b 00             	mov    (%rax),%rax
  105eab:	88 1c 02             	mov    %bl,(%rdx,%rax,1)
	sh_fprintf->ctrl_blk->buffer_cnt++;
  105eae:	49 8b 54 24 20       	mov    0x20(%r12),%rdx
  105eb3:	48 8b 02             	mov    (%rdx),%rax
  105eb6:	48 ff c0             	inc    %rax
  105eb9:	48 89 02             	mov    %rax,(%rdx)
	if (sh_fprintf->ctrl_blk->buffer_cnt == sh_fprintf->buffer_size) {
  105ebc:	49 3b 44 24 08       	cmp    0x8(%r12),%rax
  105ec1:	75 08                	jne    105ecb <out_func+0x51>
		z_shell_fprintf_buffer_flush(sh_fprintf);
  105ec3:	4c 89 e7             	mov    %r12,%rdi
  105ec6:	e8 4d ff ff ff       	callq  105e18 <z_shell_fprintf_buffer_flush>
}
  105ecb:	5b                   	pop    %rbx
  105ecc:	31 c0                	xor    %eax,%eax
  105ece:	41 5c                	pop    %r12
  105ed0:	5d                   	pop    %rbp
  105ed1:	c3                   	retq   

0000000000105ed2 <z_shell_strlen>:
	return str == NULL ? 0U : (uint16_t)strlen(str);
  105ed2:	48 85 ff             	test   %rdi,%rdi
  105ed5:	74 0b                	je     105ee2 <z_shell_strlen+0x10>
{
  105ed7:	55                   	push   %rbp
  105ed8:	48 89 e5             	mov    %rsp,%rbp
	return str == NULL ? 0U : (uint16_t)strlen(str);
  105edb:	e8 fc 40 00 00       	callq  109fdc <strlen>
}
  105ee0:	5d                   	pop    %rbp
  105ee1:	c3                   	retq   
  105ee2:	31 c0                	xor    %eax,%eax
  105ee4:	c3                   	retq   

0000000000105ee5 <z_column_span_with_buffer_offsets_get>:
/* Calculates column number of given position in buffer */
static uint32_t col_num_with_buffer_offset_get(struct shell_multiline_cons *cons,
					    uint16_t buffer_pos)
{
	/* columns are counted from 1 */
	return (1 + ((buffer_pos + cons->name_len) % cons->terminal_wid));
  105ee5:	44 0f b6 47 0c       	movzbl 0xc(%rdi),%r8d

int32_t z_column_span_with_buffer_offsets_get(struct shell_multiline_cons *cons,
					      uint16_t offset1,
					      uint16_t offset2)
{
	return col_num_with_buffer_offset_get(cons, offset2)
  105eea:	0f b7 c2             	movzwl %dx,%eax
	return (1 + ((buffer_pos + cons->name_len) % cons->terminal_wid));
  105eed:	0f b7 4f 0a          	movzwl 0xa(%rdi),%ecx
  105ef1:	44 01 c0             	add    %r8d,%eax
  105ef4:	99                   	cltd   
  105ef5:	f7 f9                	idiv   %ecx
			- col_num_with_buffer_offset_get(cons, offset1);
  105ef7:	0f b7 c6             	movzwl %si,%eax
	return (1 + ((buffer_pos + cons->name_len) % cons->terminal_wid));
  105efa:	44 01 c0             	add    %r8d,%eax
  105efd:	89 d7                	mov    %edx,%edi
  105eff:	99                   	cltd   
  105f00:	f7 f9                	idiv   %ecx
			- col_num_with_buffer_offset_get(cons, offset1);
  105f02:	89 f8                	mov    %edi,%eax
  105f04:	29 d0                	sub    %edx,%eax
}
  105f06:	c3                   	retq   

0000000000105f07 <z_row_span_with_buffer_offsets_get>:
	return ((buffer_pos + cons->name_len) / cons->terminal_wid);
  105f07:	44 0f b6 47 0c       	movzbl 0xc(%rdi),%r8d

int32_t z_row_span_with_buffer_offsets_get(struct shell_multiline_cons *cons,
					   uint16_t offset1,
					   uint16_t offset2)
{
	return line_num_with_buffer_offset_get(cons, offset2)
  105f0c:	0f b7 c2             	movzwl %dx,%eax
	return ((buffer_pos + cons->name_len) / cons->terminal_wid);
  105f0f:	0f b7 7f 0a          	movzwl 0xa(%rdi),%edi
  105f13:	44 01 c0             	add    %r8d,%eax
  105f16:	99                   	cltd   
  105f17:	f7 ff                	idiv   %edi
  105f19:	89 c1                	mov    %eax,%ecx
		- line_num_with_buffer_offset_get(cons, offset1);
  105f1b:	0f b7 c6             	movzwl %si,%eax
	return ((buffer_pos + cons->name_len) / cons->terminal_wid);
  105f1e:	44 01 c0             	add    %r8d,%eax
  105f21:	99                   	cltd   
  105f22:	f7 ff                	idiv   %edi
  105f24:	89 c6                	mov    %eax,%esi
		- line_num_with_buffer_offset_get(cons, offset1);
  105f26:	89 c8                	mov    %ecx,%eax
  105f28:	29 f0                	sub    %esi,%eax
}
  105f2a:	c3                   	retq   

0000000000105f2b <z_shell_multiline_data_calc>:
				 uint16_t buff_pos, uint16_t buff_len)
{
	/* Current cursor position in command.
	 * +1 -> because home position is (1, 1)
	 */
	cons->cur_x = (buff_pos + cons->name_len) % cons->terminal_wid + 1;
  105f2b:	44 0f b6 4f 0c       	movzbl 0xc(%rdi),%r9d
  105f30:	0f b7 c6             	movzwl %si,%eax
  105f33:	0f b7 4f 0a          	movzwl 0xa(%rdi),%ecx
{
  105f37:	41 89 d0             	mov    %edx,%r8d
	cons->cur_x = (buff_pos + cons->name_len) % cons->terminal_wid + 1;
  105f3a:	44 01 c8             	add    %r9d,%eax
  105f3d:	99                   	cltd   
  105f3e:	f7 f9                	idiv   %ecx
	cons->cur_y = (buff_pos + cons->name_len) / cons->terminal_wid + 1;
  105f40:	ff c0                	inc    %eax
	cons->cur_x = (buff_pos + cons->name_len) % cons->terminal_wid + 1;
  105f42:	ff c2                	inc    %edx
	cons->cur_y = (buff_pos + cons->name_len) / cons->terminal_wid + 1;
  105f44:	66 89 47 04          	mov    %ax,0x4(%rdi)

	/* Extreme position when cursor is at the end of command. */
	cons->cur_y_end = (buff_len + cons->name_len) / cons->terminal_wid + 1;
  105f48:	41 0f b7 c0          	movzwl %r8w,%eax
  105f4c:	44 01 c8             	add    %r9d,%eax
	cons->cur_x = (buff_pos + cons->name_len) % cons->terminal_wid + 1;
  105f4f:	66 89 17             	mov    %dx,(%rdi)
	cons->cur_y_end = (buff_len + cons->name_len) / cons->terminal_wid + 1;
  105f52:	99                   	cltd   
  105f53:	f7 f9                	idiv   %ecx
  105f55:	ff c0                	inc    %eax
	cons->cur_x_end = (buff_len + cons->name_len) % cons->terminal_wid + 1;
  105f57:	ff c2                	inc    %edx
	cons->cur_y_end = (buff_len + cons->name_len) / cons->terminal_wid + 1;
  105f59:	66 89 47 06          	mov    %ax,0x6(%rdi)
	cons->cur_x_end = (buff_len + cons->name_len) % cons->terminal_wid + 1;
  105f5d:	66 89 57 02          	mov    %dx,0x2(%rdi)
}
  105f61:	c3                   	retq   

0000000000105f62 <z_shell_make_argv>:
}


char z_shell_make_argv(size_t *argc, const char **argv, char *cmd,
		       uint8_t max_argc)
{
  105f62:	55                   	push   %rbp
			*cmd++ = '\0';
			continue;
		}

		argv[(*argc)++] = cmd;
		if (*argc == max_argc) {
  105f63:	0f b6 c1             	movzbl %cl,%eax
{
  105f66:	48 89 e5             	mov    %rsp,%rbp
  105f69:	41 57                	push   %r15
	char quote = 0;
  105f6b:	45 31 ff             	xor    %r15d,%r15d
{
  105f6e:	41 56                	push   %r14
  105f70:	49 89 f6             	mov    %rsi,%r14
  105f73:	41 55                	push   %r13
  105f75:	49 89 fd             	mov    %rdi,%r13
  105f78:	41 54                	push   %r12
  105f7a:	49 89 d4             	mov    %rdx,%r12
  105f7d:	53                   	push   %rbx
  105f7e:	48 83 ec 18          	sub    $0x18,%rsp
	*argc = 0;
  105f82:	48 c7 07 00 00 00 00 	movq   $0x0,(%rdi)
		if (*argc == max_argc) {
  105f89:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
		c = *cmd;
  105f8d:	41 8a 04 24          	mov    (%r12),%al
		if (c == '\0') {
  105f91:	84 c0                	test   %al,%al
  105f93:	0f 84 17 02 00 00    	je     1061b0 <z_shell_make_argv+0x24e>
	return (int)(c == (int)' ' || ((unsigned)c-(unsigned)'\t') < 5U);
  105f99:	0f be d0             	movsbl %al,%edx
  105f9c:	83 ea 09             	sub    $0x9,%edx
		if (isspace((int) c)) {
  105f9f:	83 fa 04             	cmp    $0x4,%edx
  105fa2:	76 04                	jbe    105fa8 <z_shell_make_argv+0x46>
  105fa4:	3c 20                	cmp    $0x20,%al
  105fa6:	75 0a                	jne    105fb2 <z_shell_make_argv+0x50>
			*cmd++ = '\0';
  105fa8:	41 c6 04 24 00       	movb   $0x0,(%r12)
  105fad:	49 ff c4             	inc    %r12
			continue;
  105fb0:	eb db                	jmp    105f8d <z_shell_make_argv+0x2b>
		argv[(*argc)++] = cmd;
  105fb2:	49 8b 55 00          	mov    0x0(%r13),%rdx
  105fb6:	48 8d 42 01          	lea    0x1(%rdx),%rax
  105fba:	49 89 45 00          	mov    %rax,0x0(%r13)
  105fbe:	4d 89 24 d6          	mov    %r12,(%r14,%rdx,8)
		if (*argc == max_argc) {
  105fc2:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  105fc6:	0f 84 e4 01 00 00    	je     1061b0 <z_shell_make_argv+0x24e>
	char quote = 0;
  105fcc:	45 31 ff             	xor    %r15d,%r15d
		c = *cmd;
  105fcf:	41 8a 1c 24          	mov    (%r12),%bl
		if (c == '\0') {
  105fd3:	84 db                	test   %bl,%bl
  105fd5:	74 b6                	je     105f8d <z_shell_make_argv+0x2b>
		if (!quote) {
  105fd7:	45 84 ff             	test   %r15b,%r15b
  105fda:	75 43                	jne    10601f <z_shell_make_argv+0xbd>
			switch (c) {
  105fdc:	80 fb 27             	cmp    $0x27,%bl
  105fdf:	74 1b                	je     105ffc <z_shell_make_argv+0x9a>
  105fe1:	80 fb 5c             	cmp    $0x5c,%bl
  105fe4:	74 07                	je     105fed <z_shell_make_argv+0x8b>
  105fe6:	80 fb 22             	cmp    $0x22,%bl
  105fe9:	75 34                	jne    10601f <z_shell_make_argv+0xbd>
  105feb:	eb 0f                	jmp    105ffc <z_shell_make_argv+0x9a>
						z_shell_strlen(cmd));
  105fed:	4c 89 e7             	mov    %r12,%rdi
				memmove(cmd, cmd + 1,
  105ff0:	49 8d 5c 24 01       	lea    0x1(%r12),%rbx
						z_shell_strlen(cmd));
  105ff5:	e8 d8 fe ff ff       	callq  105ed2 <z_shell_strlen>
  105ffa:	eb 77                	jmp    106073 <z_shell_make_argv+0x111>
						z_shell_strlen(cmd));
  105ffc:	4c 89 e7             	mov    %r12,%rdi
		c = *cmd;
  105fff:	41 89 df             	mov    %ebx,%r15d
				continue;
  106002:	4c 89 e3             	mov    %r12,%rbx
						z_shell_strlen(cmd));
  106005:	e8 c8 fe ff ff       	callq  105ed2 <z_shell_strlen>
				memmove(cmd, cmd + 1,
  10600a:	49 8d 74 24 01       	lea    0x1(%r12),%rsi
  10600f:	4c 89 e7             	mov    %r12,%rdi
  106012:	0f b7 d0             	movzwl %ax,%edx
  106015:	e8 48 40 00 00       	callq  10a062 <memmove>
				continue;
  10601a:	49 89 dc             	mov    %rbx,%r12
  10601d:	eb b0                	jmp    105fcf <z_shell_make_argv+0x6d>
		if (quote == c) {
  10601f:	0f b6 c3             	movzbl %bl,%eax
  106022:	41 0f be d7          	movsbl %r15b,%edx
  106026:	39 c2                	cmp    %eax,%edx
  106028:	75 20                	jne    10604a <z_shell_make_argv+0xe8>
			memmove(cmd, cmd + 1, z_shell_strlen(cmd));
  10602a:	4c 89 e7             	mov    %r12,%rdi
			continue;
  10602d:	4c 89 e3             	mov    %r12,%rbx
			quote = 0;
  106030:	45 31 ff             	xor    %r15d,%r15d
			memmove(cmd, cmd + 1, z_shell_strlen(cmd));
  106033:	e8 9a fe ff ff       	callq  105ed2 <z_shell_strlen>
  106038:	49 8d 74 24 01       	lea    0x1(%r12),%rsi
  10603d:	4c 89 e7             	mov    %r12,%rdi
  106040:	0f b7 d0             	movzwl %ax,%edx
  106043:	e8 1a 40 00 00       	callq  10a062 <memmove>
			continue;
  106048:	eb d0                	jmp    10601a <z_shell_make_argv+0xb8>
		if (quote && c == '\\') {
  10604a:	45 84 ff             	test   %r15b,%r15b
  10604d:	0f 84 3e 01 00 00    	je     106191 <z_shell_make_argv+0x22f>
  106053:	80 fb 5c             	cmp    $0x5c,%bl
  106056:	0f 85 30 01 00 00    	jne    10618c <z_shell_make_argv+0x22a>
			char t = *(cmd + 1);
  10605c:	41 8a 44 24 01       	mov    0x1(%r12),%al
				memmove(cmd, cmd + 1,
  106061:	49 8d 5c 24 01       	lea    0x1(%r12),%rbx
			if (t == quote) {
  106066:	41 38 c7             	cmp    %al,%r15b
  106069:	75 18                	jne    106083 <z_shell_make_argv+0x121>
						z_shell_strlen(cmd));
  10606b:	4c 89 e7             	mov    %r12,%rdi
  10606e:	e8 5f fe ff ff       	callq  105ed2 <z_shell_strlen>
				memmove(cmd, cmd + 1,
  106073:	0f b7 d0             	movzwl %ax,%edx
  106076:	48 89 de             	mov    %rbx,%rsi
  106079:	4c 89 e7             	mov    %r12,%rdi
  10607c:	e8 e1 3f 00 00       	callq  10a062 <memmove>
				continue;
  106081:	eb 97                	jmp    10601a <z_shell_make_argv+0xb8>
			if (t == '0') {
  106083:	3c 30                	cmp    $0x30,%al
  106085:	75 69                	jne    1060f0 <z_shell_make_argv+0x18e>
  106087:	be 02 00 00 00       	mov    $0x2,%esi
				uint8_t v = 0U;
  10608c:	31 c9                	xor    %ecx,%ecx
					t = *(cmd + i);
  10608e:	41 8a 04 34          	mov    (%r12,%rsi,1),%al
  106092:	89 f2                	mov    %esi,%edx
					if (t >= '0' && t <= '7') {
  106094:	8d 78 d0             	lea    -0x30(%rax),%edi
  106097:	40 80 ff 07          	cmp    $0x7,%dil
  10609b:	77 12                	ja     1060af <z_shell_make_argv+0x14d>
						v = (v << 3) | (t - '0');
  10609d:	c1 e1 03             	shl    $0x3,%ecx
				for (i = 2U; i < (2 + 3); i++) {
  1060a0:	48 ff c6             	inc    %rsi
						v = (v << 3) | (t - '0');
  1060a3:	09 f9                	or     %edi,%ecx
				for (i = 2U; i < (2 + 3); i++) {
  1060a5:	48 83 fe 05          	cmp    $0x5,%rsi
  1060a9:	75 e3                	jne    10608e <z_shell_make_argv+0x12c>
  1060ab:	b2 05                	mov    $0x5,%dl
  1060ad:	eb 06                	jmp    1060b5 <z_shell_make_argv+0x153>
				if (i > 2) {
  1060af:	40 80 fe 02          	cmp    $0x2,%sil
  1060b3:	74 3b                	je     1060f0 <z_shell_make_argv+0x18e>
						z_shell_strlen(cmd) - (i - 2));
  1060b5:	4c 89 e7             	mov    %r12,%rdi
  1060b8:	88 4d c6             	mov    %cl,-0x3a(%rbp)
  1060bb:	88 55 c7             	mov    %dl,-0x39(%rbp)
  1060be:	e8 0f fe ff ff       	callq  105ed2 <z_shell_strlen>
  1060c3:	0f b6 55 c7          	movzbl -0x39(%rbp),%edx
					memmove(cmd, cmd + (i - 1),
  1060c7:	4c 89 e7             	mov    %r12,%rdi
						z_shell_strlen(cmd) - (i - 2));
  1060ca:	44 0f b7 c8          	movzwl %ax,%r9d
  1060ce:	41 83 c1 02          	add    $0x2,%r9d
  1060d2:	41 29 d1             	sub    %edx,%r9d
					memmove(cmd, cmd + (i - 1),
  1060d5:	ff ca                	dec    %edx
  1060d7:	4d 63 c9             	movslq %r9d,%r9
  1060da:	48 63 f2             	movslq %edx,%rsi
  1060dd:	4c 01 e6             	add    %r12,%rsi
  1060e0:	4c 89 ca             	mov    %r9,%rdx
  1060e3:	e8 7a 3f 00 00       	callq  10a062 <memmove>
					*cmd++ = v;
  1060e8:	8a 4d c6             	mov    -0x3a(%rbp),%cl
  1060eb:	e9 93 00 00 00       	jmpq   106183 <z_shell_make_argv+0x221>
			if (t == 'x') {
  1060f0:	3c 78                	cmp    $0x78,%al
  1060f2:	0f 85 ae 00 00 00    	jne    1061a6 <z_shell_make_argv+0x244>
  1060f8:	ba 02 00 00 00       	mov    $0x2,%edx
				uint8_t v = 0U;
  1060fd:	31 c9                	xor    %ecx,%ecx
					t = *(cmd + i);
  1060ff:	41 8a 04 14          	mov    (%r12,%rdx,1),%al
					if (t >= '0' && t <= '9') {
  106103:	8d 70 d0             	lea    -0x30(%rax),%esi
  106106:	40 80 fe 09          	cmp    $0x9,%sil
  10610a:	77 07                	ja     106113 <z_shell_make_argv+0x1b1>
						v = (v << 4) | (t - '0');
  10610c:	c1 e1 04             	shl    $0x4,%ecx
  10610f:	09 f1                	or     %esi,%ecx
  106111:	eb 22                	jmp    106135 <z_shell_make_argv+0x1d3>
					} else if ((t >= 'a') &&
  106113:	8d 70 9f             	lea    -0x61(%rax),%esi
  106116:	40 80 fe 05          	cmp    $0x5,%sil
  10611a:	77 08                	ja     106124 <z_shell_make_argv+0x1c2>
						v = (v << 4) | (t - 'a' + 10);
  10611c:	c1 e1 04             	shl    $0x4,%ecx
  10611f:	83 e8 57             	sub    $0x57,%eax
  106122:	eb 0f                	jmp    106133 <z_shell_make_argv+0x1d1>
					} else if ((t >= 'A') && (t <= 'F')) {
  106124:	8d 70 bf             	lea    -0x41(%rax),%esi
  106127:	40 80 fe 05          	cmp    $0x5,%sil
  10612b:	77 19                	ja     106146 <z_shell_make_argv+0x1e4>
						v = (v << 4) | (t - 'A' + 10);
  10612d:	c1 e1 04             	shl    $0x4,%ecx
  106130:	83 e8 37             	sub    $0x37,%eax
  106133:	09 c1                	or     %eax,%ecx
				for (i = 2U; i < (2 + 2); i++) {
  106135:	48 83 fa 03          	cmp    $0x3,%rdx
  106139:	74 07                	je     106142 <z_shell_make_argv+0x1e0>
  10613b:	ba 03 00 00 00       	mov    $0x3,%edx
  106140:	eb bd                	jmp    1060ff <z_shell_make_argv+0x19d>
  106142:	b2 04                	mov    $0x4,%dl
  106144:	eb 07                	jmp    10614d <z_shell_make_argv+0x1eb>
				if (i > 2) {
  106146:	80 fa 02             	cmp    $0x2,%dl
  106149:	74 5b                	je     1061a6 <z_shell_make_argv+0x244>
  10614b:	b2 03                	mov    $0x3,%dl
						z_shell_strlen(cmd) - (i - 2));
  10614d:	4c 89 e7             	mov    %r12,%rdi
  106150:	88 4d c7             	mov    %cl,-0x39(%rbp)
					memmove(cmd, cmd + (i - 1),
  106153:	88 55 c6             	mov    %dl,-0x3a(%rbp)
						z_shell_strlen(cmd) - (i - 2));
  106156:	e8 77 fd ff ff       	callq  105ed2 <z_shell_strlen>
  10615b:	0f b6 55 c6          	movzbl -0x3a(%rbp),%edx
					memmove(cmd, cmd + (i - 1),
  10615f:	4c 89 e7             	mov    %r12,%rdi
						z_shell_strlen(cmd) - (i - 2));
  106162:	44 0f b7 c8          	movzwl %ax,%r9d
  106166:	41 83 c1 02          	add    $0x2,%r9d
  10616a:	41 29 d1             	sub    %edx,%r9d
					memmove(cmd, cmd + (i - 1),
  10616d:	ff ca                	dec    %edx
  10616f:	4d 63 c9             	movslq %r9d,%r9
  106172:	48 63 f2             	movslq %edx,%rsi
  106175:	4c 01 e6             	add    %r12,%rsi
  106178:	4c 89 ca             	mov    %r9,%rdx
  10617b:	e8 e2 3e 00 00       	callq  10a062 <memmove>
					*cmd++ = v;
  106180:	8a 4d c7             	mov    -0x39(%rbp),%cl
  106183:	41 88 0c 24          	mov    %cl,(%r12)
					continue;
  106187:	e9 8e fe ff ff       	jmpq   10601a <z_shell_make_argv+0xb8>
		if (!quote && isspace((int) c)) {
  10618c:	45 84 ff             	test   %r15b,%r15b
  10618f:	75 15                	jne    1061a6 <z_shell_make_argv+0x244>
  106191:	8d 50 f7             	lea    -0x9(%rax),%edx
  106194:	83 fa 04             	cmp    $0x4,%edx
  106197:	0f 86 f0 fd ff ff    	jbe    105f8d <z_shell_make_argv+0x2b>
  10619d:	83 f8 20             	cmp    $0x20,%eax
  1061a0:	0f 84 e7 fd ff ff    	je     105f8d <z_shell_make_argv+0x2b>
		cmd += 1;
  1061a6:	49 8d 5c 24 01       	lea    0x1(%r12),%rbx
  1061ab:	e9 6a fe ff ff       	jmpq   10601a <z_shell_make_argv+0xb8>
		}
		quote = make_argv(&cmd, c);
	} while (true);

	return quote;
}
  1061b0:	48 83 c4 18          	add    $0x18,%rsp
  1061b4:	44 89 f8             	mov    %r15d,%eax
  1061b7:	5b                   	pop    %rbx
  1061b8:	41 5c                	pop    %r12
  1061ba:	41 5d                	pop    %r13
  1061bc:	41 5e                	pop    %r14
  1061be:	41 5f                	pop    %r15
  1061c0:	5d                   	pop    %rbp
  1061c1:	c3                   	retq   

00000000001061c2 <z_shell_pattern_remove>:

void z_shell_pattern_remove(char *buff, uint16_t *buff_len, const char *pattern)
{
  1061c2:	55                   	push   %rbp
  1061c3:	48 89 e5             	mov    %rsp,%rbp
  1061c6:	41 57                	push   %r15
  1061c8:	49 89 d7             	mov    %rdx,%r15
  1061cb:	41 56                	push   %r14
  1061cd:	49 89 fe             	mov    %rdi,%r14
  1061d0:	41 55                	push   %r13
  1061d2:	49 89 f5             	mov    %rsi,%r13
	char *pattern_addr = strstr(buff, pattern);
  1061d5:	48 89 d6             	mov    %rdx,%rsi
{
  1061d8:	41 54                	push   %r12
  1061da:	53                   	push   %rbx
  1061db:	41 50                	push   %r8
	char *pattern_addr = strstr(buff, pattern);
  1061dd:	e8 21 3d 00 00       	callq  109f03 <strstr>
	uint16_t shift;
	uint16_t pattern_len = z_shell_strlen(pattern);
  1061e2:	4c 89 ff             	mov    %r15,%rdi
	char *pattern_addr = strstr(buff, pattern);
  1061e5:	49 89 c4             	mov    %rax,%r12
	uint16_t pattern_len = z_shell_strlen(pattern);
  1061e8:	e8 e5 fc ff ff       	callq  105ed2 <z_shell_strlen>

	if (!pattern_addr) {
  1061ed:	4d 85 e4             	test   %r12,%r12
  1061f0:	74 43                	je     106235 <z_shell_pattern_remove+0x73>
  1061f2:	89 c3                	mov    %eax,%ebx
		return;
	}

	if (pattern_addr > buff) {
  1061f4:	4d 39 e6             	cmp    %r12,%r14
  1061f7:	73 0d                	jae    106206 <z_shell_pattern_remove+0x44>
		if (*(pattern_addr - 1) == ' ') {
  1061f9:	41 80 7c 24 ff 20    	cmpb   $0x20,-0x1(%r12)
  1061ff:	75 05                	jne    106206 <z_shell_pattern_remove+0x44>
			pattern_len++; /* space needs to be removed as well */
  106201:	ff c3                	inc    %ebx
			pattern_addr--; /* set pointer to space */
  106203:	49 ff cc             	dec    %r12
		}
	}

	shift = z_shell_strlen(pattern_addr) - pattern_len + 1; /* +1 for EOS */
  106206:	4c 89 e7             	mov    %r12,%rdi
  106209:	e8 c4 fc ff ff       	callq  105ed2 <z_shell_strlen>
	*buff_len -= pattern_len;
  10620e:	66 41 29 5d 00       	sub    %bx,0x0(%r13)

	memmove(pattern_addr, pattern_addr + pattern_len, shift);
  106213:	0f b7 f3             	movzwl %bx,%esi
}
  106216:	59                   	pop    %rcx
	shift = z_shell_strlen(pattern_addr) - pattern_len + 1; /* +1 for EOS */
  106217:	29 d8                	sub    %ebx,%eax
	memmove(pattern_addr, pattern_addr + pattern_len, shift);
  106219:	4c 01 e6             	add    %r12,%rsi
}
  10621c:	5b                   	pop    %rbx
	memmove(pattern_addr, pattern_addr + pattern_len, shift);
  10621d:	4c 89 e7             	mov    %r12,%rdi
	shift = z_shell_strlen(pattern_addr) - pattern_len + 1; /* +1 for EOS */
  106220:	89 c2                	mov    %eax,%edx
}
  106222:	41 5c                	pop    %r12
  106224:	41 5d                	pop    %r13
	shift = z_shell_strlen(pattern_addr) - pattern_len + 1; /* +1 for EOS */
  106226:	ff c2                	inc    %edx
}
  106228:	41 5e                	pop    %r14
  10622a:	41 5f                	pop    %r15
	memmove(pattern_addr, pattern_addr + pattern_len, shift);
  10622c:	0f b7 d2             	movzwl %dx,%edx
}
  10622f:	5d                   	pop    %rbp
	memmove(pattern_addr, pattern_addr + pattern_len, shift);
  106230:	e9 2d 3e 00 00       	jmpq   10a062 <memmove>
}
  106235:	58                   	pop    %rax
  106236:	5b                   	pop    %rbx
  106237:	41 5c                	pop    %r12
  106239:	41 5d                	pop    %r13
  10623b:	41 5e                	pop    %r14
  10623d:	41 5f                	pop    %r15
  10623f:	5d                   	pop    %rbp
  106240:	c3                   	retq   

0000000000106241 <z_shell_cmd_get>:

const struct shell_static_entry *z_shell_cmd_get(
					const struct shell_static_entry *parent,
					size_t idx,
					struct shell_static_entry *dloc)
{
  106241:	55                   	push   %rbp
  106242:	48 89 e5             	mov    %rsp,%rbp
  106245:	41 55                	push   %r13
  106247:	41 54                	push   %r12
  106249:	49 89 f4             	mov    %rsi,%r12
  10624c:	53                   	push   %rbx
  10624d:	51                   	push   %rcx
	const struct shell_static_entry *res = NULL;

	if (parent == NULL) {
  10624e:	48 85 ff             	test   %rdi,%rdi
  106251:	75 27                	jne    10627a <z_shell_cmd_get+0x39>
	return ((uint8_t *)__shell_root_cmds_end -
  106253:	b8 20 a4 11 00       	mov    $0x11a420,%eax
  106258:	48 2d 40 a3 11 00    	sub    $0x11a340,%rax
			(uint8_t *)__shell_root_cmds_start)/
  10625e:	48 c1 e8 04          	shr    $0x4,%rax
		return  (idx < shell_root_cmd_count()) ?
				shell_root_cmd_get(idx)->u.entry : NULL;
  106262:	89 c0                	mov    %eax,%eax
  106264:	48 39 f0             	cmp    %rsi,%rax
  106267:	76 67                	jbe    1062d0 <z_shell_cmd_get+0x8f>
  106269:	41 89 f4             	mov    %esi,%r12d
  10626c:	49 c1 e4 04          	shl    $0x4,%r12
  106270:	4d 8b ac 24 48 a3 11 	mov    0x11a348(%r12),%r13
  106277:	00 
  106278:	eb 65                	jmp    1062df <z_shell_cmd_get+0x9e>
  10627a:	48 89 fb             	mov    %rdi,%rbx
  10627d:	49 89 d5             	mov    %rdx,%r13
	}

	__ASSERT_NO_MSG(dloc != NULL);
  106280:	48 85 d2             	test   %rdx,%rdx
  106283:	75 2a                	jne    1062af <z_shell_cmd_get+0x6e>
  106285:	be 1c dd 11 00       	mov    $0x11dd1c,%esi
  10628a:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  10628f:	b9 03 01 00 00       	mov    $0x103,%ecx
  106294:	31 c0                	xor    %eax,%eax
  106296:	ba ee dc 11 00       	mov    $0x11dcee,%edx
  10629b:	e8 58 a3 ff ff       	callq  1005f8 <printk>
  1062a0:	be 03 01 00 00       	mov    $0x103,%esi
  1062a5:	bf ee dc 11 00       	mov    $0x11dcee,%edi
  1062aa:	e8 e9 c8 ff ff       	callq  102b98 <assert_post_action>

	if (parent->subcmd) {
  1062af:	48 8b 43 10          	mov    0x10(%rbx),%rax
  1062b3:	48 85 c0             	test   %rax,%rax
  1062b6:	74 18                	je     1062d0 <z_shell_cmd_get+0x8f>
		if (parent->subcmd->is_dynamic) {
  1062b8:	80 38 00             	cmpb   $0x0,(%rax)
			parent->subcmd->u.dynamic_get(idx, dloc);
  1062bb:	48 8b 50 08          	mov    0x8(%rax),%rdx
		if (parent->subcmd->is_dynamic) {
  1062bf:	74 14                	je     1062d5 <z_shell_cmd_get+0x94>
			parent->subcmd->u.dynamic_get(idx, dloc);
  1062c1:	4c 89 ee             	mov    %r13,%rsi
  1062c4:	4c 89 e7             	mov    %r12,%rdi
  1062c7:	ff d2                	callq  *%rdx
			if (dloc->syntax != NULL) {
  1062c9:	49 83 7d 00 00       	cmpq   $0x0,0x0(%r13)
  1062ce:	75 0f                	jne    1062df <z_shell_cmd_get+0x9e>
	const struct shell_static_entry *res = NULL;
  1062d0:	45 31 ed             	xor    %r13d,%r13d
  1062d3:	eb 0a                	jmp    1062df <z_shell_cmd_get+0x9e>
				res = dloc;
			}
		} else {
			if (parent->subcmd->u.entry[idx].syntax != NULL) {
  1062d5:	4d 6b e4 28          	imul   $0x28,%r12,%r12
  1062d9:	4e 8d 2c 22          	lea    (%rdx,%r12,1),%r13
  1062dd:	eb ea                	jmp    1062c9 <z_shell_cmd_get+0x88>
			}
		}
	}

	return res;
}
  1062df:	5a                   	pop    %rdx
  1062e0:	4c 89 e8             	mov    %r13,%rax
  1062e3:	5b                   	pop    %rbx
  1062e4:	41 5c                	pop    %r12
  1062e6:	41 5d                	pop    %r13
  1062e8:	5d                   	pop    %rbp
  1062e9:	c3                   	retq   

00000000001062ea <z_shell_find_cmd>:
 */
const struct shell_static_entry *z_shell_find_cmd(
					const struct shell_static_entry *parent,
					const char *cmd_str,
					struct shell_static_entry *dloc)
{
  1062ea:	55                   	push   %rbp
  1062eb:	48 89 e5             	mov    %rsp,%rbp
  1062ee:	41 57                	push   %r15
  1062f0:	49 89 f7             	mov    %rsi,%r15
  1062f3:	41 56                	push   %r14
  1062f5:	41 55                	push   %r13
  1062f7:	41 54                	push   %r12
  1062f9:	49 89 fc             	mov    %rdi,%r12
  1062fc:	53                   	push   %rbx
  1062fd:	48 89 d3             	mov    %rdx,%rbx
  106300:	48 83 ec 38          	sub    $0x38,%rsp
	 * dynamic commands at the same time (current and subcommand) they
	 * will operate on the same memory region what can cause undefined
	 * behaviour.
	 * Hence we need a separate memory for each of them.
	 */
	if (parent) {
  106304:	48 85 ff             	test   %rdi,%rdi
  106307:	74 15                	je     10631e <z_shell_find_cmd+0x34>
		memcpy(&parent_cpy, parent, sizeof(struct shell_static_entry));
  106309:	48 89 fe             	mov    %rdi,%rsi
  10630c:	48 8d 7d a8          	lea    -0x58(%rbp),%rdi
		parent = &parent_cpy;
  106310:	4c 8d 65 a8          	lea    -0x58(%rbp),%r12
		memcpy(&parent_cpy, parent, sizeof(struct shell_static_entry));
  106314:	ba 28 00 00 00       	mov    $0x28,%edx
  106319:	e8 7a 3d 00 00       	callq  10a098 <memcpy>
		parent = &parent_cpy;
  10631e:	45 31 f6             	xor    %r14d,%r14d
	}

	while ((entry = z_shell_cmd_get(parent, idx++, dloc)) != NULL) {
  106321:	4c 89 f6             	mov    %r14,%rsi
  106324:	48 89 da             	mov    %rbx,%rdx
  106327:	4c 89 e7             	mov    %r12,%rdi
  10632a:	49 ff c6             	inc    %r14
  10632d:	e8 0f ff ff ff       	callq  106241 <z_shell_cmd_get>
  106332:	49 89 c5             	mov    %rax,%r13
  106335:	48 85 c0             	test   %rax,%rax
  106338:	74 10                	je     10634a <z_shell_find_cmd+0x60>
		if (strcmp(cmd_str, entry->syntax) == 0) {
  10633a:	49 8b 75 00          	mov    0x0(%r13),%rsi
  10633e:	4c 89 ff             	mov    %r15,%rdi
  106341:	e8 b7 3c 00 00       	callq  109ffd <strcmp>
  106346:	85 c0                	test   %eax,%eax
  106348:	75 d7                	jne    106321 <z_shell_find_cmd+0x37>
			return entry;
		}
	}

	return NULL;
}
  10634a:	48 83 c4 38          	add    $0x38,%rsp
  10634e:	4c 89 e8             	mov    %r13,%rax
  106351:	5b                   	pop    %rbx
  106352:	41 5c                	pop    %r12
  106354:	41 5d                	pop    %r13
  106356:	41 5e                	pop    %r14
  106358:	41 5f                	pop    %r15
  10635a:	5d                   	pop    %rbp
  10635b:	c3                   	retq   

000000000010635c <z_shell_get_last_command>:
					size_t argc,
					const char *argv[],
					size_t *match_arg,
					struct shell_static_entry *dloc,
					bool only_static)
{
  10635c:	55                   	push   %rbp
  10635d:	48 89 e5             	mov    %rsp,%rbp
  106360:	41 57                	push   %r15
  106362:	45 89 cf             	mov    %r9d,%r15d
  106365:	41 56                	push   %r14
	const struct shell_static_entry *prev_entry = NULL;

	*match_arg = Z_SHELL_CMD_ROOT_LVL;

	while (*match_arg < argc) {
  106367:	49 89 fe             	mov    %rdi,%r14
{
  10636a:	41 55                	push   %r13
  10636c:	4d 89 c5             	mov    %r8,%r13
  10636f:	41 54                	push   %r12
  106371:	49 89 d4             	mov    %rdx,%r12
  106374:	53                   	push   %rbx
  106375:	48 89 cb             	mov    %rcx,%rbx
  106378:	48 83 ec 18          	sub    $0x18,%rsp
  10637c:	48 89 75 c8          	mov    %rsi,-0x38(%rbp)
	*match_arg = Z_SHELL_CMD_ROOT_LVL;
  106380:	48 c7 01 00 00 00 00 	movq   $0x0,(%rcx)
	while (*match_arg < argc) {
  106387:	48 8b 03             	mov    (%rbx),%rax
  10638a:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  10638e:	73 4d                	jae    1063dd <z_shell_get_last_command+0x81>

		if (IS_ENABLED(CONFIG_SHELL_WILDCARD)) {
			/* ignore wildcard argument */
			if (z_shell_has_wildcard(argv[*match_arg])) {
  106390:	49 8b 3c c4          	mov    (%r12,%rax,8),%rdi
  106394:	e8 6c 1b 00 00       	callq  107f05 <z_shell_has_wildcard>
  106399:	84 c0                	test   %al,%al
  10639b:	74 08                	je     1063a5 <z_shell_get_last_command+0x49>
				(*match_arg)++;
  10639d:	48 ff 03             	incq   (%rbx)
				continue;
  1063a0:	4c 89 f0             	mov    %r14,%rax
  1063a3:	eb 33                	jmp    1063d8 <z_shell_get_last_command+0x7c>
			}
		}

		prev_entry = entry;
		entry = z_shell_find_cmd(entry, argv[*match_arg], dloc);
  1063a5:	48 8b 03             	mov    (%rbx),%rax
  1063a8:	4c 89 ea             	mov    %r13,%rdx
  1063ab:	4c 89 f7             	mov    %r14,%rdi
  1063ae:	49 8b 34 c4          	mov    (%r12,%rax,8),%rsi
  1063b2:	e8 33 ff ff ff       	callq  1062ea <z_shell_find_cmd>
		if (entry) {
  1063b7:	48 85 c0             	test   %rax,%rax
  1063ba:	74 21                	je     1063dd <z_shell_get_last_command+0x81>
			(*match_arg)++;
  1063bc:	48 8b 13             	mov    (%rbx),%rdx
  1063bf:	48 8d 4a 01          	lea    0x1(%rdx),%rcx
  1063c3:	48 89 0b             	mov    %rcx,(%rbx)
		} else {
			entry = prev_entry;
			break;
		}

		if (only_static && (entry == dloc)) {
  1063c6:	49 39 c5             	cmp    %rax,%r13
  1063c9:	75 0d                	jne    1063d8 <z_shell_get_last_command+0x7c>
  1063cb:	45 84 ff             	test   %r15b,%r15b
  1063ce:	74 08                	je     1063d8 <z_shell_get_last_command+0x7c>
			(*match_arg)--;
  1063d0:	48 89 13             	mov    %rdx,(%rbx)
			return NULL;
  1063d3:	45 31 f6             	xor    %r14d,%r14d
  1063d6:	eb 05                	jmp    1063dd <z_shell_get_last_command+0x81>
				continue;
  1063d8:	49 89 c6             	mov    %rax,%r14
  1063db:	eb aa                	jmp    106387 <z_shell_get_last_command+0x2b>
		}
	}

	return entry;
}
  1063dd:	48 83 c4 18          	add    $0x18,%rsp
  1063e1:	4c 89 f0             	mov    %r14,%rax
  1063e4:	5b                   	pop    %rbx
  1063e5:	41 5c                	pop    %r12
  1063e7:	41 5d                	pop    %r13
  1063e9:	41 5e                	pop    %r14
  1063eb:	41 5f                	pop    %r15
  1063ed:	5d                   	pop    %rbp
  1063ee:	c3                   	retq   

00000000001063ef <z_shell_spaces_trim>:




void z_shell_spaces_trim(char *str)
{
  1063ef:	55                   	push   %rbp
  1063f0:	48 89 e5             	mov    %rsp,%rbp
  1063f3:	41 56                	push   %r14
  1063f5:	41 55                	push   %r13
  1063f7:	41 54                	push   %r12
  1063f9:	53                   	push   %rbx
  1063fa:	48 89 fb             	mov    %rdi,%rbx
	uint16_t len = z_shell_strlen(str);
  1063fd:	e8 d0 fa ff ff       	callq  105ed2 <z_shell_strlen>
	uint16_t shift = 0U;

	if (!str) {
  106402:	48 85 db             	test   %rbx,%rbx
  106405:	0f 84 88 00 00 00    	je     106493 <z_shell_spaces_trim+0xa4>
  10640b:	41 89 c4             	mov    %eax,%r12d
		return;
	}

	for (uint16_t i = 0; i < len - 1; i++) {
  10640e:	45 31 ed             	xor    %r13d,%r13d
	uint16_t shift = 0U;
  106411:	45 31 f6             	xor    %r14d,%r14d
	for (uint16_t i = 0; i < len - 1; i++) {
  106414:	41 0f b7 d4          	movzwl %r12w,%edx
  106418:	41 0f b7 fd          	movzwl %r13w,%edi
  10641c:	8d 42 ff             	lea    -0x1(%rdx),%eax
  10641f:	39 c7                	cmp    %eax,%edi
  106421:	7d 70                	jge    106493 <z_shell_spaces_trim+0xa4>
		if (isspace((int)str[i])) {
  106423:	41 0f b7 c5          	movzwl %r13w,%eax
  106427:	0f be 04 03          	movsbl (%rbx,%rax,1),%eax
  10642b:	89 c1                	mov    %eax,%ecx
  10642d:	83 e8 09             	sub    $0x9,%eax
  106430:	83 f8 04             	cmp    $0x4,%eax
  106433:	76 05                	jbe    10643a <z_shell_spaces_trim+0x4b>
  106435:	80 f9 20             	cmp    $0x20,%cl
  106438:	75 54                	jne    10648e <z_shell_spaces_trim+0x9f>
			for (uint16_t j = i + 1; j < len; j++) {
  10643a:	41 8d 45 01          	lea    0x1(%r13),%eax
  10643e:	0f b7 c0             	movzwl %ax,%eax
  106441:	0f b7 c8             	movzwl %ax,%ecx
  106444:	66 41 39 c4          	cmp    %ax,%r12w
  106448:	76 44                	jbe    10648e <z_shell_spaces_trim+0x9f>
				if (isspace((int)str[j])) {
  10644a:	44 0f be 04 03       	movsbl (%rbx,%rax,1),%r8d
  10644f:	48 8d 34 03          	lea    (%rbx,%rax,1),%rsi
  106453:	48 ff c0             	inc    %rax
  106456:	45 89 c1             	mov    %r8d,%r9d
  106459:	41 83 e8 09          	sub    $0x9,%r8d
  10645d:	41 83 f8 04          	cmp    $0x4,%r8d
  106461:	76 06                	jbe    106469 <z_shell_spaces_trim+0x7a>
  106463:	41 80 f9 20          	cmp    $0x20,%r9b
  106467:	75 05                	jne    10646e <z_shell_spaces_trim+0x7f>
					shift++;
  106469:	41 ff c6             	inc    %r14d
			for (uint16_t j = i + 1; j < len; j++) {
  10646c:	eb d3                	jmp    106441 <z_shell_spaces_trim+0x52>
					continue;
				}

				if (shift > 0) {
  10646e:	66 45 85 f6          	test   %r14w,%r14w
  106472:	74 1a                	je     10648e <z_shell_spaces_trim+0x9f>
					/* +1 for EOS */
					memmove(&str[i + 1],
						&str[j],
						len - j + 1);
  106474:	ff c2                	inc    %edx
					memmove(&str[i + 1],
  106476:	ff c7                	inc    %edi
					len -= shift;
  106478:	45 29 f4             	sub    %r14d,%r12d
					shift = 0U;
  10647b:	45 31 f6             	xor    %r14d,%r14d
						len - j + 1);
  10647e:	29 ca                	sub    %ecx,%edx
					memmove(&str[i + 1],
  106480:	48 63 ff             	movslq %edi,%rdi
  106483:	48 63 d2             	movslq %edx,%rdx
  106486:	48 01 df             	add    %rbx,%rdi
  106489:	e8 d4 3b 00 00       	callq  10a062 <memmove>
	for (uint16_t i = 0; i < len - 1; i++) {
  10648e:	41 ff c5             	inc    %r13d
  106491:	eb 81                	jmp    106414 <z_shell_spaces_trim+0x25>

				break;
			}
		}
	}
}
  106493:	5b                   	pop    %rbx
  106494:	41 5c                	pop    %r12
  106496:	41 5d                	pop    %r13
  106498:	41 5e                	pop    %r14
  10649a:	5d                   	pop    %rbp
  10649b:	c3                   	retq   

000000000010649c <z_shell_cmd_trim>:
		*buff_len = *buff_len - i;
	}
}

void z_shell_cmd_trim(const struct shell *shell)
{
  10649c:	55                   	push   %rbp
  10649d:	48 89 e5             	mov    %rsp,%rbp
  1064a0:	41 55                	push   %r13
  1064a2:	41 54                	push   %r12
  1064a4:	49 89 fc             	mov    %rdi,%r12
  1064a7:	53                   	push   %rbx
  1064a8:	52                   	push   %rdx
	buffer_trim(shell->ctx->cmd_buff, &shell->ctx->cmd_buff_len);
  1064a9:	48 8b 5f 10          	mov    0x10(%rdi),%rbx
	if (buff[0] == '\0') {
  1064ad:	80 7b 76 00          	cmpb   $0x0,0x76(%rbx)
  1064b1:	48 8d 7b 76          	lea    0x76(%rbx),%rdi
  1064b5:	74 6d                	je     106524 <z_shell_cmd_trim+0x88>
	while (isspace((int) buff[*buff_len - 1U])) {
  1064b7:	0f b7 53 70          	movzwl 0x70(%rbx),%edx
  1064bb:	48 89 d0             	mov    %rdx,%rax
  1064be:	ff ca                	dec    %edx
  1064c0:	0f be 14 17          	movsbl (%rdi,%rdx,1),%edx
  1064c4:	89 d1                	mov    %edx,%ecx
  1064c6:	83 ea 09             	sub    $0x9,%edx
  1064c9:	83 fa 04             	cmp    $0x4,%edx
  1064cc:	77 11                	ja     1064df <z_shell_cmd_trim+0x43>
		*buff_len -= 1U;
  1064ce:	ff c8                	dec    %eax
  1064d0:	66 89 43 70          	mov    %ax,0x70(%rbx)
		if (*buff_len == 0U) {
  1064d4:	66 85 c0             	test   %ax,%ax
  1064d7:	75 de                	jne    1064b7 <z_shell_cmd_trim+0x1b>
			buff[0] = '\0';
  1064d9:	c6 43 76 00          	movb   $0x0,0x76(%rbx)
			return;
  1064dd:	eb 45                	jmp    106524 <z_shell_cmd_trim+0x88>
	while (isspace((int) buff[*buff_len - 1U])) {
  1064df:	80 f9 20             	cmp    $0x20,%cl
  1064e2:	74 ea                	je     1064ce <z_shell_cmd_trim+0x32>
	buff[*buff_len] = '\0';
  1064e4:	c6 44 03 76 00       	movb   $0x0,0x76(%rbx,%rax,1)
	uint16_t i = 0U;
  1064e9:	31 c0                	xor    %eax,%eax
	while (isspace((int) buff[i++])) {
  1064eb:	0f b7 f0             	movzwl %ax,%esi
  1064ee:	ff c0                	inc    %eax
  1064f0:	49 89 f5             	mov    %rsi,%r13
  1064f3:	48 01 fe             	add    %rdi,%rsi
  1064f6:	0f be 16             	movsbl (%rsi),%edx
  1064f9:	89 d1                	mov    %edx,%ecx
  1064fb:	83 ea 09             	sub    $0x9,%edx
  1064fe:	83 fa 04             	cmp    $0x4,%edx
  106501:	76 e8                	jbe    1064eb <z_shell_cmd_trim+0x4f>
  106503:	80 f9 20             	cmp    $0x20,%cl
  106506:	74 e3                	je     1064eb <z_shell_cmd_trim+0x4f>
	if (--i > 0) {
  106508:	66 45 85 ed          	test   %r13w,%r13w
  10650c:	74 16                	je     106524 <z_shell_cmd_trim+0x88>
		memmove(buff, buff + i, (*buff_len + 1U) - i); /* +1 for '\0' */
  10650e:	0f b7 53 70          	movzwl 0x70(%rbx),%edx
  106512:	41 0f b7 c5          	movzwl %r13w,%eax
  106516:	ff c2                	inc    %edx
  106518:	29 c2                	sub    %eax,%edx
  10651a:	e8 43 3b 00 00       	callq  10a062 <memmove>
		*buff_len = *buff_len - i;
  10651f:	66 44 29 6b 70       	sub    %r13w,0x70(%rbx)
	shell->ctx->cmd_buff_pos = shell->ctx->cmd_buff_len;
  106524:	49 8b 44 24 10       	mov    0x10(%r12),%rax
  106529:	8b 50 70             	mov    0x70(%rax),%edx
  10652c:	66 89 50 72          	mov    %dx,0x72(%rax)
}
  106530:	58                   	pop    %rax
  106531:	5b                   	pop    %rbx
  106532:	41 5c                	pop    %r12
  106534:	41 5d                	pop    %r13
  106536:	5d                   	pop    %rbp
  106537:	c3                   	retq   

0000000000106538 <z_shell_raw_fprintf>:
{
  106538:	55                   	push   %rbp
  106539:	48 89 e5             	mov    %rsp,%rbp
  10653c:	48 81 ec d0 00 00 00 	sub    $0xd0,%rsp
  106543:	48 89 95 60 ff ff ff 	mov    %rdx,-0xa0(%rbp)
  10654a:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  106551:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  106558:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  10655f:	84 c0                	test   %al,%al
  106561:	74 20                	je     106583 <z_shell_raw_fprintf+0x4b>
  106563:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  106567:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  10656b:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  10656f:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  106573:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  106577:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  10657b:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  10657f:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
	va_start(args, fmt);
  106583:	48 8d 45 10          	lea    0x10(%rbp),%rax
	z_shell_fprintf_fmt(ctx, fmt, args);
  106587:	48 8d 95 38 ff ff ff 	lea    -0xc8(%rbp),%rdx
	va_start(args, fmt);
  10658e:	c7 85 38 ff ff ff 10 	movl   $0x10,-0xc8(%rbp)
  106595:	00 00 00 
  106598:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  10659f:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  1065a6:	c7 85 3c ff ff ff 30 	movl   $0x30,-0xc4(%rbp)
  1065ad:	00 00 00 
  1065b0:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
	z_shell_fprintf_fmt(ctx, fmt, args);
  1065b7:	e8 85 f8 ff ff       	callq  105e41 <z_shell_fprintf_fmt>
}
  1065bc:	c9                   	leaveq 
  1065bd:	c3                   	retq   

00000000001065be <z_cursor_next_line_move.isra.0>:
	z_shell_raw_fprintf(shell->fprintf_ctx, "\n");
  1065be:	be 23 fc 11 00       	mov    $0x11fc23,%esi
  1065c3:	31 c0                	xor    %eax,%eax
  1065c5:	e9 6e ff ff ff       	jmpq   106538 <z_shell_raw_fprintf>

00000000001065ca <z_clear_eos.isra.0>:
	Z_SHELL_VT100_CMD(shell, SHELL_VT100_CLEAREOS);
  1065ca:	ba d1 dd 11 00       	mov    $0x11ddd1,%edx
  1065cf:	be b7 d5 11 00       	mov    $0x11d5b7,%esi
  1065d4:	31 c0                	xor    %eax,%eax
  1065d6:	e9 5d ff ff ff       	jmpq   106538 <z_shell_raw_fprintf>

00000000001065db <full_line_cmd>:

/* Function returns true if command length is equal to multiplicity of terminal
 * width.
 */
static inline bool full_line_cmd(const struct shell *shell)
{
  1065db:	55                   	push   %rbp
  1065dc:	48 89 e5             	mov    %rsp,%rbp
  1065df:	41 54                	push   %r12
  1065e1:	53                   	push   %rbx
	return ((shell->ctx->cmd_buff_len + z_shell_strlen(shell->ctx->prompt))
  1065e2:	48 8b 47 10          	mov    0x10(%rdi),%rax
{
  1065e6:	48 89 fb             	mov    %rdi,%rbx
	return ((shell->ctx->cmd_buff_len + z_shell_strlen(shell->ctx->prompt))
  1065e9:	48 8b 38             	mov    (%rax),%rdi
  1065ec:	44 0f b7 60 70       	movzwl 0x70(%rax),%r12d
  1065f1:	31 c0                	xor    %eax,%eax
	return str == NULL ? 0U : (uint16_t)strlen(str);
  1065f3:	48 85 ff             	test   %rdi,%rdi
  1065f6:	74 05                	je     1065fd <full_line_cmd+0x22>
  1065f8:	e8 df 39 00 00       	callq  109fdc <strlen>
			% shell->ctx->vt100_ctx.cons.terminal_wid == 0U);
  1065fd:	48 8b 53 10          	mov    0x10(%rbx),%rdx
	return ((shell->ctx->cmd_buff_len + z_shell_strlen(shell->ctx->prompt))
  106601:	0f b7 c0             	movzwl %ax,%eax
}
  106604:	5b                   	pop    %rbx
	return ((shell->ctx->cmd_buff_len + z_shell_strlen(shell->ctx->prompt))
  106605:	44 01 e0             	add    %r12d,%eax
}
  106608:	41 5c                	pop    %r12
  10660a:	5d                   	pop    %rbp
			% shell->ctx->vt100_ctx.cons.terminal_wid == 0U);
  10660b:	0f b7 4a 4a          	movzwl 0x4a(%rdx),%ecx
  10660f:	99                   	cltd   
  106610:	f7 f9                	idiv   %ecx
  106612:	85 d2                	test   %edx,%edx
  106614:	0f 94 c0             	sete   %al
}
  106617:	c3                   	retq   

0000000000106618 <z_shell_op_cursor_vert_move>:
	if (delta != 0) {
  106618:	85 f6                	test   %esi,%esi
  10661a:	74 24                	je     106640 <z_shell_op_cursor_vert_move+0x28>
		z_shell_raw_fprintf(shell->fprintf_ctx, "\033[%d%c",
  10661c:	89 f0                	mov    %esi,%eax
  10661e:	0f 9e c1             	setle  %cl
  106621:	48 8b 7f 28          	mov    0x28(%rdi),%rdi
  106625:	c1 f8 1f             	sar    $0x1f,%eax
  106628:	0f b6 c9             	movzbl %cl,%ecx
  10662b:	31 c6                	xor    %eax,%esi
  10662d:	83 c1 41             	add    $0x41,%ecx
  106630:	89 f2                	mov    %esi,%edx
  106632:	be 30 dd 11 00       	mov    $0x11dd30,%esi
  106637:	29 c2                	sub    %eax,%edx
  106639:	31 c0                	xor    %eax,%eax
  10663b:	e9 f8 fe ff ff       	jmpq   106538 <z_shell_raw_fprintf>
}
  106640:	c3                   	retq   

0000000000106641 <z_shell_op_cursor_horiz_move>:
	if (delta != 0) {
  106641:	85 f6                	test   %esi,%esi
  106643:	74 24                	je     106669 <z_shell_op_cursor_horiz_move+0x28>
		z_shell_raw_fprintf(shell->fprintf_ctx, "\033[%d%c",
  106645:	89 f0                	mov    %esi,%eax
  106647:	0f 9e c1             	setle  %cl
  10664a:	48 8b 7f 28          	mov    0x28(%rdi),%rdi
  10664e:	c1 f8 1f             	sar    $0x1f,%eax
  106651:	0f b6 c9             	movzbl %cl,%ecx
  106654:	31 c6                	xor    %eax,%esi
  106656:	83 c1 43             	add    $0x43,%ecx
  106659:	89 f2                	mov    %esi,%edx
  10665b:	be 30 dd 11 00       	mov    $0x11dd30,%esi
  106660:	29 c2                	sub    %eax,%edx
  106662:	31 c0                	xor    %eax,%eax
  106664:	e9 cf fe ff ff       	jmpq   106538 <z_shell_raw_fprintf>
}
  106669:	c3                   	retq   

000000000010666a <z_shell_cursor_in_empty_line>:

/* Function returns true if cursor is at beginning of an empty line. */
bool z_shell_cursor_in_empty_line(const struct shell *shell)
{
  10666a:	55                   	push   %rbp
  10666b:	48 89 e5             	mov    %rsp,%rbp
  10666e:	41 54                	push   %r12
  106670:	53                   	push   %rbx
	return ((shell->ctx->cmd_buff_pos + z_shell_strlen(shell->ctx->prompt))
  106671:	48 8b 47 10          	mov    0x10(%rdi),%rax
{
  106675:	48 89 fb             	mov    %rdi,%rbx
	return ((shell->ctx->cmd_buff_pos + z_shell_strlen(shell->ctx->prompt))
  106678:	48 8b 38             	mov    (%rax),%rdi
  10667b:	44 0f b7 60 72       	movzwl 0x72(%rax),%r12d
  106680:	31 c0                	xor    %eax,%eax
  106682:	48 85 ff             	test   %rdi,%rdi
  106685:	74 05                	je     10668c <z_shell_cursor_in_empty_line+0x22>
  106687:	e8 50 39 00 00       	callq  109fdc <strlen>
			% shell->ctx->vt100_ctx.cons.terminal_wid == 0U);
  10668c:	48 8b 53 10          	mov    0x10(%rbx),%rdx
	return ((shell->ctx->cmd_buff_pos + z_shell_strlen(shell->ctx->prompt))
  106690:	0f b7 c0             	movzwl %ax,%eax
}
  106693:	5b                   	pop    %rbx
	return ((shell->ctx->cmd_buff_pos + z_shell_strlen(shell->ctx->prompt))
  106694:	44 01 e0             	add    %r12d,%eax
}
  106697:	41 5c                	pop    %r12
  106699:	5d                   	pop    %rbp
			% shell->ctx->vt100_ctx.cons.terminal_wid == 0U);
  10669a:	0f b7 4a 4a          	movzwl 0x4a(%rdx),%ecx
  10669e:	99                   	cltd   
  10669f:	f7 f9                	idiv   %ecx
  1066a1:	85 d2                	test   %edx,%edx
  1066a3:	0f 94 c0             	sete   %al
}
  1066a6:	c3                   	retq   

00000000001066a7 <z_shell_op_cond_next_line>:

void z_shell_op_cond_next_line(const struct shell *shell)
{
  1066a7:	55                   	push   %rbp
  1066a8:	48 89 e5             	mov    %rsp,%rbp
  1066ab:	53                   	push   %rbx
  1066ac:	48 89 fb             	mov    %rdi,%rbx
  1066af:	51                   	push   %rcx
	if (z_shell_cursor_in_empty_line(shell) || full_line_cmd(shell)) {
  1066b0:	e8 b5 ff ff ff       	callq  10666a <z_shell_cursor_in_empty_line>
  1066b5:	84 c0                	test   %al,%al
  1066b7:	74 0c                	je     1066c5 <z_shell_op_cond_next_line+0x1e>
		z_cursor_next_line_move(shell);
  1066b9:	48 8b 7b 28          	mov    0x28(%rbx),%rdi
	}
}
  1066bd:	5a                   	pop    %rdx
  1066be:	5b                   	pop    %rbx
  1066bf:	5d                   	pop    %rbp
		z_cursor_next_line_move(shell);
  1066c0:	e9 f9 fe ff ff       	jmpq   1065be <z_cursor_next_line_move.isra.0>
	if (z_shell_cursor_in_empty_line(shell) || full_line_cmd(shell)) {
  1066c5:	48 89 df             	mov    %rbx,%rdi
  1066c8:	e8 0e ff ff ff       	callq  1065db <full_line_cmd>
  1066cd:	84 c0                	test   %al,%al
  1066cf:	75 e8                	jne    1066b9 <z_shell_op_cond_next_line+0x12>
}
  1066d1:	58                   	pop    %rax
  1066d2:	5b                   	pop    %rbx
  1066d3:	5d                   	pop    %rbp
  1066d4:	c3                   	retq   

00000000001066d5 <z_shell_op_cursor_position_synchronize>:

void z_shell_op_cursor_position_synchronize(const struct shell *shell)
{
  1066d5:	55                   	push   %rbp
  1066d6:	48 89 e5             	mov    %rsp,%rbp
  1066d9:	41 56                	push   %r14
  1066db:	41 55                	push   %r13
  1066dd:	41 54                	push   %r12
  1066df:	49 89 fc             	mov    %rdi,%r12
  1066e2:	53                   	push   %rbx
	struct shell_multiline_cons *cons = &shell->ctx->vt100_ctx.cons;
  1066e3:	48 8b 5f 10          	mov    0x10(%rdi),%rbx
	bool last_line;

	z_shell_multiline_data_calc(cons, shell->ctx->cmd_buff_pos,
  1066e7:	0f b7 53 70          	movzwl 0x70(%rbx),%edx
  1066eb:	0f b7 73 72          	movzwl 0x72(%rbx),%esi
	struct shell_multiline_cons *cons = &shell->ctx->vt100_ctx.cons;
  1066ef:	48 8d 7b 40          	lea    0x40(%rbx),%rdi
	z_shell_multiline_data_calc(cons, shell->ctx->cmd_buff_pos,
  1066f3:	e8 33 f8 ff ff       	callq  105f2b <z_shell_multiline_data_calc>
	last_line = (cons->cur_y == cons->cur_y_end);

	/* In case cursor reaches the bottom line of a terminal, it will
	 * be moved to the next line.
	 */
	if (full_line_cmd(shell)) {
  1066f8:	4c 89 e7             	mov    %r12,%rdi
	last_line = (cons->cur_y == cons->cur_y_end);
  1066fb:	66 44 8b 73 44       	mov    0x44(%rbx),%r14w
  106700:	66 44 8b 6b 46       	mov    0x46(%rbx),%r13w
	if (full_line_cmd(shell)) {
  106705:	e8 d1 fe ff ff       	callq  1065db <full_line_cmd>
  10670a:	84 c0                	test   %al,%al
  10670c:	74 0a                	je     106718 <z_shell_op_cursor_position_synchronize+0x43>
		z_cursor_next_line_move(shell);
  10670e:	49 8b 7c 24 28       	mov    0x28(%r12),%rdi
  106713:	e8 a6 fe ff ff       	callq  1065be <z_cursor_next_line_move.isra.0>
	}

	if (last_line) {
  106718:	66 45 39 ee          	cmp    %r13w,%r14w
  10671c:	74 12                	je     106730 <z_shell_op_cursor_position_synchronize+0x5b>
		z_shell_op_cursor_horiz_move(shell, cons->cur_x -
							       cons->cur_x_end);
	} else {
		z_shell_op_cursor_vert_move(shell, cons->cur_y_end - cons->cur_y);
  10671e:	0f b7 73 46          	movzwl 0x46(%rbx),%esi
  106722:	0f b7 43 44          	movzwl 0x44(%rbx),%eax
  106726:	4c 89 e7             	mov    %r12,%rdi
  106729:	29 c6                	sub    %eax,%esi
  10672b:	e8 e8 fe ff ff       	callq  106618 <z_shell_op_cursor_vert_move>
		z_shell_op_cursor_horiz_move(shell, cons->cur_x -
  106730:	0f b7 73 40          	movzwl 0x40(%rbx),%esi
							       cons->cur_x_end);
  106734:	0f b7 43 42          	movzwl 0x42(%rbx),%eax
		z_shell_op_cursor_horiz_move(shell, cons->cur_x -
  106738:	4c 89 e7             	mov    %r12,%rdi
	}
}
  10673b:	5b                   	pop    %rbx
  10673c:	41 5c                	pop    %r12
		z_shell_op_cursor_horiz_move(shell, cons->cur_x -
  10673e:	29 c6                	sub    %eax,%esi
}
  106740:	41 5d                	pop    %r13
  106742:	41 5e                	pop    %r14
  106744:	5d                   	pop    %rbp
		z_shell_op_cursor_horiz_move(shell, cons->cur_x -
  106745:	e9 f7 fe ff ff       	jmpq   106641 <z_shell_op_cursor_horiz_move>

000000000010674a <z_shell_op_cursor_move>:

void z_shell_op_cursor_move(const struct shell *shell, int16_t val)
{
  10674a:	55                   	push   %rbp
  10674b:	48 89 e5             	mov    %rsp,%rbp
  10674e:	41 56                	push   %r14
  106750:	41 55                	push   %r13
  106752:	41 54                	push   %r12
  106754:	53                   	push   %rbx
  106755:	48 89 fb             	mov    %rdi,%rbx
	struct shell_multiline_cons *cons = &shell->ctx->vt100_ctx.cons;
  106758:	48 8b 7f 10          	mov    0x10(%rdi),%rdi
	uint16_t new_pos = shell->ctx->cmd_buff_pos + val;
  10675c:	66 8b 47 72          	mov    0x72(%rdi),%ax
	int32_t row_span;
	int32_t col_span;

	z_shell_multiline_data_calc(cons, shell->ctx->cmd_buff_pos,
  106760:	0f b7 57 70          	movzwl 0x70(%rdi),%edx
	struct shell_multiline_cons *cons = &shell->ctx->vt100_ctx.cons;
  106764:	48 83 c7 40          	add    $0x40,%rdi
	uint16_t new_pos = shell->ctx->cmd_buff_pos + val;
  106768:	44 8d 2c 30          	lea    (%rax,%rsi,1),%r13d
	z_shell_multiline_data_calc(cons, shell->ctx->cmd_buff_pos,
  10676c:	0f b7 f0             	movzwl %ax,%esi
  10676f:	e8 b7 f7 ff ff       	callq  105f2b <z_shell_multiline_data_calc>
				    shell->ctx->cmd_buff_len);

	/* Calculate the new cursor. */
	row_span = z_row_span_with_buffer_offsets_get(
						&shell->ctx->vt100_ctx.cons,
						shell->ctx->cmd_buff_pos,
  106774:	48 8b 7b 10          	mov    0x10(%rbx),%rdi
	row_span = z_row_span_with_buffer_offsets_get(
  106778:	45 0f b7 f5          	movzwl %r13w,%r14d
  10677c:	44 89 f2             	mov    %r14d,%edx
  10677f:	0f b7 77 72          	movzwl 0x72(%rdi),%esi
  106783:	48 83 c7 40          	add    $0x40,%rdi
  106787:	e8 7b f7 ff ff       	callq  105f07 <z_row_span_with_buffer_offsets_get>
						new_pos);
	col_span = z_column_span_with_buffer_offsets_get(
						&shell->ctx->vt100_ctx.cons,
						shell->ctx->cmd_buff_pos,
  10678c:	48 8b 7b 10          	mov    0x10(%rbx),%rdi
	col_span = z_column_span_with_buffer_offsets_get(
  106790:	44 89 f2             	mov    %r14d,%edx
	row_span = z_row_span_with_buffer_offsets_get(
  106793:	41 89 c4             	mov    %eax,%r12d
	col_span = z_column_span_with_buffer_offsets_get(
  106796:	0f b7 77 72          	movzwl 0x72(%rdi),%esi
  10679a:	48 83 c7 40          	add    $0x40,%rdi
  10679e:	e8 42 f7 ff ff       	callq  105ee5 <z_column_span_with_buffer_offsets_get>
						new_pos);

	z_shell_op_cursor_vert_move(shell, -row_span);
  1067a3:	44 89 e6             	mov    %r12d,%esi
  1067a6:	48 89 df             	mov    %rbx,%rdi
	col_span = z_column_span_with_buffer_offsets_get(
  1067a9:	41 89 c6             	mov    %eax,%r14d
	z_shell_op_cursor_vert_move(shell, -row_span);
  1067ac:	f7 de                	neg    %esi
  1067ae:	e8 65 fe ff ff       	callq  106618 <z_shell_op_cursor_vert_move>
	z_shell_op_cursor_horiz_move(shell, col_span);
  1067b3:	44 89 f6             	mov    %r14d,%esi
  1067b6:	48 89 df             	mov    %rbx,%rdi
  1067b9:	e8 83 fe ff ff       	callq  106641 <z_shell_op_cursor_horiz_move>
	shell->ctx->cmd_buff_pos = new_pos;
  1067be:	48 8b 43 10          	mov    0x10(%rbx),%rax
  1067c2:	66 44 89 68 72       	mov    %r13w,0x72(%rax)
}
  1067c7:	5b                   	pop    %rbx
  1067c8:	41 5c                	pop    %r12
  1067ca:	41 5d                	pop    %r13
  1067cc:	41 5e                	pop    %r14
  1067ce:	5d                   	pop    %rbp
  1067cf:	c3                   	retq   

00000000001067d0 <z_shell_op_cursor_word_move>:

	return ret;
}

void z_shell_op_cursor_word_move(const struct shell *shell, int16_t val)
{
  1067d0:	55                   	push   %rbp
  1067d1:	48 89 e5             	mov    %rsp,%rbp
  1067d4:	41 56                	push   %r14
  1067d6:	49 89 fe             	mov    %rdi,%r14
  1067d9:	41 55                	push   %r13
  1067db:	41 bd 01 00 00 00    	mov    $0x1,%r13d
  1067e1:	41 54                	push   %r12
  1067e3:	53                   	push   %rbx
  1067e4:	89 f3                	mov    %esi,%ebx
	int16_t shift;
	int16_t sign;

	if (val < 0) {
  1067e6:	66 85 f6             	test   %si,%si
  1067e9:	79 06                	jns    1067f1 <z_shell_op_cursor_word_move+0x21>
		val = -val;
  1067eb:	f7 db                	neg    %ebx
		sign = -1;
  1067ed:	41 83 cd ff          	or     $0xffffffff,%r13d
		if (((idx == 0U) && (sign < 0)) ||
  1067f1:	45 89 ec             	mov    %r13d,%r12d
  1067f4:	66 41 c1 ec 0f       	shr    $0xf,%r12w
	} else {
		sign = 1;
	}

	while (val--) {
  1067f9:	66 85 db             	test   %bx,%bx
  1067fc:	74 70                	je     10686e <z_shell_op_cursor_word_move+0x9e>
		shift = shift_calc(shell->ctx->cmd_buff,
				   shell->ctx->cmd_buff_pos,
				   shell->ctx->cmd_buff_len, sign);
  1067fe:	49 8b 4e 10          	mov    0x10(%r14),%rcx
	bool found = false;
  106802:	45 31 c0             	xor    %r8d,%r8d
				   shell->ctx->cmd_buff_pos,
  106805:	66 44 8b 49 72       	mov    0x72(%rcx),%r9w
				   shell->ctx->cmd_buff_len, sign);
  10680a:	44 8b 51 70          	mov    0x70(%rcx),%r10d
		shift = shift_calc(shell->ctx->cmd_buff,
  10680e:	48 83 c1 76          	add    $0x76,%rcx
  106812:	44 89 c8             	mov    %r9d,%eax
		idx = pos + ret * sign;
  106815:	89 c7                	mov    %eax,%edi
  106817:	44 29 cf             	sub    %r9d,%edi
		if (((idx == 0U) && (sign < 0)) ||
  10681a:	66 85 c0             	test   %ax,%ax
  10681d:	75 05                	jne    106824 <z_shell_op_cursor_word_move+0x54>
  10681f:	45 84 e4             	test   %r12b,%r12b
  106822:	75 3b                	jne    10685f <z_shell_op_cursor_word_move+0x8f>
  106824:	66 41 39 c2          	cmp    %ax,%r10w
  106828:	75 06                	jne    106830 <z_shell_op_cursor_word_move+0x60>
  10682a:	66 45 85 ed          	test   %r13w,%r13w
  10682e:	7f 2f                	jg     10685f <z_shell_op_cursor_word_move+0x8f>
		if (isalnum((int)str[idx]) != 0) {
  106830:	0f b7 d0             	movzwl %ax,%edx
  106833:	0f be 14 11          	movsbl (%rcx,%rdx,1),%edx
	return (int)((((unsigned)c|32u)-(unsigned)'a') < 26U);
  106837:	89 d6                	mov    %edx,%esi
  106839:	83 ce 20             	or     $0x20,%esi
  10683c:	40 0f be f6          	movsbl %sil,%esi
  106840:	83 ee 61             	sub    $0x61,%esi
				(int)'z') ? (chr - 32) : (chr));
}

static inline int isalnum(int chr)
{
	return (int)(isalpha(chr) || isdigit(chr));
  106843:	83 fe 19             	cmp    $0x19,%esi
  106846:	76 0f                	jbe    106857 <z_shell_op_cursor_word_move+0x87>
	return (int)(((unsigned)(a)-(unsigned)'0') < 10U);
  106848:	83 ea 30             	sub    $0x30,%edx
	return (int)(isalpha(chr) || isdigit(chr));
  10684b:	83 fa 09             	cmp    $0x9,%edx
  10684e:	76 07                	jbe    106857 <z_shell_op_cursor_word_move+0x87>
			if (found) {
  106850:	45 84 c0             	test   %r8b,%r8b
  106853:	74 05                	je     10685a <z_shell_op_cursor_word_move+0x8a>
  106855:	eb 08                	jmp    10685f <z_shell_op_cursor_word_move+0x8f>
			found = true;
  106857:	41 b0 01             	mov    $0x1,%r8b
	while (1) {
  10685a:	44 01 e8             	add    %r13d,%eax
		idx = pos + ret * sign;
  10685d:	eb b6                	jmp    106815 <z_shell_op_cursor_word_move+0x45>
		z_shell_op_cursor_move(shell, sign * shift);
  10685f:	0f bf f7             	movswl %di,%esi
  106862:	4c 89 f7             	mov    %r14,%rdi
  106865:	ff cb                	dec    %ebx
  106867:	e8 de fe ff ff       	callq  10674a <z_shell_op_cursor_move>
  10686c:	eb 8b                	jmp    1067f9 <z_shell_op_cursor_word_move+0x29>
	}
}
  10686e:	5b                   	pop    %rbx
  10686f:	41 5c                	pop    %r12
  106871:	41 5d                	pop    %r13
  106873:	41 5e                	pop    %r14
  106875:	5d                   	pop    %rbp
  106876:	c3                   	retq   

0000000000106877 <z_shell_op_cursor_home_move>:
	z_cursor_restore(shell);
}

void z_shell_op_cursor_home_move(const struct shell *shell)
{
	z_shell_op_cursor_move(shell, -shell->ctx->cmd_buff_pos);
  106877:	48 8b 47 10          	mov    0x10(%rdi),%rax
  10687b:	66 8b 70 72          	mov    0x72(%rax),%si
  10687f:	f7 de                	neg    %esi
  106881:	0f bf f6             	movswl %si,%esi
  106884:	e9 c1 fe ff ff       	jmpq   10674a <z_shell_op_cursor_move>

0000000000106889 <z_shell_op_cursor_end_move>:
}

void z_shell_op_cursor_end_move(const struct shell *shell)
{
	z_shell_op_cursor_move(shell, shell->ctx->cmd_buff_len -
  106889:	48 8b 47 10          	mov    0x10(%rdi),%rax
  10688d:	8b 70 70             	mov    0x70(%rax),%esi
  106890:	66 2b 70 72          	sub    0x72(%rax),%si
  106894:	0f bf f6             	movswl %si,%esi
  106897:	e9 ae fe ff ff       	jmpq   10674a <z_shell_op_cursor_move>

000000000010689c <z_shell_op_left_arrow>:
						shell->ctx->cmd_buff_pos);
}

void z_shell_op_left_arrow(const struct shell *shell)
{
	if (shell->ctx->cmd_buff_pos > 0) {
  10689c:	48 8b 47 10          	mov    0x10(%rdi),%rax
  1068a0:	66 83 78 72 00       	cmpw   $0x0,0x72(%rax)
  1068a5:	74 08                	je     1068af <z_shell_op_left_arrow+0x13>
		z_shell_op_cursor_move(shell, -1);
  1068a7:	83 ce ff             	or     $0xffffffff,%esi
  1068aa:	e9 9b fe ff ff       	jmpq   10674a <z_shell_op_cursor_move>
	}
}
  1068af:	c3                   	retq   

00000000001068b0 <z_shell_op_right_arrow>:

void z_shell_op_right_arrow(const struct shell *shell)
{
	if (shell->ctx->cmd_buff_pos < shell->ctx->cmd_buff_len) {
  1068b0:	48 8b 47 10          	mov    0x10(%rdi),%rax
  1068b4:	8b 50 70             	mov    0x70(%rax),%edx
  1068b7:	66 39 50 72          	cmp    %dx,0x72(%rax)
  1068bb:	73 0a                	jae    1068c7 <z_shell_op_right_arrow+0x17>
		z_shell_op_cursor_move(shell, 1);
  1068bd:	be 01 00 00 00       	mov    $0x1,%esi
  1068c2:	e9 83 fe ff ff       	jmpq   10674a <z_shell_op_cursor_move>
	}
}
  1068c7:	c3                   	retq   

00000000001068c8 <z_shell_op_delete_from_cursor>:
	reprint_from_cursor(shell, --diff, true);
}

void z_shell_op_delete_from_cursor(const struct shell *shell)
{
	shell->ctx->cmd_buff_len = shell->ctx->cmd_buff_pos;
  1068c8:	48 8b 57 10          	mov    0x10(%rdi),%rdx
  1068cc:	0f b7 42 72          	movzwl 0x72(%rdx),%eax
  1068d0:	66 89 42 70          	mov    %ax,0x70(%rdx)
	shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos] = '\0';
  1068d4:	c6 44 02 76 00       	movb   $0x0,0x76(%rdx,%rax,1)

	z_clear_eos(shell);
  1068d9:	48 8b 7f 28          	mov    0x28(%rdi),%rdi
  1068dd:	e9 e8 fc ff ff       	jmpq   1065ca <z_clear_eos.isra.0>

00000000001068e2 <z_shell_cmd_line_erase>:
{
	data_insert(shell, compl, compl_len);
}

void z_shell_cmd_line_erase(const struct shell *shell)
{
  1068e2:	55                   	push   %rbp
  1068e3:	48 89 e5             	mov    %rsp,%rbp
  1068e6:	53                   	push   %rbx
  1068e7:	48 89 fb             	mov    %rdi,%rbx
  1068ea:	50                   	push   %rax
	z_shell_multiline_data_calc(&shell->ctx->vt100_ctx.cons,
				    shell->ctx->cmd_buff_pos,
				    shell->ctx->cmd_buff_len);
  1068eb:	48 8b 7f 10          	mov    0x10(%rdi),%rdi
	z_shell_multiline_data_calc(&shell->ctx->vt100_ctx.cons,
  1068ef:	0f b7 57 70          	movzwl 0x70(%rdi),%edx
  1068f3:	0f b7 77 72          	movzwl 0x72(%rdi),%esi
  1068f7:	48 83 c7 40          	add    $0x40,%rdi
  1068fb:	e8 2b f6 ff ff       	callq  105f2b <z_shell_multiline_data_calc>
	z_shell_op_cursor_horiz_move(shell,
				   -(shell->ctx->vt100_ctx.cons.cur_x - 1));
  106900:	48 8b 43 10          	mov    0x10(%rbx),%rax
	z_shell_op_cursor_horiz_move(shell,
  106904:	be 01 00 00 00       	mov    $0x1,%esi
  106909:	48 89 df             	mov    %rbx,%rdi
				   -(shell->ctx->vt100_ctx.cons.cur_x - 1));
  10690c:	0f b7 40 40          	movzwl 0x40(%rax),%eax
	z_shell_op_cursor_horiz_move(shell,
  106910:	29 c6                	sub    %eax,%esi
  106912:	e8 2a fd ff ff       	callq  106641 <z_shell_op_cursor_horiz_move>
	z_shell_op_cursor_vert_move(shell, shell->ctx->vt100_ctx.cons.cur_y - 1);
  106917:	48 8b 43 10          	mov    0x10(%rbx),%rax
  10691b:	48 89 df             	mov    %rbx,%rdi
  10691e:	0f b7 70 44          	movzwl 0x44(%rax),%esi
  106922:	ff ce                	dec    %esi
  106924:	e8 ef fc ff ff       	callq  106618 <z_shell_op_cursor_vert_move>

	z_clear_eos(shell);
  106929:	48 8b 7b 28          	mov    0x28(%rbx),%rdi
}
  10692d:	5a                   	pop    %rdx
  10692e:	5b                   	pop    %rbx
  10692f:	5d                   	pop    %rbp
	z_clear_eos(shell);
  106930:	e9 95 fc ff ff       	jmpq   1065ca <z_clear_eos.isra.0>

0000000000106935 <z_shell_print_cmd>:
	z_shell_fprintf(shell, SHELL_INFO, "%s", shell->ctx->prompt);
}

void z_shell_print_cmd(const struct shell *shell)
{
	z_shell_raw_fprintf(shell->fprintf_ctx, "%s", shell->ctx->cmd_buff);
  106935:	48 8b 47 10          	mov    0x10(%rdi),%rax
  106939:	48 8b 7f 28          	mov    0x28(%rdi),%rdi
  10693d:	be b7 d5 11 00       	mov    $0x11d5b7,%esi
  106942:	48 8d 50 76          	lea    0x76(%rax),%rdx
  106946:	31 c0                	xor    %eax,%eax
  106948:	e9 eb fb ff ff       	jmpq   106538 <z_shell_raw_fprintf>

000000000010694d <z_shell_write>:
	}
}

void z_shell_write(const struct shell *shell, const void *data,
		 size_t length)
{
  10694d:	55                   	push   %rbp
  10694e:	48 89 e5             	mov    %rsp,%rbp
  106951:	41 56                	push   %r14
  106953:	41 55                	push   %r13
  106955:	49 89 f5             	mov    %rsi,%r13
  106958:	41 54                	push   %r12
  10695a:	49 89 fc             	mov    %rdi,%r12
  10695d:	53                   	push   %rbx
  10695e:	48 89 d3             	mov    %rdx,%rbx
  106961:	48 83 ec 40          	sub    $0x40,%rsp
	__ASSERT_NO_MSG(shell && data);
  106965:	48 85 ff             	test   %rdi,%rdi
  106968:	74 05                	je     10696f <z_shell_write+0x22>
  10696a:	48 85 f6             	test   %rsi,%rsi
  10696d:	75 2a                	jne    106999 <z_shell_write+0x4c>
  10696f:	be 63 dd 11 00       	mov    $0x11dd63,%esi
  106974:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  106979:	b9 87 01 00 00       	mov    $0x187,%ecx
  10697e:	31 c0                	xor    %eax,%eax
  106980:	ba 37 dd 11 00       	mov    $0x11dd37,%edx
  106985:	e8 6e 9c ff ff       	callq  1005f8 <printk>
  10698a:	be 87 01 00 00       	mov    $0x187,%esi
  10698f:	bf 37 dd 11 00       	mov    $0x11dd37,%edi
  106994:	e8 ff c1 ff ff       	callq  102b98 <assert_post_action>
{
  106999:	45 31 f6             	xor    %r14d,%r14d

	size_t offset = 0;
	size_t tmp_cnt;

	while (length) {
  10699c:	48 85 db             	test   %rbx,%rbx
  10699f:	0f 84 2a 01 00 00    	je     106acf <z_shell_write+0x182>
		int err = shell->iface->api->write(shell->iface,
  1069a5:	49 8b 7c 24 08       	mov    0x8(%r12),%rdi
  1069aa:	4b 8d 74 35 00       	lea    0x0(%r13,%r14,1),%rsi
  1069af:	48 8d 4d a8          	lea    -0x58(%rbp),%rcx
  1069b3:	48 89 da             	mov    %rbx,%rdx
  1069b6:	48 8b 07             	mov    (%rdi),%rax
  1069b9:	ff 50 18             	callq  *0x18(%rax)
				&((const uint8_t *) data)[offset], length,
				&tmp_cnt);
		(void)err;
		__ASSERT_NO_MSG(err == 0);
  1069bc:	85 c0                	test   %eax,%eax
  1069be:	74 2a                	je     1069ea <z_shell_write+0x9d>
  1069c0:	be 9b d2 11 00       	mov    $0x11d29b,%esi
  1069c5:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  1069ca:	b9 91 01 00 00       	mov    $0x191,%ecx
  1069cf:	31 c0                	xor    %eax,%eax
  1069d1:	ba 37 dd 11 00       	mov    $0x11dd37,%edx
  1069d6:	e8 1d 9c ff ff       	callq  1005f8 <printk>
  1069db:	be 91 01 00 00       	mov    $0x191,%esi
  1069e0:	bf 37 dd 11 00       	mov    $0x11dd37,%edi
  1069e5:	e8 ae c1 ff ff       	callq  102b98 <assert_post_action>
		__ASSERT_NO_MSG(length >= tmp_cnt);
  1069ea:	48 39 5d a8          	cmp    %rbx,-0x58(%rbp)
  1069ee:	76 2a                	jbe    106a1a <z_shell_write+0xcd>
  1069f0:	be 71 dd 11 00       	mov    $0x11dd71,%esi
  1069f5:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  1069fa:	b9 92 01 00 00       	mov    $0x192,%ecx
  1069ff:	31 c0                	xor    %eax,%eax
  106a01:	ba 37 dd 11 00       	mov    $0x11dd37,%edx
  106a06:	e8 ed 9b ff ff       	callq  1005f8 <printk>
  106a0b:	be 92 01 00 00       	mov    $0x192,%esi
  106a10:	bf 37 dd 11 00       	mov    $0x11dd37,%edi
  106a15:	e8 7e c1 ff ff       	callq  102b98 <assert_post_action>
		offset += tmp_cnt;
  106a1a:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  106a1e:	49 01 c6             	add    %rax,%r14
		length -= tmp_cnt;
  106a21:	48 29 c3             	sub    %rax,%rbx
		if (tmp_cnt == 0 &&
  106a24:	48 85 c0             	test   %rax,%rax
  106a27:	0f 85 6f ff ff ff    	jne    10699c <z_shell_write+0x4f>
		    (shell->ctx->state != SHELL_STATE_PANIC_MODE_ACTIVE)) {
  106a2d:	49 8b 4c 24 10       	mov    0x10(%r12),%rcx
  106a32:	8b 41 08             	mov    0x8(%rcx),%eax
		if (tmp_cnt == 0 &&
  106a35:	83 f8 03             	cmp    $0x3,%eax
  106a38:	0f 84 5e ff ff ff    	je     10699c <z_shell_write+0x4f>
	if (IS_ENABLED(CONFIG_MULTITHREADING) &&
  106a3e:	83 f8 02             	cmp    $0x2,%eax
  106a41:	77 71                	ja     106ab4 <z_shell_write+0x167>
				  &shell->ctx->signals[SHELL_SIGNAL_TXDONE]);
  106a43:	48 81 c1 e0 02 00 00 	add    $0x2e0,%rcx
		k_poll_event_init(&event,
  106a4a:	31 d2                	xor    %edx,%edx
  106a4c:	48 8d 7d b0          	lea    -0x50(%rbp),%rdi
  106a50:	be 01 00 00 00       	mov    $0x1,%esi
  106a55:	e8 d1 e3 00 00       	callq  114e2b <k_poll_event_init>
static inline int k_poll(struct k_poll_event * events, int num_events, k_timeout_t timeout)
  106a5a:	c7 45 a4 01 00 00 00 	movl   $0x1,-0x5c(%rbp)
	__asm__ volatile ("mov %%cs, %[cs_val]" : [cs_val] "=r" (cs));
  106a61:	8c c8                	mov    %cs,%eax
	if (z_syscall_trap()) {
  106a63:	a8 03                	test   $0x3,%al
  106a65:	74 15                	je     106a7c <z_shell_write+0x12f>
	register uintptr_t rsi __asm__("%rsi") = arg2;
  106a67:	48 8b 75 a4          	mov    -0x5c(%rbp),%rsi
	register uintptr_t rax __asm__("%rax") = call_id;
  106a6b:	b8 9f 00 00 00       	mov    $0x9f,%eax
	register uintptr_t rdi __asm__("%rdi") = arg1;
  106a70:	48 8d 7d b0          	lea    -0x50(%rbp),%rdi
	register uintptr_t rdx __asm__("%rdx") = arg3;
  106a74:	48 83 ca ff          	or     $0xffffffffffffffff,%rdx
	__asm__ volatile("syscall\n\t"
  106a78:	0f 05                	syscall 
		return (int) arch_syscall_invoke3(*(uintptr_t *)&events, *(uintptr_t *)&num_events, *(uintptr_t *)&timeout, K_SYSCALL_K_POLL);
  106a7a:	eb 10                	jmp    106a8c <z_shell_write+0x13f>
	return z_impl_k_poll(events, num_events, timeout);
  106a7c:	8b 75 a4             	mov    -0x5c(%rbp),%esi
  106a7f:	48 83 ca ff          	or     $0xffffffffffffffff,%rdx
  106a83:	48 8d 7d b0          	lea    -0x50(%rbp),%rdi
  106a87:	e8 a1 e4 00 00       	callq  114f2d <z_impl_k_poll>
		k_poll_signal_reset(&shell->ctx->signals[SHELL_SIGNAL_TXDONE]);
  106a8c:	49 8b 44 24 10       	mov    0x10(%r12),%rax
  106a91:	48 8d b8 e0 02 00 00 	lea    0x2e0(%rax),%rdi
	__asm__ volatile ("mov %%cs, %[cs_val]" : [cs_val] "=r" (cs));
  106a98:	8c c8                	mov    %cs,%eax
	if (z_syscall_trap()) {
  106a9a:	a8 03                	test   $0x3,%al
  106a9c:	74 0c                	je     106aaa <z_shell_write+0x15d>
	register uintptr_t rax __asm__("%rax") = call_id;
  106a9e:	b8 a3 00 00 00       	mov    $0xa3,%eax
	__asm__ volatile("syscall\n\t"
  106aa3:	0f 05                	syscall 
	return rax;
  106aa5:	e9 f2 fe ff ff       	jmpq   10699c <z_shell_write+0x4f>
	z_impl_k_poll_signal_reset(sig);
  106aaa:	e8 fb eb 00 00       	callq  1156aa <z_impl_k_poll_signal_reset>
  106aaf:	e9 e8 fe ff ff       	jmpq   10699c <z_shell_write+0x4f>
	return shell->ctx->internal.flags.tx_rdy == 1;
  106ab4:	48 8b 81 90 02 00 00 	mov    0x290(%rcx),%rax
		while (!z_flag_tx_rdy_get(shell)) {
  106abb:	48 0f ba e0 25       	bt     $0x25,%rax
  106ac0:	73 f2                	jae    106ab4 <z_shell_write+0x167>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
  106ac2:	f0 83 a1 94 02 00 00 	lock andl $0xffffffdf,0x294(%rcx)
  106ac9:	df 
	return ret;
  106aca:	e9 cd fe ff ff       	jmpq   10699c <z_shell_write+0x4f>
			shell_pend_on_txdone(shell);
		}
	}
}
  106acf:	48 83 c4 40          	add    $0x40,%rsp
  106ad3:	5b                   	pop    %rbx
  106ad4:	41 5c                	pop    %r12
  106ad6:	41 5d                	pop    %r13
  106ad8:	41 5e                	pop    %r14
  106ada:	5d                   	pop    %rbp
  106adb:	c3                   	retq   

0000000000106adc <z_shell_print_stream>:

/* Function shall be only used by the fprintf module. */
void z_shell_print_stream(const void *user_ctx, const char *data, size_t len)
{
	z_shell_write((const struct shell *) user_ctx, data, len);
  106adc:	e9 6c fe ff ff       	jmpq   10694d <z_shell_write>

0000000000106ae1 <z_shell_vt100_color_set>:

void z_shell_vt100_color_set(const struct shell *shell,
			     enum shell_vt100_color color)
{

	if (shell->ctx->vt100_ctx.col.col == color) {
  106ae1:	48 8b 47 10          	mov    0x10(%rdi),%rax
  106ae5:	39 70 50             	cmp    %esi,0x50(%rax)
  106ae8:	74 4e                	je     106b38 <z_shell_vt100_color_set+0x57>
		return;
	}

	shell->ctx->vt100_ctx.col.col = color;
  106aea:	89 70 50             	mov    %esi,0x50(%rax)

	if (color != SHELL_NORMAL) {
  106aed:	48 8b 7f 28          	mov    0x28(%rdi),%rdi
  106af1:	85 f6                	test   %esi,%esi
  106af3:	74 32                	je     106b27 <z_shell_vt100_color_set+0x46>
{
  106af5:	55                   	push   %rbp

		uint8_t cmd[] = SHELL_VT100_COLOR(color - 1);
  106af6:	83 c6 2f             	add    $0x2f,%esi

		z_shell_raw_fprintf(shell->fprintf_ctx, "%s", cmd);
  106af9:	31 c0                	xor    %eax,%eax
{
  106afb:	48 89 e5             	mov    %rsp,%rbp
  106afe:	48 83 ec 10          	sub    $0x10,%rsp
		z_shell_raw_fprintf(shell->fprintf_ctx, "%s", cmd);
  106b02:	48 8d 55 f8          	lea    -0x8(%rbp),%rdx
		uint8_t cmd[] = SHELL_VT100_COLOR(color - 1);
  106b06:	40 88 75 fd          	mov    %sil,-0x3(%rbp)
		z_shell_raw_fprintf(shell->fprintf_ctx, "%s", cmd);
  106b0a:	be b7 d5 11 00       	mov    $0x11d5b7,%esi
		uint8_t cmd[] = SHELL_VT100_COLOR(color - 1);
  106b0f:	c7 45 f8 1b 5b 31 3b 	movl   $0x3b315b1b,-0x8(%rbp)
  106b16:	c6 45 fc 33          	movb   $0x33,-0x4(%rbp)
  106b1a:	66 c7 45 fe 6d 00    	movw   $0x6d,-0x2(%rbp)
		z_shell_raw_fprintf(shell->fprintf_ctx, "%s", cmd);
  106b20:	e8 13 fa ff ff       	callq  106538 <z_shell_raw_fprintf>
	} else {
		static const uint8_t cmd[] = SHELL_VT100_MODESOFF;

		z_shell_raw_fprintf(shell->fprintf_ctx, "%s", cmd);
	}
}
  106b25:	c9                   	leaveq 
  106b26:	c3                   	retq   
		z_shell_raw_fprintf(shell->fprintf_ctx, "%s", cmd);
  106b27:	ba ca dd 11 00       	mov    $0x11ddca,%edx
  106b2c:	be b7 d5 11 00       	mov    $0x11d5b7,%esi
  106b31:	31 c0                	xor    %eax,%eax
  106b33:	e9 00 fa ff ff       	jmpq   106538 <z_shell_raw_fprintf>
  106b38:	c3                   	retq   

0000000000106b39 <z_shell_vt100_colors_restore>:

void z_shell_vt100_colors_restore(const struct shell *shell,
				       const struct shell_vt100_colors *color)
{
  106b39:	55                   	push   %rbp
  106b3a:	48 89 e5             	mov    %rsp,%rbp
  106b3d:	41 54                	push   %r12
  106b3f:	49 89 f4             	mov    %rsi,%r12
  106b42:	53                   	push   %rbx
  106b43:	48 89 fb             	mov    %rdi,%rbx
  106b46:	48 83 ec 10          	sub    $0x10,%rsp
	z_shell_vt100_color_set(shell, color->col);
  106b4a:	8b 36                	mov    (%rsi),%esi
  106b4c:	e8 90 ff ff ff       	callq  106ae1 <z_shell_vt100_color_set>
	vt100_bgcolor_set(shell, color->bgcol);
  106b51:	41 8b 44 24 04       	mov    0x4(%r12),%eax
	if ((bgcolor == SHELL_NORMAL) ||
  106b56:	85 c0                	test   %eax,%eax
  106b58:	74 36                	je     106b90 <z_shell_vt100_colors_restore+0x57>
	    (shell->ctx->vt100_ctx.col.bgcol == bgcolor)) {
  106b5a:	48 8b 53 10          	mov    0x10(%rbx),%rdx
	if ((bgcolor == SHELL_NORMAL) ||
  106b5e:	3b 42 54             	cmp    0x54(%rdx),%eax
  106b61:	74 2d                	je     106b90 <z_shell_vt100_colors_restore+0x57>
	shell->ctx->vt100_ctx.col.bgcol = bgcolor;
  106b63:	89 42 54             	mov    %eax,0x54(%rdx)
	z_shell_raw_fprintf(shell->fprintf_ctx, "%s", cmd);
  106b66:	48 8b 7b 28          	mov    0x28(%rbx),%rdi
	uint8_t cmd[] = SHELL_VT100_BGCOLOR(bgcolor - 1);
  106b6a:	8d 48 2f             	lea    0x2f(%rax),%ecx
	z_shell_raw_fprintf(shell->fprintf_ctx, "%s", cmd);
  106b6d:	48 8d 55 ea          	lea    -0x16(%rbp),%rdx
  106b71:	be b7 d5 11 00       	mov    $0x11d5b7,%esi
  106b76:	31 c0                	xor    %eax,%eax
	uint8_t cmd[] = SHELL_VT100_BGCOLOR(bgcolor - 1);
  106b78:	66 c7 45 ea 1b 5b    	movw   $0x5b1b,-0x16(%rbp)
  106b7e:	c6 45 ec 34          	movb   $0x34,-0x14(%rbp)
  106b82:	88 4d ed             	mov    %cl,-0x13(%rbp)
  106b85:	66 c7 45 ee 6d 00    	movw   $0x6d,-0x12(%rbp)
	z_shell_raw_fprintf(shell->fprintf_ctx, "%s", cmd);
  106b8b:	e8 a8 f9 ff ff       	callq  106538 <z_shell_raw_fprintf>
}
  106b90:	58                   	pop    %rax
  106b91:	5a                   	pop    %rdx
  106b92:	5b                   	pop    %rbx
  106b93:	41 5c                	pop    %r12
  106b95:	5d                   	pop    %rbp
  106b96:	c3                   	retq   

0000000000106b97 <z_shell_vfprintf>:

void z_shell_vfprintf(const struct shell *shell, enum shell_vt100_color color,
		      const char *fmt, va_list args)
{
  106b97:	55                   	push   %rbp
  106b98:	48 89 e5             	mov    %rsp,%rbp
  106b9b:	41 57                	push   %r15
  106b9d:	41 89 f7             	mov    %esi,%r15d
  106ba0:	41 56                	push   %r14
  106ba2:	49 89 ce             	mov    %rcx,%r14
  106ba5:	41 55                	push   %r13
  106ba7:	49 89 d5             	mov    %rdx,%r13
  106baa:	41 54                	push   %r12
  106bac:	49 89 fc             	mov    %rdi,%r12
  106baf:	48 83 ec 10          	sub    $0x10,%rsp
	if (IS_ENABLED(CONFIG_SHELL_VT100_COLORS) &&
	    shell->ctx->internal.flags.use_colors &&
  106bb3:	48 8b 77 10          	mov    0x10(%rdi),%rsi
  106bb7:	48 8b 86 90 02 00 00 	mov    0x290(%rsi),%rax
	if (IS_ENABLED(CONFIG_SHELL_VT100_COLORS) &&
  106bbe:	48 0f ba e0 21       	bt     $0x21,%rax
  106bc3:	73 4b                	jae    106c10 <z_shell_vfprintf+0x79>
	    shell->ctx->internal.flags.use_colors &&
  106bc5:	44 39 7e 50          	cmp    %r15d,0x50(%rsi)
  106bc9:	74 45                	je     106c10 <z_shell_vfprintf+0x79>
			     enum shell_vt100_color color);

static inline void z_shell_vt100_colors_store(const struct shell *shell,
					      struct shell_vt100_colors *color)
{
	memcpy(color, &shell->ctx->vt100_ctx.col, sizeof(*color));
  106bcb:	ba 08 00 00 00       	mov    $0x8,%edx
  106bd0:	48 8d 7d d8          	lea    -0x28(%rbp),%rdi
  106bd4:	48 83 c6 50          	add    $0x50,%rsi
  106bd8:	e8 bb 34 00 00       	callq  10a098 <memcpy>
	    (color != shell->ctx->vt100_ctx.col.col)) {
		struct shell_vt100_colors col;

		z_shell_vt100_colors_store(shell, &col);
		z_shell_vt100_color_set(shell, color);
  106bdd:	44 89 fe             	mov    %r15d,%esi
  106be0:	4c 89 e7             	mov    %r12,%rdi
  106be3:	e8 f9 fe ff ff       	callq  106ae1 <z_shell_vt100_color_set>

		z_shell_fprintf_fmt(shell->fprintf_ctx, fmt, args);
  106be8:	49 8b 7c 24 28       	mov    0x28(%r12),%rdi
  106bed:	4c 89 f2             	mov    %r14,%rdx
  106bf0:	4c 89 ee             	mov    %r13,%rsi
  106bf3:	e8 49 f2 ff ff       	callq  105e41 <z_shell_fprintf_fmt>

		z_shell_vt100_colors_restore(shell, &col);
  106bf8:	48 8d 75 d8          	lea    -0x28(%rbp),%rsi
  106bfc:	4c 89 e7             	mov    %r12,%rdi
  106bff:	e8 35 ff ff ff       	callq  106b39 <z_shell_vt100_colors_restore>
	} else {
		z_shell_fprintf_fmt(shell->fprintf_ctx, fmt, args);
	}
}
  106c04:	5e                   	pop    %rsi
  106c05:	5f                   	pop    %rdi
  106c06:	41 5c                	pop    %r12
  106c08:	41 5d                	pop    %r13
  106c0a:	41 5e                	pop    %r14
  106c0c:	41 5f                	pop    %r15
  106c0e:	5d                   	pop    %rbp
  106c0f:	c3                   	retq   
		z_shell_fprintf_fmt(shell->fprintf_ctx, fmt, args);
  106c10:	49 8b 7c 24 28       	mov    0x28(%r12),%rdi
  106c15:	4c 89 f2             	mov    %r14,%rdx
}
  106c18:	58                   	pop    %rax
		z_shell_fprintf_fmt(shell->fprintf_ctx, fmt, args);
  106c19:	4c 89 ee             	mov    %r13,%rsi
}
  106c1c:	59                   	pop    %rcx
  106c1d:	41 5c                	pop    %r12
  106c1f:	41 5d                	pop    %r13
  106c21:	41 5e                	pop    %r14
  106c23:	41 5f                	pop    %r15
  106c25:	5d                   	pop    %rbp
		z_shell_fprintf_fmt(shell->fprintf_ctx, fmt, args);
  106c26:	e9 16 f2 ff ff       	jmpq   105e41 <z_shell_fprintf_fmt>

0000000000106c2b <z_shell_fprintf>:

void z_shell_fprintf(const struct shell *sh,
		     enum shell_vt100_color color,
		     const char *fmt, ...)
{
  106c2b:	55                   	push   %rbp
  106c2c:	48 89 e5             	mov    %rsp,%rbp
  106c2f:	41 56                	push   %r14
  106c31:	41 89 f6             	mov    %esi,%r14d
  106c34:	41 55                	push   %r13
  106c36:	49 89 d5             	mov    %rdx,%r13
  106c39:	41 54                	push   %r12
  106c3b:	49 89 fc             	mov    %rdi,%r12
  106c3e:	48 81 ec d8 00 00 00 	sub    $0xd8,%rsp
  106c45:	48 89 8d 48 ff ff ff 	mov    %rcx,-0xb8(%rbp)
  106c4c:	4c 89 85 50 ff ff ff 	mov    %r8,-0xb0(%rbp)
  106c53:	4c 89 8d 58 ff ff ff 	mov    %r9,-0xa8(%rbp)
  106c5a:	84 c0                	test   %al,%al
  106c5c:	74 26                	je     106c84 <z_shell_fprintf+0x59>
  106c5e:	0f 29 85 60 ff ff ff 	movaps %xmm0,-0xa0(%rbp)
  106c65:	0f 29 8d 70 ff ff ff 	movaps %xmm1,-0x90(%rbp)
  106c6c:	0f 29 55 80          	movaps %xmm2,-0x80(%rbp)
  106c70:	0f 29 5d 90          	movaps %xmm3,-0x70(%rbp)
  106c74:	0f 29 65 a0          	movaps %xmm4,-0x60(%rbp)
  106c78:	0f 29 6d b0          	movaps %xmm5,-0x50(%rbp)
  106c7c:	0f 29 75 c0          	movaps %xmm6,-0x40(%rbp)
  106c80:	0f 29 7d d0          	movaps %xmm7,-0x30(%rbp)
	__ASSERT_NO_MSG(sh);
  106c84:	4d 85 e4             	test   %r12,%r12
  106c87:	75 2a                	jne    106cb3 <z_shell_fprintf+0x88>
  106c89:	be 83 dd 11 00       	mov    $0x11dd83,%esi
  106c8e:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  106c93:	b9 e6 01 00 00       	mov    $0x1e6,%ecx
  106c98:	31 c0                	xor    %eax,%eax
  106c9a:	ba 37 dd 11 00       	mov    $0x11dd37,%edx
  106c9f:	e8 54 99 ff ff       	callq  1005f8 <printk>
  106ca4:	be e6 01 00 00       	mov    $0x1e6,%esi
  106ca9:	bf 37 dd 11 00       	mov    $0x11dd37,%edi
  106cae:	e8 e5 be ff ff       	callq  102b98 <assert_post_action>
	__ASSERT_NO_MSG(sh->ctx);
  106cb3:	49 83 7c 24 10 00    	cmpq   $0x0,0x10(%r12)
  106cb9:	75 2a                	jne    106ce5 <z_shell_fprintf+0xba>
  106cbb:	be 86 dd 11 00       	mov    $0x11dd86,%esi
  106cc0:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  106cc5:	b9 e7 01 00 00       	mov    $0x1e7,%ecx
  106cca:	31 c0                	xor    %eax,%eax
  106ccc:	ba 37 dd 11 00       	mov    $0x11dd37,%edx
  106cd1:	e8 22 99 ff ff       	callq  1005f8 <printk>
  106cd6:	be e7 01 00 00       	mov    $0x1e7,%esi
  106cdb:	bf 37 dd 11 00       	mov    $0x11dd37,%edi
  106ce0:	e8 b3 be ff ff       	callq  102b98 <assert_post_action>
	__ASSERT_NO_MSG(sh->fprintf_ctx);
  106ce5:	49 83 7c 24 28 00    	cmpq   $0x0,0x28(%r12)
  106ceb:	75 2a                	jne    106d17 <z_shell_fprintf+0xec>
  106ced:	be 8e dd 11 00       	mov    $0x11dd8e,%esi
  106cf2:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  106cf7:	b9 e8 01 00 00       	mov    $0x1e8,%ecx
  106cfc:	31 c0                	xor    %eax,%eax
  106cfe:	ba 37 dd 11 00       	mov    $0x11dd37,%edx
  106d03:	e8 f0 98 ff ff       	callq  1005f8 <printk>
  106d08:	be e8 01 00 00       	mov    $0x1e8,%esi
  106d0d:	bf 37 dd 11 00       	mov    $0x11dd37,%edi
  106d12:	e8 81 be ff ff       	callq  102b98 <assert_post_action>
	__ASSERT_NO_MSG(fmt);
  106d17:	4d 85 ed             	test   %r13,%r13
  106d1a:	75 2a                	jne    106d46 <z_shell_fprintf+0x11b>
  106d1c:	be 19 db 11 00       	mov    $0x11db19,%esi
  106d21:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  106d26:	b9 e9 01 00 00       	mov    $0x1e9,%ecx
  106d2b:	31 c0                	xor    %eax,%eax
  106d2d:	ba 37 dd 11 00       	mov    $0x11dd37,%edx
  106d32:	e8 c1 98 ff ff       	callq  1005f8 <printk>
  106d37:	be e9 01 00 00       	mov    $0x1e9,%esi
  106d3c:	bf 37 dd 11 00       	mov    $0x11dd37,%edi
  106d41:	e8 52 be ff ff       	callq  102b98 <assert_post_action>
	return sh->ctx->internal.flags.panic_mode == 1;
  106d46:	49 8b 44 24 10       	mov    0x10(%r12),%rax
  106d4b:	48 8b 80 90 02 00 00 	mov    0x290(%rax),%rax
	__ASSERT(z_flag_panic_mode_get(sh) || !k_is_in_isr(),
  106d52:	48 0f ba e0 32       	bt     $0x32,%rax
  106d57:	72 3f                	jb     106d98 <z_shell_fprintf+0x16d>
  106d59:	e8 43 68 00 00       	callq  10d5a1 <k_is_in_isr>
  106d5e:	84 c0                	test   %al,%al
  106d60:	74 36                	je     106d98 <z_shell_fprintf+0x16d>
  106d62:	be 9e dd 11 00       	mov    $0x11dd9e,%esi
  106d67:	b9 ea 01 00 00       	mov    $0x1ea,%ecx
  106d6c:	ba 37 dd 11 00       	mov    $0x11dd37,%edx
  106d71:	31 c0                	xor    %eax,%eax
  106d73:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  106d78:	e8 7b 98 ff ff       	callq  1005f8 <printk>
  106d7d:	bf 99 da 11 00       	mov    $0x11da99,%edi
  106d82:	31 c0                	xor    %eax,%eax
  106d84:	e8 6f 98 ff ff       	callq  1005f8 <printk>
  106d89:	be ea 01 00 00       	mov    $0x1ea,%esi
  106d8e:	bf 37 dd 11 00       	mov    $0x11dd37,%edi
  106d93:	e8 00 be ff ff       	callq  102b98 <assert_post_action>
		 "Thread context required.");

	va_list args;

	va_start(args, fmt);
  106d98:	48 8d 45 10          	lea    0x10(%rbp),%rax
	z_shell_vfprintf(sh, color, fmt, args);
  106d9c:	4c 89 ea             	mov    %r13,%rdx
  106d9f:	44 89 f6             	mov    %r14d,%esi
  106da2:	4c 89 e7             	mov    %r12,%rdi
	va_start(args, fmt);
  106da5:	48 89 85 20 ff ff ff 	mov    %rax,-0xe0(%rbp)
	z_shell_vfprintf(sh, color, fmt, args);
  106dac:	48 8d 8d 18 ff ff ff 	lea    -0xe8(%rbp),%rcx
	va_start(args, fmt);
  106db3:	48 8d 85 30 ff ff ff 	lea    -0xd0(%rbp),%rax
  106dba:	c7 85 18 ff ff ff 18 	movl   $0x18,-0xe8(%rbp)
  106dc1:	00 00 00 
  106dc4:	c7 85 1c ff ff ff 30 	movl   $0x30,-0xe4(%rbp)
  106dcb:	00 00 00 
  106dce:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)
	z_shell_vfprintf(sh, color, fmt, args);
  106dd5:	e8 bd fd ff ff       	callq  106b97 <z_shell_vfprintf>
	va_end(args);
}
  106dda:	48 81 c4 d8 00 00 00 	add    $0xd8,%rsp
  106de1:	41 5c                	pop    %r12
  106de3:	41 5d                	pop    %r13
  106de5:	41 5e                	pop    %r14
  106de7:	5d                   	pop    %rbp
  106de8:	c3                   	retq   

0000000000106de9 <z_shell_op_word_remove>:
	char *str = &shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos - 1];
  106de9:	48 8b 47 10          	mov    0x10(%rdi),%rax
  106ded:	0f b7 48 72          	movzwl 0x72(%rax),%ecx
	if ((shell->ctx->cmd_buff_len == 0) ||
  106df1:	0f b7 50 70          	movzwl 0x70(%rax),%edx
  106df5:	66 85 c9             	test   %cx,%cx
  106df8:	0f 84 d4 00 00 00    	je     106ed2 <z_shell_op_word_remove+0xe9>
  106dfe:	66 85 d2             	test   %dx,%dx
  106e01:	0f 84 cb 00 00 00    	je     106ed2 <z_shell_op_word_remove+0xe9>
{
  106e07:	55                   	push   %rbp
  106e08:	48 89 e5             	mov    %rsp,%rbp
  106e0b:	41 55                	push   %r13
  106e0d:	41 54                	push   %r12
  106e0f:	49 89 fc             	mov    %rdi,%r12
  106e12:	53                   	push   %rbx
  106e13:	56                   	push   %rsi
	char *str = &shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos - 1];
  106e14:	48 8d 74 08 75       	lea    0x75(%rax,%rcx,1),%rsi
	char *str_start = &shell->ctx->cmd_buff[0];
  106e19:	48 8d 48 76          	lea    0x76(%rax),%rcx
	char *str = &shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos - 1];
  106e1d:	48 89 f0             	mov    %rsi,%rax
  106e20:	89 f3                	mov    %esi,%ebx
  106e22:	29 c3                	sub    %eax,%ebx
	while ((str >= str_start) && (*str == ' ')) {
  106e24:	48 39 c8             	cmp    %rcx,%rax
  106e27:	72 19                	jb     106e42 <z_shell_op_word_remove+0x59>
  106e29:	80 38 20             	cmpb   $0x20,(%rax)
  106e2c:	75 0f                	jne    106e3d <z_shell_op_word_remove+0x54>
		--str;
  106e2e:	48 ff c8             	dec    %rax
  106e31:	eb ed                	jmp    106e20 <z_shell_op_word_remove+0x37>
		--str;
  106e33:	48 ff c8             	dec    %rax
		++chars_to_delete;
  106e36:	ff c3                	inc    %ebx
	while ((str >= str_start) && (*str != ' ')) {
  106e38:	48 39 c1             	cmp    %rax,%rcx
  106e3b:	77 05                	ja     106e42 <z_shell_op_word_remove+0x59>
  106e3d:	80 38 20             	cmpb   $0x20,(%rax)
  106e40:	75 f1                	jne    106e33 <z_shell_op_word_remove+0x4a>
		shell->ctx->cmd_buff_len - chars_to_delete);
  106e42:	0f b7 cb             	movzwl %bx,%ecx
	memmove(str + 1, str + 1 + chars_to_delete,
  106e45:	4c 8d 68 01          	lea    0x1(%rax),%r13
		shell->ctx->cmd_buff_len - chars_to_delete);
  106e49:	29 ca                	sub    %ecx,%edx
	memmove(str + 1, str + 1 + chars_to_delete,
  106e4b:	0f b7 cb             	movzwl %bx,%ecx
  106e4e:	4c 89 ef             	mov    %r13,%rdi
  106e51:	48 8d 74 08 01       	lea    0x1(%rax,%rcx,1),%rsi
  106e56:	48 63 d2             	movslq %edx,%rdx
  106e59:	e8 04 32 00 00       	callq  10a062 <memmove>
	shell->ctx->cmd_buff_len -= chars_to_delete;
  106e5e:	49 8b 54 24 10       	mov    0x10(%r12),%rdx
	z_shell_op_cursor_move(shell, -chars_to_delete);
  106e63:	4c 89 e7             	mov    %r12,%rdi
	shell->ctx->cmd_buff_len -= chars_to_delete;
  106e66:	8b 42 70             	mov    0x70(%rdx),%eax
  106e69:	29 d8                	sub    %ebx,%eax
	z_shell_op_cursor_move(shell, -chars_to_delete);
  106e6b:	f7 db                	neg    %ebx
	shell->ctx->cmd_buff_len -= chars_to_delete;
  106e6d:	66 89 42 70          	mov    %ax,0x70(%rdx)
	shell->ctx->cmd_buff[shell->ctx->cmd_buff_len] = '\0';
  106e71:	0f b7 c0             	movzwl %ax,%eax
	z_shell_op_cursor_move(shell, -chars_to_delete);
  106e74:	0f bf f3             	movswl %bx,%esi
	shell->ctx->cmd_buff[shell->ctx->cmd_buff_len] = '\0';
  106e77:	c6 44 02 76 00       	movb   $0x0,0x76(%rdx,%rax,1)
	z_shell_op_cursor_move(shell, -chars_to_delete);
  106e7c:	e8 c9 f8 ff ff       	callq  10674a <z_shell_op_cursor_move>
	Z_SHELL_VT100_CMD(shell, SHELL_VT100_SAVECURSOR);
  106e81:	49 8b 7c 24 28       	mov    0x28(%r12),%rdi
  106e86:	ba d5 dd 11 00       	mov    $0x11ddd5,%edx
  106e8b:	31 c0                	xor    %eax,%eax
  106e8d:	be b7 d5 11 00       	mov    $0x11d5b7,%esi
  106e92:	e8 a1 f6 ff ff       	callq  106538 <z_shell_raw_fprintf>
	z_shell_fprintf(shell, SHELL_NORMAL, "%s", str + 1);
  106e97:	4c 89 e9             	mov    %r13,%rcx
  106e9a:	ba b7 d5 11 00       	mov    $0x11d5b7,%edx
  106e9f:	31 f6                	xor    %esi,%esi
  106ea1:	4c 89 e7             	mov    %r12,%rdi
  106ea4:	31 c0                	xor    %eax,%eax
  106ea6:	e8 80 fd ff ff       	callq  106c2b <z_shell_fprintf>
	z_clear_eos(shell);
  106eab:	49 8b 7c 24 28       	mov    0x28(%r12),%rdi
  106eb0:	e8 15 f7 ff ff       	callq  1065ca <z_clear_eos.isra.0>
	Z_SHELL_VT100_CMD(shell, SHELL_VT100_RESTORECURSOR);
  106eb5:	49 8b 7c 24 28       	mov    0x28(%r12),%rdi
  106eba:	ba ce dd 11 00       	mov    $0x11ddce,%edx
}
  106ebf:	59                   	pop    %rcx
  106ec0:	be b7 d5 11 00       	mov    $0x11d5b7,%esi
  106ec5:	5b                   	pop    %rbx
  106ec6:	31 c0                	xor    %eax,%eax
  106ec8:	41 5c                	pop    %r12
  106eca:	41 5d                	pop    %r13
  106ecc:	5d                   	pop    %rbp
  106ecd:	e9 66 f6 ff ff       	jmpq   106538 <z_shell_raw_fprintf>
  106ed2:	c3                   	retq   

0000000000106ed3 <reprint_from_cursor>:
{
  106ed3:	55                   	push   %rbp
  106ed4:	48 89 e5             	mov    %rsp,%rbp
  106ed7:	41 56                	push   %r14
  106ed9:	41 89 d6             	mov    %edx,%r14d
  106edc:	41 55                	push   %r13
  106ede:	41 54                	push   %r12
  106ee0:	49 89 fc             	mov    %rdi,%r12
  106ee3:	53                   	push   %rbx
  106ee4:	89 f3                	mov    %esi,%ebx
	if (data_removed) {
  106ee6:	84 d2                	test   %dl,%dl
  106ee8:	74 09                	je     106ef3 <reprint_from_cursor+0x20>
		z_clear_eos(shell);
  106eea:	48 8b 7f 28          	mov    0x28(%rdi),%rdi
  106eee:	e8 d7 f6 ff ff       	callq  1065ca <z_clear_eos.isra.0>
	return shell->ctx->internal.flags.obscure == 1;
  106ef3:	49 8b 44 24 10       	mov    0x10(%r12),%rax
  106ef8:	48 8b 90 90 02 00 00 	mov    0x290(%rax),%rdx
		int len = strlen(&shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos]);
  106eff:	0f b7 48 72          	movzwl 0x72(%rax),%ecx
	if (z_flag_obscure_get(shell)) {
  106f03:	48 0f ba e2 23       	bt     $0x23,%rdx
		int len = strlen(&shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos]);
  106f08:	48 8d 4c 08 76       	lea    0x76(%rax,%rcx,1),%rcx
	if (z_flag_obscure_get(shell)) {
  106f0d:	73 26                	jae    106f35 <reprint_from_cursor+0x62>
		int len = strlen(&shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos]);
  106f0f:	48 89 cf             	mov    %rcx,%rdi
  106f12:	e8 c5 30 00 00       	callq  109fdc <strlen>
		while (len--) {
  106f17:	41 89 c5             	mov    %eax,%r13d
  106f1a:	45 85 ed             	test   %r13d,%r13d
  106f1d:	74 27                	je     106f46 <reprint_from_cursor+0x73>
			z_shell_raw_fprintf(shell->fprintf_ctx, "*");
  106f1f:	49 8b 7c 24 28       	mov    0x28(%r12),%rdi
  106f24:	be d6 d3 11 00       	mov    $0x11d3d6,%esi
  106f29:	31 c0                	xor    %eax,%eax
  106f2b:	41 ff cd             	dec    %r13d
  106f2e:	e8 05 f6 ff ff       	callq  106538 <z_shell_raw_fprintf>
  106f33:	eb e5                	jmp    106f1a <reprint_from_cursor+0x47>
		z_shell_fprintf(shell, SHELL_NORMAL, "%s",
  106f35:	ba b7 d5 11 00       	mov    $0x11d5b7,%edx
  106f3a:	31 f6                	xor    %esi,%esi
  106f3c:	4c 89 e7             	mov    %r12,%rdi
  106f3f:	31 c0                	xor    %eax,%eax
  106f41:	e8 e5 fc ff ff       	callq  106c2b <z_shell_fprintf>
	shell->ctx->cmd_buff_pos = shell->ctx->cmd_buff_len;
  106f46:	49 8b 44 24 10       	mov    0x10(%r12),%rax
	if (full_line_cmd(shell)) {
  106f4b:	4c 89 e7             	mov    %r12,%rdi
	shell->ctx->cmd_buff_pos = shell->ctx->cmd_buff_len;
  106f4e:	8b 50 70             	mov    0x70(%rax),%edx
  106f51:	66 89 50 72          	mov    %dx,0x72(%rax)
	if (full_line_cmd(shell)) {
  106f55:	e8 81 f6 ff ff       	callq  1065db <full_line_cmd>
  106f5a:	84 c0                	test   %al,%al
  106f5c:	74 14                	je     106f72 <reprint_from_cursor+0x9f>
		if (((data_removed) && (diff > 0)) || (!data_removed)) {
  106f5e:	66 85 db             	test   %bx,%bx
  106f61:	75 05                	jne    106f68 <reprint_from_cursor+0x95>
  106f63:	45 84 f6             	test   %r14b,%r14b
  106f66:	75 0a                	jne    106f72 <reprint_from_cursor+0x9f>
			z_cursor_next_line_move(shell);
  106f68:	49 8b 7c 24 28       	mov    0x28(%r12),%rdi
  106f6d:	e8 4c f6 ff ff       	callq  1065be <z_cursor_next_line_move.isra.0>
	z_shell_op_cursor_move(shell, -diff);
  106f72:	f7 db                	neg    %ebx
  106f74:	4c 89 e7             	mov    %r12,%rdi
  106f77:	0f bf f3             	movswl %bx,%esi
}
  106f7a:	5b                   	pop    %rbx
  106f7b:	41 5c                	pop    %r12
  106f7d:	41 5d                	pop    %r13
  106f7f:	41 5e                	pop    %r14
  106f81:	5d                   	pop    %rbp
	z_shell_op_cursor_move(shell, -diff);
  106f82:	e9 c3 f7 ff ff       	jmpq   10674a <z_shell_op_cursor_move>

0000000000106f87 <data_insert>:
{
  106f87:	55                   	push   %rbp
  106f88:	48 89 e5             	mov    %rsp,%rbp
  106f8b:	41 57                	push   %r15
  106f8d:	41 56                	push   %r14
  106f8f:	41 55                	push   %r13
  106f91:	41 54                	push   %r12
  106f93:	41 89 d4             	mov    %edx,%r12d
  106f96:	53                   	push   %rbx
	if ((shell->ctx->cmd_buff_len + len) >= CONFIG_SHELL_CMD_BUFF_SIZE) {
  106f97:	41 0f b7 cc          	movzwl %r12w,%ecx
{
  106f9b:	48 83 ec 18          	sub    $0x18,%rsp
	uint16_t after = shell->ctx->cmd_buff_len - shell->ctx->cmd_buff_pos;
  106f9f:	48 8b 57 10          	mov    0x10(%rdi),%rdx
{
  106fa3:	48 89 75 c8          	mov    %rsi,-0x38(%rbp)
	uint16_t after = shell->ctx->cmd_buff_len - shell->ctx->cmd_buff_pos;
  106fa7:	0f b7 42 70          	movzwl 0x70(%rdx),%eax
  106fab:	89 c3                	mov    %eax,%ebx
	if ((shell->ctx->cmd_buff_len + len) >= CONFIG_SHELL_CMD_BUFF_SIZE) {
  106fad:	01 c8                	add    %ecx,%eax
  106faf:	3d ff 00 00 00       	cmp    $0xff,%eax
  106fb4:	7f 79                	jg     10702f <data_insert+0xa8>
	uint16_t after = shell->ctx->cmd_buff_len - shell->ctx->cmd_buff_pos;
  106fb6:	0f b7 42 72          	movzwl 0x72(%rdx),%eax
	memmove(curr_pos + len, curr_pos, after);
  106fba:	45 0f b7 f4          	movzwl %r12w,%r14d
  106fbe:	49 89 fd             	mov    %rdi,%r13
	char *curr_pos = &shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos];
  106fc1:	4c 8d 7c 02 76       	lea    0x76(%rdx,%rax,1),%r15
	uint16_t after = shell->ctx->cmd_buff_len - shell->ctx->cmd_buff_pos;
  106fc6:	29 c3                	sub    %eax,%ebx
	memmove(curr_pos + len, curr_pos, after);
  106fc8:	0f b7 d3             	movzwl %bx,%edx
  106fcb:	4b 8d 3c 37          	lea    (%r15,%r14,1),%rdi
  106fcf:	4c 89 fe             	mov    %r15,%rsi
  106fd2:	e8 8b 30 00 00       	callq  10a062 <memmove>
	memcpy(curr_pos, data, len);
  106fd7:	4c 8b 45 c8          	mov    -0x38(%rbp),%r8
  106fdb:	4c 89 f2             	mov    %r14,%rdx
  106fde:	4c 89 ff             	mov    %r15,%rdi
  106fe1:	4c 89 c6             	mov    %r8,%rsi
  106fe4:	e8 af 30 00 00       	callq  10a098 <memcpy>
	shell->ctx->cmd_buff_len += len;
  106fe9:	49 8b 45 10          	mov    0x10(%r13),%rax
  106fed:	44 89 e2             	mov    %r12d,%edx
  106ff0:	03 50 70             	add    0x70(%rax),%edx
  106ff3:	66 89 50 70          	mov    %dx,0x70(%rax)
	shell->ctx->cmd_buff[shell->ctx->cmd_buff_len] = '\0';
  106ff7:	0f b7 d2             	movzwl %dx,%edx
  106ffa:	c6 44 10 76 00       	movb   $0x0,0x76(%rax,%rdx,1)
	return shell->ctx->internal.flags.echo == 1;
  106fff:	48 8b 90 90 02 00 00 	mov    0x290(%rax),%rdx
	if (!z_flag_echo_get(shell)) {
  107006:	48 0f ba e2 22       	bt     $0x22,%rdx
  10700b:	72 07                	jb     107014 <data_insert+0x8d>
		shell->ctx->cmd_buff_pos += len;
  10700d:	66 44 01 60 72       	add    %r12w,0x72(%rax)
		return;
  107012:	eb 1b                	jmp    10702f <data_insert+0xa8>
}
  107014:	48 83 c4 18          	add    $0x18,%rsp
	reprint_from_cursor(shell, after, false);
  107018:	0f b7 f3             	movzwl %bx,%esi
  10701b:	4c 89 ef             	mov    %r13,%rdi
  10701e:	31 d2                	xor    %edx,%edx
}
  107020:	5b                   	pop    %rbx
  107021:	41 5c                	pop    %r12
  107023:	41 5d                	pop    %r13
  107025:	41 5e                	pop    %r14
  107027:	41 5f                	pop    %r15
  107029:	5d                   	pop    %rbp
	reprint_from_cursor(shell, after, false);
  10702a:	e9 a4 fe ff ff       	jmpq   106ed3 <reprint_from_cursor>
}
  10702f:	48 83 c4 18          	add    $0x18,%rsp
  107033:	5b                   	pop    %rbx
  107034:	41 5c                	pop    %r12
  107036:	41 5d                	pop    %r13
  107038:	41 5e                	pop    %r14
  10703a:	41 5f                	pop    %r15
  10703c:	5d                   	pop    %rbp
  10703d:	c3                   	retq   

000000000010703e <z_shell_op_char_insert>:
{
  10703e:	55                   	push   %rbp
  10703f:	48 89 e5             	mov    %rsp,%rbp
  107042:	41 54                	push   %r12
  107044:	49 89 fc             	mov    %rdi,%r12
  107047:	48 83 ec 18          	sub    $0x18,%rsp
	if (shell->ctx->internal.flags.insert_mode &&
  10704b:	48 8b 47 10          	mov    0x10(%rdi),%rax
{
  10704f:	40 88 75 ec          	mov    %sil,-0x14(%rbp)
	if (shell->ctx->internal.flags.insert_mode &&
  107053:	48 8b 90 90 02 00 00 	mov    0x290(%rax),%rdx
  10705a:	48 0f ba e2 20       	bt     $0x20,%rdx
  10705f:	73 66                	jae    1070c7 <z_shell_op_char_insert+0x89>
		(shell->ctx->cmd_buff_len != shell->ctx->cmd_buff_pos)) {
  107061:	0f b7 48 72          	movzwl 0x72(%rax),%ecx
	if (shell->ctx->internal.flags.insert_mode &&
  107065:	66 39 48 70          	cmp    %cx,0x70(%rax)
  107069:	74 5c                	je     1070c7 <z_shell_op_char_insert+0x89>
	shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos++] = data;
  10706b:	8d 79 01             	lea    0x1(%rcx),%edi
		char_replace(shell, data);
  10706e:	40 0f be d6          	movsbl %sil,%edx
	shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos++] = data;
  107072:	66 89 78 72          	mov    %di,0x72(%rax)
  107076:	40 88 74 08 76       	mov    %sil,0x76(%rax,%rcx,1)
  10707b:	48 8b 88 90 02 00 00 	mov    0x290(%rax),%rcx
	if (!z_flag_echo_get(shell)) {
  107082:	48 0f ba e1 22       	bt     $0x22,%rcx
  107087:	73 4f                	jae    1070d8 <z_shell_op_char_insert+0x9a>
	return shell->ctx->internal.flags.obscure == 1;
  107089:	48 8b 80 90 02 00 00 	mov    0x290(%rax),%rax
	z_shell_raw_fprintf(shell->fprintf_ctx, "%c", data);
  107090:	49 8b 7c 24 28       	mov    0x28(%r12),%rdi
  107095:	be 34 dd 11 00       	mov    $0x11dd34,%esi
  10709a:	48 c1 e8 23          	shr    $0x23,%rax
		data = '*';
  10709e:	a8 01                	test   $0x1,%al
  1070a0:	b8 2a 00 00 00       	mov    $0x2a,%eax
  1070a5:	0f 45 d0             	cmovne %eax,%edx
	z_shell_raw_fprintf(shell->fprintf_ctx, "%c", data);
  1070a8:	31 c0                	xor    %eax,%eax
  1070aa:	e8 89 f4 ff ff       	callq  106538 <z_shell_raw_fprintf>
	if (z_shell_cursor_in_empty_line(shell)) {
  1070af:	4c 89 e7             	mov    %r12,%rdi
  1070b2:	e8 b3 f5 ff ff       	callq  10666a <z_shell_cursor_in_empty_line>
  1070b7:	84 c0                	test   %al,%al
  1070b9:	74 1d                	je     1070d8 <z_shell_op_char_insert+0x9a>
		z_cursor_next_line_move(shell);
  1070bb:	49 8b 7c 24 28       	mov    0x28(%r12),%rdi
  1070c0:	e8 f9 f4 ff ff       	callq  1065be <z_cursor_next_line_move.isra.0>
  1070c5:	eb 11                	jmp    1070d8 <z_shell_op_char_insert+0x9a>
		data_insert(shell, &data, 1);
  1070c7:	ba 01 00 00 00       	mov    $0x1,%edx
  1070cc:	48 8d 75 ec          	lea    -0x14(%rbp),%rsi
  1070d0:	4c 89 e7             	mov    %r12,%rdi
  1070d3:	e8 af fe ff ff       	callq  106f87 <data_insert>
}
  1070d8:	48 83 c4 18          	add    $0x18,%rsp
  1070dc:	41 5c                	pop    %r12
  1070de:	5d                   	pop    %rbp
  1070df:	c3                   	retq   

00000000001070e0 <z_shell_op_completion_insert>:
	data_insert(shell, compl, compl_len);
  1070e0:	0f b7 d2             	movzwl %dx,%edx
  1070e3:	e9 9f fe ff ff       	jmpq   106f87 <data_insert>

00000000001070e8 <z_shell_op_char_delete>:
{
  1070e8:	55                   	push   %rbp
  1070e9:	48 89 e5             	mov    %rsp,%rbp
  1070ec:	41 54                	push   %r12
  1070ee:	53                   	push   %rbx
	uint16_t diff = shell->ctx->cmd_buff_len - shell->ctx->cmd_buff_pos;
  1070ef:	48 8b 57 10          	mov    0x10(%rdi),%rdx
  1070f3:	0f b7 42 72          	movzwl 0x72(%rdx),%eax
	if (diff == 0U) {
  1070f7:	8b 5a 70             	mov    0x70(%rdx),%ebx
  1070fa:	66 29 c3             	sub    %ax,%bx
  1070fd:	74 34                	je     107133 <z_shell_op_char_delete+0x4b>
  1070ff:	49 89 fc             	mov    %rdi,%r12
	char *str = &shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos];
  107102:	48 8d 7c 02 76       	lea    0x76(%rdx,%rax,1),%rdi
	memmove(str, str + 1, diff);
  107107:	0f b7 d3             	movzwl %bx,%edx
  10710a:	48 8d 77 01          	lea    0x1(%rdi),%rsi
  10710e:	e8 4f 2f 00 00       	callq  10a062 <memmove>
	--shell->ctx->cmd_buff_len;
  107113:	49 8b 44 24 10       	mov    0x10(%r12),%rax
	reprint_from_cursor(shell, --diff, true);
  107118:	8d 73 ff             	lea    -0x1(%rbx),%esi
  10711b:	4c 89 e7             	mov    %r12,%rdi
  10711e:	0f b7 f6             	movzwl %si,%esi
  107121:	ba 01 00 00 00       	mov    $0x1,%edx
	--shell->ctx->cmd_buff_len;
  107126:	66 ff 48 70          	decw   0x70(%rax)
}
  10712a:	5b                   	pop    %rbx
  10712b:	41 5c                	pop    %r12
  10712d:	5d                   	pop    %rbp
	reprint_from_cursor(shell, --diff, true);
  10712e:	e9 a0 fd ff ff       	jmpq   106ed3 <reprint_from_cursor>
}
  107133:	5b                   	pop    %rbx
  107134:	41 5c                	pop    %r12
  107136:	5d                   	pop    %rbp
  107137:	c3                   	retq   

0000000000107138 <z_shell_op_char_backspace>:
	if ((shell->ctx->cmd_buff_len == 0) ||
  107138:	48 8b 47 10          	mov    0x10(%rdi),%rax
  10713c:	66 83 78 70 00       	cmpw   $0x0,0x70(%rax)
  107141:	74 25                	je     107168 <z_shell_op_char_backspace+0x30>
  107143:	66 83 78 72 00       	cmpw   $0x0,0x72(%rax)
  107148:	74 1e                	je     107168 <z_shell_op_char_backspace+0x30>
{
  10714a:	55                   	push   %rbp
	z_shell_op_cursor_move(shell, -1);
  10714b:	83 ce ff             	or     $0xffffffff,%esi
{
  10714e:	48 89 e5             	mov    %rsp,%rbp
  107151:	48 83 ec 10          	sub    $0x10,%rsp
	z_shell_op_cursor_move(shell, -1);
  107155:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  107159:	e8 ec f5 ff ff       	callq  10674a <z_shell_op_cursor_move>
	z_shell_op_char_delete(shell);
  10715e:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
}
  107162:	c9                   	leaveq 
	z_shell_op_char_delete(shell);
  107163:	e9 80 ff ff ff       	jmpq   1070e8 <z_shell_op_char_delete>
  107168:	c3                   	retq   

0000000000107169 <z_shell_print_prompt_and_cmd>:
{
  107169:	55                   	push   %rbp
	z_shell_fprintf(shell, SHELL_INFO, "%s", shell->ctx->prompt);
  10716a:	ba b7 d5 11 00       	mov    $0x11d5b7,%edx
  10716f:	be 03 00 00 00       	mov    $0x3,%esi
{
  107174:	48 89 e5             	mov    %rsp,%rbp
  107177:	41 54                	push   %r12
  107179:	49 89 fc             	mov    %rdi,%r12
  10717c:	51                   	push   %rcx
	z_shell_fprintf(shell, SHELL_INFO, "%s", shell->ctx->prompt);
  10717d:	48 8b 47 10          	mov    0x10(%rdi),%rax
  107181:	48 8b 08             	mov    (%rax),%rcx
  107184:	31 c0                	xor    %eax,%eax
  107186:	e8 a0 fa ff ff       	callq  106c2b <z_shell_fprintf>
	return shell->ctx->internal.flags.echo == 1;
  10718b:	49 8b 44 24 10       	mov    0x10(%r12),%rax
  107190:	48 8b 80 90 02 00 00 	mov    0x290(%rax),%rax
	if (z_flag_echo_get(shell)) {
  107197:	48 0f ba e0 22       	bt     $0x22,%rax
  10719c:	73 14                	jae    1071b2 <z_shell_print_prompt_and_cmd+0x49>
		z_shell_print_cmd(shell);
  10719e:	4c 89 e7             	mov    %r12,%rdi
  1071a1:	e8 8f f7 ff ff       	callq  106935 <z_shell_print_cmd>
}
  1071a6:	5a                   	pop    %rdx
		z_shell_op_cursor_position_synchronize(shell);
  1071a7:	4c 89 e7             	mov    %r12,%rdi
}
  1071aa:	41 5c                	pop    %r12
  1071ac:	5d                   	pop    %rbp
		z_shell_op_cursor_position_synchronize(shell);
  1071ad:	e9 23 f5 ff ff       	jmpq   1066d5 <z_shell_op_cursor_position_synchronize>
}
  1071b2:	58                   	pop    %rax
  1071b3:	41 5c                	pop    %r12
  1071b5:	5d                   	pop    %rbp
  1071b6:	c3                   	retq   

00000000001071b7 <arch_is_user_context>:
	__asm__ volatile ("mov %%cs, %[cs_val]" : [cs_val] "=r" (cs));
  1071b7:	8c c8                	mov    %cs,%eax
	return (cs & 0x3) != 0;
  1071b9:	a8 03                	test   $0x3,%al
  1071bb:	0f 95 c0             	setne  %al
}
  1071be:	c3                   	retq   

00000000001071bf <enable>:

static int enable(const struct shell_transport *transport, bool blocking_tx)
{
	const struct shell_uart *sh_uart = (struct shell_uart *)transport->ctx;

	sh_uart->ctrl_blk->blocking_tx = blocking_tx;
  1071bf:	48 8b 47 08          	mov    0x8(%rdi),%rax
  1071c3:	48 8b 00             	mov    (%rax),%rax
  1071c6:	40 88 70 1c          	mov    %sil,0x1c(%rax)
		uart_irq_tx_disable(sh_uart->ctrl_blk->dev);
#endif
	}

	return 0;
}
  1071ca:	31 c0                	xor    %eax,%eax
  1071cc:	c3                   	retq   

00000000001071cd <read>:
	return 0;
}

static int read(const struct shell_transport *transport,
		void *data, size_t length, size_t *cnt)
{
  1071cd:	55                   	push   %rbp
  1071ce:	48 89 e5             	mov    %rsp,%rbp
  1071d1:	53                   	push   %rbx
  1071d2:	48 89 cb             	mov    %rcx,%rbx
  1071d5:	50                   	push   %rax
	struct shell_uart *sh_uart = (struct shell_uart *)transport->ctx;

	*cnt = ring_buf_get(sh_uart->rx_ringbuf, data, length);
  1071d6:	48 8b 47 08          	mov    0x8(%rdi),%rax
  1071da:	48 8b 78 18          	mov    0x18(%rax),%rdi
  1071de:	e8 12 b9 ff ff       	callq  102af5 <ring_buf_get>
  1071e3:	89 c0                	mov    %eax,%eax
  1071e5:	48 89 03             	mov    %rax,(%rbx)

	return 0;
}
  1071e8:	5a                   	pop    %rdx
  1071e9:	31 c0                	xor    %eax,%eax
  1071eb:	5b                   	pop    %rbx
  1071ec:	5d                   	pop    %rbp
  1071ed:	c3                   	retq   

00000000001071ee <init>:
{
  1071ee:	55                   	push   %rbp
  1071ef:	48 89 e5             	mov    %rsp,%rbp
  1071f2:	53                   	push   %rbx
  1071f3:	41 50                	push   %r8
	const struct shell_uart *sh_uart = (struct shell_uart *)transport->ctx;
  1071f5:	48 8b 5f 08          	mov    0x8(%rdi),%rbx
	sh_uart->ctrl_blk->dev = (const struct device *)config;
  1071f9:	48 8b 03             	mov    (%rbx),%rax
		k_timer_init(sh_uart->timer, timer_handler, NULL);
  1071fc:	48 8b 7b 08          	mov    0x8(%rbx),%rdi
	sh_uart->ctrl_blk->dev = (const struct device *)config;
  107200:	48 89 30             	mov    %rsi,(%rax)
		k_timer_init(sh_uart->timer, timer_handler, NULL);
  107203:	be 5e 73 10 00       	mov    $0x10735e,%esi
	sh_uart->ctrl_blk->handler = evt_handler;
  107208:	48 89 50 08          	mov    %rdx,0x8(%rax)
		k_timer_init(sh_uart->timer, timer_handler, NULL);
  10720c:	31 d2                	xor    %edx,%edx
	sh_uart->ctrl_blk->context = context;
  10720e:	48 89 48 10          	mov    %rcx,0x10(%rax)
		k_timer_init(sh_uart->timer, timer_handler, NULL);
  107212:	e8 fc c6 00 00       	callq  113913 <k_timer_init>
		k_timer_user_data_set(sh_uart->timer, (void *)sh_uart);
  107217:	48 8b 7b 08          	mov    0x8(%rbx),%rdi
  10721b:	e8 97 ff ff ff       	callq  1071b7 <arch_is_user_context>
	if (z_syscall_trap()) {
  107220:	84 c0                	test   %al,%al
  107222:	74 0c                	je     107230 <init+0x42>
	register uintptr_t rax __asm__("%rax") = call_id;
  107224:	b8 cd 00 00 00       	mov    $0xcd,%eax
	register uintptr_t rsi __asm__("%rsi") = arg2;
  107229:	48 89 de             	mov    %rbx,%rsi
	__asm__ volatile("syscall\n\t"
  10722c:	0f 05                	syscall 
	return rax;
  10722e:	eb 04                	jmp    107234 <init+0x46>
 * @internal
 */
static inline void z_impl_k_timer_user_data_set(struct k_timer *timer,
					       void *user_data)
{
	timer->user_data = user_data;
  107230:	48 89 5f 50          	mov    %rbx,0x50(%rdi)
		k_timer_start(sh_uart->timer, RX_POLL_PERIOD, RX_POLL_PERIOD);
  107234:	48 8b 7b 08          	mov    0x8(%rbx),%rdi
  107238:	e8 7a ff ff ff       	callq  1071b7 <arch_is_user_context>
	if (z_syscall_trap()) {
  10723d:	84 c0                	test   %al,%al
  10723f:	74 13                	je     107254 <init+0x66>
	register uintptr_t rax __asm__("%rax") = call_id;
  107241:	b8 c8 00 00 00       	mov    $0xc8,%eax
	register uintptr_t rsi __asm__("%rsi") = arg2;
  107246:	be 64 00 00 00       	mov    $0x64,%esi
	register uintptr_t rdx __asm__("%rdx") = arg3;
  10724b:	ba 64 00 00 00       	mov    $0x64,%edx
	__asm__ volatile("syscall\n\t"
  107250:	0f 05                	syscall 
	return rax;
  107252:	eb 0f                	jmp    107263 <init+0x75>
	z_impl_k_timer_start(timer, duration, period);
  107254:	ba 64 00 00 00       	mov    $0x64,%edx
  107259:	be 64 00 00 00       	mov    $0x64,%esi
  10725e:	e8 e7 c6 00 00       	callq  11394a <z_impl_k_timer_start>
}
  107263:	5a                   	pop    %rdx
  107264:	31 c0                	xor    %eax,%eax
  107266:	5b                   	pop    %rbx
  107267:	5d                   	pop    %rbp
  107268:	c3                   	retq   

0000000000107269 <enable_shell_uart>:
	.update = update,
#endif /* CONFIG_MCUMGR_SMP_SHELL */
};

static int enable_shell_uart(const struct device *arg)
{
  107269:	55                   	push   %rbp
  10726a:	48 89 e5             	mov    %rsp,%rbp
  10726d:	e8 45 ff ff ff       	callq  1071b7 <arch_is_user_context>
	if (z_syscall_trap()) {
  107272:	84 c0                	test   %al,%al
  107274:	74 33                	je     1072a9 <enable_shell_uart+0x40>
	register uintptr_t rax __asm__("%rax") = call_id;
  107276:	b8 2f 00 00 00       	mov    $0x2f,%eax
	register uintptr_t rdi __asm__("%rdi") = arg1;
  10727b:	bf 50 a1 11 00       	mov    $0x11a150,%edi
	__asm__ volatile("syscall\n\t"
  107280:	0f 05                	syscall 
	bool log_backend = CONFIG_SHELL_BACKEND_SERIAL_LOG_LEVEL > 0;
	uint32_t level =
		(CONFIG_SHELL_BACKEND_SERIAL_LOG_LEVEL > LOG_LEVEL_DBG) ?
		CONFIG_LOG_MAX_LEVEL : CONFIG_SHELL_BACKEND_SERIAL_LOG_LEVEL;

	if (!device_is_ready(dev)) {
  107282:	85 c0                	test   %eax,%eax
  107284:	75 31                	jne    1072b7 <enable_shell_uart+0x4e>

	if (IS_ENABLED(CONFIG_MCUMGR_SMP_SHELL)) {
		smp_shell_init();
	}

	shell_init(&shell_uart, dev, true, log_backend, level);
  107286:	41 b8 04 00 00 00    	mov    $0x4,%r8d
  10728c:	b9 01 00 00 00       	mov    $0x1,%ecx
  107291:	ba 01 00 00 00       	mov    $0x1,%edx
  107296:	be 50 a1 11 00       	mov    $0x11a150,%esi
  10729b:	bf e0 a2 11 00       	mov    $0x11a2e0,%edi
  1072a0:	e8 46 e2 ff ff       	callq  1054eb <shell_init>

	return 0;
  1072a5:	31 c0                	xor    %eax,%eax
  1072a7:	eb 13                	jmp    1072bc <enable_shell_uart+0x53>
	return z_device_ready(dev) ? 0 : -ENODEV;
  1072a9:	bf 50 a1 11 00       	mov    $0x11a150,%edi
  1072ae:	e8 a2 5b 00 00       	callq  10ce55 <z_device_ready>
  1072b3:	84 c0                	test   %al,%al
  1072b5:	75 cf                	jne    107286 <enable_shell_uart+0x1d>
		return -ENODEV;
  1072b7:	b8 ed ff ff ff       	mov    $0xffffffed,%eax
}
  1072bc:	5d                   	pop    %rbp
  1072bd:	c3                   	retq   

00000000001072be <uninit>:
{
  1072be:	55                   	push   %rbp
		k_timer_stop(sh_uart->timer);
  1072bf:	48 8b 47 08          	mov    0x8(%rdi),%rax
  1072c3:	48 8b 78 08          	mov    0x8(%rax),%rdi
{
  1072c7:	48 89 e5             	mov    %rsp,%rbp
  1072ca:	e8 e8 fe ff ff       	callq  1071b7 <arch_is_user_context>
	if (z_syscall_trap()) {
  1072cf:	84 c0                	test   %al,%al
  1072d1:	74 09                	je     1072dc <uninit+0x1e>
	register uintptr_t rax __asm__("%rax") = call_id;
  1072d3:	b8 cb 00 00 00       	mov    $0xcb,%eax
	__asm__ volatile("syscall\n\t"
  1072d8:	0f 05                	syscall 
	return rax;
  1072da:	eb 05                	jmp    1072e1 <uninit+0x23>
	z_impl_k_timer_stop(timer);
  1072dc:	e8 89 c7 00 00       	callq  113a6a <z_impl_k_timer_stop>
}
  1072e1:	31 c0                	xor    %eax,%eax
  1072e3:	5d                   	pop    %rbp
  1072e4:	c3                   	retq   

00000000001072e5 <write>:
{
  1072e5:	55                   	push   %rbp
  1072e6:	48 89 e5             	mov    %rsp,%rbp
  1072e9:	41 57                	push   %r15
  1072eb:	41 56                	push   %r14
  1072ed:	4c 8d 34 16          	lea    (%rsi,%rdx,1),%r14
  1072f1:	41 55                	push   %r13
  1072f3:	49 89 cd             	mov    %rcx,%r13
  1072f6:	41 54                	push   %r12
  1072f8:	49 89 d4             	mov    %rdx,%r12
  1072fb:	53                   	push   %rbx
  1072fc:	48 89 f3             	mov    %rsi,%rbx
  1072ff:	48 83 ec 18          	sub    $0x18,%rsp
	const struct shell_uart *sh_uart = (struct shell_uart *)transport->ctx;
  107303:	4c 8b 7f 08          	mov    0x8(%rdi),%r15
			uart_poll_out(sh_uart->ctrl_blk->dev, data8[i]);
  107307:	49 8b 07             	mov    (%r15),%rax
		for (size_t i = 0; i < length; i++) {
  10730a:	49 39 de             	cmp    %rbx,%r14
  10730d:	74 2e                	je     10733d <write+0x58>
			uart_poll_out(sh_uart->ctrl_blk->dev, data8[i]);
  10730f:	48 8b 38             	mov    (%rax),%rdi
  107312:	8a 03                	mov    (%rbx),%al
  107314:	88 45 cf             	mov    %al,-0x31(%rbp)
  107317:	e8 9b fe ff ff       	callq  1071b7 <arch_is_user_context>

__pinned_func
static inline void uart_poll_out(const struct device * dev, unsigned char out_char)
{
#ifdef CONFIG_USERSPACE
	if (z_syscall_trap()) {
  10731c:	84 c0                	test   %al,%al
  10731e:	74 0d                	je     10732d <write+0x48>
	register uintptr_t rsi __asm__("%rsi") = arg2;
  107320:	48 8b 75 cf          	mov    -0x31(%rbp),%rsi
	register uintptr_t rax __asm__("%rax") = call_id;
  107324:	b8 27 01 00 00       	mov    $0x127,%eax
	__asm__ volatile("syscall\n\t"
  107329:	0f 05                	syscall 
	return rax;
  10732b:	eb 0b                	jmp    107338 <write+0x53>
						unsigned char out_char)
{
	const struct uart_driver_api *api =
		(const struct uart_driver_api *)dev->api;

	api->poll_out(dev, out_char);
  10732d:	48 8b 47 10          	mov    0x10(%rdi),%rax
		arch_syscall_invoke2(*(uintptr_t *)&dev, *(uintptr_t *)&out_char, K_SYSCALL_UART_POLL_OUT);
		return;
	}
#endif
	compiler_barrier();
	z_impl_uart_poll_out(dev, out_char);
  107331:	0f b6 75 cf          	movzbl -0x31(%rbp),%esi
  107335:	ff 50 08             	callq  *0x8(%rax)
		for (size_t i = 0; i < length; i++) {
  107338:	48 ff c3             	inc    %rbx
  10733b:	eb ca                	jmp    107307 <write+0x22>
		*cnt = length;
  10733d:	4d 89 65 00          	mov    %r12,0x0(%r13)
		sh_uart->ctrl_blk->handler(SHELL_TRANSPORT_EVT_TX_RDY,
  107341:	48 8b 70 10          	mov    0x10(%rax),%rsi
  107345:	bf 01 00 00 00       	mov    $0x1,%edi
  10734a:	ff 50 08             	callq  *0x8(%rax)
}
  10734d:	48 83 c4 18          	add    $0x18,%rsp
  107351:	31 c0                	xor    %eax,%eax
  107353:	5b                   	pop    %rbx
  107354:	41 5c                	pop    %r12
  107356:	41 5d                	pop    %r13
  107358:	41 5e                	pop    %r14
  10735a:	41 5f                	pop    %r15
  10735c:	5d                   	pop    %rbp
  10735d:	c3                   	retq   

000000000010735e <timer_handler>:
{
  10735e:	55                   	push   %rbp
  10735f:	48 89 e5             	mov    %rsp,%rbp
  107362:	53                   	push   %rbx
  107363:	48 83 ec 18          	sub    $0x18,%rsp
  107367:	e8 4b fe ff ff       	callq  1071b7 <arch_is_user_context>
	if (z_syscall_trap()) {
  10736c:	84 c0                	test   %al,%al
  10736e:	74 0c                	je     10737c <timer_handler+0x1e>
	register uintptr_t rax __asm__("%rax") = call_id;
  107370:	b8 cc 00 00 00       	mov    $0xcc,%eax
	__asm__ volatile("syscall\n\t"
  107375:	0f 05                	syscall 
	return rax;
  107377:	48 89 c3             	mov    %rax,%rbx
		return (void *) arch_syscall_invoke1(*(uintptr_t *)&timer, K_SYSCALL_K_TIMER_USER_DATA_GET);
  10737a:	eb 4d                	jmp    1073c9 <timer_handler+0x6b>
 */
__syscall void *k_timer_user_data_get(const struct k_timer *timer);

static inline void *z_impl_k_timer_user_data_get(const struct k_timer *timer)
{
	return timer->user_data;
  10737c:	48 8b 5f 50          	mov    0x50(%rdi),%rbx
	while (uart_poll_in(sh_uart->ctrl_blk->dev, &c) == 0) {
  107380:	eb 47                	jmp    1073c9 <timer_handler+0x6b>
	if (api->poll_in == NULL) {
  107382:	48 8b 47 10          	mov    0x10(%rdi),%rax
  107386:	48 8b 00             	mov    (%rax),%rax
  107389:	48 85 c0             	test   %rax,%rax
  10738c:	74 57                	je     1073e5 <timer_handler+0x87>
	return api->poll_in(dev, p_char);
  10738e:	48 8d 75 ef          	lea    -0x11(%rbp),%rsi
  107392:	ff d0                	callq  *%rax
  107394:	85 c0                	test   %eax,%eax
  107396:	75 4d                	jne    1073e5 <timer_handler+0x87>
		if (ring_buf_put(sh_uart->rx_ringbuf, &c, 1) == 0U) {
  107398:	48 8b 7b 18          	mov    0x18(%rbx),%rdi
  10739c:	ba 01 00 00 00       	mov    $0x1,%edx
  1073a1:	48 8d 75 ef          	lea    -0x11(%rbp),%rsi
  1073a5:	e8 df b5 ff ff       	callq  102989 <ring_buf_put>
  1073aa:	85 c0                	test   %eax,%eax
  1073ac:	75 0f                	jne    1073bd <timer_handler+0x5f>
			LOG_WRN("RX ring buffer full.");
  1073ae:	be 57 00 00 00       	mov    $0x57,%esi
  1073b3:	bf d8 dd 11 00       	mov    $0x11ddd8,%edi
  1073b8:	e8 09 bd ff ff       	callq  1030c6 <z_log_minimal_printk>
		sh_uart->ctrl_blk->handler(SHELL_TRANSPORT_EVT_RX_RDY,
  1073bd:	48 8b 03             	mov    (%rbx),%rax
  1073c0:	31 ff                	xor    %edi,%edi
  1073c2:	48 8b 70 10          	mov    0x10(%rax),%rsi
  1073c6:	ff 50 08             	callq  *0x8(%rax)
	while (uart_poll_in(sh_uart->ctrl_blk->dev, &c) == 0) {
  1073c9:	48 8b 03             	mov    (%rbx),%rax
  1073cc:	48 8b 38             	mov    (%rax),%rdi
  1073cf:	e8 e3 fd ff ff       	callq  1071b7 <arch_is_user_context>
	if (z_syscall_trap()) {
  1073d4:	84 c0                	test   %al,%al
  1073d6:	74 aa                	je     107382 <timer_handler+0x24>
	register uintptr_t rax __asm__("%rax") = call_id;
  1073d8:	b8 26 01 00 00       	mov    $0x126,%eax
	register uintptr_t rsi __asm__("%rsi") = arg2;
  1073dd:	48 8d 75 ef          	lea    -0x11(%rbp),%rsi
	__asm__ volatile("syscall\n\t"
  1073e1:	0f 05                	syscall 
		return (int) arch_syscall_invoke2(*(uintptr_t *)&dev, *(uintptr_t *)&p_char, K_SYSCALL_UART_POLL_IN);
  1073e3:	eb af                	jmp    107394 <timer_handler+0x36>
}
  1073e5:	48 83 c4 18          	add    $0x18,%rsp
  1073e9:	5b                   	pop    %rbx
  1073ea:	5d                   	pop    %rbp
  1073eb:	c3                   	retq   

00000000001073ec <z_shell_raw_fprintf>:
{
  1073ec:	55                   	push   %rbp
  1073ed:	48 89 e5             	mov    %rsp,%rbp
  1073f0:	48 81 ec d0 00 00 00 	sub    $0xd0,%rsp
  1073f7:	48 89 95 60 ff ff ff 	mov    %rdx,-0xa0(%rbp)
  1073fe:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  107405:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  10740c:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  107413:	84 c0                	test   %al,%al
  107415:	74 20                	je     107437 <z_shell_raw_fprintf+0x4b>
  107417:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  10741b:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  10741f:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  107423:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  107427:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  10742b:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  10742f:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  107433:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
	va_start(args, fmt);
  107437:	48 8d 45 10          	lea    0x10(%rbp),%rax
	z_shell_fprintf_fmt(ctx, fmt, args);
  10743b:	48 8d 95 38 ff ff ff 	lea    -0xc8(%rbp),%rdx
	va_start(args, fmt);
  107442:	c7 85 38 ff ff ff 10 	movl   $0x10,-0xc8(%rbp)
  107449:	00 00 00 
  10744c:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  107453:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  10745a:	c7 85 3c ff ff ff 30 	movl   $0x30,-0xc4(%rbp)
  107461:	00 00 00 
  107464:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
	z_shell_fprintf_fmt(ctx, fmt, args);
  10746b:	e8 d1 e9 ff ff       	callq  105e41 <z_shell_fprintf_fmt>
}
  107470:	c9                   	leaveq 
  107471:	c3                   	retq   

0000000000107472 <z_cursor_next_line_move.isra.0>:
	z_shell_raw_fprintf(shell->fprintf_ctx, "\n");
  107472:	be 23 fc 11 00       	mov    $0x11fc23,%esi
  107477:	31 c0                	xor    %eax,%eax
  107479:	e9 6e ff ff ff       	jmpq   1073ec <z_shell_raw_fprintf>

000000000010747e <formatted_text_print.constprop.0>:
				 size_t terminal_offset, bool offset_first_line)
{
	size_t offset = 0;
	size_t length;

	if (str == NULL) {
  10747e:	48 85 f6             	test   %rsi,%rsi
  107481:	0f 84 60 01 00 00    	je     1075e7 <formatted_text_print.constprop.0+0x169>
static void formatted_text_print(const struct shell *shell, const char *str,
  107487:	55                   	push   %rbp
  107488:	48 89 e5             	mov    %rsp,%rbp
  10748b:	41 57                	push   %r15
  10748d:	49 89 d7             	mov    %rdx,%r15
  107490:	41 56                	push   %r14
  107492:	41 55                	push   %r13
  107494:	49 89 f5             	mov    %rsi,%r13
  107497:	41 54                	push   %r12
  107499:	49 89 fc             	mov    %rdi,%r12
  10749c:	53                   	push   %rbx
  10749d:	31 db                	xor    %ebx,%ebx
  10749f:	48 83 ec 18          	sub    $0x18,%rsp
		z_shell_op_cursor_horiz_move(shell, terminal_offset);
	}


	/* Skipping whitespace. */
	while (isspace((int) *(str + offset))) {
  1074a3:	41 0f be 44 1d 00    	movsbl 0x0(%r13,%rbx,1),%eax
  1074a9:	89 c2                	mov    %eax,%edx
	return (int)(c == (int)' ' || ((unsigned)c-(unsigned)'\t') < 5U);
  1074ab:	83 e8 09             	sub    $0x9,%eax
  1074ae:	83 f8 04             	cmp    $0x4,%eax
  1074b1:	77 05                	ja     1074b8 <formatted_text_print.constprop.0+0x3a>
		++offset;
  1074b3:	48 ff c3             	inc    %rbx
  1074b6:	eb eb                	jmp    1074a3 <formatted_text_print.constprop.0+0x25>
	while (isspace((int) *(str + offset))) {
  1074b8:	80 fa 20             	cmp    $0x20,%dl
  1074bb:	74 f6                	je     1074b3 <formatted_text_print.constprop.0+0x35>
  1074bd:	4c 89 ef             	mov    %r13,%rdi
  1074c0:	e8 17 2b 00 00       	callq  109fdc <strlen>
		size_t idx = 0;

		length = z_shell_strlen(str) - offset;

		if (length <=
		    shell->ctx->vt100_ctx.cons.terminal_wid - terminal_offset) {
  1074c5:	49 8b 54 24 10       	mov    0x10(%r12),%rdx
  1074ca:	49 8d 74 1d 00       	lea    0x0(%r13,%rbx,1),%rsi
		length = z_shell_strlen(str) - offset;
  1074cf:	0f b7 c0             	movzwl %ax,%eax
		    shell->ctx->vt100_ctx.cons.terminal_wid - terminal_offset) {
  1074d2:	0f b7 7a 4a          	movzwl 0x4a(%rdx),%edi
		length = z_shell_strlen(str) - offset;
  1074d6:	48 29 d8             	sub    %rbx,%rax
		    shell->ctx->vt100_ctx.cons.terminal_wid - terminal_offset) {
  1074d9:	48 89 fa             	mov    %rdi,%rdx
  1074dc:	4c 29 fa             	sub    %r15,%rdx
		if (length <=
  1074df:	48 39 d0             	cmp    %rdx,%rax
  1074e2:	76 08                	jbe    1074ec <formatted_text_print.constprop.0+0x6e>
		size_t idx = 0;
  1074e4:	45 31 f6             	xor    %r14d,%r14d
  1074e7:	e9 8c 00 00 00       	jmpq   107578 <formatted_text_print.constprop.0+0xfa>
			for (idx = 0; idx < length; idx++) {
  1074ec:	31 d2                	xor    %edx,%edx
  1074ee:	48 39 d0             	cmp    %rdx,%rax
  1074f1:	74 4c                	je     10753f <formatted_text_print.constprop.0+0xc1>
				if (*(str + offset + idx) == '\n') {
  1074f3:	80 3c 16 0a          	cmpb   $0xa,(%rsi,%rdx,1)
  1074f7:	4c 8d 34 13          	lea    (%rbx,%rdx,1),%r14
  1074fb:	75 3d                	jne    10753a <formatted_text_print.constprop.0+0xbc>
	z_shell_fprintf_buffer_flush(shell->fprintf_ctx);
  1074fd:	49 8b 7c 24 28       	mov    0x28(%r12),%rdi
  107502:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
					z_transport_buffer_flush(shell);
					z_shell_write(shell, str + offset, idx);
					offset += idx + 1;
  107506:	49 8d 5e 01          	lea    0x1(%r14),%rbx
  10750a:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  10750e:	e8 05 e9 ff ff       	callq  105e18 <z_shell_fprintf_buffer_flush>
					z_shell_write(shell, str + offset, idx);
  107513:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  107517:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  10751b:	4c 89 e7             	mov    %r12,%rdi
  10751e:	e8 2a f4 ff ff       	callq  10694d <z_shell_write>
					z_cursor_next_line_move(shell);
  107523:	49 8b 7c 24 28       	mov    0x28(%r12),%rdi
  107528:	e8 45 ff ff ff       	callq  107472 <z_cursor_next_line_move.isra.0>
					z_shell_op_cursor_horiz_move(shell,
  10752d:	44 89 fe             	mov    %r15d,%esi
  107530:	4c 89 e7             	mov    %r12,%rdi
  107533:	e8 09 f1 ff ff       	callq  106641 <z_shell_op_cursor_horiz_move>
							terminal_offset);
					break;
  107538:	eb 05                	jmp    10753f <formatted_text_print.constprop.0+0xc1>
			for (idx = 0; idx < length; idx++) {
  10753a:	48 ff c2             	inc    %rdx
  10753d:	eb af                	jmp    1074ee <formatted_text_print.constprop.0+0x70>
				}
			}

			/* String will fit in one line. */
			z_shell_raw_fprintf(shell->fprintf_ctx, str + offset);
  10753f:	49 8b 7c 24 28       	mov    0x28(%r12),%rdi
  107544:	49 8d 74 1d 00       	lea    0x0(%r13,%rbx,1),%rsi
  107549:	31 c0                	xor    %eax,%eax
  10754b:	e8 9c fe ff ff       	callq  1073ec <z_shell_raw_fprintf>

		z_cursor_next_line_move(shell);
		z_shell_op_cursor_horiz_move(shell, terminal_offset);

	}
	z_cursor_next_line_move(shell);
  107550:	49 8b 7c 24 28       	mov    0x28(%r12),%rdi
}
  107555:	48 83 c4 18          	add    $0x18,%rsp
  107559:	5b                   	pop    %rbx
  10755a:	41 5c                	pop    %r12
  10755c:	41 5d                	pop    %r13
  10755e:	41 5e                	pop    %r14
  107560:	41 5f                	pop    %r15
  107562:	5d                   	pop    %rbp
	z_cursor_next_line_move(shell);
  107563:	e9 0a ff ff ff       	jmpq   107472 <z_cursor_next_line_move.isra.0>
			if (isspace((int) (*(str + offset + idx)))) {
  107568:	3c 20                	cmp    $0x20,%al
  10756a:	74 1b                	je     107587 <formatted_text_print.constprop.0+0x109>
			if ((idx + terminal_offset) >=
  10756c:	4b 8d 04 37          	lea    (%r15,%r14,1),%rax
  107570:	48 39 c7             	cmp    %rax,%rdi
  107573:	76 1b                	jbe    107590 <formatted_text_print.constprop.0+0x112>
			++idx;
  107575:	49 ff c6             	inc    %r14
			if (isspace((int) (*(str + offset + idx)))) {
  107578:	42 0f be 0c 36       	movsbl (%rsi,%r14,1),%ecx
  10757d:	89 c8                	mov    %ecx,%eax
  10757f:	83 e9 09             	sub    $0x9,%ecx
  107582:	83 f9 04             	cmp    $0x4,%ecx
  107585:	77 e1                	ja     107568 <formatted_text_print.constprop.0+0xea>
				if (*(str + offset + idx) == '\n') {
  107587:	3c 0a                	cmp    $0xa,%al
  107589:	74 08                	je     107593 <formatted_text_print.constprop.0+0x115>
  10758b:	4c 89 f2             	mov    %r14,%rdx
  10758e:	eb dc                	jmp    10756c <formatted_text_print.constprop.0+0xee>
  107590:	49 89 d6             	mov    %rdx,%r14
  107593:	49 8b 7c 24 28       	mov    0x28(%r12),%rdi
  107598:	48 89 75 c8          	mov    %rsi,-0x38(%rbp)
		offset += length;
  10759c:	4c 01 f3             	add    %r14,%rbx
  10759f:	e8 74 e8 ff ff       	callq  105e18 <z_shell_fprintf_buffer_flush>
		z_shell_write(shell, str + offset, length);
  1075a4:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
  1075a8:	4c 89 f2             	mov    %r14,%rdx
  1075ab:	4c 89 e7             	mov    %r12,%rdi
  1075ae:	e8 9a f3 ff ff       	callq  10694d <z_shell_write>
		while (isspace((int) (*(str + offset)))) {
  1075b3:	41 0f be 44 1d 00    	movsbl 0x0(%r13,%rbx,1),%eax
  1075b9:	89 c2                	mov    %eax,%edx
  1075bb:	83 e8 09             	sub    $0x9,%eax
  1075be:	83 f8 04             	cmp    $0x4,%eax
  1075c1:	77 05                	ja     1075c8 <formatted_text_print.constprop.0+0x14a>
			++offset;
  1075c3:	48 ff c3             	inc    %rbx
  1075c6:	eb eb                	jmp    1075b3 <formatted_text_print.constprop.0+0x135>
		while (isspace((int) (*(str + offset)))) {
  1075c8:	80 fa 20             	cmp    $0x20,%dl
  1075cb:	74 f6                	je     1075c3 <formatted_text_print.constprop.0+0x145>
		z_cursor_next_line_move(shell);
  1075cd:	49 8b 7c 24 28       	mov    0x28(%r12),%rdi
  1075d2:	e8 9b fe ff ff       	callq  107472 <z_cursor_next_line_move.isra.0>
		z_shell_op_cursor_horiz_move(shell, terminal_offset);
  1075d7:	44 89 fe             	mov    %r15d,%esi
  1075da:	4c 89 e7             	mov    %r12,%rdi
  1075dd:	e8 5f f0 ff ff       	callq  106641 <z_shell_op_cursor_horiz_move>
	while (true) {
  1075e2:	e9 d6 fe ff ff       	jmpq   1074bd <formatted_text_print.constprop.0+0x3f>
  1075e7:	c3                   	retq   

00000000001075e8 <z_shell_help_subcmd_print>:
 * help string
 */
void z_shell_help_subcmd_print(const struct shell *shell,
			       const struct shell_static_entry *parent,
			       const char *description)
{
  1075e8:	55                   	push   %rbp
  1075e9:	48 89 e5             	mov    %rsp,%rbp
  1075ec:	41 57                	push   %r15
  1075ee:	41 56                	push   %r14
  1075f0:	49 89 d6             	mov    %rdx,%r14
  1075f3:	41 55                	push   %r13
  1075f5:	49 89 f5             	mov    %rsi,%r13
	const struct shell_static_entry *entry = NULL;
	struct shell_static_entry dloc;
	uint16_t longest = 0U;
	size_t idx = 0;
  1075f8:	31 f6                	xor    %esi,%esi
{
  1075fa:	41 54                	push   %r12
  1075fc:	49 89 fc             	mov    %rdi,%r12
  1075ff:	53                   	push   %rbx
	uint16_t longest = 0U;
  107600:	31 db                	xor    %ebx,%ebx
{
  107602:	48 83 ec 58          	sub    $0x58,%rsp

	/* Searching for the longest subcommand to print. */
	while ((entry = z_shell_cmd_get(parent, idx++, &dloc)) != NULL) {
  107606:	48 8d 55 a8          	lea    -0x58(%rbp),%rdx
  10760a:	4c 89 ef             	mov    %r13,%rdi
  10760d:	4c 8d 7e 01          	lea    0x1(%rsi),%r15
  107611:	e8 2b ec ff ff       	callq  106241 <z_shell_cmd_get>
  107616:	48 85 c0             	test   %rax,%rax
  107619:	74 1a                	je     107635 <z_shell_help_subcmd_print+0x4d>
		longest = Z_MAX(longest, z_shell_strlen(entry->syntax));
  10761b:	48 8b 38             	mov    (%rax),%rdi
	return str == NULL ? 0U : (uint16_t)strlen(str);
  10761e:	31 c0                	xor    %eax,%eax
  107620:	48 85 ff             	test   %rdi,%rdi
  107623:	74 05                	je     10762a <z_shell_help_subcmd_print+0x42>
  107625:	e8 b2 29 00 00       	callq  109fdc <strlen>
  10762a:	66 39 c3             	cmp    %ax,%bx
	while ((entry = z_shell_cmd_get(parent, idx++, &dloc)) != NULL) {
  10762d:	4c 89 fe             	mov    %r15,%rsi
		longest = Z_MAX(longest, z_shell_strlen(entry->syntax));
  107630:	0f 42 d8             	cmovb  %eax,%ebx
  107633:	eb d1                	jmp    107606 <z_shell_help_subcmd_print+0x1e>
	}

	/* No help to print */
	if (longest == 0) {
  107635:	66 85 db             	test   %bx,%bx
  107638:	0f 84 ab 00 00 00    	je     1076e9 <z_shell_help_subcmd_print+0x101>
		return;
	}

	if (description != NULL) {
  10763e:	4d 85 f6             	test   %r14,%r14
  107641:	74 0d                	je     107650 <z_shell_help_subcmd_print+0x68>
		z_shell_fprintf(shell, SHELL_NORMAL, description);
  107643:	4c 89 f2             	mov    %r14,%rdx
  107646:	31 f6                	xor    %esi,%esi
  107648:	4c 89 e7             	mov    %r12,%rdi
  10764b:	e8 db f5 ff ff       	callq  106c2b <z_shell_fprintf>
	while ((entry = z_shell_cmd_get(parent, idx++, &dloc)) != NULL) {
  107650:	31 f6                	xor    %esi,%esi

	/* Printing subcommands and help string (if exists). */
	idx = 0;

	while ((entry = z_shell_cmd_get(parent, idx++, &dloc)) != NULL) {
		help_item_print(shell, entry->syntax, longest, entry->help);
  107652:	44 0f b7 fb          	movzwl %bx,%r15d
	while ((entry = z_shell_cmd_get(parent, idx++, &dloc)) != NULL) {
  107656:	48 8d 46 01          	lea    0x1(%rsi),%rax
  10765a:	48 8d 55 a8          	lea    -0x58(%rbp),%rdx
  10765e:	4c 89 ef             	mov    %r13,%rdi
  107661:	48 89 45 98          	mov    %rax,-0x68(%rbp)
  107665:	e8 d7 eb ff ff       	callq  106241 <z_shell_cmd_get>
  10766a:	48 85 c0             	test   %rax,%rax
  10766d:	74 7a                	je     1076e9 <z_shell_help_subcmd_print+0x101>
		help_item_print(shell, entry->syntax, longest, entry->help);
  10766f:	4c 8b 08             	mov    (%rax),%r9
	const uint16_t offset = 2 * strlen(tabulator) + item_name_width + 1;
  107672:	bf 24 de 11 00       	mov    $0x11de24,%edi
		help_item_print(shell, entry->syntax, longest, entry->help);
  107677:	4c 8b 70 08          	mov    0x8(%rax),%r14
  10767b:	4c 89 4d 88          	mov    %r9,-0x78(%rbp)
	const uint16_t offset = 2 * strlen(tabulator) + item_name_width + 1;
  10767f:	e8 58 29 00 00       	callq  109fdc <strlen>
	if ((item_name == NULL) || (item_name[0] == '\0')) {
  107684:	4c 8b 4d 88          	mov    -0x78(%rbp),%r9
	const uint16_t offset = 2 * strlen(tabulator) + item_name_width + 1;
  107688:	48 89 45 90          	mov    %rax,-0x70(%rbp)
	if ((item_name == NULL) || (item_name[0] == '\0')) {
  10768c:	4d 85 c9             	test   %r9,%r9
  10768f:	74 4f                	je     1076e0 <z_shell_help_subcmd_print+0xf8>
  107691:	41 80 39 00          	cmpb   $0x0,(%r9)
  107695:	74 49                	je     1076e0 <z_shell_help_subcmd_print+0xf8>
		z_shell_fprintf(shell, SHELL_NORMAL, "%s%-*s%s:", tabulator,
  107697:	50                   	push   %rax
  107698:	b9 24 de 11 00       	mov    $0x11de24,%ecx
  10769d:	ba 0c de 11 00       	mov    $0x11de0c,%edx
  1076a2:	31 f6                	xor    %esi,%esi
  1076a4:	68 24 de 11 00       	pushq  $0x11de24
  1076a9:	31 c0                	xor    %eax,%eax
  1076ab:	45 89 f8             	mov    %r15d,%r8d
  1076ae:	4c 89 e7             	mov    %r12,%rdi
  1076b1:	e8 75 f5 ff ff       	callq  106c2b <z_shell_fprintf>
	if (item_help == NULL) {
  1076b6:	4d 85 f6             	test   %r14,%r14
		z_shell_fprintf(shell, SHELL_NORMAL, "%s%-*s%s:", tabulator,
  1076b9:	5a                   	pop    %rdx
	if (item_help == NULL) {
  1076ba:	4c 8b 55 90          	mov    -0x70(%rbp),%r10
		z_shell_fprintf(shell, SHELL_NORMAL, "%s%-*s%s:", tabulator,
  1076be:	59                   	pop    %rcx
	if (item_help == NULL) {
  1076bf:	75 0c                	jne    1076cd <z_shell_help_subcmd_print+0xe5>
		z_cursor_next_line_move(shell);
  1076c1:	49 8b 7c 24 28       	mov    0x28(%r12),%rdi
  1076c6:	e8 a7 fd ff ff       	callq  107472 <z_cursor_next_line_move.isra.0>
		return;
  1076cb:	eb 13                	jmp    1076e0 <z_shell_help_subcmd_print+0xf8>
	const uint16_t offset = 2 * strlen(tabulator) + item_name_width + 1;
  1076cd:	42 8d 54 53 01       	lea    0x1(%rbx,%r10,2),%edx
	formatted_text_print(shell, item_help, offset, false);
  1076d2:	4c 89 f6             	mov    %r14,%rsi
  1076d5:	4c 89 e7             	mov    %r12,%rdi
  1076d8:	0f b7 d2             	movzwl %dx,%edx
  1076db:	e8 9e fd ff ff       	callq  10747e <formatted_text_print.constprop.0>
	while ((entry = z_shell_cmd_get(parent, idx++, &dloc)) != NULL) {
  1076e0:	48 8b 75 98          	mov    -0x68(%rbp),%rsi
  1076e4:	e9 6d ff ff ff       	jmpq   107656 <z_shell_help_subcmd_print+0x6e>
	}
}
  1076e9:	48 8d 65 d8          	lea    -0x28(%rbp),%rsp
  1076ed:	5b                   	pop    %rbx
  1076ee:	41 5c                	pop    %r12
  1076f0:	41 5d                	pop    %r13
  1076f2:	41 5e                	pop    %r14
  1076f4:	41 5f                	pop    %r15
  1076f6:	5d                   	pop    %rbp
  1076f7:	c3                   	retq   

00000000001076f8 <z_shell_help_cmd_print>:

void z_shell_help_cmd_print(const struct shell *shell,
			    const struct shell_static_entry *cmd)
{
  1076f8:	55                   	push   %rbp
  1076f9:	48 89 e5             	mov    %rsp,%rbp
  1076fc:	41 55                	push   %r13
  1076fe:	49 89 fd             	mov    %rdi,%r13
  107701:	41 54                	push   %r12
  107703:	49 89 f4             	mov    %rsi,%r12
  107706:	53                   	push   %rbx
  107707:	31 db                	xor    %ebx,%ebx
  107709:	52                   	push   %rdx
	static const char cmd_sep[] = " - "; /* commands separator */
	uint16_t field_width;

	field_width = z_shell_strlen(cmd->syntax) + z_shell_strlen(cmd_sep);
  10770a:	48 8b 3e             	mov    (%rsi),%rdi
  10770d:	48 85 ff             	test   %rdi,%rdi
  107710:	74 07                	je     107719 <z_shell_help_cmd_print+0x21>
  107712:	e8 c5 28 00 00       	callq  109fdc <strlen>
  107717:	89 c3                	mov    %eax,%ebx
  107719:	bf 20 de 11 00       	mov    $0x11de20,%edi
  10771e:	e8 b9 28 00 00       	callq  109fdc <strlen>

	z_shell_fprintf(shell, SHELL_NORMAL, "%s%s", cmd->syntax, cmd_sep);
  107723:	49 8b 0c 24          	mov    (%r12),%rcx
  107727:	4c 89 ef             	mov    %r13,%rdi
  10772a:	31 f6                	xor    %esi,%esi
	field_width = z_shell_strlen(cmd->syntax) + z_shell_strlen(cmd_sep);
  10772c:	01 c3                	add    %eax,%ebx
	z_shell_fprintf(shell, SHELL_NORMAL, "%s%s", cmd->syntax, cmd_sep);
  10772e:	ba e6 d9 11 00       	mov    $0x11d9e6,%edx
  107733:	31 c0                	xor    %eax,%eax
  107735:	41 b8 20 de 11 00    	mov    $0x11de20,%r8d
  10773b:	e8 eb f4 ff ff       	callq  106c2b <z_shell_fprintf>

	formatted_text_print(shell, cmd->help, field_width, false);
  107740:	49 8b 74 24 08       	mov    0x8(%r12),%rsi
  107745:	0f b7 d3             	movzwl %bx,%edx
}
  107748:	58                   	pop    %rax
	formatted_text_print(shell, cmd->help, field_width, false);
  107749:	4c 89 ef             	mov    %r13,%rdi
}
  10774c:	5b                   	pop    %rbx
  10774d:	41 5c                	pop    %r12
  10774f:	41 5d                	pop    %r13
  107751:	5d                   	pop    %rbp
	formatted_text_print(shell, cmd->help, field_width, false);
  107752:	e9 27 fd ff ff       	jmpq   10747e <formatted_text_print.constprop.0>

0000000000107757 <z_shell_help_request>:

bool z_shell_help_request(const char *str)
{
  107757:	55                   	push   %rbp
	if (!IS_ENABLED(CONFIG_SHELL_HELP_OPT_PARSE)) {
		return false;
	}

	if (!strcmp(str, "-h") || !strcmp(str, "--help")) {
  107758:	be 16 de 11 00       	mov    $0x11de16,%esi
{
  10775d:	48 89 e5             	mov    %rsp,%rbp
  107760:	48 83 ec 10          	sub    $0x10,%rsp
	if (!strcmp(str, "-h") || !strcmp(str, "--help")) {
  107764:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  107768:	e8 90 28 00 00       	callq  109ffd <strcmp>
  10776d:	41 89 c0             	mov    %eax,%r8d
  107770:	b0 01                	mov    $0x1,%al
  107772:	45 85 c0             	test   %r8d,%r8d
  107775:	74 13                	je     10778a <z_shell_help_request+0x33>
  107777:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
  10777b:	be 19 de 11 00       	mov    $0x11de19,%esi
  107780:	e8 78 28 00 00       	callq  109ffd <strcmp>
  107785:	85 c0                	test   %eax,%eax
  107787:	0f 94 c0             	sete   %al
		return true;
	}

	return false;
}
  10778a:	c9                   	leaveq 
  10778b:	c3                   	retq   

000000000010778c <cmd_shell_stats_reset>:
				 size_t argc, char **argv)
{
	ARG_UNUSED(argc);
	ARG_UNUSED(argv);

	shell->stats->log_lost_cnt = 0;
  10778c:	48 8b 47 30          	mov    0x30(%rdi),%rax
  107790:	c7 00 00 00 00 00    	movl   $0x0,(%rax)

	return 0;
}
  107796:	31 c0                	xor    %eax,%eax
  107798:	c3                   	retq   

0000000000107799 <z_shell_raw_fprintf>:
{
  107799:	55                   	push   %rbp
  10779a:	48 89 e5             	mov    %rsp,%rbp
  10779d:	48 81 ec d0 00 00 00 	sub    $0xd0,%rsp
  1077a4:	48 89 95 60 ff ff ff 	mov    %rdx,-0xa0(%rbp)
  1077ab:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  1077b2:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  1077b9:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  1077c0:	84 c0                	test   %al,%al
  1077c2:	74 20                	je     1077e4 <z_shell_raw_fprintf+0x4b>
  1077c4:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  1077c8:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  1077cc:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  1077d0:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  1077d4:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  1077d8:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  1077dc:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  1077e0:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
	va_start(args, fmt);
  1077e4:	48 8d 45 10          	lea    0x10(%rbp),%rax
	z_shell_fprintf_fmt(ctx, fmt, args);
  1077e8:	48 8d 95 38 ff ff ff 	lea    -0xc8(%rbp),%rdx
	va_start(args, fmt);
  1077ef:	c7 85 38 ff ff ff 10 	movl   $0x10,-0xc8(%rbp)
  1077f6:	00 00 00 
  1077f9:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  107800:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  107807:	c7 85 3c ff ff ff 30 	movl   $0x30,-0xc4(%rbp)
  10780e:	00 00 00 
  107811:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
	z_shell_fprintf_fmt(ctx, fmt, args);
  107818:	e8 24 e6 ff ff       	callq  105e41 <z_shell_fprintf_fmt>
}
  10781d:	c9                   	leaveq 
  10781e:	c3                   	retq   

000000000010781f <cmd_clear>:
{
  10781f:	55                   	push   %rbp
	Z_SHELL_VT100_CMD(shell, SHELL_VT100_CURSORHOME);
  107820:	ba c3 de 11 00       	mov    $0x11dec3,%edx
  107825:	be b7 d5 11 00       	mov    $0x11d5b7,%esi
{
  10782a:	48 89 e5             	mov    %rsp,%rbp
  10782d:	53                   	push   %rbx
  10782e:	48 89 fb             	mov    %rdi,%rbx
  107831:	50                   	push   %rax
	Z_SHELL_VT100_CMD(shell, SHELL_VT100_CURSORHOME);
  107832:	48 8b 7f 28          	mov    0x28(%rdi),%rdi
  107836:	31 c0                	xor    %eax,%eax
  107838:	e8 5c ff ff ff       	callq  107799 <z_shell_raw_fprintf>
	Z_SHELL_VT100_CMD(shell, SHELL_VT100_CLEARSCREEN);
  10783d:	48 8b 7b 28          	mov    0x28(%rbx),%rdi
  107841:	ba be de 11 00       	mov    $0x11debe,%edx
  107846:	31 c0                	xor    %eax,%eax
  107848:	be b7 d5 11 00       	mov    $0x11d5b7,%esi
  10784d:	e8 47 ff ff ff       	callq  107799 <z_shell_raw_fprintf>
}
  107852:	5a                   	pop    %rdx
  107853:	31 c0                	xor    %eax,%eax
  107855:	5b                   	pop    %rbx
  107856:	5d                   	pop    %rbp
  107857:	c3                   	retq   

0000000000107858 <cmd_resize_default>:

static int cmd_resize_default(const struct shell *shell,
			      size_t argc, char **argv)
{
  107858:	55                   	push   %rbp
	ARG_UNUSED(argc);
	ARG_UNUSED(argv);

	Z_SHELL_VT100_CMD(shell, SHELL_VT100_SETCOL_80);
  107859:	ba ad de 11 00       	mov    $0x11dead,%edx
  10785e:	be b7 d5 11 00       	mov    $0x11d5b7,%esi
{
  107863:	48 89 e5             	mov    %rsp,%rbp
  107866:	53                   	push   %rbx
  107867:	48 89 fb             	mov    %rdi,%rbx
  10786a:	50                   	push   %rax
	Z_SHELL_VT100_CMD(shell, SHELL_VT100_SETCOL_80);
  10786b:	48 8b 7f 28          	mov    0x28(%rdi),%rdi
  10786f:	31 c0                	xor    %eax,%eax
  107871:	e8 23 ff ff ff       	callq  107799 <z_shell_raw_fprintf>
	shell->ctx->vt100_ctx.cons.terminal_wid = SHELL_DEFAULT_TERMINAL_WIDTH;
	shell->ctx->vt100_ctx.cons.terminal_hei = SHELL_DEFAULT_TERMINAL_HEIGHT;
  107876:	48 8b 43 10          	mov    0x10(%rbx),%rax
  10787a:	c7 40 48 18 00 50 00 	movl   $0x500018,0x48(%rax)

	return 0;
}
  107881:	31 c0                	xor    %eax,%eax
  107883:	5a                   	pop    %rdx
  107884:	5b                   	pop    %rbx
  107885:	5d                   	pop    %rbp
  107886:	c3                   	retq   

0000000000107887 <cmd_shell_stats_show>:
{
  107887:	55                   	push   %rbp
	shell_print(shell, "Lost logs: %u", shell->stats->log_lost_cnt);
  107888:	48 8b 47 30          	mov    0x30(%rdi),%rax
  10788c:	ba 27 de 11 00       	mov    $0x11de27,%edx
  107891:	31 f6                	xor    %esi,%esi
  107893:	8b 08                	mov    (%rax),%ecx
  107895:	31 c0                	xor    %eax,%eax
{
  107897:	48 89 e5             	mov    %rsp,%rbp
	shell_print(shell, "Lost logs: %u", shell->stats->log_lost_cnt);
  10789a:	e8 f4 e2 ff ff       	callq  105b93 <shell_fprintf>
}
  10789f:	31 c0                	xor    %eax,%eax
  1078a1:	5d                   	pop    %rbp
  1078a2:	c3                   	retq   

00000000001078a3 <cmd_history>:
{
  1078a3:	55                   	push   %rbp
  1078a4:	48 89 e5             	mov    %rsp,%rbp
  1078a7:	41 55                	push   %r13
  1078a9:	41 54                	push   %r12
	size_t i = 0;
  1078ab:	45 31 e4             	xor    %r12d,%r12d
{
  1078ae:	53                   	push   %rbx
  1078af:	48 89 fb             	mov    %rdi,%rbx
  1078b2:	48 83 ec 18          	sub    $0x18,%rsp
				    shell->ctx->temp_buff, &len);
  1078b6:	48 8b 43 10          	mov    0x10(%rbx),%rax
		z_shell_history_get(shell->history, true,
  1078ba:	48 8b 7b 18          	mov    0x18(%rbx),%rdi
  1078be:	48 8d 4d de          	lea    -0x22(%rbp),%rcx
  1078c2:	be 01 00 00 00       	mov    $0x1,%esi
				    shell->ctx->temp_buff, &len);
  1078c7:	48 8d 90 76 01 00 00 	lea    0x176(%rax),%rdx
		z_shell_history_get(shell->history, true,
  1078ce:	e8 cb 03 00 00       	callq  107c9e <z_shell_history_get>
		if (len) {
  1078d3:	66 83 7d de 00       	cmpw   $0x0,-0x22(%rbp)
  1078d8:	4c 8b 43 10          	mov    0x10(%rbx),%r8
  1078dc:	74 25                	je     107903 <cmd_history+0x60>
			shell_print(shell, "[%3d] %s",
  1078de:	4c 89 e1             	mov    %r12,%rcx
  1078e1:	4d 8d 6c 24 01       	lea    0x1(%r12),%r13
  1078e6:	ba 36 de 11 00       	mov    $0x11de36,%edx
  1078eb:	31 f6                	xor    %esi,%esi
  1078ed:	49 81 c0 76 01 00 00 	add    $0x176,%r8
  1078f4:	48 89 df             	mov    %rbx,%rdi
  1078f7:	31 c0                	xor    %eax,%eax
  1078f9:	4d 89 ec             	mov    %r13,%r12
  1078fc:	e8 92 e2 ff ff       	callq  105b93 <shell_fprintf>
		z_shell_history_get(shell->history, true,
  107901:	eb b3                	jmp    1078b6 <cmd_history+0x13>
	shell->ctx->temp_buff[0] = '\0';
  107903:	41 c6 80 76 01 00 00 	movb   $0x0,0x176(%r8)
  10790a:	00 
}
  10790b:	48 83 c4 18          	add    $0x18,%rsp
  10790f:	31 c0                	xor    %eax,%eax
  107911:	5b                   	pop    %rbx
  107912:	41 5c                	pop    %r12
  107914:	41 5d                	pop    %r13
  107916:	5d                   	pop    %rbp
  107917:	c3                   	retq   

0000000000107918 <cmd_echo>:
{
  107918:	55                   	push   %rbp
  107919:	48 89 e5             	mov    %rsp,%rbp
	if (argc == 2) {
  10791c:	48 83 fe 02          	cmp    $0x2,%rsi
  107920:	75 20                	jne    107942 <cmd_echo+0x2a>
		shell_error(shell, "%s:%s%s", argv[0],
  107922:	4c 8b 4a 08          	mov    0x8(%rdx),%r9
  107926:	48 8b 0a             	mov    (%rdx),%rcx
  107929:	31 c0                	xor    %eax,%eax
  10792b:	41 b8 44 de 11 00    	mov    $0x11de44,%r8d
  107931:	ba 59 de 11 00       	mov    $0x11de59,%edx
  107936:	e8 58 e2 ff ff       	callq  105b93 <shell_fprintf>
  10793b:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
  107940:	eb 2f                	jmp    107971 <cmd_echo+0x59>
	return shell->ctx->internal.flags.echo == 1;
  107942:	48 8b 47 10          	mov    0x10(%rdi),%rax
	shell_print(shell, "Echo status: %s",
  107946:	b9 a3 fd 11 00       	mov    $0x11fda3,%ecx
  10794b:	ba 62 de 11 00       	mov    $0x11de62,%edx
  107950:	48 8b 80 90 02 00 00 	mov    0x290(%rax),%rax
  107957:	48 c1 e8 22          	shr    $0x22,%rax
  10795b:	a8 01                	test   $0x1,%al
  10795d:	b8 40 de 11 00       	mov    $0x11de40,%eax
  107962:	48 0f 44 c8          	cmove  %rax,%rcx
  107966:	31 c0                	xor    %eax,%eax
  107968:	31 f6                	xor    %esi,%esi
  10796a:	e8 24 e2 ff ff       	callq  105b93 <shell_fprintf>
	return 0;
  10796f:	31 c0                	xor    %eax,%eax
}
  107971:	5d                   	pop    %rbp
  107972:	c3                   	retq   

0000000000107973 <z_flag_mode_delete_set.isra.0>:
	Z_SHELL_SET_FLAG_ATOMIC(shell, mode_delete, val, ret);
  107973:	48 81 c7 94 02 00 00 	add    $0x294,%rdi
  10797a:	40 84 f6             	test   %sil,%sil
  10797d:	74 05                	je     107984 <z_flag_mode_delete_set.isra.0+0x11>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
  10797f:	f0 83 0f 40          	lock orl $0x40,(%rdi)
  107983:	c3                   	retq   
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
  107984:	f0 83 27 bf          	lock andl $0xffffffbf,(%rdi)
}
  107988:	c3                   	retq   

0000000000107989 <cmd_bacskpace_mode_backspace>:
{
  107989:	55                   	push   %rbp
	z_flag_mode_delete_set(shell, false);
  10798a:	48 8b 7f 10          	mov    0x10(%rdi),%rdi
  10798e:	31 f6                	xor    %esi,%esi
}
  107990:	31 c0                	xor    %eax,%eax
{
  107992:	48 89 e5             	mov    %rsp,%rbp
	z_flag_mode_delete_set(shell, false);
  107995:	e8 d9 ff ff ff       	callq  107973 <z_flag_mode_delete_set.isra.0>
}
  10799a:	5d                   	pop    %rbp
  10799b:	c3                   	retq   

000000000010799c <cmd_bacskpace_mode_delete>:
{
  10799c:	55                   	push   %rbp
	z_flag_mode_delete_set(shell, true);
  10799d:	48 8b 7f 10          	mov    0x10(%rdi),%rdi
  1079a1:	be 01 00 00 00       	mov    $0x1,%esi
}
  1079a6:	31 c0                	xor    %eax,%eax
{
  1079a8:	48 89 e5             	mov    %rsp,%rbp
	z_flag_mode_delete_set(shell, true);
  1079ab:	e8 c3 ff ff ff       	callq  107973 <z_flag_mode_delete_set.isra.0>
}
  1079b0:	5d                   	pop    %rbp
  1079b1:	c3                   	retq   

00000000001079b2 <cmd_resize>:

static int cmd_resize(const struct shell *shell, size_t argc, char **argv)
{
  1079b2:	55                   	push   %rbp
  1079b3:	48 89 e5             	mov    %rsp,%rbp
  1079b6:	41 55                	push   %r13
  1079b8:	41 54                	push   %r12
  1079ba:	49 89 fc             	mov    %rdi,%r12
  1079bd:	53                   	push   %rbx
  1079be:	48 83 ec 18          	sub    $0x18,%rsp
	int err;

	if (argc != 1) {
  1079c2:	48 ff ce             	dec    %rsi
  1079c5:	74 29                	je     1079f0 <cmd_resize+0x3e>
		shell_error(shell, "%s:%s%s", argv[0],
  1079c7:	4c 8b 4a 08          	mov    0x8(%rdx),%r9
  1079cb:	48 8b 0a             	mov    (%rdx),%rcx
  1079ce:	41 b8 44 de 11 00    	mov    $0x11de44,%r8d
  1079d4:	31 c0                	xor    %eax,%eax
  1079d6:	ba 59 de 11 00       	mov    $0x11de59,%edx
  1079db:	be 02 00 00 00       	mov    $0x2,%esi
			    SHELL_MSG_UNKNOWN_PARAMETER, argv[1]);
		return -EINVAL;
  1079e0:	41 bd ea ff ff ff    	mov    $0xffffffea,%r13d
		shell_error(shell, "%s:%s%s", argv[0],
  1079e6:	e8 a8 e1 ff ff       	callq  105b93 <shell_fprintf>
		return -EINVAL;
  1079eb:	e9 dc 01 00 00       	jmpq   107bcc <cmd_resize+0x21a>
	Z_SHELL_VT100_CMD(shell, SHELL_VT100_SAVECURSOR);
  1079f0:	48 8b 7f 28          	mov    0x28(%rdi),%rdi
  1079f4:	ba bb de 11 00       	mov    $0x11debb,%edx
  1079f9:	31 c0                	xor    %eax,%eax
  1079fb:	be b7 d5 11 00       	mov    $0x11d5b7,%esi
	z_shell_fprintf_buffer_flush(shell->fprintf_ctx);
  107a00:	41 bd e8 03 00 00    	mov    $0x3e8,%r13d
	uint16_t buff_idx = 0U;
  107a06:	31 db                	xor    %ebx,%ebx
  107a08:	e8 8c fd ff ff       	callq  107799 <z_shell_raw_fprintf>
	z_shell_op_cursor_vert_move(shell, -SHELL_MAX_TERMINAL_SIZE);
  107a0d:	be 06 ff ff ff       	mov    $0xffffff06,%esi
  107a12:	4c 89 e7             	mov    %r12,%rdi
  107a15:	e8 fe eb ff ff       	callq  106618 <z_shell_op_cursor_vert_move>
	z_shell_op_cursor_horiz_move(shell, SHELL_MAX_TERMINAL_SIZE);
  107a1a:	be fa 00 00 00       	mov    $0xfa,%esi
  107a1f:	4c 89 e7             	mov    %r12,%rdi
  107a22:	e8 1a ec ff ff       	callq  106641 <z_shell_op_cursor_horiz_move>
	memset(shell->ctx->temp_buff, 0, sizeof(shell->ctx->temp_buff));
  107a27:	49 8b 44 24 10       	mov    0x10(%r12),%rax
  107a2c:	31 f6                	xor    %esi,%esi
	char c = 0;
  107a2e:	c6 45 d3 00          	movb   $0x0,-0x2d(%rbp)
	memset(shell->ctx->temp_buff, 0, sizeof(shell->ctx->temp_buff));
  107a32:	ba 00 01 00 00       	mov    $0x100,%edx
  107a37:	48 8d b8 76 01 00 00 	lea    0x176(%rax),%rdi
  107a3e:	e8 6f 26 00 00       	callq  10a0b2 <memset>
	z_shell_raw_fprintf(shell->fprintf_ctx, cmd_get_terminal_size);
  107a43:	49 8b 7c 24 28       	mov    0x28(%r12),%rdi
  107a48:	be b6 de 11 00       	mov    $0x11deb6,%esi
  107a4d:	31 c0                	xor    %eax,%eax
  107a4f:	e8 45 fd ff ff       	callq  107799 <z_shell_raw_fprintf>
  107a54:	49 8b 7c 24 28       	mov    0x28(%r12),%rdi
  107a59:	e8 ba e3 ff ff       	callq  105e18 <z_shell_fprintf_buffer_flush>
			(void)shell->iface->api->read(shell->iface, &c,
  107a5e:	49 8b 7c 24 08       	mov    0x8(%r12),%rdi
  107a63:	48 8d 4d d8          	lea    -0x28(%rbp),%rcx
  107a67:	ba 01 00 00 00       	mov    $0x1,%edx
  107a6c:	48 8d 75 d3          	lea    -0x2d(%rbp),%rsi
  107a70:	48 8b 07             	mov    (%rdi),%rax
  107a73:	ff 50 20             	callq  *0x20(%rax)
			if (cnt == 0) {
  107a76:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  107a7b:	75 2d                	jne    107aaa <cmd_resize+0xf8>
static inline void k_busy_wait(uint32_t usec_to_wait)
  107a7d:	c7 45 d4 e8 03 00 00 	movl   $0x3e8,-0x2c(%rbp)
	__asm__ volatile ("mov %%cs, %[cs_val]" : [cs_val] "=r" (cs));
  107a84:	8c c8                	mov    %cs,%eax
	if (z_syscall_trap()) {
  107a86:	a8 03                	test   $0x3,%al
  107a88:	74 0d                	je     107a97 <cmd_resize+0xe5>
	register uintptr_t rdi __asm__("%rdi") = arg1;
  107a8a:	48 8b 7d d4          	mov    -0x2c(%rbp),%rdi
	register uintptr_t rax __asm__("%rax") = call_id;
  107a8e:	b8 7d 00 00 00       	mov    $0x7d,%eax
	__asm__ volatile("syscall\n\t"
  107a93:	0f 05                	syscall 
	return rax;
  107a95:	eb 08                	jmp    107a9f <cmd_resize+0xed>
	z_impl_k_busy_wait(usec_to_wait);
  107a97:	8b 7d d4             	mov    -0x2c(%rbp),%edi
  107a9a:	e8 6c bb 00 00       	callq  11360b <z_impl_k_busy_wait>
	for (uint16_t i = 0; i < 1000; i++) {
  107a9f:	66 41 ff cd          	dec    %r13w
  107aa3:	75 b9                	jne    107a5e <cmd_resize+0xac>
  107aa5:	e9 db 00 00 00       	jmpq   107b85 <cmd_resize+0x1d3>
			if ((c != SHELL_VT100_ASCII_ESC) &&
  107aaa:	8a 55 d3             	mov    -0x2d(%rbp),%dl
			    (shell->ctx->temp_buff[0] !=
  107aad:	49 8b 44 24 10       	mov    0x10(%r12),%rax
			if ((c != SHELL_VT100_ASCII_ESC) &&
  107ab2:	80 fa 1b             	cmp    $0x1b,%dl
  107ab5:	0f 84 ad 00 00 00    	je     107b68 <cmd_resize+0x1b6>
  107abb:	80 b8 76 01 00 00 1b 	cmpb   $0x1b,0x176(%rax)
  107ac2:	75 9a                	jne    107a5e <cmd_resize+0xac>
			if (c == 'R') { /* End of response from the terminal. */
  107ac4:	80 fa 52             	cmp    $0x52,%dl
  107ac7:	0f 85 9b 00 00 00    	jne    107b68 <cmd_resize+0x1b6>
				shell->ctx->temp_buff[buff_idx] = '\0';
  107acd:	0f b7 db             	movzwl %bx,%ebx
  107ad0:	31 c9                	xor    %ecx,%ecx
	*y = 0U;
  107ad2:	31 d2                	xor    %edx,%edx
				shell->ctx->temp_buff[buff_idx] = '\0';
  107ad4:	c6 84 18 76 01 00 00 	movb   $0x0,0x176(%rax,%rbx,1)
  107adb:	00 
				if (shell->ctx->temp_buff[1] != '[') {
  107adc:	80 b8 77 01 00 00 5b 	cmpb   $0x5b,0x177(%rax)
  107ae3:	0f 85 95 00 00 00    	jne    107b7e <cmd_resize+0x1cc>
				while (shell->ctx->temp_buff[buff_idx] != ';') {
  107ae9:	66 0f be bc 08 78 01 	movsbw 0x178(%rax,%rcx,1),%di
  107af0:	00 00 
					(shell->ctx->temp_buff[buff_idx++] -
  107af2:	8d 71 03             	lea    0x3(%rcx),%esi
				while (shell->ctx->temp_buff[buff_idx] != ';') {
  107af5:	40 80 ff 3b          	cmp    $0x3b,%dil
  107af9:	74 15                	je     107b10 <cmd_resize+0x15e>
					*y = *y * 10U +
  107afb:	6b d2 0a             	imul   $0xa,%edx,%edx
					if (buff_idx >=
  107afe:	48 ff c1             	inc    %rcx
					*y = *y * 10U +
  107b01:	8d 54 3a d0          	lea    -0x30(%rdx,%rdi,1),%edx
					if (buff_idx >=
  107b05:	48 81 f9 fe 00 00 00 	cmp    $0xfe,%rcx
  107b0c:	75 db                	jne    107ae9 <cmd_resize+0x137>
  107b0e:	eb 75                	jmp    107b85 <cmd_resize+0x1d3>
				if (++buff_idx >= CONFIG_SHELL_CMD_BUFF_SIZE) {
  107b10:	66 81 fe 00 01       	cmp    $0x100,%si
  107b15:	74 6e                	je     107b85 <cmd_resize+0x1d3>
  107b17:	0f b7 f6             	movzwl %si,%esi
	*x = 0U;
  107b1a:	31 c9                	xor    %ecx,%ecx
				while (shell->ctx->temp_buff[buff_idx]
  107b1c:	48 63 fe             	movslq %esi,%rdi
  107b1f:	66 0f be bc 38 76 01 	movsbw 0x176(%rax,%rdi,1),%di
  107b26:	00 00 
  107b28:	40 84 ff             	test   %dil,%dil
  107b2b:	74 12                	je     107b3f <cmd_resize+0x18d>
					*x = *x * 10U +
  107b2d:	6b c9 0a             	imul   $0xa,%ecx,%ecx
					if (buff_idx >=
  107b30:	ff c6                	inc    %esi
					*x = *x * 10U +
  107b32:	8d 4c 39 d0          	lea    -0x30(%rcx,%rdi,1),%ecx
					if (buff_idx >=
  107b36:	66 81 fe ff 00       	cmp    $0xff,%si
  107b3b:	76 df                	jbe    107b1c <cmd_resize+0x16a>
  107b3d:	eb 46                	jmp    107b85 <cmd_resize+0x1d3>
		shell->ctx->vt100_ctx.cons.terminal_wid = x;
  107b3f:	be fa 00 00 00       	mov    $0xfa,%esi
  107b44:	66 81 f9 fa 00       	cmp    $0xfa,%cx
				shell->ctx->temp_buff[0] = 0;
  107b49:	c6 80 76 01 00 00 00 	movb   $0x0,0x176(%rax)
		shell->ctx->vt100_ctx.cons.terminal_wid = x;
  107b50:	0f 47 ce             	cmova  %esi,%ecx
		shell->ctx->vt100_ctx.cons.terminal_hei = y;
  107b53:	66 81 fa fa 00       	cmp    $0xfa,%dx
  107b58:	0f 47 d6             	cmova  %esi,%edx
	int ret_val = 0;
  107b5b:	45 31 ed             	xor    %r13d,%r13d
		shell->ctx->vt100_ctx.cons.terminal_wid = x;
  107b5e:	66 89 48 4a          	mov    %cx,0x4a(%rax)
		shell->ctx->vt100_ctx.cons.terminal_hei = y;
  107b62:	66 89 50 48          	mov    %dx,0x48(%rax)
  107b66:	eb 23                	jmp    107b8b <cmd_resize+0x1d9>
			shell->ctx->temp_buff[buff_idx] = c;
  107b68:	0f b7 cb             	movzwl %bx,%ecx
			if (++buff_idx > SHELL_CURSOR_POSITION_BUFFER - 1) {
  107b6b:	ff c3                	inc    %ebx
			shell->ctx->temp_buff[buff_idx] = c;
  107b6d:	88 94 08 76 01 00 00 	mov    %dl,0x176(%rax,%rcx,1)
			if (++buff_idx > SHELL_CURSOR_POSITION_BUFFER - 1) {
  107b74:	66 83 fb 09          	cmp    $0x9,%bx
  107b78:	0f 86 e0 fe ff ff    	jbe    107a5e <cmd_resize+0xac>
				shell->ctx->temp_buff[0] = 0;
  107b7e:	c6 80 76 01 00 00 00 	movb   $0x0,0x176(%rax)
		ret_val = -ENOTSUP;
  107b85:	41 bd 7a ff ff ff    	mov    $0xffffff7a,%r13d
	Z_SHELL_VT100_CMD(shell, SHELL_VT100_RESTORECURSOR);
  107b8b:	49 8b 7c 24 28       	mov    0x28(%r12),%rdi
  107b90:	31 c0                	xor    %eax,%eax
  107b92:	ba b3 de 11 00       	mov    $0x11deb3,%edx
  107b97:	be b7 d5 11 00       	mov    $0x11d5b7,%esi
  107b9c:	e8 f8 fb ff ff       	callq  107799 <z_shell_raw_fprintf>
	}

	err = terminal_size_get(shell);
	if (err != 0) {
  107ba1:	45 85 ed             	test   %r13d,%r13d
  107ba4:	74 26                	je     107bcc <cmd_resize+0x21a>
		shell->ctx->vt100_ctx.cons.terminal_wid =
				CONFIG_SHELL_DEFAULT_TERMINAL_WIDTH;
		shell->ctx->vt100_ctx.cons.terminal_hei =
  107ba6:	49 8b 44 24 10       	mov    0x10(%r12),%rax
				CONFIG_SHELL_DEFAULT_TERMINAL_HEIGHT;
		shell_warn(shell, "No response from the terminal, assumed 80x24"
  107bab:	ba 73 de 11 00       	mov    $0x11de73,%edx
  107bb0:	be 04 00 00 00       	mov    $0x4,%esi
  107bb5:	4c 89 e7             	mov    %r12,%rdi
  107bb8:	41 bd f8 ff ff ff    	mov    $0xfffffff8,%r13d
		shell->ctx->vt100_ctx.cons.terminal_hei =
  107bbe:	c7 40 48 18 00 50 00 	movl   $0x500018,0x48(%rax)
		shell_warn(shell, "No response from the terminal, assumed 80x24"
  107bc5:	31 c0                	xor    %eax,%eax
  107bc7:	e8 c7 df ff ff       	callq  105b93 <shell_fprintf>
			   " screen size");
		return -ENOEXEC;
	}

	return 0;
}
  107bcc:	48 83 c4 18          	add    $0x18,%rsp
  107bd0:	44 89 e8             	mov    %r13d,%eax
  107bd3:	5b                   	pop    %rbx
  107bd4:	41 5c                	pop    %r12
  107bd6:	41 5d                	pop    %r13
  107bd8:	5d                   	pop    %rbp
  107bd9:	c3                   	retq   

0000000000107bda <z_flag_use_colors_set.isra.0>:
	Z_SHELL_SET_FLAG_ATOMIC(shell, use_colors, val, ret);
  107bda:	48 81 c7 94 02 00 00 	add    $0x294,%rdi
  107be1:	40 84 f6             	test   %sil,%sil
  107be4:	74 05                	je     107beb <z_flag_use_colors_set.isra.0+0x11>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
  107be6:	f0 83 0f 02          	lock orl $0x2,(%rdi)
  107bea:	c3                   	retq   
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
  107beb:	f0 83 27 fd          	lock andl $0xfffffffd,(%rdi)
}
  107bef:	c3                   	retq   

0000000000107bf0 <cmd_colors_off>:
{
  107bf0:	55                   	push   %rbp
	z_flag_use_colors_set(shell, false);
  107bf1:	48 8b 7f 10          	mov    0x10(%rdi),%rdi
  107bf5:	31 f6                	xor    %esi,%esi
}
  107bf7:	31 c0                	xor    %eax,%eax
{
  107bf9:	48 89 e5             	mov    %rsp,%rbp
	z_flag_use_colors_set(shell, false);
  107bfc:	e8 d9 ff ff ff       	callq  107bda <z_flag_use_colors_set.isra.0>
}
  107c01:	5d                   	pop    %rbp
  107c02:	c3                   	retq   

0000000000107c03 <cmd_colors_on>:
{
  107c03:	55                   	push   %rbp
	z_flag_use_colors_set(shell, true);
  107c04:	48 8b 7f 10          	mov    0x10(%rdi),%rdi
  107c08:	be 01 00 00 00       	mov    $0x1,%esi
}
  107c0d:	31 c0                	xor    %eax,%eax
{
  107c0f:	48 89 e5             	mov    %rsp,%rbp
	z_flag_use_colors_set(shell, true);
  107c12:	e8 c3 ff ff ff       	callq  107bda <z_flag_use_colors_set.isra.0>
}
  107c17:	5d                   	pop    %rbp
  107c18:	c3                   	retq   

0000000000107c19 <z_flag_echo_set.isra.0>:
	Z_SHELL_SET_FLAG_ATOMIC(shell, echo, val, ret);
  107c19:	48 81 c7 94 02 00 00 	add    $0x294,%rdi
  107c20:	40 84 f6             	test   %sil,%sil
  107c23:	74 05                	je     107c2a <z_flag_echo_set.isra.0+0x11>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
  107c25:	f0 83 0f 04          	lock orl $0x4,(%rdi)
  107c29:	c3                   	retq   
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
  107c2a:	f0 83 27 fb          	lock andl $0xfffffffb,(%rdi)
}
  107c2e:	c3                   	retq   

0000000000107c2f <cmd_echo_off>:
{
  107c2f:	55                   	push   %rbp
	z_flag_echo_set(shell, false);
  107c30:	48 8b 7f 10          	mov    0x10(%rdi),%rdi
  107c34:	31 f6                	xor    %esi,%esi
}
  107c36:	31 c0                	xor    %eax,%eax
{
  107c38:	48 89 e5             	mov    %rsp,%rbp
	z_flag_echo_set(shell, false);
  107c3b:	e8 d9 ff ff ff       	callq  107c19 <z_flag_echo_set.isra.0>
}
  107c40:	5d                   	pop    %rbp
  107c41:	c3                   	retq   

0000000000107c42 <cmd_echo_on>:
{
  107c42:	55                   	push   %rbp
	z_flag_echo_set(shell, true);
  107c43:	48 8b 7f 10          	mov    0x10(%rdi),%rdi
  107c47:	be 01 00 00 00       	mov    $0x1,%esi
}
  107c4c:	31 c0                	xor    %eax,%eax
{
  107c4e:	48 89 e5             	mov    %rsp,%rbp
	z_flag_echo_set(shell, true);
  107c51:	e8 c3 ff ff ff       	callq  107c19 <z_flag_echo_set.isra.0>
}
  107c56:	5d                   	pop    %rbp
  107c57:	c3                   	retq   

0000000000107c58 <remove_from_tail.part.0>:
	memcpy(item->data, src, len);
	sys_dlist_prepend(&history->list, &item->dnode);
}

/* Returns true if element was removed. */
static bool remove_from_tail(struct shell_history *history)
  107c58:	55                   	push   %rbp
 * @return a pointer to the tail element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_tail(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->tail;
  107c59:	48 8b 47 10          	mov    0x10(%rdi),%rax

	h_item = CONTAINER_OF(l_item, struct shell_history_item, dnode);

	total_len = offsetof(struct shell_history_item, data) +
			h_item->len + h_item->padding;
	ring_buf_get_finish(history->ring_buf, total_len);
  107c5d:	48 8b 3f             	mov    (%rdi),%rdi
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	sys_dnode_t *const prev = node->prev;
	sys_dnode_t *const next = node->next;
  107c60:	48 8b 10             	mov    (%rax),%rdx
	sys_dnode_t *const prev = node->prev;
  107c63:	48 8b 48 08          	mov    0x8(%rax),%rcx
static bool remove_from_tail(struct shell_history *history)
  107c67:	48 89 e5             	mov    %rsp,%rbp

	prev->next = next;
  107c6a:	48 89 11             	mov    %rdx,(%rcx)
	next->prev = prev;
  107c6d:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
			h_item->len + h_item->padding;
  107c71:	0f b7 50 10          	movzwl 0x10(%rax),%edx
	node->next = NULL;
  107c75:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	node->prev = NULL;
  107c7c:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  107c83:	00 
  107c84:	0f b7 40 12          	movzwl 0x12(%rax),%eax
	total_len = offsetof(struct shell_history_item, data) +
  107c88:	8d 74 02 14          	lea    0x14(%rdx,%rax,1),%esi
	ring_buf_get_finish(history->ring_buf, total_len);
  107c8c:	e8 0b ae ff ff       	callq  102a9c <ring_buf_get_finish>

	return true;
}
  107c91:	b0 01                	mov    $0x1,%al
  107c93:	5d                   	pop    %rbp
  107c94:	c3                   	retq   

0000000000107c95 <z_shell_history_mode_exit>:
	history->current = NULL;
  107c95:	48 c7 47 18 00 00 00 	movq   $0x0,0x18(%rdi)
  107c9c:	00 
}
  107c9d:	c3                   	retq   

0000000000107c9e <z_shell_history_get>:
{
  107c9e:	55                   	push   %rbp
	if (sys_dlist_is_empty(&history->list)) {
  107c9f:	48 8d 47 08          	lea    0x8(%rdi),%rax
{
  107ca3:	48 89 e5             	mov    %rsp,%rbp
  107ca6:	41 55                	push   %r13
  107ca8:	49 89 cd             	mov    %rcx,%r13
  107cab:	41 54                	push   %r12
  107cad:	53                   	push   %rbx
  107cae:	41 50                	push   %r8
	return list->head == list;
  107cb0:	48 8b 5f 08          	mov    0x8(%rdi),%rbx
	if (sys_dlist_is_empty(&history->list)) {
  107cb4:	48 39 c3             	cmp    %rax,%rbx
  107cb7:	75 0b                	jne    107cc4 <z_shell_history_get+0x26>
		*len = 0U;
  107cb9:	66 41 c7 45 00 00 00 	movw   $0x0,0x0(%r13)
		return false;
  107cc0:	31 c0                	xor    %eax,%eax
  107cc2:	eb 5d                	jmp    107d21 <z_shell_history_get+0x83>
		if (history->current == NULL) {
  107cc4:	48 8b 47 18          	mov    0x18(%rdi),%rax
  107cc8:	49 89 d4             	mov    %rdx,%r12
	if (!up) { /* button down */
  107ccb:	40 84 f6             	test   %sil,%sil
  107cce:	75 1a                	jne    107cea <z_shell_history_get+0x4c>
		if (history->current == NULL) {
  107cd0:	48 85 c0             	test   %rax,%rax
  107cd3:	74 e4                	je     107cb9 <z_shell_history_get+0x1b>
	return (node == list->head) ? NULL : node->prev;
  107cd5:	48 39 c3             	cmp    %rax,%rbx
  107cd8:	75 0a                	jne    107ce4 <z_shell_history_get+0x46>
	history->current = l_item;
  107cda:	48 c7 47 18 00 00 00 	movq   $0x0,0x18(%rdi)
  107ce1:	00 
	if (l_item) {
  107ce2:	eb d5                	jmp    107cb9 <z_shell_history_get+0x1b>
  107ce4:	48 8b 58 08          	mov    0x8(%rax),%rbx
  107ce8:	eb 0e                	jmp    107cf8 <z_shell_history_get+0x5a>
		sys_dlist_peek_head_not_empty(&history->list) :
  107cea:	48 85 c0             	test   %rax,%rax
  107ced:	74 09                	je     107cf8 <z_shell_history_get+0x5a>
	return (node == list->tail) ? NULL : node->next;
  107cef:	48 39 47 10          	cmp    %rax,0x10(%rdi)
  107cf3:	74 e5                	je     107cda <z_shell_history_get+0x3c>
  107cf5:	48 8b 18             	mov    (%rax),%rbx
	history->current = l_item;
  107cf8:	48 89 5f 18          	mov    %rbx,0x18(%rdi)
	if (l_item) {
  107cfc:	48 85 db             	test   %rbx,%rbx
  107cff:	74 b8                	je     107cb9 <z_shell_history_get+0x1b>
		memcpy(dst, h_item->data, h_item->len);
  107d01:	0f b7 53 10          	movzwl 0x10(%rbx),%edx
  107d05:	48 8d 73 14          	lea    0x14(%rbx),%rsi
  107d09:	4c 89 e7             	mov    %r12,%rdi
  107d0c:	e8 87 23 00 00       	callq  10a098 <memcpy>
		*len = h_item->len;
  107d11:	0f b7 43 10          	movzwl 0x10(%rbx),%eax
  107d15:	66 41 89 45 00       	mov    %ax,0x0(%r13)
		dst[*len] = '\0';
  107d1a:	41 c6 04 04 00       	movb   $0x0,(%r12,%rax,1)
		return true;
  107d1f:	b0 01                	mov    $0x1,%al
}
  107d21:	5a                   	pop    %rdx
  107d22:	5b                   	pop    %rbx
  107d23:	41 5c                	pop    %r12
  107d25:	41 5d                	pop    %r13
  107d27:	5d                   	pop    %rbp
  107d28:	c3                   	retq   

0000000000107d29 <z_shell_history_purge>:

void z_shell_history_purge(struct shell_history *history)
{
  107d29:	55                   	push   %rbp
  107d2a:	48 89 e5             	mov    %rsp,%rbp
  107d2d:	41 54                	push   %r12
	if (sys_dlist_is_empty(&history->list)) {
  107d2f:	4c 8d 67 08          	lea    0x8(%rdi),%r12
{
  107d33:	53                   	push   %rbx
  107d34:	48 89 fb             	mov    %rdi,%rbx
	if (sys_dlist_is_empty(&history->list)) {
  107d37:	4c 39 63 08          	cmp    %r12,0x8(%rbx)
  107d3b:	74 0c                	je     107d49 <z_shell_history_purge+0x20>
  107d3d:	48 89 df             	mov    %rbx,%rdi
  107d40:	e8 13 ff ff ff       	callq  107c58 <remove_from_tail.part.0>
	while (remove_from_tail(history)) {
  107d45:	84 c0                	test   %al,%al
  107d47:	75 ee                	jne    107d37 <z_shell_history_purge+0xe>
	}
}
  107d49:	5b                   	pop    %rbx
  107d4a:	41 5c                	pop    %r12
  107d4c:	5d                   	pop    %rbp
  107d4d:	c3                   	retq   

0000000000107d4e <z_shell_history_put>:

void z_shell_history_put(struct shell_history *history, uint8_t *line,
			 size_t len)
{
  107d4e:	55                   	push   %rbp
	sys_dnode_t *l_item; /* list item */
	struct shell_history_item *h_item;
	uint32_t total_len = len + offsetof(struct shell_history_item, data);
  107d4f:	8d 42 14             	lea    0x14(%rdx),%eax
{
  107d52:	48 89 e5             	mov    %rsp,%rbp
  107d55:	41 57                	push   %r15
  107d57:	41 56                	push   %r14
  107d59:	41 55                	push   %r13
  107d5b:	41 54                	push   %r12
	uint32_t claim_len;
	uint32_t claim2_len;
	uint16_t padding = (~total_len + 1) & (sizeof(void *) - 1);
  107d5d:	41 89 c4             	mov    %eax,%r12d
{
  107d60:	53                   	push   %rbx
	uint16_t padding = (~total_len + 1) & (sizeof(void *) - 1);
  107d61:	41 f7 dc             	neg    %r12d
  107d64:	44 89 e1             	mov    %r12d,%ecx

	/* align to word. */
	total_len += padding;
  107d67:	41 83 e4 07          	and    $0x7,%r12d
  107d6b:	41 01 c4             	add    %eax,%r12d
	uint16_t padding = (~total_len + 1) & (sizeof(void *) - 1);
  107d6e:	83 e1 07             	and    $0x7,%ecx
{
  107d71:	48 83 ec 28          	sub    $0x28,%rsp
 *
 * @return Ring buffer capacity (in 32-bit words or bytes).
 */
static inline uint32_t ring_buf_capacity_get(struct ring_buf *buf)
{
	return buf->size;
  107d75:	48 8b 07             	mov    (%rdi),%rax
  107d78:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
	uint16_t padding = (~total_len + 1) & (sizeof(void *) - 1);
  107d7c:	66 89 4d be          	mov    %cx,-0x42(%rbp)

	if (total_len > ring_buf_capacity_get(history->ring_buf)) {
  107d80:	44 3b 60 10          	cmp    0x10(%rax),%r12d
  107d84:	0f 87 57 01 00 00    	ja     107ee1 <z_shell_history_put+0x193>
	history->current = NULL;
  107d8a:	48 c7 47 18 00 00 00 	movq   $0x0,0x18(%rdi)
  107d91:	00 
  107d92:	48 89 fb             	mov    %rdi,%rbx
  107d95:	49 89 d5             	mov    %rdx,%r13
		return;
	}

	z_shell_history_mode_exit(history);

	if (len == 0) {
  107d98:	48 85 d2             	test   %rdx,%rdx
  107d9b:	0f 84 40 01 00 00    	je     107ee1 <z_shell_history_put+0x193>
		return;
	}

	l_item = sys_dlist_peek_head(&history->list);
  107da1:	4c 8d 7f 08          	lea    0x8(%rdi),%r15
	return list->head == list;
  107da5:	48 8b 7f 08          	mov    0x8(%rdi),%rdi
	return sys_dlist_is_empty(list) ? NULL : list->head;
  107da9:	49 39 ff             	cmp    %rdi,%r15
  107dac:	75 0a                	jne    107db8 <z_shell_history_put+0x6a>
	h_item = CONTAINER_OF(l_item, struct shell_history_item, dnode);
  107dae:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
  107db5:	00 

	if (l_item &&
  107db6:	eb 27                	jmp    107ddf <z_shell_history_put+0x91>
	h_item = CONTAINER_OF(l_item, struct shell_history_item, dnode);
  107db8:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
	if (l_item &&
  107dbc:	48 85 ff             	test   %rdi,%rdi
  107dbf:	74 1e                	je     107ddf <z_shell_history_put+0x91>
	   (h_item->len == len) &&
  107dc1:	0f b7 47 10          	movzwl 0x10(%rdi),%eax
	if (l_item &&
  107dc5:	48 39 d0             	cmp    %rdx,%rax
  107dc8:	75 15                	jne    107ddf <z_shell_history_put+0x91>
	   (memcmp(h_item->data, line, len) == 0)) {
  107dca:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  107dce:	48 83 c7 14          	add    $0x14,%rdi
  107dd2:	e8 63 22 00 00       	callq  10a03a <memcmp>
	   (h_item->len == len) &&
  107dd7:	85 c0                	test   %eax,%eax
  107dd9:	0f 84 02 01 00 00    	je     107ee1 <z_shell_history_put+0x193>
		/* Same command as before, do not store */
		return;
	}

	do {
		claim_len = ring_buf_put_claim(history->ring_buf,
  107ddf:	48 8b 3b             	mov    (%rbx),%rdi
  107de2:	44 89 e2             	mov    %r12d,%edx
  107de5:	48 8d 75 c8          	lea    -0x38(%rbp),%rsi
  107de9:	e8 07 ab ff ff       	callq  1028f5 <ring_buf_put_claim>
  107dee:	41 89 c6             	mov    %eax,%r14d
						(uint8_t **)&h_item, total_len);
		/* second allocation may succeed if we were at the end of the
		 * buffer.
		 */
		if (claim_len < total_len) {
  107df1:	41 39 c4             	cmp    %eax,%r12d
  107df4:	76 29                	jbe    107e1f <z_shell_history_put+0xd1>
			claim2_len =
				ring_buf_put_claim(history->ring_buf,
  107df6:	48 8b 3b             	mov    (%rbx),%rdi
  107df9:	44 89 e2             	mov    %r12d,%edx
  107dfc:	48 8d 75 c8          	lea    -0x38(%rbp),%rsi
  107e00:	e8 f0 aa ff ff       	callq  1028f5 <ring_buf_put_claim>
						   (uint8_t **)&h_item, total_len);
			if (claim2_len == total_len) {
  107e05:	41 39 c4             	cmp    %eax,%r12d
  107e08:	75 5e                	jne    107e68 <z_shell_history_put+0x11a>
				ring_buf_put_finish(history->ring_buf,
  107e0a:	48 8b 3b             	mov    (%rbx),%rdi
  107e0d:	44 89 f6             	mov    %r14d,%esi
  107e10:	e8 20 ab ff ff       	callq  102935 <ring_buf_put_finish>
						    claim_len);
				padding += claim_len;
  107e15:	66 44 01 75 be       	add    %r14w,-0x42(%rbp)
  107e1a:	45 89 e6             	mov    %r12d,%r14d
  107e1d:	eb 02                	jmp    107e21 <z_shell_history_put+0xd3>
				claim_len = total_len;
			}
		}

		if (claim_len == total_len) {
  107e1f:	75 47                	jne    107e68 <z_shell_history_put+0x11a>
			add_to_head(history, h_item, line, len, padding);
  107e21:	4c 8b 65 c8          	mov    -0x38(%rbp),%r12
	item->padding = padding;
  107e25:	66 8b 45 be          	mov    -0x42(%rbp),%ax
	memcpy(item->data, src, len);
  107e29:	4c 89 ea             	mov    %r13,%rdx
  107e2c:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
	item->len = len;
  107e30:	66 45 89 6c 24 10    	mov    %r13w,0x10(%r12)
	memcpy(item->data, src, len);
  107e36:	49 8d 7c 24 14       	lea    0x14(%r12),%rdi
	item->padding = padding;
  107e3b:	66 41 89 44 24 12    	mov    %ax,0x12(%r12)
	memcpy(item->data, src, len);
  107e41:	e8 52 22 00 00       	callq  10a098 <memcpy>
	sys_dnode_t *const head = list->head;
  107e46:	48 8b 43 08          	mov    0x8(%rbx),%rax
			ring_buf_put_finish(history->ring_buf, claim_len);
  107e4a:	48 8b 3b             	mov    (%rbx),%rdi
  107e4d:	44 89 f6             	mov    %r14d,%esi
	node->prev = list;
  107e50:	4d 89 7c 24 08       	mov    %r15,0x8(%r12)
	node->next = head;
  107e55:	49 89 04 24          	mov    %rax,(%r12)
	head->prev = node;
  107e59:	4c 89 60 08          	mov    %r12,0x8(%rax)
	list->head = node;
  107e5d:	4c 89 63 08          	mov    %r12,0x8(%rbx)
  107e61:	e8 cf aa ff ff       	callq  102935 <ring_buf_put_finish>
			break;
  107e66:	eb 79                	jmp    107ee1 <z_shell_history_put+0x193>
		}

		ring_buf_put_finish(history->ring_buf, 0);
  107e68:	48 8b 3b             	mov    (%rbx),%rdi
  107e6b:	31 f6                	xor    %esi,%esi
  107e6d:	e8 c3 aa ff ff       	callq  102935 <ring_buf_put_finish>
	if (sys_dlist_is_empty(&history->list)) {
  107e72:	4c 3b 7b 08          	cmp    0x8(%rbx),%r15
  107e76:	75 38                	jne    107eb0 <z_shell_history_put+0x162>
		if (remove_from_tail(history) == false) {
			__ASSERT_NO_MSG(ring_buf_is_empty(history->ring_buf));
  107e78:	48 8b 3b             	mov    (%rbx),%rdi
  107e7b:	e8 3a aa ff ff       	callq  1028ba <ring_buf_is_empty>
  107e80:	85 c0                	test   %eax,%eax
  107e82:	75 3e                	jne    107ec2 <z_shell_history_put+0x174>
  107e84:	b9 bd 00 00 00       	mov    $0xbd,%ecx
  107e89:	ba 85 e2 11 00       	mov    $0x11e285,%edx
  107e8e:	be b5 e2 11 00       	mov    $0x11e2b5,%esi
  107e93:	31 c0                	xor    %eax,%eax
  107e95:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  107e9a:	e8 59 87 ff ff       	callq  1005f8 <printk>
  107e9f:	be bd 00 00 00       	mov    $0xbd,%esi
  107ea4:	bf 85 e2 11 00       	mov    $0x11e285,%edi
  107ea9:	e8 ea ac ff ff       	callq  102b98 <assert_post_action>
  107eae:	eb 12                	jmp    107ec2 <z_shell_history_put+0x174>
  107eb0:	48 89 df             	mov    %rbx,%rdi
  107eb3:	e8 a0 fd ff ff       	callq  107c58 <remove_from_tail.part.0>
		if (remove_from_tail(history) == false) {
  107eb8:	84 c0                	test   %al,%al
  107eba:	0f 85 1f ff ff ff    	jne    107ddf <z_shell_history_put+0x91>
  107ec0:	eb b6                	jmp    107e78 <z_shell_history_put+0x12a>
			 * continues memory in worst case equals half of the
			 * ring buffer capacity. By reseting ring buffer we
			 * ensure that it is capable to provide continues memory
			 * of ring buffer capacity length.
			 */
			ring_buf_reset(history->ring_buf);
  107ec2:	48 8b 3b             	mov    (%rbx),%rdi
	memset(&buf->misc, 0, sizeof(buf->misc));
  107ec5:	ba 08 00 00 00       	mov    $0x8,%edx
  107eca:	31 f6                	xor    %esi,%esi
	buf->head = 0;
  107ecc:	48 c7 07 00 00 00 00 	movq   $0x0,(%rdi)
	memset(&buf->misc, 0, sizeof(buf->misc));
  107ed3:	48 83 c7 08          	add    $0x8,%rdi
  107ed7:	e8 d6 21 00 00       	callq  10a0b2 <memset>
}
  107edc:	e9 fe fe ff ff       	jmpq   107ddf <z_shell_history_put+0x91>
		}
	} while (1);
}
  107ee1:	48 83 c4 28          	add    $0x28,%rsp
  107ee5:	5b                   	pop    %rbx
  107ee6:	41 5c                	pop    %r12
  107ee8:	41 5d                	pop    %r13
  107eea:	41 5e                	pop    %r14
  107eec:	41 5f                	pop    %r15
  107eee:	5d                   	pop    %rbp
  107eef:	c3                   	retq   

0000000000107ef0 <z_shell_history_init>:

void z_shell_history_init(struct shell_history *history)
{
	sys_dlist_init(&history->list);
  107ef0:	48 8d 47 08          	lea    0x8(%rdi),%rax
	history->current = NULL;
  107ef4:	48 c7 47 18 00 00 00 	movq   $0x0,0x18(%rdi)
  107efb:	00 
	list->head = (sys_dnode_t *)list;
  107efc:	48 89 47 08          	mov    %rax,0x8(%rdi)
	list->tail = (sys_dnode_t *)list;
  107f00:	48 89 47 10          	mov    %rax,0x10(%rdi)
}
  107f04:	c3                   	retq   

0000000000107f05 <z_shell_has_wildcard>:
	return str == NULL ? 0U : (uint16_t)strlen(str);
  107f05:	48 85 ff             	test   %rdi,%rdi
  107f08:	74 3d                	je     107f47 <z_shell_has_wildcard+0x42>

	return ret_val;
}

bool z_shell_has_wildcard(const char *str)
{
  107f0a:	55                   	push   %rbp
  107f0b:	48 89 e5             	mov    %rsp,%rbp
  107f0e:	53                   	push   %rbx
  107f0f:	48 89 fb             	mov    %rdi,%rbx
  107f12:	51                   	push   %rcx
  107f13:	e8 c4 20 00 00       	callq  109fdc <strlen>
	uint16_t str_len = z_shell_strlen(str);

	for (size_t i = 0; i < str_len; i++) {
  107f18:	31 d2                	xor    %edx,%edx
  107f1a:	0f b7 c8             	movzwl %ax,%ecx
  107f1d:	48 39 ca             	cmp    %rcx,%rdx
  107f20:	72 04                	jb     107f26 <z_shell_has_wildcard+0x21>
		if ((str[i] == '?') || (str[i] == '*')) {
			return true;
		}
	}

	return false;
  107f22:	31 c0                	xor    %eax,%eax
  107f24:	eb 1d                	jmp    107f43 <z_shell_has_wildcard+0x3e>
		if ((str[i] == '?') || (str[i] == '*')) {
  107f26:	40 8a 34 13          	mov    (%rbx,%rdx,1),%sil
  107f2a:	40 80 fe 3f          	cmp    $0x3f,%sil
  107f2e:	0f 94 c0             	sete   %al
  107f31:	40 80 fe 2a          	cmp    $0x2a,%sil
  107f35:	40 0f 94 c6          	sete   %sil
  107f39:	40 08 f0             	or     %sil,%al
  107f3c:	75 05                	jne    107f43 <z_shell_has_wildcard+0x3e>
	for (size_t i = 0; i < str_len; i++) {
  107f3e:	48 ff c2             	inc    %rdx
  107f41:	eb da                	jmp    107f1d <z_shell_has_wildcard+0x18>
}
  107f43:	5a                   	pop    %rdx
  107f44:	5b                   	pop    %rbx
  107f45:	5d                   	pop    %rbp
  107f46:	c3                   	retq   
	return false;
  107f47:	31 c0                	xor    %eax,%eax
}
  107f49:	c3                   	retq   

0000000000107f4a <z_shell_wildcard_prepare>:

void z_shell_wildcard_prepare(const struct shell *shell)
{
  107f4a:	55                   	push   %rbp
	 *    buffer with all expanded commands is copied to Command buffer.
	 * 7. Deepest found handler is executed and all lower level commands,
	 *    including expanded commands, are passed as arguments.
	 */

	memset(shell->ctx->temp_buff, 0, sizeof(shell->ctx->temp_buff));
  107f4b:	31 f6                	xor    %esi,%esi
{
  107f4d:	48 89 e5             	mov    %rsp,%rbp
  107f50:	53                   	push   %rbx
  107f51:	48 89 fb             	mov    %rdi,%rbx
  107f54:	52                   	push   %rdx
	memset(shell->ctx->temp_buff, 0, sizeof(shell->ctx->temp_buff));
  107f55:	48 8b 47 10          	mov    0x10(%rdi),%rax
  107f59:	ba 00 01 00 00       	mov    $0x100,%edx
  107f5e:	48 8d b8 76 01 00 00 	lea    0x176(%rax),%rdi
  107f65:	e8 48 21 00 00       	callq  10a0b2 <memset>
	memcpy(shell->ctx->temp_buff,
			shell->ctx->cmd_buff,
			shell->ctx->cmd_buff_len);
  107f6a:	48 8b 7b 10          	mov    0x10(%rbx),%rdi
	memcpy(shell->ctx->temp_buff,
  107f6e:	0f b7 57 70          	movzwl 0x70(%rdi),%edx
			shell->ctx->cmd_buff,
  107f72:	48 8d 77 76          	lea    0x76(%rdi),%rsi
	memcpy(shell->ctx->temp_buff,
  107f76:	48 81 c7 76 01 00 00 	add    $0x176,%rdi
  107f7d:	e8 16 21 00 00       	callq  10a098 <memcpy>

	/* Function shell_spaces_trim must be used instead of shell_make_argv.
	 * At this point it is important to keep temp_buff as one string.
	 * It will allow to find wildcard commands easily with strstr function.
	 */
	z_shell_spaces_trim(shell->ctx->temp_buff);
  107f82:	48 8b 43 10          	mov    0x10(%rbx),%rax
  107f86:	48 8d b8 76 01 00 00 	lea    0x176(%rax),%rdi
  107f8d:	e8 5d e4 ff ff       	callq  1063ef <z_shell_spaces_trim>
  107f92:	48 8b 7b 10          	mov    0x10(%rbx),%rdi
  107f96:	48 81 c7 76 01 00 00 	add    $0x176,%rdi
  107f9d:	74 07                	je     107fa6 <z_shell_wildcard_prepare+0x5c>
  107f9f:	e8 38 20 00 00       	callq  109fdc <strlen>
  107fa4:	eb 02                	jmp    107fa8 <z_shell_wildcard_prepare+0x5e>
  107fa6:	31 c0                	xor    %eax,%eax

	/* +1 for EOS*/
	shell->ctx->cmd_tmp_buff_len = z_shell_strlen(shell->ctx->temp_buff) + 1;
  107fa8:	48 8b 53 10          	mov    0x10(%rbx),%rdx
  107fac:	ff c0                	inc    %eax
  107fae:	66 89 42 74          	mov    %ax,0x74(%rdx)
}
  107fb2:	58                   	pop    %rax
  107fb3:	5b                   	pop    %rbx
  107fb4:	5d                   	pop    %rbp
  107fb5:	c3                   	retq   

0000000000107fb6 <z_shell_wildcard_process>:


enum shell_wildcard_status z_shell_wildcard_process(const struct shell *shell,
					const struct shell_static_entry *cmd,
					const char *pattern)
{
  107fb6:	55                   	push   %rbp
  107fb7:	48 89 e5             	mov    %rsp,%rbp
  107fba:	41 57                	push   %r15
  107fbc:	41 56                	push   %r14
  107fbe:	41 55                	push   %r13
  107fc0:	41 54                	push   %r12
  107fc2:	53                   	push   %rbx
  107fc3:	48 83 ec 68          	sub    $0x68,%rsp
  107fc7:	48 89 7d 98          	mov    %rdi,-0x68(%rbp)
  107fcb:	48 89 75 88          	mov    %rsi,-0x78(%rbp)
	enum shell_wildcard_status ret_val = SHELL_WILDCARD_NOT_FOUND;

	if (cmd == NULL) {
  107fcf:	48 85 f6             	test   %rsi,%rsi
  107fd2:	75 0b                	jne    107fdf <z_shell_wildcard_process+0x29>
		return ret_val;
  107fd4:	41 be 03 00 00 00    	mov    $0x3,%r14d
  107fda:	e9 4b 01 00 00       	jmpq   10812a <z_shell_wildcard_process+0x174>
	}

	if (!z_shell_has_wildcard(pattern)) {
  107fdf:	48 89 d7             	mov    %rdx,%rdi
  107fe2:	49 89 d4             	mov    %rdx,%r12
  107fe5:	e8 1b ff ff ff       	callq  107f05 <z_shell_has_wildcard>
  107fea:	84 c0                	test   %al,%al
  107fec:	74 e6                	je     107fd4 <z_shell_wildcard_process+0x1e>
	size_t cnt = 0;
  107fee:	48 c7 45 90 00 00 00 	movq   $0x0,-0x70(%rbp)
  107ff5:	00 
	size_t cmd_idx = 0;
  107ff6:	31 f6                	xor    %esi,%esi
	enum shell_wildcard_status ret_val = SHELL_WILDCARD_CMD_NO_MATCH_FOUND;
  107ff8:	41 be 02 00 00 00    	mov    $0x2,%r14d
	while ((entry = z_shell_cmd_get(cmd, cmd_idx++, &dloc)) != NULL) {
  107ffe:	48 8b 7d 88          	mov    -0x78(%rbp),%rdi
  108002:	48 8d 46 01          	lea    0x1(%rsi),%rax
  108006:	48 8d 55 a8          	lea    -0x58(%rbp),%rdx
  10800a:	48 89 45 80          	mov    %rax,-0x80(%rbp)
  10800e:	e8 2e e2 ff ff       	callq  106241 <z_shell_cmd_get>
  108013:	48 89 c3             	mov    %rax,%rbx
  108016:	48 85 c0             	test   %rax,%rax
  108019:	0f 84 e9 00 00 00    	je     108108 <z_shell_wildcard_process+0x152>
		if (fnmatch(pattern, entry->syntax, 0) == 0) {
  10801f:	48 8b 33             	mov    (%rbx),%rsi
  108022:	31 d2                	xor    %edx,%edx
  108024:	4c 89 e7             	mov    %r12,%rdi
  108027:	e8 8f b0 ff ff       	callq  1030bb <fnmatch>
  10802c:	85 c0                	test   %eax,%eax
  10802e:	0f 85 c5 00 00 00    	jne    1080f9 <z_shell_wildcard_process+0x143>
			ret_val = command_add(shell->ctx->temp_buff,
  108034:	4c 8b 3b             	mov    (%rbx),%r15
					      &shell->ctx->cmd_tmp_buff_len,
  108037:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  10803b:	31 db                	xor    %ebx,%ebx
  10803d:	4c 8b 70 10          	mov    0x10(%rax),%r14
  108041:	4d 85 ff             	test   %r15,%r15
  108044:	74 0a                	je     108050 <z_shell_wildcard_process+0x9a>
  108046:	4c 89 ff             	mov    %r15,%rdi
  108049:	e8 8e 1f 00 00       	callq  109fdc <strlen>
  10804e:	89 c3                	mov    %eax,%ebx
	if ((*buff_len + cmd_len + 1) > CONFIG_SHELL_CMD_BUFF_SIZE) {
  108050:	41 0f b7 56 74       	movzwl 0x74(%r14),%edx
  108055:	0f b7 c3             	movzwl %bx,%eax
  108058:	8d 44 02 01          	lea    0x1(%rdx,%rax,1),%eax
  10805c:	3d 00 01 00 00       	cmp    $0x100,%eax
  108061:	7e 23                	jle    108086 <z_shell_wildcard_process+0xd0>
				z_shell_fprintf(shell, SHELL_WARNING,
  108063:	48 8b 7d 98          	mov    -0x68(%rbp),%rdi
  108067:	4c 89 e1             	mov    %r12,%rcx
  10806a:	ba da e2 11 00       	mov    $0x11e2da,%edx
  10806f:	31 c0                	xor    %eax,%eax
  108071:	be 04 00 00 00       	mov    $0x4,%esi
			ret_val = command_add(shell->ctx->temp_buff,
  108076:	41 be 01 00 00 00    	mov    $0x1,%r14d
				z_shell_fprintf(shell, SHELL_WARNING,
  10807c:	e8 aa eb ff ff       	callq  106c2b <z_shell_fprintf>
				break;
  108081:	e9 82 00 00 00       	jmpq   108108 <z_shell_wildcard_process+0x152>
			ret_val = command_add(shell->ctx->temp_buff,
  108086:	49 8d be 76 01 00 00 	lea    0x176(%r14),%rdi
	completion_addr = strstr(buff, pattern);
  10808d:	4c 89 e6             	mov    %r12,%rsi
  108090:	e8 6e 1e 00 00       	callq  109f03 <strstr>
  108095:	49 89 c5             	mov    %rax,%r13
	if (!completion_addr) {
  108098:	48 85 c0             	test   %rax,%rax
  10809b:	74 65                	je     108102 <z_shell_wildcard_process+0x14c>
  10809d:	48 89 c7             	mov    %rax,%rdi
  1080a0:	e8 37 1f 00 00       	callq  109fdc <strlen>
	memmove(completion_addr + cmd_len + 1, completion_addr, shift + 1);
  1080a5:	44 0f b7 c3          	movzwl %bx,%r8d
  1080a9:	4c 89 ee             	mov    %r13,%rsi
  1080ac:	0f b7 c0             	movzwl %ax,%eax
  1080af:	4b 8d 7c 05 01       	lea    0x1(%r13,%r8,1),%rdi
  1080b4:	4c 89 85 78 ff ff ff 	mov    %r8,-0x88(%rbp)
  1080bb:	48 8d 50 01          	lea    0x1(%rax),%rdx
  1080bf:	e8 9e 1f 00 00       	callq  10a062 <memmove>
	memcpy(completion_addr, cmd, cmd_len);
  1080c4:	4c 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%r8
  1080cb:	4c 89 fe             	mov    %r15,%rsi
  1080ce:	4c 89 ef             	mov    %r13,%rdi
  1080d1:	4c 89 c2             	mov    %r8,%rdx
  1080d4:	e8 bf 1f 00 00       	callq  10a098 <memcpy>
	completion_addr[cmd_len] = ' ';
  1080d9:	4c 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%r8
			cnt++;
  1080e0:	48 ff 45 90          	incq   -0x70(%rbp)
	completion_addr[cmd_len] = ' ';
  1080e4:	43 c6 44 05 00 20    	movb   $0x20,0x0(%r13,%r8,1)
	*buff_len += cmd_len + 1; /* + 1 for space */
  1080ea:	66 41 03 5e 74       	add    0x74(%r14),%bx
  1080ef:	ff c3                	inc    %ebx
  1080f1:	66 41 89 5e 74       	mov    %bx,0x74(%r14)
			ret_val = command_add(shell->ctx->temp_buff,
  1080f6:	45 31 f6             	xor    %r14d,%r14d
  1080f9:	48 8b 75 80          	mov    -0x80(%rbp),%rsi
  1080fd:	e9 fc fe ff ff       	jmpq   107ffe <z_shell_wildcard_process+0x48>
		return SHELL_WILDCARD_CMD_NO_MATCH_FOUND;
  108102:	41 be 02 00 00 00    	mov    $0x2,%r14d
	if (cnt > 0) {
  108108:	48 83 7d 90 00       	cmpq   $0x0,-0x70(%rbp)
  10810d:	74 1b                	je     10812a <z_shell_wildcard_process+0x174>
				       &shell->ctx->cmd_tmp_buff_len, pattern);
  10810f:	48 8b 45 98          	mov    -0x68(%rbp),%rax
		z_shell_pattern_remove(shell->ctx->temp_buff,
  108113:	4c 89 e2             	mov    %r12,%rdx
				       &shell->ctx->cmd_tmp_buff_len, pattern);
  108116:	48 8b 78 10          	mov    0x10(%rax),%rdi
		z_shell_pattern_remove(shell->ctx->temp_buff,
  10811a:	48 8d 77 74          	lea    0x74(%rdi),%rsi
  10811e:	48 81 c7 76 01 00 00 	add    $0x176,%rdi
  108125:	e8 98 e0 ff ff       	callq  1061c2 <z_shell_pattern_remove>
	 * and it will try to add matching commands.
	 */
	ret_val = commands_expand(shell, cmd, pattern);

	return ret_val;
}
  10812a:	48 83 c4 68          	add    $0x68,%rsp
  10812e:	44 89 f0             	mov    %r14d,%eax
  108131:	5b                   	pop    %rbx
  108132:	41 5c                	pop    %r12
  108134:	41 5d                	pop    %r13
  108136:	41 5e                	pop    %r14
  108138:	41 5f                	pop    %r15
  10813a:	5d                   	pop    %rbp
  10813b:	c3                   	retq   

000000000010813c <z_shell_wildcard_finalize>:

void z_shell_wildcard_finalize(const struct shell *shell)
{
  10813c:	55                   	push   %rbp
  10813d:	48 89 e5             	mov    %rsp,%rbp
  108140:	53                   	push   %rbx
  108141:	48 89 fb             	mov    %rdi,%rbx
  108144:	50                   	push   %rax
	memcpy(shell->ctx->cmd_buff,
	       shell->ctx->temp_buff,
	       shell->ctx->cmd_tmp_buff_len);
  108145:	48 8b 7f 10          	mov    0x10(%rdi),%rdi
	memcpy(shell->ctx->cmd_buff,
  108149:	0f b7 57 74          	movzwl 0x74(%rdi),%edx
	       shell->ctx->temp_buff,
  10814d:	48 8d b7 76 01 00 00 	lea    0x176(%rdi),%rsi
	memcpy(shell->ctx->cmd_buff,
  108154:	48 83 c7 76          	add    $0x76,%rdi
  108158:	e8 3b 1f 00 00       	callq  10a098 <memcpy>
	shell->ctx->cmd_buff_len = shell->ctx->cmd_tmp_buff_len;
  10815d:	48 8b 43 10          	mov    0x10(%rbx),%rax
  108161:	8b 50 74             	mov    0x74(%rax),%edx
  108164:	66 89 50 70          	mov    %dx,0x70(%rax)
}
  108168:	5a                   	pop    %rdx
  108169:	5b                   	pop    %rbx
  10816a:	5d                   	pop    %rbp
  10816b:	c3                   	retq   

000000000010816c <sys_trace_idle>:
  10816c:	c3                   	retq   

000000000010816d <arch_cpu_idle>:
#include <tracing/tracing.h>
#include <arch/cpu.h>

__pinned_func
void arch_cpu_idle(void)
{
  10816d:	55                   	push   %rbp
  10816e:	48 89 e5             	mov    %rsp,%rbp
	sys_trace_idle();
  108171:	e8 f6 ff ff ff       	callq  10816c <sys_trace_idle>
	__asm__ volatile (
  108176:	fb                   	sti    
  108177:	f4                   	hlt    
	    "sti\n\t"
	    "hlt\n\t");
}
  108178:	5d                   	pop    %rbp
  108179:	c3                   	retq   

000000000010817a <z_x86_prep_c>:
/* Early global initialization functions, C domain. This runs only on the first
 * CPU for SMP systems.
 */
__boot_func
FUNC_NORETURN void z_x86_prep_c(void *arg)
{
  10817a:	55                   	push   %rbp
	struct multiboot_info *info = arg;

	_kernel.cpus[0].nested = 0;
  10817b:	c7 05 bb 05 02 00 00 	movl   $0x0,0x205bb(%rip)        # 128740 <_kernel>
  108182:	00 00 00 
{
  108185:	48 89 e5             	mov    %rsp,%rbp

#ifdef CONFIG_MMU
	z_x86_mmu_init();
  108188:	e8 08 12 00 00       	callq  109395 <z_x86_mmu_init>
#endif

#if defined(CONFIG_LOAPIC)
	z_loapic_enable(0);
  10818d:	31 ff                	xor    %edi,%edi
  10818f:	e8 74 27 00 00       	callq  10a908 <z_loapic_enable>
#endif

#ifdef CONFIG_X86_VERY_EARLY_CONSOLE
	z_x86_early_serial_init();
  108194:	e8 15 17 00 00       	callq  1098ae <z_x86_early_serial_init>
#endif

#ifdef CONFIG_X86_64
	x86_64_irq_init();
  108199:	e8 0c 18 00 00       	callq  1099aa <x86_64_irq_init>
	ARG_UNUSED(info);
#endif

#if CONFIG_X86_STACK_PROTECTION
	for (int i = 0; i < CONFIG_MP_NUM_CPUS; i++) {
		z_x86_set_stack_guard(z_interrupt_stacks[i]);
  10819e:	bf 00 b0 5c 00       	mov    $0x5cb000,%edi
  1081a3:	e8 ee 11 00 00       	callq  109396 <z_x86_set_stack_guard>

#if defined(CONFIG_SMP)
	z_x86_ipi_setup();
#endif

	z_cstart();
  1081a8:	e8 9b 50 00 00       	callq  10d248 <z_cstart>

00000000001081ad <z_x86_check_stack_bounds>:
}

#ifdef CONFIG_THREAD_STACK_INFO
__pinned_func
bool z_x86_check_stack_bounds(uintptr_t addr, size_t size, uint16_t cs)
{
  1081ad:	89 d1                	mov    %edx,%ecx
	uintptr_t start, end;

	if (_current == NULL || arch_is_in_isr()) {
  1081af:	48 8b 15 9a 05 02 00 	mov    0x2059a(%rip),%rdx        # 128750 <_kernel+0x10>
  1081b6:	48 85 d2             	test   %rdx,%rdx
  1081b9:	74 09                	je     1081c4 <z_x86_check_stack_bounds+0x17>
  1081bb:	83 3d 7e 05 02 00 00 	cmpl   $0x0,0x2057e(%rip)        # 128740 <_kernel>
  1081c2:	74 0c                	je     1081d0 <z_x86_check_stack_bounds+0x23>
#ifdef CONFIG_SMP
		cpu_id = arch_curr_cpu()->id;
#else
		cpu_id = 0;
#endif
		start = (uintptr_t)Z_KERNEL_STACK_BUFFER(
  1081c4:	b8 00 c0 5c 00       	mov    $0x5cc000,%eax
		    z_interrupt_stacks[cpu_id]);
		end = start + CONFIG_ISR_STACK_SIZE;
  1081c9:	ba 00 00 5d 00       	mov    $0x5d0000,%edx
	if (_current == NULL || arch_is_in_isr()) {
  1081ce:	eb 2e                	jmp    1081fe <z_x86_check_stack_bounds+0x51>
#ifdef CONFIG_USERSPACE
	} else if ((cs & 0x3U) == 0U &&
  1081d0:	80 e1 03             	and    $0x3,%cl
		 * corresponding to ring 0 / ring 3.
		 *
		 * If we get here, we must have been doing a syscall, check
		 * privilege elevation stack bounds
		 */
		start = _current->stack_info.start - CONFIG_MMU_PAGE_SIZE;
  1081d3:	48 8b 82 08 01 00 00 	mov    0x108(%rdx),%rax
	} else if ((cs & 0x3U) == 0U &&
  1081da:	75 11                	jne    1081ed <z_x86_check_stack_bounds+0x40>
  1081dc:	f6 42 18 04          	testb  $0x4,0x18(%rdx)
  1081e0:	74 0b                	je     1081ed <z_x86_check_stack_bounds+0x40>
		end = _current->stack_info.start;
  1081e2:	48 89 c2             	mov    %rax,%rdx
		start = _current->stack_info.start - CONFIG_MMU_PAGE_SIZE;
  1081e5:	48 2d 00 10 00 00    	sub    $0x1000,%rax
		end = _current->stack_info.start;
  1081eb:	eb 11                	jmp    1081fe <z_x86_check_stack_bounds+0x51>
#endif /* CONFIG_USERSPACE */
	} else {
		/* Normal thread operation, check its stack buffer */
		start = _current->stack_info.start;
		end = Z_STACK_PTR_ALIGN(_current->stack_info.start +
  1081ed:	48 8b 8a 10 01 00 00 	mov    0x110(%rdx),%rcx
  1081f4:	48 01 c1             	add    %rax,%rcx
  1081f7:	48 89 ca             	mov    %rcx,%rdx
 * @param ptr Proposed stack pointer address
 * @return Properly aligned stack pointer address
 */
static inline char *z_stack_ptr_align(char *ptr)
{
	return (char *)ROUND_DOWN(ptr, ARCH_STACK_PTR_ALIGN);
  1081fa:	48 83 e2 f0          	and    $0xfffffffffffffff0,%rdx
					_current->stack_info.size);
	}

	return (addr <= start) || (addr + size > end);
  1081fe:	b9 01 00 00 00       	mov    $0x1,%ecx
  108203:	48 39 f8             	cmp    %rdi,%rax
  108206:	73 0b                	jae    108213 <z_x86_check_stack_bounds+0x66>
  108208:	48 01 f7             	add    %rsi,%rdi
  10820b:	31 c9                	xor    %ecx,%ecx
  10820d:	48 39 d7             	cmp    %rdx,%rdi
  108210:	0f 97 c1             	seta   %cl
  108213:	89 c8                	mov    %ecx,%eax
  108215:	83 e0 01             	and    $0x1,%eax
}
  108218:	c3                   	retq   

0000000000108219 <z_x86_fatal_error>:
#endif /* CONFIG_EXCEPTION_DEBUG */

__pinned_func
FUNC_NORETURN void z_x86_fatal_error(unsigned int reason,
				     const z_arch_esf_t *esf)
{
  108219:	55                   	push   %rbp
  10821a:	48 89 e5             	mov    %rsp,%rbp
  10821d:	41 55                	push   %r13
  10821f:	41 89 fd             	mov    %edi,%r13d
  108222:	41 54                	push   %r12
  108224:	49 89 f4             	mov    %rsi,%r12
	if (esf != NULL) {
  108227:	48 85 f6             	test   %rsi,%rsi
  10822a:	0f 84 1a 01 00 00    	je     10834a <z_x86_fatal_error+0x131>
	LOG_ERR("RAX: 0x%016lx RBX: 0x%016lx RCX: 0x%016lx RDX: 0x%016lx",
  108230:	48 8b 56 30          	mov    0x30(%rsi),%rdx
  108234:	4c 8b 4e 40          	mov    0x40(%rsi),%r9
  108238:	bf 2c e3 11 00       	mov    $0x11e32c,%edi
  10823d:	31 c0                	xor    %eax,%eax
  10823f:	4c 8b 46 38          	mov    0x38(%rsi),%r8
  108243:	48 8b 0e             	mov    (%rsi),%rcx
  108246:	be 45 00 00 00       	mov    $0x45,%esi
  10824b:	e8 76 ae ff ff       	callq  1030c6 <z_log_minimal_printk>
	LOG_ERR("RSI: 0x%016lx RDI: 0x%016lx RBP: 0x%016lx RSP: 0x%016lx",
  108250:	49 8b 4c 24 50       	mov    0x50(%r12),%rcx
  108255:	49 8b 54 24 48       	mov    0x48(%r12),%rdx
  10825a:	be 45 00 00 00       	mov    $0x45,%esi
  10825f:	4d 8b 8c 24 a0 02 00 	mov    0x2a0(%r12),%r9
  108266:	00 
  108267:	4d 8b 44 24 28       	mov    0x28(%r12),%r8
  10826c:	bf 69 e3 11 00       	mov    $0x11e369,%edi
  108271:	31 c0                	xor    %eax,%eax
  108273:	e8 4e ae ff ff       	callq  1030c6 <z_log_minimal_printk>
	LOG_ERR(" R8: 0x%016lx  R9: 0x%016lx R10: 0x%016lx R11: 0x%016lx",
  108278:	49 8b 4c 24 60       	mov    0x60(%r12),%rcx
  10827d:	49 8b 54 24 58       	mov    0x58(%r12),%rdx
  108282:	be 45 00 00 00       	mov    $0x45,%esi
  108287:	4d 8b 8c 24 70 02 00 	mov    0x270(%r12),%r9
  10828e:	00 
  10828f:	4d 8b 44 24 68       	mov    0x68(%r12),%r8
  108294:	bf a6 e3 11 00       	mov    $0x11e3a6,%edi
  108299:	31 c0                	xor    %eax,%eax
  10829b:	e8 26 ae ff ff       	callq  1030c6 <z_log_minimal_printk>
	LOG_ERR("R12: 0x%016lx R13: 0x%016lx R14: 0x%016lx R15: 0x%016lx",
  1082a0:	4d 8b 44 24 18       	mov    0x18(%r12),%r8
  1082a5:	49 8b 4c 24 10       	mov    0x10(%r12),%rcx
  1082aa:	be 45 00 00 00       	mov    $0x45,%esi
  1082af:	49 8b 54 24 08       	mov    0x8(%r12),%rdx
  1082b4:	4d 8b 4c 24 20       	mov    0x20(%r12),%r9
  1082b9:	bf e3 e3 11 00       	mov    $0x11e3e3,%edi
  1082be:	31 c0                	xor    %eax,%eax
  1082c0:	e8 01 ae ff ff       	callq  1030c6 <z_log_minimal_printk>
	LOG_ERR("RSP: 0x%016lx RFLAGS: 0x%016lx CS: 0x%04lx CR3: 0x%016lx",
  1082c5:	4d 8b 84 24 90 02 00 	mov    0x290(%r12),%r8
  1082cc:	00 
	if ((esf->cs & 0x3) != 0) {
  1082cd:	41 f6 c0 03          	test   $0x3,%r8b
  1082d1:	74 10                	je     1082e3 <z_x86_fatal_error+0xca>
		return _current->arch.ptables;
  1082d3:	48 8b 05 76 04 02 00 	mov    0x20476(%rip),%rax        # 128750 <_kernel+0x10>
  1082da:	4c 8b 88 78 01 00 00 	mov    0x178(%rax),%r9
  1082e1:	eb 04                	jmp    1082e7 <z_x86_fatal_error+0xce>
 */
static inline uintptr_t z_x86_cr3_get(void)
{
	uintptr_t cr3;
#ifdef CONFIG_X86_64
	__asm__ volatile("movq %%cr3, %0\n\t" : "=r" (cr3));
  1082e3:	41 0f 20 d9          	mov    %cr3,%r9
	LOG_ERR("RSP: 0x%016lx RFLAGS: 0x%016lx CS: 0x%04lx CR3: 0x%016lx",
  1082e7:	31 c0                	xor    %eax,%eax
  1082e9:	45 0f b7 c0          	movzwl %r8w,%r8d
  1082ed:	be 45 00 00 00       	mov    $0x45,%esi
  1082f2:	bf 20 e4 11 00       	mov    $0x11e420,%edi
  1082f7:	49 8b 8c 24 98 02 00 	mov    0x298(%r12),%rcx
  1082fe:	00 
  1082ff:	49 8b 94 24 a0 02 00 	mov    0x2a0(%r12),%rdx
  108306:	00 
  108307:	e8 ba ad ff ff       	callq  1030c6 <z_log_minimal_printk>
	LOG_ERR("RIP: 0x%016lx", esf->rip);
  10830c:	49 8b 94 24 88 02 00 	mov    0x288(%r12),%rdx
  108313:	00 
  108314:	31 c0                	xor    %eax,%eax
  108316:	be 45 00 00 00       	mov    $0x45,%esi
  10831b:	bf 5e e4 11 00       	mov    $0x11e45e,%edi
  108320:	e8 a1 ad ff ff       	callq  1030c6 <z_log_minimal_printk>
#ifdef CONFIG_EXCEPTION_DEBUG
		dump_regs(esf);
#endif
#if defined(CONFIG_ASSERT) && defined(CONFIG_X86_64)
		if (esf->rip == 0xb9) {
  108325:	49 81 bc 24 88 02 00 	cmpq   $0xb9,0x288(%r12)
  10832c:	00 b9 00 00 00 
  108331:	75 17                	jne    10834a <z_x86_fatal_error+0x131>
			/* See implementation of __resume in locore.S. This is
			 * never a valid RIP value. Treat this as a kernel
			 * panic.
			 */
			LOG_ERR("Attempt to resume un-suspended thread object");
  108333:	be 45 00 00 00       	mov    $0x45,%esi
  108338:	bf 71 e4 11 00       	mov    $0x11e471,%edi
  10833d:	31 c0                	xor    %eax,%eax
			reason = K_ERR_KERNEL_PANIC;
  10833f:	41 bd 04 00 00 00    	mov    $0x4,%r13d
			LOG_ERR("Attempt to resume un-suspended thread object");
  108345:	e8 7c ad ff ff       	callq  1030c6 <z_log_minimal_printk>
		}
#endif
	}
	z_fatal_error(reason, esf);
  10834a:	4c 89 e6             	mov    %r12,%rsi
  10834d:	44 89 ef             	mov    %r13d,%edi
  108350:	e8 7e 4d 00 00       	callq  10d0d3 <z_fatal_error>

0000000000108355 <z_x86_unhandled_cpu_exception>:
}

__pinned_func
FUNC_NORETURN void z_x86_unhandled_cpu_exception(uintptr_t vector,
						 const z_arch_esf_t *esf)
{
  108355:	55                   	push   %rbp
  108356:	48 89 e5             	mov    %rsp,%rbp
  108359:	41 54                	push   %r12
  10835b:	49 89 f4             	mov    %rsi,%r12
  10835e:	50                   	push   %rax
	return esf->code;
  10835f:	48 8b 96 80 02 00 00 	mov    0x280(%rsi),%rdx
		LOG_ERR("Exception not handled (code 0x%lx)", code);
  108366:	be 45 00 00 00       	mov    $0x45,%esi
	switch (vector) {
  10836b:	48 83 ff 1e          	cmp    $0x1e,%rdi
  10836f:	0f 87 a3 00 00 00    	ja     108418 <z_x86_unhandled_cpu_exception+0xc3>
  108375:	ff 24 fd f0 cb 11 00 	jmpq   *0x11cbf0(,%rdi,8)
		LOG_ERR("Divide by zero");
  10837c:	bf a3 e4 11 00       	mov    $0x11e4a3,%edi
  108381:	eb 05                	jmp    108388 <z_x86_unhandled_cpu_exception+0x33>
		LOG_ERR("Debug");
  108383:	bf b7 e4 11 00       	mov    $0x11e4b7,%edi
  108388:	31 c0                	xor    %eax,%eax
  10838a:	e8 37 ad ff ff       	callq  1030c6 <z_log_minimal_printk>
  10838f:	e9 90 00 00 00       	jmpq   108424 <z_x86_unhandled_cpu_exception+0xcf>
		LOG_ERR("Non-maskable interrupt");
  108394:	bf c2 e4 11 00       	mov    $0x11e4c2,%edi
  108399:	eb ed                	jmp    108388 <z_x86_unhandled_cpu_exception+0x33>
		LOG_ERR("Breakpoint");
  10839b:	bf de e4 11 00       	mov    $0x11e4de,%edi
  1083a0:	eb e6                	jmp    108388 <z_x86_unhandled_cpu_exception+0x33>
		LOG_ERR("Overflow");
  1083a2:	bf ee e4 11 00       	mov    $0x11e4ee,%edi
  1083a7:	eb df                	jmp    108388 <z_x86_unhandled_cpu_exception+0x33>
		LOG_ERR("Bound range exceeded");
  1083a9:	bf fc e4 11 00       	mov    $0x11e4fc,%edi
  1083ae:	eb d8                	jmp    108388 <z_x86_unhandled_cpu_exception+0x33>
		LOG_ERR("Invalid opcode");
  1083b0:	bf 16 e5 11 00       	mov    $0x11e516,%edi
  1083b5:	eb d1                	jmp    108388 <z_x86_unhandled_cpu_exception+0x33>
		LOG_ERR("Floating point unit device not available");
  1083b7:	bf 2a e5 11 00       	mov    $0x11e52a,%edi
  1083bc:	eb ca                	jmp    108388 <z_x86_unhandled_cpu_exception+0x33>
		LOG_ERR("Double fault (code 0x%lx)", code);
  1083be:	bf 58 e5 11 00       	mov    $0x11e558,%edi
  1083c3:	eb 58                	jmp    10841d <z_x86_unhandled_cpu_exception+0xc8>
		LOG_ERR("Co-processor segment overrun");
  1083c5:	bf 77 e5 11 00       	mov    $0x11e577,%edi
  1083ca:	eb bc                	jmp    108388 <z_x86_unhandled_cpu_exception+0x33>
		LOG_ERR("Invalid TSS (code 0x%lx)", code);
  1083cc:	bf 99 e5 11 00       	mov    $0x11e599,%edi
  1083d1:	eb 4a                	jmp    10841d <z_x86_unhandled_cpu_exception+0xc8>
		LOG_ERR("Segment not present (code 0x%lx)", code);
  1083d3:	bf b7 e5 11 00       	mov    $0x11e5b7,%edi
  1083d8:	eb 43                	jmp    10841d <z_x86_unhandled_cpu_exception+0xc8>
		LOG_ERR("Stack segment fault");
  1083da:	bf dd e5 11 00       	mov    $0x11e5dd,%edi
  1083df:	eb a7                	jmp    108388 <z_x86_unhandled_cpu_exception+0x33>
		LOG_ERR("General protection fault (code 0x%lx)", code);
  1083e1:	bf f6 e5 11 00       	mov    $0x11e5f6,%edi
  1083e6:	eb 35                	jmp    10841d <z_x86_unhandled_cpu_exception+0xc8>
		LOG_ERR("x87 floating point exception");
  1083e8:	bf 21 e6 11 00       	mov    $0x11e621,%edi
  1083ed:	eb 99                	jmp    108388 <z_x86_unhandled_cpu_exception+0x33>
		LOG_ERR("Alignment check (code 0x%lx)", code);
  1083ef:	bf 43 e6 11 00       	mov    $0x11e643,%edi
  1083f4:	eb 27                	jmp    10841d <z_x86_unhandled_cpu_exception+0xc8>
		LOG_ERR("Machine check");
  1083f6:	bf 65 e6 11 00       	mov    $0x11e665,%edi
  1083fb:	eb 8b                	jmp    108388 <z_x86_unhandled_cpu_exception+0x33>
		LOG_ERR("SIMD floating point exception");
  1083fd:	bf 78 e6 11 00       	mov    $0x11e678,%edi
  108402:	eb 84                	jmp    108388 <z_x86_unhandled_cpu_exception+0x33>
		LOG_ERR("Virtualization exception");
  108404:	bf 9b e6 11 00       	mov    $0x11e69b,%edi
  108409:	e9 7a ff ff ff       	jmpq   108388 <z_x86_unhandled_cpu_exception+0x33>
		LOG_ERR("Security exception");
  10840e:	bf b9 e6 11 00       	mov    $0x11e6b9,%edi
  108413:	e9 70 ff ff ff       	jmpq   108388 <z_x86_unhandled_cpu_exception+0x33>
		LOG_ERR("Exception not handled (code 0x%lx)", code);
  108418:	bf d1 e6 11 00       	mov    $0x11e6d1,%edi
  10841d:	31 c0                	xor    %eax,%eax
  10841f:	e8 a2 ac ff ff       	callq  1030c6 <z_log_minimal_printk>
#ifdef CONFIG_EXCEPTION_DEBUG
	log_exception(vector, esf_get_code(esf));
#else
	ARG_UNUSED(vector);
#endif
	z_x86_fatal_error(K_ERR_CPU_EXCEPTION, esf);
  108424:	4c 89 e6             	mov    %r12,%rsi
  108427:	31 ff                	xor    %edi,%edi
  108429:	e8 eb fd ff ff       	callq  108219 <z_x86_fatal_error>

000000000010842e <z_x86_page_fault_handler>:
};
#endif

__pinned_func
void z_x86_page_fault_handler(z_arch_esf_t *esf)
{
  10842e:	55                   	push   %rbp
  10842f:	48 89 e5             	mov    %rsp,%rbp
  108432:	41 56                	push   %r14
  108434:	41 55                	push   %r13
  108436:	41 54                	push   %r12
  108438:	49 89 fc             	mov    %rdi,%r12
  10843b:	53                   	push   %rbx
#ifdef CONFIG_USERSPACE
	int i;

	for (i = 0; i < ARRAY_SIZE(exceptions); i++) {
#ifdef CONFIG_X86_64
		if ((void *)esf->rip >= exceptions[i].start &&
  10843c:	48 8b 87 88 02 00 00 	mov    0x288(%rdi),%rax
  108443:	48 3d 4e 01 10 00    	cmp    $0x10014e,%rax
  108449:	73 1c                	jae    108467 <z_x86_page_fault_handler+0x39>
  10844b:	48 3d 4a 01 10 00    	cmp    $0x10014a,%rax
  108451:	72 14                	jb     108467 <z_x86_page_fault_handler+0x39>
		    (void *)esf->rip < exceptions[i].end) {
			esf->rip = (uint64_t)(exceptions[i].fixup);
  108453:	48 c7 87 88 02 00 00 	movq   $0x10015d,0x288(%rdi)
  10845a:	5d 01 10 00 
		z_x86_fatal_error(K_ERR_STACK_CHK_FAIL, esf);
	}
#endif
	z_x86_fatal_error(K_ERR_CPU_EXCEPTION, esf);
	CODE_UNREACHABLE;
}
  10845e:	5b                   	pop    %rbx
  10845f:	41 5c                	pop    %r12
  108461:	41 5d                	pop    %r13
  108463:	41 5e                	pop    %r14
  108465:	5d                   	pop    %rbp
  108466:	c3                   	retq   
 */
static inline void *z_x86_cr2_get(void)
{
	void *cr2;
#ifdef CONFIG_X86_64
	__asm__ volatile("movq %%cr2, %0\n\t" : "=r" (cr2));
  108467:	41 0f 20 d6          	mov    %cr2,%r14
	LOG_ERR("Page fault at address %p (error code 0x%lx)", cr2, err);
  10846b:	31 c0                	xor    %eax,%eax
  10846d:	4c 89 f2             	mov    %r14,%rdx
  108470:	be 45 00 00 00       	mov    $0x45,%esi
  108475:	bf 11 e7 11 00       	mov    $0x11e711,%edi
	return esf->code;
  10847a:	49 8b 9c 24 80 02 00 	mov    0x280(%r12),%rbx
  108481:	00 
	LOG_ERR("Page fault at address %p (error code 0x%lx)", cr2, err);
  108482:	48 89 d9             	mov    %rbx,%rcx
  108485:	e8 3c ac ff ff       	callq  1030c6 <z_log_minimal_printk>
	if ((err & PF_RSVD) != 0) {
  10848a:	f6 c3 08             	test   $0x8,%bl
  10848d:	74 0c                	je     10849b <z_x86_page_fault_handler+0x6d>
		LOG_ERR("Reserved bits set in page tables");
  10848f:	be 45 00 00 00       	mov    $0x45,%esi
  108494:	bf 42 e7 11 00       	mov    $0x11e742,%edi
  108499:	eb 74                	jmp    10850f <z_x86_page_fault_handler+0xe1>
		if ((err & PF_P) == 0) {
  10849b:	f6 c3 01             	test   $0x1,%bl
  10849e:	75 11                	jne    1084b1 <z_x86_page_fault_handler+0x83>
			LOG_ERR("Linear address not present in page tables");
  1084a0:	be 45 00 00 00       	mov    $0x45,%esi
  1084a5:	bf 68 e7 11 00       	mov    $0x11e768,%edi
  1084aa:	31 c0                	xor    %eax,%eax
  1084ac:	e8 15 ac ff ff       	callq  1030c6 <z_log_minimal_printk>
		LOG_ERR("Access violation: %s thread not allowed to %s",
  1084b1:	b9 f9 e6 11 00       	mov    $0x11e6f9,%ecx
  1084b6:	f6 c3 10             	test   $0x10,%bl
  1084b9:	75 11                	jne    1084cc <z_x86_page_fault_handler+0x9e>
  1084bb:	f6 c3 02             	test   $0x2,%bl
  1084be:	b9 a4 d2 11 00       	mov    $0x11d2a4,%ecx
  1084c3:	b8 de 0d 12 00       	mov    $0x120dde,%eax
  1084c8:	48 0f 44 c8          	cmove  %rax,%rcx
  1084cc:	f6 c3 04             	test   $0x4,%bl
  1084cf:	b8 06 e7 11 00       	mov    $0x11e706,%eax
  1084d4:	ba 01 e7 11 00       	mov    $0x11e701,%edx
  1084d9:	48 0f 44 d0          	cmove  %rax,%rdx
  1084dd:	be 45 00 00 00       	mov    $0x45,%esi
  1084e2:	31 c0                	xor    %eax,%eax
  1084e4:	bf 97 e7 11 00       	mov    $0x11e797,%edi
  1084e9:	e8 d8 ab ff ff       	callq  1030c6 <z_log_minimal_printk>
		if ((err & PF_PK) != 0) {
  1084ee:	f6 c3 20             	test   $0x20,%bl
  1084f1:	74 0c                	je     1084ff <z_x86_page_fault_handler+0xd1>
			LOG_ERR("Protection key disallowed");
  1084f3:	be 45 00 00 00       	mov    $0x45,%esi
  1084f8:	bf ca e7 11 00       	mov    $0x11e7ca,%edi
  1084fd:	eb 10                	jmp    10850f <z_x86_page_fault_handler+0xe1>
		} else if ((err & PF_SGX) != 0) {
  1084ff:	0f ba e3 0f          	bt     $0xf,%ebx
  108503:	73 11                	jae    108516 <z_x86_page_fault_handler+0xe8>
			LOG_ERR("SGX access control violation");
  108505:	be 45 00 00 00       	mov    $0x45,%esi
  10850a:	bf e9 e7 11 00       	mov    $0x11e7e9,%edi
  10850f:	31 c0                	xor    %eax,%eax
  108511:	e8 b0 ab ff ff       	callq  1030c6 <z_log_minimal_printk>
	if ((esf->cs & 0x3) != 0) {
  108516:	41 f6 84 24 90 02 00 	testb  $0x3,0x290(%r12)
  10851d:	00 03 
  10851f:	74 10                	je     108531 <z_x86_page_fault_handler+0x103>
		return _current->arch.ptables;
  108521:	48 8b 05 28 02 02 00 	mov    0x20228(%rip),%rax        # 128750 <_kernel+0x10>
  108528:	4c 8b a8 78 01 00 00 	mov    0x178(%rax),%r13
  10852f:	eb 04                	jmp    108535 <z_x86_page_fault_handler+0x107>
	__asm__ volatile("movq %%cr3, %0\n\t" : "=r" (cr3));
  108531:	41 0f 20 dd          	mov    %cr3,%r13
}

/* Just like Z_MEM_VIRT_ADDR() but with type safety and assertions */
static inline void *z_mem_virt_addr(uintptr_t phys)
{
	__ASSERT((phys >= CONFIG_SRAM_BASE_ADDRESS) &&
  108535:	49 81 fd ff ff ff 0f 	cmp    $0xfffffff,%r13
  10853c:	76 39                	jbe    108577 <z_x86_page_fault_handler+0x149>
  10853e:	b9 98 00 00 00       	mov    $0x98,%ecx
  108543:	ba 0b e8 11 00       	mov    $0x11e80b,%edx
  108548:	be 37 e8 11 00       	mov    $0x11e837,%esi
  10854d:	31 c0                	xor    %eax,%eax
  10854f:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  108554:	e8 9f 80 ff ff       	callq  1005f8 <printk>
  108559:	4c 89 ee             	mov    %r13,%rsi
  10855c:	bf 6b e8 11 00       	mov    $0x11e86b,%edi
  108561:	31 c0                	xor    %eax,%eax
  108563:	e8 90 80 ff ff       	callq  1005f8 <printk>
  108568:	be 98 00 00 00       	mov    $0x98,%esi
  10856d:	bf 0b e8 11 00       	mov    $0x11e80b,%edi
  108572:	e8 21 a6 ff ff       	callq  102b98 <assert_post_action>
	z_x86_dump_mmu_flags(get_ptables(esf), cr2);
  108577:	4c 89 f6             	mov    %r14,%rsi
  10857a:	4c 89 ef             	mov    %r13,%rdi
  10857d:	e8 d3 0b 00 00       	callq  109155 <z_x86_dump_mmu_flags>
	if (z_x86_check_stack_bounds(esf_get_sp(esf), 0, esf->cs)) {
  108582:	49 8b bc 24 a0 02 00 	mov    0x2a0(%r12),%rdi
  108589:	00 
  10858a:	31 f6                	xor    %esi,%esi
  10858c:	41 0f b7 94 24 90 02 	movzwl 0x290(%r12),%edx
  108593:	00 00 
  108595:	e8 13 fc ff ff       	callq  1081ad <z_x86_check_stack_bounds>
		z_x86_fatal_error(K_ERR_STACK_CHK_FAIL, esf);
  10859a:	4c 89 e6             	mov    %r12,%rsi
  10859d:	bf 02 00 00 00       	mov    $0x2,%edi
	if (z_x86_check_stack_bounds(esf_get_sp(esf), 0, esf->cs)) {
  1085a2:	84 c0                	test   %al,%al
  1085a4:	75 02                	jne    1085a8 <z_x86_page_fault_handler+0x17a>
	z_x86_fatal_error(K_ERR_CPU_EXCEPTION, esf);
  1085a6:	31 ff                	xor    %edi,%edi
  1085a8:	e8 6c fc ff ff       	callq  108219 <z_x86_fatal_error>

00000000001085ad <z_x86_do_kernel_oops>:

__pinned_func
void z_x86_do_kernel_oops(const z_arch_esf_t *esf)
{
  1085ad:	55                   	push   %rbp
  1085ae:	48 89 fe             	mov    %rdi,%rsi
	uintptr_t reason;

#ifdef CONFIG_X86_64
	reason = esf->rax;
  1085b1:	48 8b 7f 30          	mov    0x30(%rdi),%rdi
{
  1085b5:	48 89 e5             	mov    %rsp,%rbp

#ifdef CONFIG_USERSPACE
	/* User mode is only allowed to induce oopses and stack check
	 * failures via this software interrupt
	 */
	if ((esf->cs & 0x3) != 0 && !(reason == K_ERR_KERNEL_OOPS ||
  1085b8:	f6 86 90 02 00 00 03 	testb  $0x3,0x290(%rsi)
  1085bf:	74 11                	je     1085d2 <z_x86_do_kernel_oops+0x25>
  1085c1:	48 8d 47 fe          	lea    -0x2(%rdi),%rax
				      reason == K_ERR_STACK_CHK_FAIL)) {
		reason = K_ERR_KERNEL_OOPS;
  1085c5:	48 83 f8 02          	cmp    $0x2,%rax
  1085c9:	b8 03 00 00 00       	mov    $0x3,%eax
  1085ce:	48 0f 43 f8          	cmovae %rax,%rdi
	}
#endif

	z_x86_fatal_error(reason, esf);
  1085d2:	e8 42 fc ff ff       	callq  108219 <z_x86_fatal_error>

00000000001085d7 <z_x86_cpuid_extended_features>:
#include <kernel_structs.h>
#include <arch/x86/cpuid.h>
#include <kernel.h>

uint32_t z_x86_cpuid_extended_features(void)
{
  1085d7:	55                   	push   %rbp
  if (!((__eax ^ __ebx) & 0x00200000))
    return 0;
#endif

  /* Host supports cpuid.  Return highest supported cpuid input value.  */
  __cpuid (__ext, __eax, __ebx, __ecx, __edx);
  1085d8:	31 c0                	xor    %eax,%eax
  1085da:	48 89 e5             	mov    %rsp,%rbp
  1085dd:	53                   	push   %rbx
  1085de:	0f a2                	cpuid  
	     unsigned int *__ecx, unsigned int *__edx)
{
  unsigned int __ext = __leaf & 0x80000000;
  unsigned int __maxlevel = __get_cpuid_max (__ext, 0);

  if (__maxlevel == 0 || __maxlevel < __leaf)
  1085e0:	45 31 c0             	xor    %r8d,%r8d
  1085e3:	83 f8 06             	cmp    $0x6,%eax
  1085e6:	76 0a                	jbe    1085f2 <z_x86_cpuid_extended_features+0x1b>
    return 0;

  __cpuid (__leaf, *__eax, *__ebx, *__ecx, *__edx);
  1085e8:	b8 07 00 00 00       	mov    $0x7,%eax
  1085ed:	0f a2                	cpuid  
  1085ef:	41 89 d0             	mov    %edx,%r8d
			&eax, &ebx, &ecx, &edx) == 0) {
		return 0;
	}

	return edx;
}
  1085f2:	44 89 c0             	mov    %r8d,%eax
  1085f5:	5b                   	pop    %rbx
  1085f6:	5d                   	pop    %rbp
  1085f7:	c3                   	retq   

00000000001085f8 <z_x86_cpuid_get_current_physical_apic_id>:

#define INITIAL_APIC_ID_SHIFT (24)
#define INITIAL_APIC_ID_MASK (0xFF)

uint8_t z_x86_cpuid_get_current_physical_apic_id(void)
{
  1085f8:	55                   	push   %rbp
  __cpuid (__ext, __eax, __ebx, __ecx, __edx);
  1085f9:	31 f6                	xor    %esi,%esi
  1085fb:	89 f0                	mov    %esi,%eax
  1085fd:	48 89 e5             	mov    %rsp,%rbp
  108600:	53                   	push   %rbx
  108601:	0f a2                	cpuid  
  if (__maxlevel == 0 || __maxlevel < __leaf)
  108603:	83 f8 1e             	cmp    $0x1e,%eax
  108606:	77 13                	ja     10861b <z_x86_cpuid_get_current_physical_apic_id+0x23>
  __cpuid (__ext, __eax, __ebx, __ecx, __edx);
  108608:	89 f0                	mov    %esi,%eax
  10860a:	0f a2                	cpuid  
		/* leaf 0x1F should be used first prior to using 0x0B */
		if (__get_cpuid(CPUID_EXTENDED_TOPOLOGY_ENUMERATION_V2,
				&eax, &ebx, &ecx, &edx) == 0) {
			if (__get_cpuid(CPUID_EXTENDED_TOPOLOGY_ENUMERATION,
					&eax, &ebx, &ecx, &edx) == 0) {
				return 0;
  10860c:	45 31 c0             	xor    %r8d,%r8d
  if (__maxlevel == 0 || __maxlevel < __leaf)
  10860f:	83 f8 0a             	cmp    $0xa,%eax
  108612:	76 11                	jbe    108625 <z_x86_cpuid_get_current_physical_apic_id+0x2d>
  __cpuid (__leaf, *__eax, *__ebx, *__ecx, *__edx);
  108614:	b8 0b 00 00 00       	mov    $0xb,%eax
  108619:	eb 05                	jmp    108620 <z_x86_cpuid_get_current_physical_apic_id+0x28>
  10861b:	b8 1f 00 00 00       	mov    $0x1f,%eax
  108620:	0f a2                	cpuid  
		}

		edx = (ebx >> INITIAL_APIC_ID_SHIFT);
	}

	return (uint8_t)(edx & INITIAL_APIC_ID_MASK);
  108622:	41 89 d0             	mov    %edx,%r8d
}
  108625:	44 89 c0             	mov    %r8d,%eax
  108628:	5b                   	pop    %rbx
  108629:	5d                   	pop    %rbp
  10862a:	c3                   	retq   

000000000010862b <spec_ctrl_init>:
 * https://software.intel.com/security-software-guidance/api-app/sites/default/files/336996-Speculative-Execution-Side-Channel-Mitigations.pdf
 */

#if defined(CONFIG_DISABLE_SSBD) || defined(CONFIG_ENABLE_EXTENDED_IBRS)
static int spec_ctrl_init(const struct device *dev)
{
  10862b:	55                   	push   %rbp
  10862c:	48 89 e5             	mov    %rsp,%rbp
	ARG_UNUSED(dev);

	uint32_t enable_bits = 0U;
	uint32_t cpuid7 = z_x86_cpuid_extended_features();
  10862f:	e8 a3 ff ff ff       	callq  1085d7 <z_x86_cpuid_extended_features>

#ifdef CONFIG_DISABLE_SSBD
	if ((cpuid7 & CPUID_SPEC_CTRL_SSBD) != 0U) {
		enable_bits |= X86_SPEC_CTRL_MSR_SSBD;
  108634:	89 c6                	mov    %eax,%esi
  108636:	c1 ee 1f             	shr    $0x1f,%esi
  108639:	c1 e6 02             	shl    $0x2,%esi
	}
#endif
#ifdef CONFIG_ENABLE_EXTENDED_IBRS
	if ((cpuid7 & CPUID_SPEC_CTRL_IBRS) != 0U) {
  10863c:	0f ba e0 1a          	bt     $0x1a,%eax
  108640:	73 05                	jae    108647 <spec_ctrl_init+0x1c>
		enable_bits |= X86_SPEC_CTRL_MSR_IBRS;
  108642:	83 ce 01             	or     $0x1,%esi
	}
#endif
	if (enable_bits != 0U) {
  108645:	eb 04                	jmp    10864b <spec_ctrl_init+0x20>
  108647:	85 f6                	test   %esi,%esi
  108649:	74 1e                	je     108669 <spec_ctrl_init+0x3e>
			uint32_t hi;
		};
		uint64_t value;
	} rv;

	__asm__ volatile ("rdmsr" : "=a" (rv.lo), "=d" (rv.hi) : "c" (msr));
  10864b:	b9 48 00 00 00       	mov    $0x48,%ecx
  108650:	0f 32                	rdmsr  
  108652:	48 89 d7             	mov    %rdx,%rdi
  108655:	89 c2                	mov    %eax,%edx
		uint64_t cur = z_x86_msr_read(X86_SPEC_CTRL_MSR);

		z_x86_msr_write(X86_SPEC_CTRL_MSR,
  108657:	89 f0                	mov    %esi,%eax
  108659:	48 c1 e7 20          	shl    $0x20,%rdi
  10865d:	48 09 fa             	or     %rdi,%rdx
  108660:	48 09 d0             	or     %rdx,%rax
	uint32_t high = data >> 32;
  108663:	48 c1 ea 20          	shr    $0x20,%rdx
	__asm__ volatile ("wrmsr" : : "c"(msr), "a"(low), "d"(high));
  108667:	0f 30                	wrmsr  
			       cur | enable_bits);
	}

	return 0;
}
  108669:	31 c0                	xor    %eax,%eax
  10866b:	5d                   	pop    %rbp
  10866c:	c3                   	retq   

000000000010866d <pcie_io_conf>:
 * Helper function for exported configuration functions. Configuration access
 * is not atomic, so spinlock to keep drivers from clobbering each other.
 */
static inline void pcie_io_conf(pcie_bdf_t bdf, unsigned int reg,
				bool write, uint32_t *data)
{
  10866d:	55                   	push   %rbp
	static struct k_spinlock lock;
	k_spinlock_key_t k;

	bdf &= PCIE_X86_CAP_BDF_MASK;
	bdf |= PCIE_X86_CAP_EN;
	bdf |= (reg & PCIE_X86_CAP_WORD_MASK) << PCIE_X86_CAP_WORD_SHIFT;
  10866e:	c1 e6 02             	shl    $0x2,%esi
	bdf &= PCIE_X86_CAP_BDF_MASK;
  108671:	81 e7 00 ff ff 00    	and    $0xffff00,%edi
{
  108677:	48 89 e5             	mov    %rsp,%rbp
  10867a:	41 56                	push   %r14
  10867c:	41 55                	push   %r13
  10867e:	41 89 d5             	mov    %edx,%r13d
  108681:	41 54                	push   %r12
  108683:	49 89 cc             	mov    %rcx,%r12
  108686:	53                   	push   %rbx
	bdf |= (reg & PCIE_X86_CAP_WORD_MASK) << PCIE_X86_CAP_WORD_SHIFT;
  108687:	40 0f b6 de          	movzbl %sil,%ebx
  10868b:	09 fb                	or     %edi,%ebx
  10868d:	81 cb 00 00 00 80    	or     $0x80000000,%ebx
  108693:	9c                   	pushfq 
  108694:	fa                   	cli    
  108695:	41 5e                	pop    %r14
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  108697:	bf 60 cd 1b 00       	mov    $0x1bcd60,%edi
  10869c:	e8 d8 51 00 00       	callq  10d879 <z_spin_lock_valid>
  1086a1:	84 c0                	test   %al,%al
  1086a3:	75 39                	jne    1086de <pcie_io_conf+0x71>
  1086a5:	b9 8e 00 00 00       	mov    $0x8e,%ecx
  1086aa:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  1086af:	be fd d1 11 00       	mov    $0x11d1fd,%esi
  1086b4:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  1086b9:	e8 3a 7f ff ff       	callq  1005f8 <printk>
  1086be:	be 60 cd 1b 00       	mov    $0x1bcd60,%esi
  1086c3:	bf 12 d2 11 00       	mov    $0x11d212,%edi
  1086c8:	31 c0                	xor    %eax,%eax
  1086ca:	e8 29 7f ff ff       	callq  1005f8 <printk>
  1086cf:	be 8e 00 00 00       	mov    $0x8e,%esi
  1086d4:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  1086d9:	e8 ba a4 ff ff       	callq  102b98 <assert_post_action>
	z_spin_lock_set_owner(l);
  1086de:	bf 60 cd 1b 00       	mov    $0x1bcd60,%edi
  1086e3:	e8 d5 51 00 00       	callq  10d8bd <z_spin_lock_set_owner>
	__asm__ volatile("outl %0, %w1" :: "a"(data), "Nd"(port));
  1086e8:	ba f8 0c 00 00       	mov    $0xcf8,%edx
  1086ed:	89 d8                	mov    %ebx,%eax
  1086ef:	ef                   	out    %eax,(%dx)

	k = k_spin_lock(&lock);
	sys_out32(bdf, PCIE_X86_CAP);

	if (write) {
  1086f0:	45 84 ed             	test   %r13b,%r13b
  1086f3:	74 0c                	je     108701 <pcie_io_conf+0x94>
  1086f5:	41 8b 04 24          	mov    (%r12),%eax
  1086f9:	ba fc 0c 00 00       	mov    $0xcfc,%edx
  1086fe:	ef                   	out    %eax,(%dx)
}
  1086ff:	eb 0a                	jmp    10870b <pcie_io_conf+0x9e>
	__asm__ volatile("inl %w1, %0" : "=a"(ret) : "Nd"(port));
  108701:	ba fc 0c 00 00       	mov    $0xcfc,%edx
  108706:	ed                   	in     (%dx),%eax
		sys_out32(*data, PCIE_X86_CDP);
	} else {
		*data = sys_in32(PCIE_X86_CDP);
  108707:	41 89 04 24          	mov    %eax,(%r12)
	__asm__ volatile("outl %0, %w1" :: "a"(data), "Nd"(port));
  10870b:	31 c0                	xor    %eax,%eax
  10870d:	ba f8 0c 00 00       	mov    $0xcf8,%edx
  108712:	ef                   	out    %eax,(%dx)
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  108713:	bf 60 cd 1b 00       	mov    $0x1bcd60,%edi
  108718:	e8 7c 51 00 00       	callq  10d899 <z_spin_unlock_valid>
  10871d:	84 c0                	test   %al,%al
  10871f:	75 39                	jne    10875a <pcie_io_conf+0xed>
  108721:	b9 b9 00 00 00       	mov    $0xb9,%ecx
  108726:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  10872b:	be 41 d2 11 00       	mov    $0x11d241,%esi
  108730:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  108735:	e8 be 7e ff ff       	callq  1005f8 <printk>
  10873a:	be 60 cd 1b 00       	mov    $0x1bcd60,%esi
  10873f:	bf 58 d2 11 00       	mov    $0x11d258,%edi
  108744:	31 c0                	xor    %eax,%eax
  108746:	e8 ad 7e ff ff       	callq  1005f8 <printk>
  10874b:	be b9 00 00 00       	mov    $0xb9,%esi
  108750:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  108755:	e8 3e a4 ff ff       	callq  102b98 <assert_post_action>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  10875a:	41 0f ba e6 09       	bt     $0x9,%r14d
  10875f:	73 01                	jae    108762 <pcie_io_conf+0xf5>
		__asm__ volatile ("sti" ::: "memory");
  108761:	fb                   	sti    
	}

	sys_out32(0U, PCIE_X86_CAP);
	k_spin_unlock(&lock, k);
}
  108762:	5b                   	pop    %rbx
  108763:	41 5c                	pop    %r12
  108765:	41 5d                	pop    %r13
  108767:	41 5e                	pop    %r14
  108769:	5d                   	pop    %rbp
  10876a:	c3                   	retq   

000000000010876b <pcie_conf_read>:
}

/* these functions are explained in include/drivers/pcie/pcie.h */

uint32_t pcie_conf_read(pcie_bdf_t bdf, unsigned int reg)
{
  10876b:	55                   	push   %rbp
		pcie_io_conf(bdf, reg, write, data);
  10876c:	31 d2                	xor    %edx,%edx
{
  10876e:	48 89 e5             	mov    %rsp,%rbp
  108771:	48 83 ec 10          	sub    $0x10,%rsp
		pcie_io_conf(bdf, reg, write, data);
  108775:	48 8d 4d fc          	lea    -0x4(%rbp),%rcx
	uint32_t data = 0U;
  108779:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
		pcie_io_conf(bdf, reg, write, data);
  108780:	e8 e8 fe ff ff       	callq  10866d <pcie_io_conf>

	pcie_conf(bdf, reg, false, &data);
	return data;
}
  108785:	8b 45 fc             	mov    -0x4(%rbp),%eax
  108788:	c9                   	leaveq 
  108789:	c3                   	retq   

000000000010878a <pcie_conf_write>:

void pcie_conf_write(pcie_bdf_t bdf, unsigned int reg, uint32_t data)
{
  10878a:	55                   	push   %rbp
  10878b:	48 89 e5             	mov    %rsp,%rbp
  10878e:	48 83 ec 10          	sub    $0x10,%rsp
		pcie_io_conf(bdf, reg, write, data);
  108792:	48 8d 4d fc          	lea    -0x4(%rbp),%rcx
{
  108796:	89 55 fc             	mov    %edx,-0x4(%rbp)
		pcie_io_conf(bdf, reg, write, data);
  108799:	ba 01 00 00 00       	mov    $0x1,%edx
  10879e:	e8 ca fe ff ff       	callq  10866d <pcie_io_conf>
	pcie_conf(bdf, reg, true, &data);
}
  1087a3:	c9                   	leaveq 
  1087a4:	c3                   	retq   

00000000001087a5 <pcie_msi_map>:
#define MSI_MAP_DESTINATION_ID_SHIFT 12
#define MSI_RH BIT(3)

uint32_t pcie_msi_map(unsigned int irq,
		      msi_vector_t *vector)
{
  1087a5:	55                   	push   %rbp
  1087a6:	48 89 e5             	mov    %rsp,%rbp
#endif
#endif
	{
		uint32_t dest_id;

		dest_id = z_x86_cpuid_get_current_physical_apic_id() <<
  1087a9:	e8 4a fe ff ff       	callq  1085f8 <z_x86_cpuid_get_current_physical_apic_id>
		 */
		map = 0xFEE00000U | dest_id | MSI_RH;
	}

	return map;
}
  1087ae:	5d                   	pop    %rbp
		dest_id = z_x86_cpuid_get_current_physical_apic_id() <<
  1087af:	0f b6 c0             	movzbl %al,%eax
  1087b2:	c1 e0 0c             	shl    $0xc,%eax
		map = 0xFEE00000U | dest_id | MSI_RH;
  1087b5:	0d 08 00 e0 fe       	or     $0xfee00008,%eax
}
  1087ba:	c3                   	retq   

00000000001087bb <pcie_msi_mdr>:

uint16_t pcie_msi_mdr(unsigned int irq,
		      msi_vector_t *vector)
{
#ifdef CONFIG_PCIE_MSI_X
	if ((vector != NULL) && (vector->msix)) {
  1087bb:	48 85 f6             	test   %rsi,%rsi
  1087be:	74 0e                	je     1087ce <pcie_msi_mdr+0x13>
		/* edge triggered */
		return 0x4000U | Z_IRQ_TO_INTERRUPT_VECTOR(irq);
	}

	/* VT-D requires it to be 0, so let's return 0 by default */
	return 0;
  1087c0:	31 c0                	xor    %eax,%eax
	if ((vector != NULL) && (vector->msix)) {
  1087c2:	80 7e 18 00          	cmpb   $0x0,0x18(%rsi)
  1087c6:	74 12                	je     1087da <pcie_msi_mdr+0x1f>
		return 0x4000U | vector->arch.vector;
  1087c8:	0f b6 46 08          	movzbl 0x8(%rsi),%eax
  1087cc:	eb 09                	jmp    1087d7 <pcie_msi_mdr+0x1c>
		return 0x4000U | Z_IRQ_TO_INTERRUPT_VECTOR(irq);
  1087ce:	89 ff                	mov    %edi,%edi
  1087d0:	0f b6 87 20 7b 12 00 	movzbl 0x127b20(%rdi),%eax
  1087d7:	80 cc 40             	or     $0x40,%ah
}
  1087da:	c3                   	retq   

00000000001087db <arch_pcie_msi_vectors_allocate>:
}

uint8_t arch_pcie_msi_vectors_allocate(unsigned int priority,
				       msi_vector_t *vectors,
				       uint8_t n_vector)
{
  1087db:	55                   	push   %rbp
  1087dc:	48 89 e5             	mov    %rsp,%rbp
  1087df:	41 57                	push   %r15
  1087e1:	41 56                	push   %r14
  1087e3:	41 89 d6             	mov    %edx,%r14d
  1087e6:	41 55                	push   %r13
  1087e8:	41 89 fd             	mov    %edi,%r13d
  1087eb:	41 54                	push   %r12
  1087ed:	53                   	push   %rbx
  1087ee:	48 89 f3             	mov    %rsi,%rbx
  1087f1:	48 83 ec 18          	sub    $0x18,%rsp
	if (n_vector > 1) {
  1087f5:	80 fa 01             	cmp    $0x1,%dl
  1087f8:	76 70                	jbe    10886a <arch_pcie_msi_vectors_allocate+0x8f>
				vectors[i].arch.remap = true;
			}
		}
#endif /* CONFIG_INTEL_VTD_ICTL */

		for (i = 0; i < n_vector; i++) {
  1087fa:	0f b6 c2             	movzbl %dl,%eax
  1087fd:	31 c9                	xor    %ecx,%ecx
		int prev_vector = -1;
  1087ff:	41 83 cc ff          	or     $0xffffffff,%r12d
		for (i = 0; i < n_vector; i++) {
  108803:	89 45 cc             	mov    %eax,-0x34(%rbp)
			uint32_t data;

			data = _read_pcie_irq_data(vectors[i].bdf);
  108806:	8b 3b                	mov    (%rbx),%edi
	data = pcie_conf_read(bdf, PCIE_CONF_INTR);
  108808:	be 0f 00 00 00       	mov    $0xf,%esi
  10880d:	89 4d c4             	mov    %ecx,-0x3c(%rbp)
		for (i = 0; i < n_vector; i++) {
  108810:	48 83 c3 20          	add    $0x20,%rbx
	data = pcie_conf_read(bdf, PCIE_CONF_INTR);
  108814:	89 7d c8             	mov    %edi,-0x38(%rbp)
  108817:	e8 4f ff ff ff       	callq  10876b <pcie_conf_read>
	pcie_conf_write(bdf, PCIE_CONF_INTR, data | PCIE_CONF_INTR_IRQ_NONE);
  10881c:	8b 7d c8             	mov    -0x38(%rbp),%edi
  10881f:	be 0f 00 00 00       	mov    $0xf,%esi
  108824:	89 c2                	mov    %eax,%edx
	data = pcie_conf_read(bdf, PCIE_CONF_INTR);
  108826:	41 89 c7             	mov    %eax,%r15d
	pcie_conf_write(bdf, PCIE_CONF_INTR, data | PCIE_CONF_INTR_IRQ_NONE);
  108829:	80 ca ff             	or     $0xff,%dl
  10882c:	e8 59 ff ff ff       	callq  10878a <pcie_conf_write>

			vectors[i].arch.irq = pcie_alloc_irq(vectors[i].bdf);
  108831:	8b 7b e0             	mov    -0x20(%rbx),%edi
  108834:	e8 b7 24 00 00       	callq  10acf0 <pcie_alloc_irq>
	pcie_conf_write(bdf, PCIE_CONF_INTR, data);
  108839:	8b 7b e0             	mov    -0x20(%rbx),%edi
  10883c:	44 89 fa             	mov    %r15d,%edx
  10883f:	be 0f 00 00 00       	mov    $0xf,%esi
			vectors[i].arch.irq = pcie_alloc_irq(vectors[i].bdf);
  108844:	89 43 e4             	mov    %eax,-0x1c(%rbx)
	pcie_conf_write(bdf, PCIE_CONF_INTR, data);
  108847:	e8 3e ff ff ff       	callq  10878a <pcie_conf_write>

			_write_pcie_irq_data(vectors[i].bdf, data);

			vectors[i].arch.vector =
				z_x86_allocate_vector(priority, prev_vector);
  10884c:	44 89 e6             	mov    %r12d,%esi
  10884f:	44 89 ef             	mov    %r13d,%edi
  108852:	e8 78 11 00 00       	callq  1099cf <z_x86_allocate_vector>
		for (i = 0; i < n_vector; i++) {
  108857:	8b 4d c4             	mov    -0x3c(%rbp),%ecx
			vectors[i].arch.vector =
  10885a:	88 43 e8             	mov    %al,-0x18(%rbx)
			if (vectors[i].arch.vector < 0) {
				return 0;
			}

			prev_vector = vectors[i].arch.vector;
  10885d:	44 0f b6 e0          	movzbl %al,%r12d
		for (i = 0; i < n_vector; i++) {
  108861:	ff c1                	inc    %ecx
  108863:	39 4d cc             	cmp    %ecx,-0x34(%rbp)
  108866:	7f 9e                	jg     108806 <arch_pcie_msi_vectors_allocate+0x2b>
  108868:	eb 0b                	jmp    108875 <arch_pcie_msi_vectors_allocate+0x9a>
		}
	} else {
		vectors[0].arch.vector = z_x86_allocate_vector(priority, -1);
  10886a:	83 ce ff             	or     $0xffffffff,%esi
  10886d:	e8 5d 11 00 00       	callq  1099cf <z_x86_allocate_vector>
  108872:	88 43 08             	mov    %al,0x8(%rbx)
	}

	return n_vector;
}
  108875:	48 83 c4 18          	add    $0x18,%rsp
  108879:	44 89 f0             	mov    %r14d,%eax
  10887c:	5b                   	pop    %rbx
  10887d:	41 5c                	pop    %r12
  10887f:	41 5d                	pop    %r13
  108881:	41 5e                	pop    %r14
  108883:	41 5f                	pop    %r15
  108885:	5d                   	pop    %rbp
  108886:	c3                   	retq   

0000000000108887 <arch_pcie_msi_vector_connect>:

bool arch_pcie_msi_vector_connect(msi_vector_t *vector,
				  void (*routine)(const void *parameter),
				  const void *parameter,
				  uint32_t flags)
{
  108887:	55                   	push   %rbp
  108888:	49 89 f1             	mov    %rsi,%r9

		vtd_remap(vtd, vector);
	}
#endif /* CONFIG_INTEL_VTD_ICTL */

	z_x86_irq_connect_on_vector(vector->arch.irq, vector->arch.vector,
  10888b:	0f b6 77 08          	movzbl 0x8(%rdi),%esi
{
  10888f:	41 89 c8             	mov    %ecx,%r8d
	z_x86_irq_connect_on_vector(vector->arch.irq, vector->arch.vector,
  108892:	8b 7f 04             	mov    0x4(%rdi),%edi
  108895:	48 89 d1             	mov    %rdx,%rcx
  108898:	4c 89 ca             	mov    %r9,%rdx
{
  10889b:	48 89 e5             	mov    %rsp,%rbp
	z_x86_irq_connect_on_vector(vector->arch.irq, vector->arch.vector,
  10889e:	e8 7b 11 00 00       	callq  109a1e <z_x86_irq_connect_on_vector>
				    routine, parameter, flags);

	return true;
}
  1088a3:	b0 01                	mov    $0x1,%al
  1088a5:	5d                   	pop    %rbp
  1088a6:	c3                   	retq   

00000000001088a7 <reset_pte>:
static inline pentry_t reset_pte(pentry_t old_val)
{
	pentry_t new_val;

	/* Clear any existing state in permission bits */
	new_val = old_val & (~K_MEM_PARTITION_PERM_MASK);
  1088a7:	48 b8 f9 ff ff ff ff 	movabs $0x7ffffffffffffff9,%rax
  1088ae:	ff ff 7f 
  1088b1:	48 21 f8             	and    %rdi,%rax

	/* Now set permissions based on the stashed original values */
	if ((old_val & MMU_RW_ORIG) != 0) {
  1088b4:	0f ba e7 09          	bt     $0x9,%edi
  1088b8:	73 04                	jae    1088be <reset_pte+0x17>
		new_val |= MMU_RW;
  1088ba:	48 83 c8 02          	or     $0x2,%rax
	}
	if ((old_val & MMU_US_ORIG) != 0) {
  1088be:	0f ba e7 0a          	bt     $0xa,%edi
  1088c2:	73 04                	jae    1088c8 <reset_pte+0x21>
		new_val |= MMU_US;
  1088c4:	48 83 c8 04          	or     $0x4,%rax
	}
#if defined(CONFIG_X86_64) || defined(CONFIG_X86_PAE)
	if ((old_val & MMU_XD_ORIG) != 0) {
  1088c8:	0f ba e7 0b          	bt     $0xb,%edi
  1088cc:	73 05                	jae    1088d3 <reset_pte+0x2c>
		new_val |= MMU_XD;
  1088ce:	48 0f ba e8 3f       	bts    $0x3f,%rax
	}
#endif
	return new_val;
}
  1088d3:	c3                   	retq   

00000000001088d4 <z_mem_virt_addr>:
{
  1088d4:	55                   	push   %rbp
  1088d5:	48 89 e5             	mov    %rsp,%rbp
  1088d8:	41 54                	push   %r12
  1088da:	49 89 fc             	mov    %rdi,%r12
  1088dd:	51                   	push   %rcx
	__ASSERT((phys >= CONFIG_SRAM_BASE_ADDRESS) &&
  1088de:	48 81 ff ff ff ff 0f 	cmp    $0xfffffff,%rdi
  1088e5:	76 39                	jbe    108920 <z_mem_virt_addr+0x4c>
  1088e7:	b9 98 00 00 00       	mov    $0x98,%ecx
  1088ec:	ba 0b e8 11 00       	mov    $0x11e80b,%edx
  1088f1:	be 37 e8 11 00       	mov    $0x11e837,%esi
  1088f6:	31 c0                	xor    %eax,%eax
  1088f8:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  1088fd:	e8 f6 7c ff ff       	callq  1005f8 <printk>
  108902:	4c 89 e6             	mov    %r12,%rsi
  108905:	bf 6b e8 11 00       	mov    $0x11e86b,%edi
  10890a:	31 c0                	xor    %eax,%eax
  10890c:	e8 e7 7c ff ff       	callq  1005f8 <printk>
  108911:	be 98 00 00 00       	mov    $0x98,%esi
  108916:	bf 0b e8 11 00       	mov    $0x11e80b,%edi
  10891b:	e8 78 a2 ff ff       	callq  102b98 <assert_post_action>
	/* TODO add assertion that this page frame is pinned to boot mapping,
	 * the above check won't be sufficient with demand paging
	 */

	return (void *)Z_MEM_VIRT_ADDR(phys);
}
  108920:	4c 89 e0             	mov    %r12,%rax
  108923:	5a                   	pop    %rdx
  108924:	41 5c                	pop    %r12
  108926:	5d                   	pop    %rbp
  108927:	c3                   	retq   

0000000000108928 <next_table>:
	return entry & paging_levels[level].mask;
  108928:	48 63 f6             	movslq %esi,%rsi
  10892b:	48 c1 e6 05          	shl    $0x5,%rsi
  10892f:	48 23 be 20 ad 11 00 	and    0x11ad20(%rsi),%rdi
	return z_mem_virt_addr(get_entry_phys(entry, level));
  108936:	e9 99 ff ff ff       	jmpq   1088d4 <z_mem_virt_addr>

000000000010893b <str_append>:
{
  10893b:	55                   	push   %rbp
  10893c:	48 89 d1             	mov    %rdx,%rcx
	int ret = snprintk(*buf, *size, "%s", str);
  10893f:	31 c0                	xor    %eax,%eax
  108941:	ba b7 d5 11 00       	mov    $0x11d5b7,%edx
{
  108946:	48 89 e5             	mov    %rsp,%rbp
  108949:	41 54                	push   %r12
  10894b:	49 89 fc             	mov    %rdi,%r12
  10894e:	53                   	push   %rbx
  10894f:	48 89 f3             	mov    %rsi,%rbx
	int ret = snprintk(*buf, *size, "%s", str);
  108952:	48 8b 3f             	mov    (%rdi),%rdi
  108955:	48 8b 36             	mov    (%rsi),%rsi
  108958:	e8 66 7d ff ff       	callq  1006c3 <snprintk>
	if (ret >= *size) {
  10895d:	48 8b 13             	mov    (%rbx),%rdx
  108960:	48 98                	cltq   
  108962:	48 39 d0             	cmp    %rdx,%rax
  108965:	72 09                	jb     108970 <str_append+0x35>
		*size = 0U;
  108967:	48 c7 03 00 00 00 00 	movq   $0x0,(%rbx)
  10896e:	eb 0a                	jmp    10897a <str_append+0x3f>
		*size -= ret;
  108970:	48 29 c2             	sub    %rax,%rdx
  108973:	48 89 13             	mov    %rdx,(%rbx)
		*buf += ret;
  108976:	49 01 04 24          	add    %rax,(%r12)
}
  10897a:	5b                   	pop    %rbx
  10897b:	41 5c                	pop    %r12
  10897d:	5d                   	pop    %rbp
  10897e:	c3                   	retq   

000000000010897f <page_pool_get>:
/* Return a zeroed and suitably aligned memory page for page table data
 * from the global page pool
 */
__pinned_func
static void *page_pool_get(void)
{
  10897f:	55                   	push   %rbp
  108980:	48 89 e5             	mov    %rsp,%rbp
  108983:	41 54                	push   %r12
	void *ret;

	if (page_pos == page_pool) {
		ret = NULL;
  108985:	45 31 e4             	xor    %r12d,%r12d
{
  108988:	51                   	push   %rcx
	if (page_pos == page_pool) {
  108989:	48 8b 05 b0 8a 4d 00 	mov    0x4d8ab0(%rip),%rax        # 5e1440 <page_pos>
  108990:	48 3d 00 f0 1b 00    	cmp    $0x1bf000,%rax
  108996:	74 22                	je     1089ba <page_pool_get+0x3b>
	} else {
		page_pos -= CONFIG_MMU_PAGE_SIZE;
  108998:	4c 8d a0 00 f0 ff ff 	lea    -0x1000(%rax),%r12
  10899f:	4c 89 25 9a 8a 4d 00 	mov    %r12,0x4d8a9a(%rip)        # 5e1440 <page_pos>
		ret = page_pos;
	}

	if (ret != NULL) {
  1089a6:	4d 85 e4             	test   %r12,%r12
  1089a9:	74 0f                	je     1089ba <page_pool_get+0x3b>
		memset(ret, 0, CONFIG_MMU_PAGE_SIZE);
  1089ab:	ba 00 10 00 00       	mov    $0x1000,%edx
  1089b0:	31 f6                	xor    %esi,%esi
  1089b2:	4c 89 e7             	mov    %r12,%rdi
  1089b5:	e8 f8 16 00 00       	callq  10a0b2 <memset>
	}

	return ret;
}
  1089ba:	4c 89 e0             	mov    %r12,%rax
  1089bd:	5a                   	pop    %rdx
  1089be:	41 5c                	pop    %r12
  1089c0:	5d                   	pop    %rbp
  1089c1:	c3                   	retq   

00000000001089c2 <z_mem_phys_addr>:
{
  1089c2:	55                   	push   %rbp
  1089c3:	48 89 e5             	mov    %rsp,%rbp
  1089c6:	41 54                	push   %r12
  1089c8:	49 89 fc             	mov    %rdi,%r12
  1089cb:	51                   	push   %rcx
	__ASSERT((addr >= CONFIG_KERNEL_VM_BASE) &&
  1089cc:	48 81 ff ff ff ff 1f 	cmp    $0x1fffffff,%rdi
  1089d3:	76 39                	jbe    108a0e <z_mem_phys_addr+0x4c>
  1089d5:	b9 81 00 00 00       	mov    $0x81,%ecx
  1089da:	ba 0b e8 11 00       	mov    $0x11e80b,%edx
  1089df:	be 8f e8 11 00       	mov    $0x11e88f,%esi
  1089e4:	31 c0                	xor    %eax,%eax
  1089e6:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  1089eb:	e8 08 7c ff ff       	callq  1005f8 <printk>
  1089f0:	4c 89 e6             	mov    %r12,%rsi
  1089f3:	bf be e8 11 00       	mov    $0x11e8be,%edi
  1089f8:	31 c0                	xor    %eax,%eax
  1089fa:	e8 f9 7b ff ff       	callq  1005f8 <printk>
  1089ff:	be 81 00 00 00       	mov    $0x81,%esi
  108a04:	bf 0b e8 11 00       	mov    $0x11e80b,%edi
  108a09:	e8 8a a1 ff ff       	callq  102b98 <assert_post_action>
}
  108a0e:	4c 89 e0             	mov    %r12,%rax
  108a11:	5a                   	pop    %rdx
  108a12:	41 5c                	pop    %r12
  108a14:	5d                   	pop    %rbp
  108a15:	c3                   	retq   

0000000000108a16 <copy_page_table>:
 * @retval 0 Success
 * @retval -ENOMEM Insufficient page pool memory
 */
__pinned_func
static int copy_page_table(pentry_t *dst, pentry_t *src, int level)
{
  108a16:	55                   	push   %rbp
  108a17:	48 89 e5             	mov    %rsp,%rbp
  108a1a:	41 57                	push   %r15
  108a1c:	41 56                	push   %r14
  108a1e:	41 55                	push   %r13
  108a20:	49 89 f5             	mov    %rsi,%r13
  108a23:	41 54                	push   %r12
  108a25:	49 89 fc             	mov    %rdi,%r12
  108a28:	53                   	push   %rbx
  108a29:	48 83 ec 28          	sub    $0x28,%rsp
		}
	} else {
		/* Recursive case: allocate sub-structures as needed and
		 * make recursive calls on them
		 */
		for (int i = 0; i < get_num_entries(level); i++) {
  108a2d:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%rbp)
	if (level == PTE_LEVEL) {
  108a34:	83 fa 03             	cmp    $0x3,%edx
  108a37:	74 15                	je     108a4e <copy_page_table+0x38>
	return paging_levels[level].entries;
  108a39:	48 63 c2             	movslq %edx,%rax
  108a3c:	89 d3                	mov    %edx,%ebx
  108a3e:	48 c1 e0 05          	shl    $0x5,%rax
  108a42:	48 05 20 ad 11 00    	add    $0x11ad20,%rax
  108a48:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  108a4c:	eb 62                	jmp    108ab0 <copy_page_table+0x9a>
	return entry & paging_levels[level].mask;
  108a4e:	48 b9 00 f0 ff ff ff 	movabs $0x7fffffffffff000,%rcx
  108a55:	ff ff 07 
  108a58:	31 d2                	xor    %edx,%edx
			dst[i] = pte_finalize_value(reset_pte(src[i]), true,
  108a5a:	49 8b 7c 15 00       	mov    0x0(%r13,%rdx,1),%rdi
  108a5f:	e8 43 fe ff ff       	callq  1088a7 <reset_pte>
	if (user_table && (val & MMU_US) == 0 && (val & MMU_P) != 0 &&
  108a64:	48 89 c6             	mov    %rax,%rsi
  108a67:	83 e6 05             	and    $0x5,%esi
  108a6a:	48 ff ce             	dec    %rsi
  108a6d:	75 12                	jne    108a81 <copy_page_table+0x6b>
	return entry & paging_levels[level].mask;
  108a6f:	48 89 c6             	mov    %rax,%rsi
  108a72:	48 21 ce             	and    %rcx,%rsi
	if (user_table && (val & MMU_US) == 0 && (val & MMU_P) != 0 &&
  108a75:	48 81 fe 00 60 00 00 	cmp    $0x6000,%rsi
  108a7c:	74 03                	je     108a81 <copy_page_table+0x6b>
		val = ~val;
  108a7e:	48 f7 d0             	not    %rax
			dst[i] = pte_finalize_value(reset_pte(src[i]), true,
  108a81:	49 89 04 14          	mov    %rax,(%r12,%rdx,1)
		for (int i = 0; i < get_num_entries(level); i++) {
  108a85:	48 83 c2 08          	add    $0x8,%rdx
  108a89:	48 81 fa 00 10 00 00 	cmp    $0x1000,%rdx
  108a90:	75 c8                	jne    108a5a <copy_page_table+0x44>
				return ret;
			}
		}
	}

	return 0;
  108a92:	31 c0                	xor    %eax,%eax
  108a94:	e9 ea 00 00 00       	jmpq   108b83 <copy_page_table+0x16d>
			if ((src[i] & MMU_P) == 0) {
  108a99:	4a 8d 14 f5 00 00 00 	lea    0x0(,%r14,8),%rdx
  108aa0:	00 
  108aa1:	4d 8d 7c 15 00       	lea    0x0(%r13,%rdx,1),%r15
  108aa6:	49 8b 07             	mov    (%r15),%rax
  108aa9:	a8 01                	test   $0x1,%al
  108aab:	75 13                	jne    108ac0 <copy_page_table+0xaa>
		for (int i = 0; i < get_num_entries(level); i++) {
  108aad:	ff 45 cc             	incl   -0x34(%rbp)
  108ab0:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  108ab4:	4c 63 75 cc          	movslq -0x34(%rbp),%r14
  108ab8:	4c 3b 70 08          	cmp    0x8(%rax),%r14
  108abc:	72 db                	jb     108a99 <copy_page_table+0x83>
  108abe:	eb d2                	jmp    108a92 <copy_page_table+0x7c>
			if ((level == PDE_LEVEL) && ((src[i] & MMU_PS) != 0)) {
  108ac0:	48 89 c1             	mov    %rax,%rcx
  108ac3:	81 e1 80 00 00 00    	and    $0x80,%ecx
  108ac9:	83 fb 02             	cmp    $0x2,%ebx
  108acc:	75 31                	jne    108aff <copy_page_table+0xe9>
  108ace:	48 85 c9             	test   %rcx,%rcx
  108ad1:	74 67                	je     108b3a <copy_page_table+0x124>
	if (user_table && (val & MMU_US) == 0 && (val & MMU_P) != 0 &&
  108ad3:	48 89 c1             	mov    %rax,%rcx
				dst[i] = pte_finalize_value(src[i], true,
  108ad6:	4c 01 e2             	add    %r12,%rdx
	if (user_table && (val & MMU_US) == 0 && (val & MMU_P) != 0 &&
  108ad9:	83 e1 05             	and    $0x5,%ecx
  108adc:	48 ff c9             	dec    %rcx
  108adf:	75 19                	jne    108afa <copy_page_table+0xe4>
	return entry & paging_levels[level].mask;
  108ae1:	48 b9 00 f0 ff ff ff 	movabs $0x7ffffffffffff000,%rcx
  108ae8:	ff ff 7f 
  108aeb:	48 21 c1             	and    %rax,%rcx
	if (user_table && (val & MMU_US) == 0 && (val & MMU_P) != 0 &&
  108aee:	48 81 f9 00 60 00 00 	cmp    $0x6000,%rcx
  108af5:	74 03                	je     108afa <copy_page_table+0xe4>
		val = ~val;
  108af7:	48 f7 d0             	not    %rax
				dst[i] = pte_finalize_value(src[i], true,
  108afa:	48 89 02             	mov    %rax,(%rdx)
				continue;
  108afd:	eb ae                	jmp    108aad <copy_page_table+0x97>
			__ASSERT((src[i] & MMU_PS) == 0,
  108aff:	48 85 c9             	test   %rcx,%rcx
  108b02:	74 36                	je     108b3a <copy_page_table+0x124>
  108b04:	be 10 e9 11 00       	mov    $0x11e910,%esi
  108b09:	b9 2b 06 00 00       	mov    $0x62b,%ecx
  108b0e:	ba e5 e8 11 00       	mov    $0x11e8e5,%edx
  108b13:	31 c0                	xor    %eax,%eax
  108b15:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  108b1a:	e8 d9 7a ff ff       	callq  1005f8 <printk>
  108b1f:	bf 2e e9 11 00       	mov    $0x11e92e,%edi
  108b24:	31 c0                	xor    %eax,%eax
  108b26:	e8 cd 7a ff ff       	callq  1005f8 <printk>
  108b2b:	be 2b 06 00 00       	mov    $0x62b,%esi
  108b30:	bf e5 e8 11 00       	mov    $0x11e8e5,%edi
  108b35:	e8 5e a0 ff ff       	callq  102b98 <assert_post_action>
			child_dst = page_pool_get();
  108b3a:	e8 40 fe ff ff       	callq  10897f <page_pool_get>
			if (child_dst == NULL) {
  108b3f:	48 85 c0             	test   %rax,%rax
  108b42:	74 3a                	je     108b7e <copy_page_table+0x168>
			dst[i] = ((pentry_t)z_mem_phys_addr(child_dst) |
  108b44:	48 89 c7             	mov    %rax,%rdi
  108b47:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
  108b4b:	e8 72 fe ff ff       	callq  1089c2 <z_mem_phys_addr>
			ret = copy_page_table(child_dst,
  108b50:	89 de                	mov    %ebx,%esi
			dst[i] = ((pentry_t)z_mem_phys_addr(child_dst) |
  108b52:	48 83 c8 07          	or     $0x7,%rax
  108b56:	4b 89 04 f4          	mov    %rax,(%r12,%r14,8)
			ret = copy_page_table(child_dst,
  108b5a:	49 8b 3f             	mov    (%r15),%rdi
  108b5d:	e8 c6 fd ff ff       	callq  108928 <next_table>
  108b62:	4c 8b 45 b8          	mov    -0x48(%rbp),%r8
  108b66:	8d 53 01             	lea    0x1(%rbx),%edx
  108b69:	48 89 c6             	mov    %rax,%rsi
  108b6c:	4c 89 c7             	mov    %r8,%rdi
  108b6f:	e8 a2 fe ff ff       	callq  108a16 <copy_page_table>
			if (ret != 0) {
  108b74:	85 c0                	test   %eax,%eax
  108b76:	0f 84 31 ff ff ff    	je     108aad <copy_page_table+0x97>
  108b7c:	eb 05                	jmp    108b83 <copy_page_table+0x16d>
				return -ENOMEM;
  108b7e:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
}
  108b83:	48 83 c4 28          	add    $0x28,%rsp
  108b87:	5b                   	pop    %rbx
  108b88:	41 5c                	pop    %r12
  108b8a:	41 5d                	pop    %r13
  108b8c:	41 5e                	pop    %r14
  108b8e:	41 5f                	pop    %r15
  108b90:	5d                   	pop    %rbp
  108b91:	c3                   	retq   

0000000000108b92 <pentry_get>:
{
  108b92:	55                   	push   %rbp
  108b93:	48 89 e5             	mov    %rsp,%rbp
  108b96:	41 57                	push   %r15
  108b98:	49 89 f7             	mov    %rsi,%r15
  108b9b:	48 89 d6             	mov    %rdx,%rsi
  108b9e:	41 56                	push   %r14
  108ba0:	49 89 fe             	mov    %rdi,%r14
  108ba3:	41 55                	push   %r13
  108ba5:	49 89 cd             	mov    %rcx,%r13
  108ba8:	41 54                	push   %r12
  108baa:	41 bc 20 ad 11 00    	mov    $0x11ad20,%r12d
  108bb0:	53                   	push   %rbx
	for (int level = 0; level < NUM_LEVELS; level++) {
  108bb1:	31 db                	xor    %ebx,%ebx
{
  108bb3:	41 50                	push   %r8
	return (((uintptr_t)virt >> paging_levels[level].shift) %
  108bb5:	41 8b 4c 24 10       	mov    0x10(%r12),%ecx
  108bba:	4c 89 e8             	mov    %r13,%rax
  108bbd:	31 d2                	xor    %edx,%edx
  108bbf:	48 d3 e8             	shr    %cl,%rax
  108bc2:	49 f7 74 24 08       	divq   0x8(%r12)
	return ptables[get_index(virt, level)];
  108bc7:	48 63 d2             	movslq %edx,%rdx
  108bca:	48 8b 3c d6          	mov    (%rsi,%rdx,8),%rdi
		if ((entry & MMU_P) == 0 || is_leaf(level, entry)) {
  108bce:	40 f6 c7 01          	test   $0x1,%dil
  108bd2:	74 0f                	je     108be3 <pentry_get+0x51>
	if (level == PTE_LEVEL) {
  108bd4:	83 fb 03             	cmp    $0x3,%ebx
  108bd7:	74 0a                	je     108be3 <pentry_get+0x51>
		if ((entry & MMU_P) == 0 || is_leaf(level, entry)) {
  108bd9:	49 83 c4 20          	add    $0x20,%r12
  108bdd:	40 f6 c7 80          	test   $0x80,%dil
  108be1:	74 0d                	je     108bf0 <pentry_get+0x5e>
			*val = entry;
  108be3:	49 89 3f             	mov    %rdi,(%r15)
			if (paging_level != NULL) {
  108be6:	4d 85 f6             	test   %r14,%r14
  108be9:	74 13                	je     108bfe <pentry_get+0x6c>
				*paging_level = level;
  108beb:	41 89 1e             	mov    %ebx,(%r14)
  108bee:	eb 0e                	jmp    108bfe <pentry_get+0x6c>
			table = next_table(entry, level);
  108bf0:	89 de                	mov    %ebx,%esi
	for (int level = 0; level < NUM_LEVELS; level++) {
  108bf2:	ff c3                	inc    %ebx
			table = next_table(entry, level);
  108bf4:	e8 2f fd ff ff       	callq  108928 <next_table>
  108bf9:	48 89 c6             	mov    %rax,%rsi
	for (int level = 0; level < NUM_LEVELS; level++) {
  108bfc:	eb b7                	jmp    108bb5 <pentry_get+0x23>
}
  108bfe:	58                   	pop    %rax
  108bff:	5b                   	pop    %rbx
  108c00:	41 5c                	pop    %r12
  108c02:	41 5d                	pop    %r13
  108c04:	41 5e                	pop    %r14
  108c06:	41 5f                	pop    %r15
  108c08:	5d                   	pop    %rbp
  108c09:	c3                   	retq   

0000000000108c0a <range_map_ptables>:
{
  108c0a:	55                   	push   %rbp
  108c0b:	48 89 e5             	mov    %rsp,%rbp
  108c0e:	41 57                	push   %r15
  108c10:	41 56                	push   %r14
  108c12:	41 55                	push   %r13
  108c14:	41 54                	push   %r12
  108c16:	53                   	push   %rbx
  108c17:	48 83 ec 48          	sub    $0x48,%rsp
  108c1b:	8b 45 10             	mov    0x10(%rbp),%eax
  108c1e:	48 89 7d a0          	mov    %rdi,-0x60(%rbp)
  108c22:	48 89 75 98          	mov    %rsi,-0x68(%rbp)
  108c26:	83 e0 0c             	and    $0xc,%eax
  108c29:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  108c2d:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
  108c31:	4c 89 45 b8          	mov    %r8,-0x48(%rbp)
  108c35:	4c 89 4d 90          	mov    %r9,-0x70(%rbp)
  108c39:	89 45 ac             	mov    %eax,-0x54(%rbp)
	__ASSERT((addr & (CONFIG_MMU_PAGE_SIZE - 1)) == 0U,
  108c3c:	f7 c2 ff 0f 00 00    	test   $0xfff,%edx
  108c42:	74 3a                	je     108c7e <range_map_ptables+0x74>
  108c44:	b9 c2 01 00 00       	mov    $0x1c2,%ecx
  108c49:	ba e5 e8 11 00       	mov    $0x11e8e5,%edx
  108c4e:	be 47 e9 11 00       	mov    $0x11e947,%esi
  108c53:	31 c0                	xor    %eax,%eax
  108c55:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  108c5a:	e8 99 79 ff ff       	callq  1005f8 <printk>
  108c5f:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
  108c63:	bf 63 e9 11 00       	mov    $0x11e963,%edi
  108c68:	31 c0                	xor    %eax,%eax
  108c6a:	e8 89 79 ff ff       	callq  1005f8 <printk>
  108c6f:	be c2 01 00 00       	mov    $0x1c2,%esi
  108c74:	bf e5 e8 11 00       	mov    $0x11e8e5,%edi
  108c79:	e8 1a 9f ff ff       	callq  102b98 <assert_post_action>
	__ASSERT((size & (CONFIG_MMU_PAGE_SIZE - 1)) == 0U,
  108c7e:	48 f7 45 c0 ff 0f 00 	testq  $0xfff,-0x40(%rbp)
  108c85:	00 
  108c86:	74 3a                	je     108cc2 <range_map_ptables+0xb8>
  108c88:	b9 00 04 00 00       	mov    $0x400,%ecx
  108c8d:	ba e5 e8 11 00       	mov    $0x11e8e5,%edx
  108c92:	be 7d e9 11 00       	mov    $0x11e97d,%esi
  108c97:	31 c0                	xor    %eax,%eax
  108c99:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  108c9e:	e8 55 79 ff ff       	callq  1005f8 <printk>
  108ca3:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  108ca7:	bf 99 e9 11 00       	mov    $0x11e999,%edi
  108cac:	31 c0                	xor    %eax,%eax
  108cae:	e8 45 79 ff ff       	callq  1005f8 <printk>
  108cb3:	be 00 04 00 00       	mov    $0x400,%esi
  108cb8:	bf e5 e8 11 00       	mov    $0x11e8e5,%edi
  108cbd:	e8 d6 9e ff ff       	callq  102b98 <assert_post_action>
	__ASSERT((entry_flags & paging_levels[0].mask) == 0U,
  108cc2:	48 b8 00 f0 ff ff ff 	movabs $0x7ffffffffffff000,%rax
  108cc9:	ff ff 7f 
  108ccc:	48 85 45 b8          	test   %rax,-0x48(%rbp)
  108cd0:	74 3a                	je     108d0c <range_map_ptables+0x102>
  108cd2:	b9 02 04 00 00       	mov    $0x402,%ecx
  108cd7:	ba e5 e8 11 00       	mov    $0x11e8e5,%edx
  108cdc:	be ae e9 11 00       	mov    $0x11e9ae,%esi
  108ce1:	31 c0                	xor    %eax,%eax
  108ce3:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  108ce8:	e8 0b 79 ff ff       	callq  1005f8 <printk>
  108ced:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  108cf1:	bf da e9 11 00       	mov    $0x11e9da,%edi
  108cf6:	31 c0                	xor    %eax,%eax
  108cf8:	e8 fb 78 ff ff       	callq  1005f8 <printk>
  108cfd:	be 02 04 00 00       	mov    $0x402,%esi
  108d02:	bf e5 e8 11 00       	mov    $0x11e8e5,%edi
  108d07:	e8 8c 9e ff ff       	callq  102b98 <assert_post_action>
	for (int level = 0; level < NUM_LEVELS; level++) {
  108d0c:	31 db                	xor    %ebx,%ebx
	for (size_t offset = 0; offset < size; offset += CONFIG_MMU_PAGE_SIZE) {
  108d0e:	48 3b 5d c0          	cmp    -0x40(%rbp),%rbx
  108d12:	0f 83 9a 01 00 00    	jae    108eb2 <range_map_ptables+0x2a8>
		uint8_t *dest_virt = (uint8_t *)virt + offset;
  108d18:	48 8b 45 98          	mov    -0x68(%rbp),%rax
		if (zero_entry) {
  108d1c:	83 7d ac 00          	cmpl   $0x0,-0x54(%rbp)
			entry_val = 0;
  108d20:	48 c7 45 b0 00 00 00 	movq   $0x0,-0x50(%rbp)
  108d27:	00 
  108d28:	4c 8d 3c 18          	lea    (%rax,%rbx,1),%r15
		if (zero_entry) {
  108d2c:	75 0f                	jne    108d3d <range_map_ptables+0x133>
			entry_val = (pentry_t)(phys + offset) | entry_flags;
  108d2e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  108d32:	48 01 d8             	add    %rbx,%rax
  108d35:	48 0b 45 b8          	or     -0x48(%rbp),%rax
  108d39:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
	bool flush = (options & OPTION_FLUSH) != 0U;
  108d3d:	8b 45 10             	mov    0x10(%rbp),%eax
	pentry_t *table = ptables;
  108d40:	4c 8b 65 a0          	mov    -0x60(%rbp),%r12
  108d44:	41 be 20 ad 11 00    	mov    $0x11ad20,%r14d
	for (int level = 0; level < NUM_LEVELS; level++) {
  108d4a:	45 31 ed             	xor    %r13d,%r13d
  108d4d:	83 e0 02             	and    $0x2,%eax
  108d50:	89 45 a8             	mov    %eax,-0x58(%rbp)
	return (((uintptr_t)virt >> paging_levels[level].shift) %
  108d53:	41 8b 4e 10          	mov    0x10(%r14),%ecx
  108d57:	4c 89 f8             	mov    %r15,%rax
  108d5a:	31 d2                	xor    %edx,%edx
  108d5c:	48 d3 e8             	shr    %cl,%rax
  108d5f:	49 f7 76 08          	divq   0x8(%r14)
		entryp = &table[index];
  108d63:	48 63 d2             	movslq %edx,%rdx
  108d66:	4d 8d 24 d4          	lea    (%r12,%rdx,8),%r12
		if (level == PTE_LEVEL) {
  108d6a:	41 83 fd 03          	cmp    $0x3,%r13d
  108d6e:	0f 85 99 00 00 00    	jne    108e0d <range_map_ptables+0x203>
	bool reset = (options & OPTION_RESET) != 0U;
  108d74:	8b 75 10             	mov    0x10(%rbp),%esi
  108d77:	44 8b 4d 10          	mov    0x10(%rbp),%r9d
	if (user_table && (val & MMU_US) == 0 && (val & MMU_P) != 0 &&
  108d7b:	44 8a 55 10          	mov    0x10(%rbp),%r10b
  108d7f:	83 e6 04             	and    $0x4,%esi
	bool clear = (options & OPTION_CLEAR) != 0U;
  108d82:	41 83 e1 08          	and    $0x8,%r9d
	if (user_table && (val & MMU_US) == 0 && (val & MMU_P) != 0 &&
  108d86:	41 83 e2 01          	and    $0x1,%r10d
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
  108d8a:	49 8b 0c 24          	mov    (%r12),%rcx
	return (pte & MMU_P) == 0 && (pte & PTE_ZERO) != 0;
  108d8e:	48 89 c8             	mov    %rcx,%rax
  108d91:	48 89 cf             	mov    %rcx,%rdi
  108d94:	25 81 00 00 00       	and    $0x81,%eax
		if (is_flipped_pte(new_val)) {
  108d99:	48 3d 80 00 00 00    	cmp    $0x80,%rax
  108d9f:	75 03                	jne    108da4 <range_map_ptables+0x19a>
			new_val = ~new_val;
  108da1:	48 f7 d7             	not    %rdi
		if (reset) {
  108da4:	85 f6                	test   %esi,%esi
  108da6:	74 0a                	je     108db2 <range_map_ptables+0x1a8>
			new_val = reset_pte(new_val);
  108da8:	e8 fa fa ff ff       	callq  1088a7 <reset_pte>
  108dad:	48 89 c2             	mov    %rax,%rdx
  108db0:	eb 15                	jmp    108dc7 <range_map_ptables+0x1bd>
			new_val = 0;
  108db2:	31 d2                	xor    %edx,%edx
		} else if (clear) {
  108db4:	45 85 c9             	test   %r9d,%r9d
  108db7:	75 0e                	jne    108dc7 <range_map_ptables+0x1bd>
			new_val = ((new_val & ~update_mask) |
  108db9:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  108dbd:	48 31 fa             	xor    %rdi,%rdx
  108dc0:	48 23 55 90          	and    -0x70(%rbp),%rdx
  108dc4:	48 31 fa             	xor    %rdi,%rdx
	if (user_table && (val & MMU_US) == 0 && (val & MMU_P) != 0 &&
  108dc7:	45 84 d2             	test   %r10b,%r10b
  108dca:	74 23                	je     108def <range_map_ptables+0x1e5>
  108dcc:	48 89 d0             	mov    %rdx,%rax
  108dcf:	83 e0 05             	and    $0x5,%eax
  108dd2:	48 ff c8             	dec    %rax
  108dd5:	75 18                	jne    108def <range_map_ptables+0x1e5>
	return entry & paging_levels[level].mask;
  108dd7:	48 b8 00 f0 ff ff ff 	movabs $0x7fffffffffff000,%rax
  108dde:	ff ff 07 
  108de1:	48 21 d0             	and    %rdx,%rax
	if (user_table && (val & MMU_US) == 0 && (val & MMU_P) != 0 &&
  108de4:	48 3d 00 60 00 00    	cmp    $0x6000,%rax
  108dea:	74 03                	je     108def <range_map_ptables+0x1e5>
		val = ~val;
  108dec:	48 f7 d2             	not    %rdx
	return __atomic_compare_exchange_n(target, &old_value, new_value,
  108def:	48 89 c8             	mov    %rcx,%rax
  108df2:	f0 49 0f b1 14 24    	lock cmpxchg %rdx,(%r12)
	} while (atomic_pte_cas(pte, old_val, new_val) == false);
  108df8:	75 90                	jne    108d8a <range_map_ptables+0x180>
	if (flush) {
  108dfa:	83 7d a8 00          	cmpl   $0x0,-0x58(%rbp)
  108dfe:	0f 84 a2 00 00 00    	je     108ea6 <range_map_ptables+0x29c>
	__asm__ ("invlpg %0" :: "m" (*page));
  108e04:	41 0f 01 3f          	invlpg (%r15)
}
  108e08:	e9 99 00 00 00       	jmpq   108ea6 <range_map_ptables+0x29c>
		__ASSERT((*entryp & MMU_PS) == 0U, "large page encountered");
  108e0d:	41 f6 04 24 80       	testb  $0x80,(%r12)
  108e12:	74 36                	je     108e4a <range_map_ptables+0x240>
  108e14:	be 08 ea 11 00       	mov    $0x11ea08,%esi
  108e19:	b9 d3 03 00 00       	mov    $0x3d3,%ecx
  108e1e:	ba e5 e8 11 00       	mov    $0x11e8e5,%edx
  108e23:	31 c0                	xor    %eax,%eax
  108e25:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  108e2a:	e8 c9 77 ff ff       	callq  1005f8 <printk>
  108e2f:	bf 2e e9 11 00       	mov    $0x11e92e,%edi
  108e34:	31 c0                	xor    %eax,%eax
  108e36:	e8 bd 77 ff ff       	callq  1005f8 <printk>
  108e3b:	be d3 03 00 00       	mov    $0x3d3,%esi
  108e40:	bf e5 e8 11 00       	mov    $0x11e8e5,%edi
  108e45:	e8 4e 9d ff ff       	callq  102b98 <assert_post_action>
		table = next_table(*entryp, level);
  108e4a:	49 8b 3c 24          	mov    (%r12),%rdi
  108e4e:	44 89 ee             	mov    %r13d,%esi
		__ASSERT(table != NULL,
  108e51:	41 ff c5             	inc    %r13d
		table = next_table(*entryp, level);
  108e54:	e8 cf fa ff ff       	callq  108928 <next_table>
  108e59:	49 89 c4             	mov    %rax,%r12
		__ASSERT(table != NULL,
  108e5c:	48 85 c0             	test   %rax,%rax
  108e5f:	75 3c                	jne    108e9d <range_map_ptables+0x293>
  108e61:	b9 d5 03 00 00       	mov    $0x3d5,%ecx
  108e66:	ba e5 e8 11 00       	mov    $0x11e8e5,%edx
  108e6b:	be 28 ea 11 00       	mov    $0x11ea28,%esi
  108e70:	31 c0                	xor    %eax,%eax
  108e72:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  108e77:	e8 7c 77 ff ff       	callq  1005f8 <printk>
  108e7c:	44 89 ee             	mov    %r13d,%esi
  108e7f:	bf 3d ea 11 00       	mov    $0x11ea3d,%edi
  108e84:	4c 89 fa             	mov    %r15,%rdx
  108e87:	31 c0                	xor    %eax,%eax
  108e89:	e8 6a 77 ff ff       	callq  1005f8 <printk>
  108e8e:	be d5 03 00 00       	mov    $0x3d5,%esi
  108e93:	bf e5 e8 11 00       	mov    $0x11e8e5,%edi
  108e98:	e8 fb 9c ff ff       	callq  102b98 <assert_post_action>
	for (int level = 0; level < NUM_LEVELS; level++) {
  108e9d:	49 83 c6 20          	add    $0x20,%r14
  108ea1:	e9 ad fe ff ff       	jmpq   108d53 <range_map_ptables+0x149>
	for (size_t offset = 0; offset < size; offset += CONFIG_MMU_PAGE_SIZE) {
  108ea6:	48 81 c3 00 10 00 00 	add    $0x1000,%rbx
  108ead:	e9 5c fe ff ff       	jmpq   108d0e <range_map_ptables+0x104>
}
  108eb2:	48 83 c4 48          	add    $0x48,%rsp
  108eb6:	5b                   	pop    %rbx
  108eb7:	41 5c                	pop    %r12
  108eb9:	41 5d                	pop    %r13
  108ebb:	41 5e                	pop    %r14
  108ebd:	41 5f                	pop    %r15
  108ebf:	5d                   	pop    %rbp
  108ec0:	c3                   	retq   

0000000000108ec1 <range_map_unlocked>:
{
  108ec1:	55                   	push   %rbp
  108ec2:	48 89 e5             	mov    %rsp,%rbp
  108ec5:	41 57                	push   %r15
  108ec7:	49 89 f7             	mov    %rsi,%r15
  108eca:	41 56                	push   %r14
  108ecc:	4d 89 c6             	mov    %r8,%r14
  108ecf:	41 55                	push   %r13
  108ed1:	49 89 d5             	mov    %rdx,%r13
  108ed4:	41 54                	push   %r12
  108ed6:	49 89 fc             	mov    %rdi,%r12
  108ed9:	53                   	push   %rbx
  108eda:	48 89 cb             	mov    %rcx,%rbx
  108edd:	48 83 ec 28          	sub    $0x28,%rsp
  108ee1:	44 89 4d cc          	mov    %r9d,-0x34(%rbp)
  108ee5:	9c                   	pushfq 
  108ee6:	fa                   	cli    
  108ee7:	8f 45 c0             	popq   -0x40(%rbp)
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  108eea:	bf 68 cd 1b 00       	mov    $0x1bcd68,%edi
  108eef:	e8 85 49 00 00       	callq  10d879 <z_spin_lock_valid>
  108ef4:	84 c0                	test   %al,%al
  108ef6:	75 39                	jne    108f31 <range_map_unlocked+0x70>
  108ef8:	b9 8e 00 00 00       	mov    $0x8e,%ecx
  108efd:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  108f02:	be fd d1 11 00       	mov    $0x11d1fd,%esi
  108f07:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  108f0c:	e8 e7 76 ff ff       	callq  1005f8 <printk>
  108f11:	be 68 cd 1b 00       	mov    $0x1bcd68,%esi
  108f16:	bf 12 d2 11 00       	mov    $0x11d212,%edi
  108f1b:	31 c0                	xor    %eax,%eax
  108f1d:	e8 d6 76 ff ff       	callq  1005f8 <printk>
  108f22:	be 8e 00 00 00       	mov    $0x8e,%esi
  108f27:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  108f2c:	e8 67 9c ff ff       	callq  102b98 <assert_post_action>
	z_spin_lock_set_owner(l);
  108f31:	bf 68 cd 1b 00       	mov    $0x1bcd68,%edi
  108f36:	e8 82 49 00 00       	callq  10d8bd <z_spin_lock_set_owner>
	__ASSERT(((((intptr_t)virt) << 16) >> 16) == (intptr_t)virt,
  108f3b:	4c 89 e0             	mov    %r12,%rax
  108f3e:	48 c1 e0 10          	shl    $0x10,%rax
  108f42:	48 c1 f8 10          	sar    $0x10,%rax
  108f46:	49 39 c4             	cmp    %rax,%r12
  108f49:	74 3c                	je     108f87 <range_map_unlocked+0xc6>
  108f4b:	b9 3c 04 00 00       	mov    $0x43c,%ecx
  108f50:	ba e5 e8 11 00       	mov    $0x11e8e5,%edx
  108f55:	be 71 ea 11 00       	mov    $0x11ea71,%esi
  108f5a:	31 c0                	xor    %eax,%eax
  108f5c:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  108f61:	e8 92 76 ff ff       	callq  1005f8 <printk>
  108f66:	4c 89 e6             	mov    %r12,%rsi
  108f69:	bf a4 ea 11 00       	mov    $0x11eaa4,%edi
  108f6e:	4c 89 ea             	mov    %r13,%rdx
  108f71:	31 c0                	xor    %eax,%eax
  108f73:	e8 80 76 ff ff       	callq  1005f8 <printk>
  108f78:	be 3c 04 00 00       	mov    $0x43c,%esi
  108f7d:	bf e5 e8 11 00       	mov    $0x11e8e5,%edi
  108f82:	e8 11 9c ff ff       	callq  102b98 <assert_post_action>
		range_map_ptables(domain->ptables, virt, phys, size,
  108f87:	8b 4d cc             	mov    -0x34(%rbp),%ecx
 *
 * @return A pointer on the first node of the list (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_head(sys_slist_t *list)
{
	return list->head;
  108f8a:	48 8b 05 6f 3d 0b 00 	mov    0xb3d6f(%rip),%rax        # 1bcd00 <x86_domain_list>
  108f91:	83 c9 01             	or     $0x1,%ecx
  108f94:	89 4d c8             	mov    %ecx,-0x38(%rbp)
	SYS_SLIST_FOR_EACH_NODE(&x86_domain_list, node) {
  108f97:	48 85 c0             	test   %rax,%rax
  108f9a:	74 2d                	je     108fc9 <range_map_unlocked+0x108>
		range_map_ptables(domain->ptables, virt, phys, size,
  108f9c:	48 8b 78 f8          	mov    -0x8(%rax),%rdi
  108fa0:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
  108fa4:	49 89 d8             	mov    %rbx,%r8
  108fa7:	4d 89 f1             	mov    %r14,%r9
  108faa:	8b 45 c8             	mov    -0x38(%rbp),%eax
  108fad:	56                   	push   %rsi
  108fae:	4c 89 e9             	mov    %r13,%rcx
  108fb1:	4c 89 fa             	mov    %r15,%rdx
  108fb4:	4c 89 e6             	mov    %r12,%rsi
  108fb7:	50                   	push   %rax
  108fb8:	e8 4d fc ff ff       	callq  108c0a <range_map_ptables>
	return node->next;
  108fbd:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  108fc1:	5f                   	pop    %rdi
  108fc2:	41 58                	pop    %r8
  108fc4:	48 8b 00             	mov    (%rax),%rax
  108fc7:	eb ce                	jmp    108f97 <range_map_unlocked+0xd6>
	range_map_ptables(z_x86_kernel_ptables, virt, phys, size, entry_flags,
  108fc9:	50                   	push   %rax
  108fca:	8b 45 cc             	mov    -0x34(%rbp),%eax
  108fcd:	4c 89 e9             	mov    %r13,%rcx
  108fd0:	4c 89 fa             	mov    %r15,%rdx
  108fd3:	bf 00 40 6e 00       	mov    $0x6e4000,%edi
  108fd8:	4d 89 f1             	mov    %r14,%r9
  108fdb:	49 89 d8             	mov    %rbx,%r8
  108fde:	4c 89 e6             	mov    %r12,%rsi
  108fe1:	50                   	push   %rax
  108fe2:	e8 23 fc ff ff       	callq  108c0a <range_map_ptables>
  108fe7:	5a                   	pop    %rdx
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  108fe8:	bf 68 cd 1b 00       	mov    $0x1bcd68,%edi
  108fed:	59                   	pop    %rcx
  108fee:	e8 a6 48 00 00       	callq  10d899 <z_spin_unlock_valid>
  108ff3:	84 c0                	test   %al,%al
  108ff5:	75 39                	jne    109030 <range_map_unlocked+0x16f>
  108ff7:	b9 b9 00 00 00       	mov    $0xb9,%ecx
  108ffc:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  109001:	be 41 d2 11 00       	mov    $0x11d241,%esi
  109006:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  10900b:	e8 e8 75 ff ff       	callq  1005f8 <printk>
  109010:	be 68 cd 1b 00       	mov    $0x1bcd68,%esi
  109015:	bf 58 d2 11 00       	mov    $0x11d258,%edi
  10901a:	31 c0                	xor    %eax,%eax
  10901c:	e8 d7 75 ff ff       	callq  1005f8 <printk>
  109021:	be b9 00 00 00       	mov    $0xb9,%esi
  109026:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  10902b:	e8 68 9b ff ff       	callq  102b98 <assert_post_action>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  109030:	0f ba 65 c0 09       	btl    $0x9,-0x40(%rbp)
  109035:	73 01                	jae    109038 <range_map_unlocked+0x177>
		__asm__ volatile ("sti" ::: "memory");
  109037:	fb                   	sti    
}
  109038:	48 8d 65 d8          	lea    -0x28(%rbp),%rsp
  10903c:	5b                   	pop    %rbx
  10903d:	41 5c                	pop    %r12
  10903f:	41 5d                	pop    %r13
  109041:	41 5e                	pop    %r14
  109043:	41 5f                	pop    %r15
  109045:	5d                   	pop    %rbp
  109046:	c3                   	retq   

0000000000109047 <region_map_update>:

__pinned_func
static void region_map_update(pentry_t *ptables, void *start,
			      size_t size, pentry_t flags, bool reset)
{
  109047:	55                   	push   %rbp
  109048:	48 89 e5             	mov    %rsp,%rbp
  10904b:	41 57                	push   %r15
  10904d:	49 89 cf             	mov    %rcx,%r15
  109050:	41 56                	push   %r14
  109052:	49 89 d6             	mov    %rdx,%r14
  109055:	41 55                	push   %r13
  109057:	49 89 f5             	mov    %rsi,%r13
  10905a:	41 54                	push   %r12
  10905c:	49 89 fc             	mov    %rdi,%r12
  10905f:	53                   	push   %rbx
  109060:	48 83 ec 18          	sub    $0x18,%rsp
	uint32_t options = OPTION_USER;
	k_spinlock_key_t key;

	if (reset) {
		options |= OPTION_RESET;
  109064:	41 80 f8 01          	cmp    $0x1,%r8b
  109068:	19 db                	sbb    %ebx,%ebx
  10906a:	83 e3 fc             	and    $0xfffffffc,%ebx
  10906d:	83 c3 05             	add    $0x5,%ebx
  109070:	0f 20 df             	mov    %cr3,%rdi
	return z_mem_virt_addr(z_x86_cr3_get());
  109073:	e8 5c f8 ff ff       	callq  1088d4 <z_mem_virt_addr>
	}
	if (ptables == z_x86_page_tables_get()) {
  109078:	49 39 c4             	cmp    %rax,%r12
  10907b:	75 03                	jne    109080 <region_map_update+0x39>
		options |= OPTION_FLUSH;
  10907d:	83 cb 02             	or     $0x2,%ebx
  109080:	9c                   	pushfq 
  109081:	fa                   	cli    
  109082:	8f 45 c8             	popq   -0x38(%rbp)
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  109085:	bf 68 cd 1b 00       	mov    $0x1bcd68,%edi
  10908a:	e8 ea 47 00 00       	callq  10d879 <z_spin_lock_valid>
  10908f:	84 c0                	test   %al,%al
  109091:	75 39                	jne    1090cc <region_map_update+0x85>
  109093:	b9 8e 00 00 00       	mov    $0x8e,%ecx
  109098:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  10909d:	be fd d1 11 00       	mov    $0x11d1fd,%esi
  1090a2:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  1090a7:	e8 4c 75 ff ff       	callq  1005f8 <printk>
  1090ac:	be 68 cd 1b 00       	mov    $0x1bcd68,%esi
  1090b1:	bf 12 d2 11 00       	mov    $0x11d212,%edi
  1090b6:	31 c0                	xor    %eax,%eax
  1090b8:	e8 3b 75 ff ff       	callq  1005f8 <printk>
  1090bd:	be 8e 00 00 00       	mov    $0x8e,%esi
  1090c2:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  1090c7:	e8 cc 9a ff ff       	callq  102b98 <assert_post_action>
	z_spin_lock_set_owner(l);
  1090cc:	bf 68 cd 1b 00       	mov    $0x1bcd68,%edi
  1090d1:	e8 e7 47 00 00       	callq  10d8bd <z_spin_lock_set_owner>
	}

	key = k_spin_lock(&x86_mmu_lock);
	(void)range_map_ptables(ptables, start, 0, size, flags, MASK_PERM,
  1090d6:	31 d2                	xor    %edx,%edx
  1090d8:	4c 89 f1             	mov    %r14,%rcx
  1090db:	4c 89 e7             	mov    %r12,%rdi
  1090de:	50                   	push   %rax
  1090df:	4d 89 f8             	mov    %r15,%r8
  1090e2:	4c 89 ee             	mov    %r13,%rsi
  1090e5:	49 b9 06 00 00 00 00 	movabs $0x8000000000000006,%r9
  1090ec:	00 00 80 
  1090ef:	53                   	push   %rbx
  1090f0:	e8 15 fb ff ff       	callq  108c0a <range_map_ptables>
  1090f5:	5a                   	pop    %rdx
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  1090f6:	bf 68 cd 1b 00       	mov    $0x1bcd68,%edi
  1090fb:	59                   	pop    %rcx
  1090fc:	e8 98 47 00 00       	callq  10d899 <z_spin_unlock_valid>
  109101:	84 c0                	test   %al,%al
  109103:	75 39                	jne    10913e <region_map_update+0xf7>
  109105:	b9 b9 00 00 00       	mov    $0xb9,%ecx
  10910a:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  10910f:	be 41 d2 11 00       	mov    $0x11d241,%esi
  109114:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  109119:	e8 da 74 ff ff       	callq  1005f8 <printk>
  10911e:	be 68 cd 1b 00       	mov    $0x1bcd68,%esi
  109123:	bf 58 d2 11 00       	mov    $0x11d258,%edi
  109128:	31 c0                	xor    %eax,%eax
  10912a:	e8 c9 74 ff ff       	callq  1005f8 <printk>
  10912f:	be b9 00 00 00       	mov    $0xb9,%esi
  109134:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  109139:	e8 5a 9a ff ff       	callq  102b98 <assert_post_action>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  10913e:	0f ba 65 c8 09       	btl    $0x9,-0x38(%rbp)
  109143:	73 01                	jae    109146 <region_map_update+0xff>
		__asm__ volatile ("sti" ::: "memory");
  109145:	fb                   	sti    
	k_spin_unlock(&x86_mmu_lock, key);

#ifdef CONFIG_SMP
	tlb_shootdown();
#endif
}
  109146:	48 8d 65 d8          	lea    -0x28(%rbp),%rsp
  10914a:	5b                   	pop    %rbx
  10914b:	41 5c                	pop    %r12
  10914d:	41 5d                	pop    %r13
  10914f:	41 5e                	pop    %r14
  109151:	41 5f                	pop    %r15
  109153:	5d                   	pop    %rbp
  109154:	c3                   	retq   

0000000000109155 <z_x86_dump_mmu_flags>:
{
  109155:	55                   	push   %rbp
  109156:	48 89 fa             	mov    %rdi,%rdx
	pentry_get(&level, &entry, ptables, virt);
  109159:	48 89 f1             	mov    %rsi,%rcx
{
  10915c:	48 89 e5             	mov    %rsp,%rbp
  10915f:	41 56                	push   %r14
  109161:	41 55                	push   %r13
	pentry_get(&level, &entry, ptables, virt);
  109163:	48 8d 7d ac          	lea    -0x54(%rbp),%rdi
{
  109167:	49 89 f5             	mov    %rsi,%r13
	pentry_get(&level, &entry, ptables, virt);
  10916a:	48 8d 75 b0          	lea    -0x50(%rbp),%rsi
{
  10916e:	41 54                	push   %r12
  109170:	53                   	push   %rbx
  109171:	48 83 ec 40          	sub    $0x40,%rsp
	pentry_t entry = 0;
  109175:	48 c7 45 b0 00 00 00 	movq   $0x0,-0x50(%rbp)
  10917c:	00 
	int level = 0;
  10917d:	c7 45 ac 00 00 00 00 	movl   $0x0,-0x54(%rbp)
	pentry_get(&level, &entry, ptables, virt);
  109184:	e8 09 fa ff ff       	callq  108b92 <pentry_get>
	if ((entry & MMU_P) == 0) {
  109189:	4c 8b 65 b0          	mov    -0x50(%rbp),%r12
  10918d:	48 63 5d ac          	movslq -0x54(%rbp),%rbx
  109191:	41 f6 c4 01          	test   $0x1,%r12b
  109195:	75 21                	jne    1091b8 <z_x86_dump_mmu_flags+0x63>
		LOG_ERR("%sE: not present", paging_levels[level].name);
  109197:	48 c1 e3 05          	shl    $0x5,%rbx
  10919b:	be 45 00 00 00       	mov    $0x45,%esi
  1091a0:	bf da ea 11 00       	mov    $0x11eada,%edi
  1091a5:	31 c0                	xor    %eax,%eax
  1091a7:	48 8b 93 38 ad 11 00 	mov    0x11ad38(%rbx),%rdx
  1091ae:	e8 13 9f ff ff       	callq  1030c6 <z_log_minimal_printk>
  1091b3:	e9 22 01 00 00       	jmpq   1092da <z_x86_dump_mmu_flags+0x185>
	return (1UL << paging_levels[level].shift);
  1091b8:	48 89 d8             	mov    %rbx,%rax
	char buf[24] = { 0 };
  1091bb:	0f 57 c0             	xorps  %xmm0,%xmm0
	char *pos = buf;
  1091be:	4c 8d 75 c8          	lea    -0x38(%rbp),%r14
	return (1UL << paging_levels[level].shift);
  1091c2:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
  1091c6:	48 c1 e0 05          	shl    $0x5,%rax
	char buf[24] = { 0 };
  1091ca:	48 c7 45 d8 00 00 00 	movq   $0x0,-0x28(%rbp)
  1091d1:	00 
	return (1UL << paging_levels[level].shift);
  1091d2:	8b 88 30 ad 11 00    	mov    0x11ad30(%rax),%ecx
	char *pos = buf;
  1091d8:	4c 89 75 b8          	mov    %r14,-0x48(%rbp)
	size_t sz = sizeof(buf);
  1091dc:	48 c7 45 c0 18 00 00 	movq   $0x18,-0x40(%rbp)
  1091e3:	00 
	uint8_t *virtmap = (uint8_t *)ROUND_DOWN(virt, get_entry_scope(level));
  1091e4:	48 d3 e6             	shl    %cl,%rsi
	char buf[24] = { 0 };
  1091e7:	0f 11 45 c8          	movups %xmm0,-0x38(%rbp)
	uint8_t *virtmap = (uint8_t *)ROUND_DOWN(virt, get_entry_scope(level));
  1091eb:	49 21 f5             	and    %rsi,%r13
	DUMP_BIT(RW);
  1091ee:	41 f6 c4 02          	test   $0x2,%r12b
  1091f2:	74 12                	je     109206 <z_x86_dump_mmu_flags+0xb1>
  1091f4:	ba f0 ea 11 00       	mov    $0x11eaf0,%edx
  1091f9:	48 8d 75 c0          	lea    -0x40(%rbp),%rsi
  1091fd:	48 8d 7d b8          	lea    -0x48(%rbp),%rdi
  109201:	e8 35 f7 ff ff       	callq  10893b <str_append>
	DUMP_BIT(US);
  109206:	41 f6 c4 04          	test   $0x4,%r12b
  10920a:	74 12                	je     10921e <z_x86_dump_mmu_flags+0xc9>
  10920c:	ba f4 ea 11 00       	mov    $0x11eaf4,%edx
  109211:	48 8d 75 c0          	lea    -0x40(%rbp),%rsi
  109215:	48 8d 7d b8          	lea    -0x48(%rbp),%rdi
  109219:	e8 1d f7 ff ff       	callq  10893b <str_append>
	DUMP_BIT(PWT);
  10921e:	41 f6 c4 08          	test   $0x8,%r12b
  109222:	74 12                	je     109236 <z_x86_dump_mmu_flags+0xe1>
  109224:	ba f8 ea 11 00       	mov    $0x11eaf8,%edx
  109229:	48 8d 75 c0          	lea    -0x40(%rbp),%rsi
  10922d:	48 8d 7d b8          	lea    -0x48(%rbp),%rdi
  109231:	e8 05 f7 ff ff       	callq  10893b <str_append>
	DUMP_BIT(PCD);
  109236:	41 f6 c4 10          	test   $0x10,%r12b
  10923a:	74 12                	je     10924e <z_x86_dump_mmu_flags+0xf9>
  10923c:	ba fd ea 11 00       	mov    $0x11eafd,%edx
  109241:	48 8d 75 c0          	lea    -0x40(%rbp),%rsi
  109245:	48 8d 7d b8          	lea    -0x48(%rbp),%rdi
  109249:	e8 ed f6 ff ff       	callq  10893b <str_append>
	DUMP_BIT(A);
  10924e:	41 f6 c4 20          	test   $0x20,%r12b
  109252:	74 12                	je     109266 <z_x86_dump_mmu_flags+0x111>
  109254:	ba 02 eb 11 00       	mov    $0x11eb02,%edx
  109259:	48 8d 75 c0          	lea    -0x40(%rbp),%rsi
  10925d:	48 8d 7d b8          	lea    -0x48(%rbp),%rdi
  109261:	e8 d5 f6 ff ff       	callq  10893b <str_append>
	DUMP_BIT(D);
  109266:	41 f6 c4 40          	test   $0x40,%r12b
  10926a:	74 12                	je     10927e <z_x86_dump_mmu_flags+0x129>
  10926c:	ba ff ea 11 00       	mov    $0x11eaff,%edx
  109271:	48 8d 75 c0          	lea    -0x40(%rbp),%rsi
  109275:	48 8d 7d b8          	lea    -0x48(%rbp),%rdi
  109279:	e8 bd f6 ff ff       	callq  10893b <str_append>
	DUMP_BIT(G);
  10927e:	41 0f ba e4 08       	bt     $0x8,%r12d
  109283:	73 12                	jae    109297 <z_x86_dump_mmu_flags+0x142>
  109285:	ba 05 eb 11 00       	mov    $0x11eb05,%edx
  10928a:	48 8d 75 c0          	lea    -0x40(%rbp),%rsi
  10928e:	48 8d 7d b8          	lea    -0x48(%rbp),%rdi
  109292:	e8 a4 f6 ff ff       	callq  10893b <str_append>
	DUMP_BIT(XD);
  109297:	4d 85 e4             	test   %r12,%r12
  10929a:	79 12                	jns    1092ae <z_x86_dump_mmu_flags+0x159>
  10929c:	ba 08 eb 11 00       	mov    $0x11eb08,%edx
  1092a1:	48 8d 75 c0          	lea    -0x40(%rbp),%rsi
  1092a5:	48 8d 7d b8          	lea    -0x48(%rbp),%rdi
  1092a9:	e8 8d f6 ff ff       	callq  10893b <str_append>
	LOG_ERR("%sE: %p -> " PRI_ENTRY ": %s", info->name,
  1092ae:	48 c1 e3 05          	shl    $0x5,%rbx
  1092b2:	4d 89 f1             	mov    %r14,%r9
  1092b5:	4c 89 e9             	mov    %r13,%rcx
  1092b8:	be 45 00 00 00       	mov    $0x45,%esi
  1092bd:	4c 8b 83 20 ad 11 00 	mov    0x11ad20(%rbx),%r8
  1092c4:	48 8b 93 38 ad 11 00 	mov    0x11ad38(%rbx),%rdx
  1092cb:	bf 0c eb 11 00       	mov    $0x11eb0c,%edi
  1092d0:	31 c0                	xor    %eax,%eax
  1092d2:	4d 21 e0             	and    %r12,%r8
  1092d5:	e8 ec 9d ff ff       	callq  1030c6 <z_log_minimal_printk>
}
  1092da:	48 83 c4 40          	add    $0x40,%rsp
  1092de:	5b                   	pop    %rbx
  1092df:	41 5c                	pop    %r12
  1092e1:	41 5d                	pop    %r13
  1092e3:	41 5e                	pop    %r14
  1092e5:	5d                   	pop    %rbp
  1092e6:	c3                   	retq   

00000000001092e7 <arch_mem_map>:
{
  1092e7:	55                   	push   %rbp
  1092e8:	89 c8                	mov    %ecx,%eax
  1092ea:	83 e0 07             	and    $0x7,%eax
  1092ed:	48 89 e5             	mov    %rsp,%rbp
  1092f0:	41 56                	push   %r14
  1092f2:	49 89 d6             	mov    %rdx,%r14
  1092f5:	41 55                	push   %r13
  1092f7:	49 89 f5             	mov    %rsi,%r13
  1092fa:	41 54                	push   %r12
  1092fc:	49 89 fc             	mov    %rdi,%r12
  1092ff:	53                   	push   %rbx
  109300:	89 cb                	mov    %ecx,%ebx
  109302:	83 f8 02             	cmp    $0x2,%eax
  109305:	77 0a                	ja     109311 <arch_mem_map+0x2a>
  109307:	48 8d 0c c5 01 00 00 	lea    0x1(,%rax,8),%rcx
  10930e:	00 
  10930f:	eb 3d                	jmp    10934e <arch_mem_map+0x67>
		__ASSERT(false, "bad memory mapping flags 0x%x", flags);
  109311:	b9 80 04 00 00       	mov    $0x480,%ecx
  109316:	ba e5 e8 11 00       	mov    $0x11e8e5,%edx
  10931b:	be cb f4 11 00       	mov    $0x11f4cb,%esi
  109320:	31 c0                	xor    %eax,%eax
  109322:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  109327:	e8 cc 72 ff ff       	callq  1005f8 <printk>
  10932c:	89 de                	mov    %ebx,%esi
  10932e:	bf 2a eb 11 00       	mov    $0x11eb2a,%edi
  109333:	31 c0                	xor    %eax,%eax
  109335:	e8 be 72 ff ff       	callq  1005f8 <printk>
  10933a:	be 80 04 00 00       	mov    $0x480,%esi
  10933f:	bf e5 e8 11 00       	mov    $0x11e8e5,%edi
  109344:	e8 4f 98 ff ff       	callq  102b98 <assert_post_action>
	pentry_t entry_flags = MMU_P;
  109349:	b9 01 00 00 00       	mov    $0x1,%ecx
	if ((flags & K_MEM_PERM_RW) != 0U) {
  10934e:	f6 c3 08             	test   $0x8,%bl
  109351:	74 07                	je     10935a <arch_mem_map+0x73>
		entry_flags |= ENTRY_RW;
  109353:	48 81 c9 02 02 00 00 	or     $0x202,%rcx
	if ((flags & K_MEM_PERM_USER) != 0U) {
  10935a:	f6 c3 20             	test   $0x20,%bl
  10935d:	74 07                	je     109366 <arch_mem_map+0x7f>
		entry_flags |= ENTRY_US;
  10935f:	48 81 c9 04 04 00 00 	or     $0x404,%rcx
	if ((flags & K_MEM_PERM_EXEC) == 0U) {
  109366:	80 e3 10             	and    $0x10,%bl
  109369:	75 0d                	jne    109378 <arch_mem_map+0x91>
		entry_flags |= ENTRY_XD;
  10936b:	48 b8 00 08 00 00 00 	movabs $0x8000000000000800,%rax
  109372:	00 00 80 
  109375:	48 09 c1             	or     %rax,%rcx
}
  109378:	5b                   	pop    %rbx
	range_map_unlocked(virt, phys, size, flags_to_entry(flags),
  109379:	4c 89 f2             	mov    %r14,%rdx
  10937c:	4c 89 ee             	mov    %r13,%rsi
  10937f:	4c 89 e7             	mov    %r12,%rdi
  109382:	45 31 c9             	xor    %r9d,%r9d
}
  109385:	41 5c                	pop    %r12
	range_map_unlocked(virt, phys, size, flags_to_entry(flags),
  109387:	49 83 c8 ff          	or     $0xffffffffffffffff,%r8
}
  10938b:	41 5d                	pop    %r13
  10938d:	41 5e                	pop    %r14
  10938f:	5d                   	pop    %rbp
	range_map_unlocked(virt, phys, size, flags_to_entry(flags),
  109390:	e9 2c fb ff ff       	jmpq   108ec1 <range_map_unlocked>

0000000000109395 <z_x86_mmu_init>:
}
  109395:	c3                   	retq   

0000000000109396 <z_x86_set_stack_guard>:
	range_map_unlocked(stack, 0, CONFIG_MMU_PAGE_SIZE,
  109396:	41 b9 02 00 00 00    	mov    $0x2,%r9d
  10939c:	ba 00 10 00 00       	mov    $0x1000,%edx
  1093a1:	31 f6                	xor    %esi,%esi
  1093a3:	49 b8 06 00 00 00 00 	movabs $0x8000000000000006,%r8
  1093aa:	00 00 80 
  1093ad:	48 b9 01 08 00 00 00 	movabs $0x8000000000000801,%rcx
  1093b4:	00 00 80 
  1093b7:	e9 05 fb ff ff       	jmpq   108ec1 <range_map_unlocked>

00000000001093bc <arch_buffer_validate>:
{
  1093bc:	55                   	push   %rbp
  1093bd:	48 89 e5             	mov    %rsp,%rbp
  1093c0:	41 57                	push   %r15
  1093c2:	49 89 f7             	mov    %rsi,%r15
  1093c5:	41 56                	push   %r14
  1093c7:	49 89 fe             	mov    %rdi,%r14
  1093ca:	41 55                	push   %r13
  1093cc:	41 89 d5             	mov    %edx,%r13d
  1093cf:	41 54                	push   %r12
  1093d1:	41 bc 00 40 6e 00    	mov    $0x6e4000,%r12d
  1093d7:	53                   	push   %rbx
  1093d8:	48 83 ec 28          	sub    $0x28,%rsp
	pentry_t *ptables = z_x86_thread_page_tables_get(_current);
  1093dc:	48 8b 05 6d f3 01 00 	mov    0x1f36d(%rip),%rax        # 128750 <_kernel+0x10>

/* Get the page tables used by this thread during normal execution */
static inline pentry_t *z_x86_thread_page_tables_get(struct k_thread *thread)
{
#if defined(CONFIG_USERSPACE) && !defined(CONFIG_X86_COMMON_PAGE_TABLE)
	if (!IS_ENABLED(CONFIG_X86_KPTI) ||
  1093e3:	f6 40 18 04          	testb  $0x4,0x18(%rax)
  1093e7:	74 0f                	je     1093f8 <arch_buffer_validate+0x3c>
	    (thread->base.user_options & K_USER) != 0U) {
		/* If KPTI is enabled, supervisor threads always use
		 * the kernel's page tables and not the page tables associated
		 * with their memory domain.
		 */
		return z_mem_virt_addr(thread->arch.ptables);
  1093e9:	48 8b b8 78 01 00 00 	mov    0x178(%rax),%rdi
  1093f0:	e8 df f4 ff ff       	callq  1088d4 <z_mem_virt_addr>
  1093f5:	49 89 c4             	mov    %rax,%r12
	k_mem_region_align((uintptr_t *)&virt, &aligned_size,
  1093f8:	4c 89 f2             	mov    %r14,%rdx
  1093fb:	41 b8 00 10 00 00    	mov    $0x1000,%r8d
  109401:	4c 89 f9             	mov    %r15,%rcx
	for (size_t offset = 0; offset < aligned_size;
  109404:	45 31 f6             	xor    %r14d,%r14d
	k_mem_region_align((uintptr_t *)&virt, &aligned_size,
  109407:	48 8d 75 c8          	lea    -0x38(%rbp),%rsi
  10940b:	48 8d 7d c0          	lea    -0x40(%rbp),%rdi
  10940f:	e8 fa b0 00 00       	callq  11450e <k_mem_region_align>
	for (size_t offset = 0; offset < aligned_size;
  109414:	4c 39 75 c8          	cmp    %r14,-0x38(%rbp)
  109418:	0f 86 83 00 00 00    	jbe    1094a1 <arch_buffer_validate+0xe5>
		if (!page_validate(ptables, virt + offset, write)) {
  10941e:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  109422:	41 bf 20 ad 11 00    	mov    $0x11ad20,%r15d
	pentry_t *table = (pentry_t *)ptables;
  109428:	4c 89 e6             	mov    %r12,%rsi
	for (int level = 0; level < NUM_LEVELS; level++) {
  10942b:	31 db                	xor    %ebx,%ebx
		if (!page_validate(ptables, virt + offset, write)) {
  10942d:	4c 01 f0             	add    %r14,%rax
  109430:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	return (((uintptr_t)virt >> paging_levels[level].shift) %
  109434:	41 8b 4f 10          	mov    0x10(%r15),%ecx
  109438:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  10943c:	31 d2                	xor    %edx,%edx
  10943e:	48 d3 e8             	shr    %cl,%rax
  109441:	49 f7 77 08          	divq   0x8(%r15)
	return ptables[get_index(virt, level)];
  109445:	48 63 d2             	movslq %edx,%rdx
  109448:	48 8b 3c d6          	mov    (%rsi,%rdx,8),%rdi
	if (level == PTE_LEVEL) {
  10944c:	83 fb 03             	cmp    $0x3,%ebx
  10944f:	74 06                	je     109457 <arch_buffer_validate+0x9b>
		if (is_leaf(level, entry)) {
  109451:	40 f6 c7 80          	test   $0x80,%dil
  109455:	74 23                	je     10947a <arch_buffer_validate+0xbe>
	return (pte & MMU_P) == 0 && (pte & PTE_ZERO) != 0;
  109457:	48 89 f8             	mov    %rdi,%rax
  10945a:	25 81 00 00 00       	and    $0x81,%eax
			if (is_flipped_pte(entry)) {
  10945f:	48 3d 80 00 00 00    	cmp    $0x80,%rax
  109465:	74 3e                	je     1094a5 <arch_buffer_validate+0xe9>
			if (((entry & MMU_US) == 0U) ||
  109467:	40 f6 c7 04          	test   $0x4,%dil
  10946b:	74 38                	je     1094a5 <arch_buffer_validate+0xe9>
  10946d:	45 85 ed             	test   %r13d,%r13d
  109470:	74 18                	je     10948a <arch_buffer_validate+0xce>
			    (write && ((entry & MMU_RW) == 0U))) {
  109472:	40 80 e7 02          	and    $0x2,%dil
  109476:	75 12                	jne    10948a <arch_buffer_validate+0xce>
  109478:	eb 2b                	jmp    1094a5 <arch_buffer_validate+0xe9>
			if ((entry & MMU_P) == 0U) {
  10947a:	40 f6 c7 01          	test   $0x1,%dil
  10947e:	74 25                	je     1094a5 <arch_buffer_validate+0xe9>
			table = next_table(entry, level);
  109480:	89 de                	mov    %ebx,%esi
  109482:	e8 a1 f4 ff ff       	callq  108928 <next_table>
  109487:	48 89 c6             	mov    %rax,%rsi
	for (int level = 0; level < NUM_LEVELS; level++) {
  10948a:	ff c3                	inc    %ebx
  10948c:	49 83 c7 20          	add    $0x20,%r15
  109490:	83 fb 04             	cmp    $0x4,%ebx
  109493:	75 9f                	jne    109434 <arch_buffer_validate+0x78>
	     offset += CONFIG_MMU_PAGE_SIZE) {
  109495:	49 81 c6 00 10 00 00 	add    $0x1000,%r14
  10949c:	e9 73 ff ff ff       	jmpq   109414 <arch_buffer_validate+0x58>
	int ret = 0;
  1094a1:	31 c0                	xor    %eax,%eax
  1094a3:	eb 03                	jmp    1094a8 <arch_buffer_validate+0xec>
			ret = -1;
  1094a5:	83 c8 ff             	or     $0xffffffff,%eax
	__asm__ volatile ("lfence" : : : "memory");
  1094a8:	0f ae e8             	lfence 
}
  1094ab:	48 83 c4 28          	add    $0x28,%rsp
  1094af:	5b                   	pop    %rbx
  1094b0:	41 5c                	pop    %r12
  1094b2:	41 5d                	pop    %r13
  1094b4:	41 5e                	pop    %r14
  1094b6:	41 5f                	pop    %r15
  1094b8:	5d                   	pop    %rbp
  1094b9:	c3                   	retq   

00000000001094ba <arch_mem_domain_init>:
 * Arch interface implementations for memory domains and userspace
 */

__boot_func
int arch_mem_domain_init(struct k_mem_domain *domain)
{
  1094ba:	55                   	push   %rbp
  1094bb:	48 89 e5             	mov    %rsp,%rbp
  1094be:	41 55                	push   %r13
  1094c0:	41 54                	push   %r12
  1094c2:	53                   	push   %rbx
  1094c3:	48 89 fb             	mov    %rdi,%rbx
  1094c6:	51                   	push   %rcx
  1094c7:	9c                   	pushfq 
  1094c8:	fa                   	cli    
  1094c9:	41 5d                	pop    %r13
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  1094cb:	bf 68 cd 1b 00       	mov    $0x1bcd68,%edi
  1094d0:	e8 a4 43 00 00       	callq  10d879 <z_spin_lock_valid>
  1094d5:	84 c0                	test   %al,%al
  1094d7:	75 39                	jne    109512 <arch_mem_domain_init+0x58>
  1094d9:	b9 8e 00 00 00       	mov    $0x8e,%ecx
  1094de:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  1094e3:	be fd d1 11 00       	mov    $0x11d1fd,%esi
  1094e8:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  1094ed:	e8 06 71 ff ff       	callq  1005f8 <printk>
  1094f2:	be 68 cd 1b 00       	mov    $0x1bcd68,%esi
  1094f7:	bf 12 d2 11 00       	mov    $0x11d212,%edi
  1094fc:	31 c0                	xor    %eax,%eax
  1094fe:	e8 f5 70 ff ff       	callq  1005f8 <printk>
  109503:	be 8e 00 00 00       	mov    $0x8e,%esi
  109508:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  10950d:	e8 86 96 ff ff       	callq  102b98 <assert_post_action>
	z_spin_lock_set_owner(l);
  109512:	bf 68 cd 1b 00       	mov    $0x1bcd68,%edi
  109517:	e8 a1 43 00 00       	callq  10d8bd <z_spin_lock_set_owner>
	return list->head;
  10951c:	4c 8b 25 dd 37 0b 00 	mov    0xb37dd(%rip),%r12        # 1bcd00 <x86_domain_list>
	LOG_DBG("%s(%p)", __func__, domain);
#if __ASSERT_ON
	sys_snode_t *node;

	/* Assert that we have not already initialized this domain */
	SYS_SLIST_FOR_EACH_NODE(&x86_domain_list, node) {
  109523:	4d 85 e4             	test   %r12,%r12
  109526:	74 4e                	je     109576 <arch_mem_domain_init+0xbc>
		struct arch_mem_domain *list_domain =
  109528:	49 8d 44 24 f8       	lea    -0x8(%r12),%rax
			CONTAINER_OF(node, struct arch_mem_domain, node);

		__ASSERT(list_domain != &domain->arch,
  10952d:	48 39 c3             	cmp    %rax,%rbx
  109530:	75 3e                	jne    109570 <arch_mem_domain_init+0xb6>
  109532:	b9 8d 06 00 00       	mov    $0x68d,%ecx
  109537:	ba e5 e8 11 00       	mov    $0x11e8e5,%edx
  10953c:	be 4a eb 11 00       	mov    $0x11eb4a,%esi
  109541:	31 c0                	xor    %eax,%eax
  109543:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  109548:	e8 ab 70 ff ff       	callq  1005f8 <printk>
  10954d:	be 10 bf 11 00       	mov    $0x11bf10,%esi
  109552:	48 89 da             	mov    %rbx,%rdx
  109555:	31 c0                	xor    %eax,%eax
  109557:	bf 67 eb 11 00       	mov    $0x11eb67,%edi
  10955c:	e8 97 70 ff ff       	callq  1005f8 <printk>
  109561:	be 8d 06 00 00       	mov    $0x68d,%esi
  109566:	bf e5 e8 11 00       	mov    $0x11e8e5,%edi
  10956b:	e8 28 96 ff ff       	callq  102b98 <assert_post_action>
	return node->next;
  109570:	4d 8b 24 24          	mov    (%r12),%r12
  109574:	eb ad                	jmp    109523 <arch_mem_domain_init+0x69>
	 */
	(void)memset(domain->arch.pdpt, 0, sizeof(domain->arch.pdpt));
	domain->arch.ptables = domain->arch.pdpt;
#else
	/* Allocate a page-sized top-level structure, either a PD or PML4 */
	domain->arch.ptables = page_pool_get();
  109576:	e8 04 f4 ff ff       	callq  10897f <page_pool_get>
  10957b:	48 89 03             	mov    %rax,(%rbx)
  10957e:	48 89 c7             	mov    %rax,%rdi
	if (domain->arch.ptables == NULL) {
  109581:	48 85 c0             	test   %rax,%rax
  109584:	75 52                	jne    1095d8 <arch_mem_domain_init+0x11e>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  109586:	bf 68 cd 1b 00       	mov    $0x1bcd68,%edi
  10958b:	e8 09 43 00 00       	callq  10d899 <z_spin_unlock_valid>
  109590:	84 c0                	test   %al,%al
  109592:	75 39                	jne    1095cd <arch_mem_domain_init+0x113>
  109594:	b9 b9 00 00 00       	mov    $0xb9,%ecx
  109599:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  10959e:	be 41 d2 11 00       	mov    $0x11d241,%esi
  1095a3:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  1095a8:	e8 4b 70 ff ff       	callq  1005f8 <printk>
  1095ad:	be 68 cd 1b 00       	mov    $0x1bcd68,%esi
  1095b2:	bf 58 d2 11 00       	mov    $0x11d258,%edi
  1095b7:	31 c0                	xor    %eax,%eax
  1095b9:	e8 3a 70 ff ff       	callq  1005f8 <printk>
  1095be:	be b9 00 00 00       	mov    $0xb9,%esi
  1095c3:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  1095c8:	e8 cb 95 ff ff       	callq  102b98 <assert_post_action>
		k_spin_unlock(&x86_mmu_lock, key);
		return -ENOMEM;
  1095cd:	41 bc f4 ff ff ff    	mov    $0xfffffff4,%r12d
  1095d3:	e9 8c 00 00 00       	jmpq   109664 <arch_mem_domain_init+0x1aa>

	LOG_DBG("copy_page_table(%p, %p, 0)", domain->arch.ptables,
		z_x86_kernel_ptables);

	/* Make a copy of the boot page tables created by gen_mmu.py */
	ret = copy_page_table(domain->arch.ptables, z_x86_kernel_ptables, 0);
  1095d8:	31 d2                	xor    %edx,%edx
  1095da:	be 00 40 6e 00       	mov    $0x6e4000,%esi
  1095df:	e8 32 f4 ff ff       	callq  108a16 <copy_page_table>
  1095e4:	41 89 c4             	mov    %eax,%r12d
	if (ret == 0) {
  1095e7:	85 c0                	test   %eax,%eax
  1095e9:	75 32                	jne    10961d <arch_mem_domain_init+0x163>
 *
 * @return A pointer on the last node of the list (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_tail(sys_slist_t *list)
{
	return list->tail;
  1095eb:	48 8b 15 16 37 0b 00 	mov    0xb3716(%rip),%rdx        # 1bcd08 <x86_domain_list+0x8>
	parent->next = child;
  1095f2:	48 c7 43 08 00 00 00 	movq   $0x0,0x8(%rbx)
  1095f9:	00 
		sys_slist_append(&x86_domain_list, &domain->arch.node);
  1095fa:	48 8d 43 08          	lea    0x8(%rbx),%rax
 * @param node A pointer on the node to append
 */
static inline void sys_slist_append(sys_slist_t *list,
				    sys_snode_t *node);

Z_GENLIST_APPEND(slist, snode)
  1095fe:	48 85 d2             	test   %rdx,%rdx
  109601:	75 10                	jne    109613 <arch_mem_domain_init+0x159>
	list->tail = node;
  109603:	48 89 05 fe 36 0b 00 	mov    %rax,0xb36fe(%rip)        # 1bcd08 <x86_domain_list+0x8>
	list->head = node;
  10960a:	48 89 05 ef 36 0b 00 	mov    %rax,0xb36ef(%rip)        # 1bcd00 <x86_domain_list>
}
  109611:	eb 0a                	jmp    10961d <arch_mem_domain_init+0x163>
	parent->next = child;
  109613:	48 89 02             	mov    %rax,(%rdx)
	list->tail = node;
  109616:	48 89 05 eb 36 0b 00 	mov    %rax,0xb36eb(%rip)        # 1bcd08 <x86_domain_list+0x8>
  10961d:	bf 68 cd 1b 00       	mov    $0x1bcd68,%edi
  109622:	e8 72 42 00 00       	callq  10d899 <z_spin_unlock_valid>
  109627:	84 c0                	test   %al,%al
  109629:	75 39                	jne    109664 <arch_mem_domain_init+0x1aa>
  10962b:	b9 b9 00 00 00       	mov    $0xb9,%ecx
  109630:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  109635:	be 41 d2 11 00       	mov    $0x11d241,%esi
  10963a:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  10963f:	e8 b4 6f ff ff       	callq  1005f8 <printk>
  109644:	be 68 cd 1b 00       	mov    $0x1bcd68,%esi
  109649:	bf 58 d2 11 00       	mov    $0x11d258,%edi
  10964e:	31 c0                	xor    %eax,%eax
  109650:	e8 a3 6f ff ff       	callq  1005f8 <printk>
  109655:	be b9 00 00 00       	mov    $0xb9,%esi
  10965a:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  10965f:	e8 34 95 ff ff       	callq  102b98 <assert_post_action>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  109664:	41 0f ba e5 09       	bt     $0x9,%r13d
  109669:	73 01                	jae    10966c <arch_mem_domain_init+0x1b2>
		__asm__ volatile ("sti" ::: "memory");
  10966b:	fb                   	sti    
	}
	k_spin_unlock(&x86_mmu_lock, key);

	return ret;
}
  10966c:	5a                   	pop    %rdx
  10966d:	44 89 e0             	mov    %r12d,%eax
  109670:	5b                   	pop    %rbx
  109671:	41 5c                	pop    %r12
  109673:	41 5d                	pop    %r13
  109675:	5d                   	pop    %rbp
  109676:	c3                   	retq   

0000000000109677 <arch_mem_domain_thread_remove>:
/* Called on thread exit or when moving it to a different memory domain */
void arch_mem_domain_thread_remove(struct k_thread *thread)
{
	struct k_mem_domain *domain = thread->mem_domain_info.mem_domain;

	if ((thread->base.user_options & K_USER) == 0) {
  109677:	f6 47 18 04          	testb  $0x4,0x18(%rdi)
  10967b:	74 2b                	je     1096a8 <arch_mem_domain_thread_remove+0x31>
		return;
	}

	if ((thread->base.thread_state & _THREAD_DEAD) == 0) {
  10967d:	f6 47 19 08          	testb  $0x8,0x19(%rdi)
  109681:	74 25                	je     1096a8 <arch_mem_domain_thread_remove+0x31>
	}

	/* Restore permissions on the thread's stack area since it is no
	 * longer a member of the domain.
	 */
	reset_region(domain->arch.ptables, (void *)thread->stack_info.start,
  109683:	48 8b 87 30 01 00 00 	mov    0x130(%rdi),%rax
	region_map_update(ptables, start, size, 0, true);
  10968a:	48 8b 97 10 01 00 00 	mov    0x110(%rdi),%rdx
  109691:	41 b8 01 00 00 00    	mov    $0x1,%r8d
  109697:	31 c9                	xor    %ecx,%ecx
  109699:	48 8b b7 08 01 00 00 	mov    0x108(%rdi),%rsi
  1096a0:	48 8b 38             	mov    (%rax),%rdi
  1096a3:	e9 9f f9 ff ff       	jmpq   109047 <region_map_update>
		     thread->stack_info.size);
}
  1096a8:	c3                   	retq   

00000000001096a9 <arch_mem_domain_partition_add>:
{
	struct k_mem_partition *partition = &domain->partitions[partition_id];

	/* Update the page tables with the partition info */
	apply_region(domain->arch.ptables, (void *)partition->start,
		     partition->size, partition->attr | MMU_P);
  1096a9:	89 f6                	mov    %esi,%esi
	region_map_update(ptables, start, size, attr, false);
  1096ab:	45 31 c0             	xor    %r8d,%r8d
		     partition->size, partition->attr | MMU_P);
  1096ae:	48 6b f6 18          	imul   $0x18,%rsi,%rsi
  1096b2:	48 01 fe             	add    %rdi,%rsi
	region_map_update(ptables, start, size, attr, false);
  1096b5:	48 8b 3f             	mov    (%rdi),%rdi
	apply_region(domain->arch.ptables, (void *)partition->start,
  1096b8:	48 8b 4e 20          	mov    0x20(%rsi),%rcx
	region_map_update(ptables, start, size, attr, false);
  1096bc:	48 8b 56 18          	mov    0x18(%rsi),%rdx
  1096c0:	48 8b 76 10          	mov    0x10(%rsi),%rsi
	apply_region(domain->arch.ptables, (void *)partition->start,
  1096c4:	48 83 c9 01          	or     $0x1,%rcx
	region_map_update(ptables, start, size, attr, false);
  1096c8:	e9 7a f9 ff ff       	jmpq   109047 <region_map_update>

00000000001096cd <arch_mem_domain_thread_add>:
}

/* Invoked from memory domain API calls, as well as during thread creation */
__pinned_func
void arch_mem_domain_thread_add(struct k_thread *thread)
{
  1096cd:	55                   	push   %rbp
  1096ce:	48 89 e5             	mov    %rsp,%rbp
  1096d1:	41 56                	push   %r14
  1096d3:	41 55                	push   %r13
  1096d5:	41 54                	push   %r12
  1096d7:	53                   	push   %rbx
  1096d8:	48 89 fb             	mov    %rdi,%rbx
	/* New memory domain we are being added to */
	struct k_mem_domain *domain = thread->mem_domain_info.mem_domain;
  1096db:	4c 8b af 30 01 00 00 	mov    0x130(%rdi),%r13
	 *
	 * Note that NULL check on old_ptables must be done before any
	 * address translation or else (NULL + offset) != NULL.
	 */
	pentry_t *old_ptables = UINT_TO_POINTER(thread->arch.ptables);
	bool is_user = (thread->base.user_options & K_USER) != 0;
  1096e2:	8a 43 18             	mov    0x18(%rbx),%al
	pentry_t *old_ptables = UINT_TO_POINTER(thread->arch.ptables);
  1096e5:	48 8b bf 78 01 00 00 	mov    0x178(%rdi),%rdi
	bool is_user = (thread->base.user_options & K_USER) != 0;
  1096ec:	c0 e8 02             	shr    $0x2,%al
	bool is_migration = (old_ptables != NULL) && is_user;
  1096ef:	48 85 ff             	test   %rdi,%rdi
	pentry_t *old_ptables = UINT_TO_POINTER(thread->arch.ptables);
  1096f2:	49 89 fe             	mov    %rdi,%r14
	bool is_migration = (old_ptables != NULL) && is_user;
  1096f5:	41 0f 95 c4          	setne  %r12b

	/* Allow US access to the thread's stack in its new domain if
	 * we are migrating. If we are not migrating this is done in
	 * z_x86_current_stack_perms()
	 */
	if (is_migration) {
  1096f9:	41 20 c4             	and    %al,%r12b
  1096fc:	74 2c                	je     10972a <arch_mem_domain_thread_add+0x5d>
		old_ptables = z_mem_virt_addr(thread->arch.ptables);
  1096fe:	e8 d1 f1 ff ff       	callq  1088d4 <z_mem_virt_addr>
	region_map_update(ptables, start, size, attr, false);
  109703:	48 8b 93 10 01 00 00 	mov    0x110(%rbx),%rdx
  10970a:	49 8b 7d 00          	mov    0x0(%r13),%rdi
  10970e:	45 31 c0             	xor    %r8d,%r8d
  109711:	48 8b b3 08 01 00 00 	mov    0x108(%rbx),%rsi
		old_ptables = z_mem_virt_addr(thread->arch.ptables);
  109718:	49 89 c6             	mov    %rax,%r14
	region_map_update(ptables, start, size, attr, false);
  10971b:	48 b9 07 00 00 00 00 	movabs $0x8000000000000007,%rcx
  109722:	00 00 80 
  109725:	e8 1d f9 ff ff       	callq  109047 <region_map_update>
		set_stack_perms(thread, domain->arch.ptables);
	}

	thread->arch.ptables = z_mem_phys_addr(domain->arch.ptables);
  10972a:	49 8b 7d 00          	mov    0x0(%r13),%rdi
  10972e:	e8 8f f2 ff ff       	callq  1089c2 <z_mem_phys_addr>
  109733:	48 89 83 78 01 00 00 	mov    %rax,0x178(%rbx)
	 * XXX: The checks we have to do here and in
	 * arch_mem_domain_thread_remove() are clumsy, it may be worth looking
	 * into adding a specific arch_mem_domain_thread_migrate() API.
	 * See #29601
	 */
	if (is_migration) {
  10973a:	45 84 e4             	test   %r12b,%r12b
  10973d:	74 26                	je     109765 <arch_mem_domain_thread_add+0x98>
	region_map_update(ptables, start, size, 0, true);
  10973f:	48 8b 93 10 01 00 00 	mov    0x110(%rbx),%rdx
  109746:	48 8b b3 08 01 00 00 	mov    0x108(%rbx),%rsi
  10974d:	4c 89 f7             	mov    %r14,%rdi
  109750:	31 c9                	xor    %ecx,%ecx
	 */
	if (thread == _current && thread->arch.ptables != z_x86_cr3_get()) {
		z_x86_cr3_set(thread->arch.ptables);
	}
#endif /* CONFIG_X86_KPTI */
}
  109752:	5b                   	pop    %rbx
	region_map_update(ptables, start, size, 0, true);
  109753:	41 b8 01 00 00 00    	mov    $0x1,%r8d
}
  109759:	41 5c                	pop    %r12
  10975b:	41 5d                	pop    %r13
  10975d:	41 5e                	pop    %r14
  10975f:	5d                   	pop    %rbp
	region_map_update(ptables, start, size, 0, true);
  109760:	e9 e2 f8 ff ff       	jmpq   109047 <region_map_update>
}
  109765:	5b                   	pop    %rbx
  109766:	41 5c                	pop    %r12
  109768:	41 5d                	pop    %r13
  10976a:	41 5e                	pop    %r14
  10976c:	5d                   	pop    %rbp
  10976d:	c3                   	retq   

000000000010976e <arch_mem_domain_max_partitions_get>:

__pinned_func
int arch_mem_domain_max_partitions_get(void)
{
	return CONFIG_MAX_DOMAIN_PARTITIONS;
}
  10976e:	b8 0a 00 00 00       	mov    $0xa,%eax
  109773:	c3                   	retq   

0000000000109774 <z_x86_current_stack_perms>:

/* Invoked from z_x86_userspace_enter */
__pinned_func
void z_x86_current_stack_perms(void)
{
  109774:	55                   	push   %rbp
	/* Clear any previous context in the stack buffer to prevent
	 * unintentional data leakage.
	 */
	(void)memset((void *)_current->stack_info.start, 0xAA,
		     _current->stack_info.size - _current->stack_info.delta);
  109775:	48 8b 05 d4 ef 01 00 	mov    0x1efd4(%rip),%rax        # 128750 <_kernel+0x10>
	(void)memset((void *)_current->stack_info.start, 0xAA,
  10977c:	be aa 00 00 00       	mov    $0xaa,%esi
  109781:	48 8b b8 08 01 00 00 	mov    0x108(%rax),%rdi
  109788:	48 8b 90 10 01 00 00 	mov    0x110(%rax),%rdx
{
  10978f:	48 89 e5             	mov    %rsp,%rbp
	(void)memset((void *)_current->stack_info.start, 0xAA,
  109792:	48 2b 90 18 01 00 00 	sub    0x118(%rax),%rdx
  109799:	e8 14 09 00 00       	callq  10a0b2 <memset>
#else
	/* Memory domain access is already programmed into the page tables.
	 * Need to enable access to this new user thread's stack buffer in
	 * its domain-specific page tables.
	 */
	set_stack_perms(_current, z_x86_thread_page_tables_get(_current));
  10979e:	48 8b 05 ab ef 01 00 	mov    0x1efab(%rip),%rax        # 128750 <_kernel+0x10>
	if (!IS_ENABLED(CONFIG_X86_KPTI) ||
  1097a5:	bf 00 40 6e 00       	mov    $0x6e4000,%edi
  1097aa:	f6 40 18 04          	testb  $0x4,0x18(%rax)
  1097ae:	74 0f                	je     1097bf <z_x86_current_stack_perms+0x4b>
		return z_mem_virt_addr(thread->arch.ptables);
  1097b0:	48 8b b8 78 01 00 00 	mov    0x178(%rax),%rdi
  1097b7:	e8 18 f1 ff ff       	callq  1088d4 <z_mem_virt_addr>
  1097bc:	48 89 c7             	mov    %rax,%rdi
  1097bf:	48 8b 05 8a ef 01 00 	mov    0x1ef8a(%rip),%rax        # 128750 <_kernel+0x10>
	region_map_update(ptables, start, size, attr, false);
  1097c6:	45 31 c0             	xor    %r8d,%r8d
#endif
}
  1097c9:	5d                   	pop    %rbp
	region_map_update(ptables, start, size, attr, false);
  1097ca:	48 b9 07 00 00 00 00 	movabs $0x8000000000000007,%rcx
  1097d1:	00 00 80 
  1097d4:	48 8b 90 10 01 00 00 	mov    0x110(%rax),%rdx
  1097db:	48 8b b0 08 01 00 00 	mov    0x108(%rax),%rsi
  1097e2:	e9 60 f8 ff ff       	jmpq   109047 <region_map_update>

00000000001097e7 <arch_reserved_pages_update>:

#ifdef CONFIG_ARCH_HAS_RESERVED_PAGE_FRAMES
__boot_func
static void mark_addr_page_reserved(uintptr_t addr, size_t len)
{
	uintptr_t pos = ROUND_DOWN(addr, CONFIG_MMU_PAGE_SIZE);
  1097e7:	31 c0                	xor    %eax,%eax
static inline struct z_page_frame *z_phys_to_page_frame(uintptr_t phys)
{
	__ASSERT(z_is_page_frame(phys),
		 "0x%lx not an SRAM physical address", phys);

	return &z_page_frames[(phys - Z_PHYS_RAM_START) /
  1097e9:	48 89 c2             	mov    %rax,%rdx
	uintptr_t end = ROUND_UP(addr + len, CONFIG_MMU_PAGE_SIZE);

	for (; pos < end; pos += CONFIG_MMU_PAGE_SIZE) {
  1097ec:	48 05 00 10 00 00    	add    $0x1000,%rax
  1097f2:	48 c1 ea 0c          	shr    $0xc,%rdx
			continue;
		}

		struct z_page_frame *pf = z_phys_to_page_frame(pos);

		pf->flags |= Z_PAGE_FRAME_RESERVED;
  1097f6:	48 8d 14 d2          	lea    (%rdx,%rdx,8),%rdx
  1097fa:	80 8a a8 c7 12 00 02 	orb    $0x2,0x12c7a8(%rdx)
	for (; pos < end; pos += CONFIG_MMU_PAGE_SIZE) {
  109801:	48 3d 00 00 10 00    	cmp    $0x100000,%rax
  109807:	75 e0                	jne    1097e9 <arch_reserved_pages_update+0x2>
		}

		mark_addr_page_reserved(entry->base, entry->length);
	}
#endif /* CONFIG_X86_MEMMAP */
}
  109809:	c3                   	retq   

000000000010980a <arch_user_mode_enter>:
	size_t stack_end;

	/* Transition will reset stack pointer to initial, discarding
	 * any old context since this is a one-way operation
	 */
	stack_end = Z_STACK_PTR_ALIGN(_current->stack_info.start +
  10980a:	4c 8b 05 3f ef 01 00 	mov    0x1ef3f(%rip),%r8        # 128750 <_kernel+0x10>
{
  109811:	55                   	push   %rbp
	stack_end = Z_STACK_PTR_ALIGN(_current->stack_info.start +
  109812:	4d 8b 88 08 01 00 00 	mov    0x108(%r8),%r9
  109819:	49 8b 80 10 01 00 00 	mov    0x110(%r8),%rax
{
  109820:	48 89 e5             	mov    %rsp,%rbp
	stack_end = Z_STACK_PTR_ALIGN(_current->stack_info.start +
  109823:	4c 01 c8             	add    %r9,%rax
  109826:	49 2b 80 18 01 00 00 	sub    0x118(%r8),%rax
  10982d:	48 83 e0 f0          	and    $0xfffffffffffffff0,%rax
				 CONFIG_MMU_PAGE_SIZE);
	k_mem_page_in(UINT_TO_POINTER(stack_aligned_start),
		      stack_aligned_size);
#endif

	z_x86_userspace_enter(user_entry, p1, p2, p3, stack_end,
  109831:	4c 8d 40 f8          	lea    -0x8(%rax),%r8
  109835:	e8 2f 69 ff ff       	callq  100169 <z_x86_userspace_enter>

000000000010983a <z_x86_userspace_prepare_thread>:
		header->privilege_stack + sizeof(header->privilege_stack);
  10983a:	48 8b 87 38 01 00 00 	mov    0x138(%rdi),%rax
		initial_entry = z_thread_entry;
  109841:	ba 9b 0f 10 00       	mov    $0x100f9b,%edx
	thread->arch.ptables = (uintptr_t)NULL;
  109846:	48 c7 87 78 01 00 00 	movq   $0x0,0x178(%rdi)
  10984d:	00 00 00 00 
		header->privilege_stack + sizeof(header->privilege_stack);
  109851:	48 05 00 20 00 00    	add    $0x2000,%rax
		initial_entry = z_thread_entry;
  109857:	f6 47 18 04          	testb  $0x4,0x18(%rdi)
	thread->arch.psp =
  10985b:	48 89 87 80 01 00 00 	mov    %rax,0x180(%rdi)
		initial_entry = z_thread_entry;
  109862:	b8 0a 98 10 00       	mov    $0x10980a,%eax
  109867:	48 0f 44 c2          	cmove  %rdx,%rax
}
  10986b:	c3                   	retq   

000000000010986c <arch_printk_char_out>:
	OUT(REG_THR, c);
}

int arch_printk_char_out(int c)
{
	if (!early_serial_init_done) {
  10986c:	80 3d d6 35 0b 00 00 	cmpb   $0x0,0xb35d6(%rip)        # 1bce49 <early_serial_init_done>
{
  109873:	41 89 f8             	mov    %edi,%r8d
	if (!early_serial_init_done) {
  109876:	75 08                	jne    109880 <arch_printk_char_out+0x14>
		suppressed_chars++;
  109878:	ff 05 ae 35 0b 00    	incl   0xb35ae(%rip)        # 1bce2c <suppressed_chars>
		return c;
  10987e:	eb 2a                	jmp    1098aa <arch_printk_char_out+0x3e>
	}

	if (c == '\n') {
  109880:	83 ff 0a             	cmp    $0xa,%edi
  109883:	75 12                	jne    109897 <arch_printk_char_out+0x2b>
	__asm__ volatile("inb %w1, %b0" : "=a"(ret) : "Nd"(port));
  109885:	ba fd 03 00 00       	mov    $0x3fd,%edx
  10988a:	ec                   	in     (%dx),%al
	while ((IN(REG_LSR) & LSR_THRE) == 0) {
  10988b:	a8 20                	test   $0x20,%al
  10988d:	74 fb                	je     10988a <arch_printk_char_out+0x1e>
	__asm__ volatile("outb %b0, %w1" :: "a"(data), "Nd"(port));
  10988f:	b0 0d                	mov    $0xd,%al
  109891:	ba f8 03 00 00       	mov    $0x3f8,%edx
  109896:	ee                   	out    %al,(%dx)
	__asm__ volatile("inb %w1, %b0" : "=a"(ret) : "Nd"(port));
  109897:	ba fd 03 00 00       	mov    $0x3fd,%edx
  10989c:	ec                   	in     (%dx),%al
  10989d:	a8 20                	test   $0x20,%al
  10989f:	74 fb                	je     10989c <arch_printk_char_out+0x30>
	__asm__ volatile("outb %b0, %w1" :: "a"(data), "Nd"(port));
  1098a1:	ba f8 03 00 00       	mov    $0x3f8,%edx
  1098a6:	44 89 c0             	mov    %r8d,%eax
  1098a9:	ee                   	out    %al,(%dx)
		serout('\r');
	}
	serout(c);
	return c;
}
  1098aa:	44 89 c0             	mov    %r8d,%eax
  1098ad:	c3                   	retq   

00000000001098ae <z_x86_early_serial_init>:
  1098ae:	31 f6                	xor    %esi,%esi
  1098b0:	bf f9 03 00 00       	mov    $0x3f9,%edi
  1098b5:	89 f0                	mov    %esi,%eax
  1098b7:	89 fa                	mov    %edi,%edx
  1098b9:	ee                   	out    %al,(%dx)
  1098ba:	b9 fb 03 00 00       	mov    $0x3fb,%ecx
  1098bf:	b0 80                	mov    $0x80,%al
  1098c1:	89 ca                	mov    %ecx,%edx
  1098c3:	ee                   	out    %al,(%dx)
  1098c4:	b0 01                	mov    $0x1,%al
  1098c6:	ba f8 03 00 00       	mov    $0x3f8,%edx
  1098cb:	ee                   	out    %al,(%dx)
  1098cc:	89 f0                	mov    %esi,%eax
  1098ce:	89 fa                	mov    %edi,%edx
  1098d0:	ee                   	out    %al,(%dx)
  1098d1:	b0 03                	mov    $0x3,%al
  1098d3:	89 ca                	mov    %ecx,%edx
  1098d5:	ee                   	out    %al,(%dx)
  1098d6:	ba fc 03 00 00       	mov    $0x3fc,%edx
  1098db:	ee                   	out    %al,(%dx)
  1098dc:	b0 07                	mov    $0x7,%al
  1098de:	ba fa 03 00 00       	mov    $0x3fa,%edx
  1098e3:	ee                   	out    %al,(%dx)
	/* Turn on FIFO. Some hardware needs this before transmitting */
	OUT(REG_FCR, FCR_FIFO | FCR_FIFO_1 | FCR_RCVRCLR | FCR_XMITCLR);

	early_serial_init_done = true;

	if (suppressed_chars != 0U) {
  1098e4:	8b 35 42 35 0b 00    	mov    0xb3542(%rip),%esi        # 1bce2c <suppressed_chars>
	early_serial_init_done = true;
  1098ea:	c6 05 58 35 0b 00 01 	movb   $0x1,0xb3558(%rip)        # 1bce49 <early_serial_init_done>
	if (suppressed_chars != 0U) {
  1098f1:	85 f6                	test   %esi,%esi
  1098f3:	74 0c                	je     109901 <z_x86_early_serial_init+0x53>
		printk("WARNING: %u chars lost before early serial init\n",
  1098f5:	bf 93 eb 11 00       	mov    $0x11eb93,%edi
  1098fa:	31 c0                	xor    %eax,%eax
  1098fc:	e9 f7 6c ff ff       	jmpq   1005f8 <printk>
		       suppressed_chars);
	}
}
  109901:	c3                   	retq   

0000000000109902 <z_x86_cpu_init>:

/* Per-CPU initialization, C domain. On the first CPU, z_x86_prep_c is the
 * next step. For other CPUs it is probably smp_init_top().
 */
FUNC_NORETURN void z_x86_cpu_init(struct x86_cpuboot *cpuboot)
{
  109902:	55                   	push   %rbp
  109903:	48 89 e5             	mov    %rsp,%rbp
  109906:	41 54                	push   %r12
  109908:	49 89 fc             	mov    %rdi,%r12
	x86_sse_init(NULL);
  10990b:	31 ff                	xor    %edi,%edi
{
  10990d:	53                   	push   %rbx

	/* The internal cpu_number is the index to x86_cpuboot[] */
	unsigned char cpu_num = (unsigned char)(cpuboot - x86_cpuboot);
  10990e:	4c 89 e3             	mov    %r12,%rbx
  109911:	48 81 eb a0 10 5e 00 	sub    $0x5e10a0,%rbx
  109918:	48 c1 fb 04          	sar    $0x4,%rbx
	x86_sse_init(NULL);
  10991c:	e8 47 78 ef ff       	callq  1168 <x86_sse_init>
	unsigned char cpu_num = (unsigned char)(cpuboot - x86_cpuboot);
  109921:	48 bf ab aa aa aa aa 	movabs $0xaaaaaaaaaaaaaaab,%rdi
  109928:	aa aa aa 
  10992b:	48 0f af df          	imul   %rdi,%rbx

	if (cpu_num == 0U) {
  10992f:	84 db                	test   %bl,%bl
  109931:	75 05                	jne    109938 <z_x86_cpu_init+0x36>
		/* Only need to do these once per boot */
		z_bss_zero();
  109933:	e8 f8 38 00 00       	callq  10d230 <z_bss_zero>
#ifdef CONFIG_XIP
		z_data_copy();
#endif
	}

	z_loapic_enable(cpu_num);
  109938:	0f b6 fb             	movzbl %bl,%edi
  10993b:	e8 c8 0f 00 00       	callq  10a908 <z_loapic_enable>

#ifdef CONFIG_USERSPACE
	/* Set landing site for 'syscall' instruction */
	z_x86_msr_write(X86_LSTAR_MSR, (uint64_t)z_x86_syscall_entry_stub);
  109940:	b8 46 00 10 00       	mov    $0x100046,%eax
  109945:	b9 82 00 00 c0       	mov    $0xc0000082,%ecx
	uint32_t high = data >> 32;
  10994a:	48 89 c2             	mov    %rax,%rdx
  10994d:	48 c1 ea 20          	shr    $0x20,%rdx
	__asm__ volatile ("wrmsr" : : "c"(msr), "a"(low), "d"(high));
  109951:	0f 30                	wrmsr  
  109953:	31 f6                	xor    %esi,%esi
  109955:	b9 81 00 00 c0       	mov    $0xc0000081,%ecx
  10995a:	ba 18 00 28 00       	mov    $0x280018,%edx
  10995f:	89 f0                	mov    %esi,%eax
  109961:	0f 30                	wrmsr  
  109963:	b9 84 00 00 c0       	mov    $0xc0000084,%ecx
  109968:	b8 00 06 00 00       	mov    $0x600,%eax
  10996d:	89 f2                	mov    %esi,%edx
  10996f:	0f 30                	wrmsr  
	/* Mask applied to RFLAGS when making a syscall */
	z_x86_msr_write(X86_FMASK_MSR, EFLAGS_SYSCALL);
#endif

	/* Enter kernel, never return */
	cpuboot->ready++;
  109971:	41 8b 04 24          	mov    (%r12),%eax
	cpuboot->fn(cpuboot->arg);
  109975:	49 8b 7c 24 28       	mov    0x28(%r12),%rdi
	cpuboot->ready++;
  10997a:	ff c0                	inc    %eax
  10997c:	41 89 04 24          	mov    %eax,(%r12)
	cpuboot->fn(cpuboot->arg);
  109980:	41 ff 54 24 20       	callq  *0x20(%r12)

0000000000109985 <irq_spurious>:

void (*x86_irq_funcs[NR_IRQ_VECTORS])(const void *);
const void *x86_irq_args[NR_IRQ_VECTORS];

static void irq_spurious(const void *arg)
{
  109985:	55                   	push   %rbp
  109986:	48 89 fa             	mov    %rdi,%rdx
	LOG_ERR("Spurious interrupt, vector %d\n", (uint32_t)(uint64_t)arg);
  109989:	be 45 00 00 00       	mov    $0x45,%esi
  10998e:	bf c4 eb 11 00       	mov    $0x11ebc4,%edi
  109993:	31 c0                	xor    %eax,%eax
{
  109995:	48 89 e5             	mov    %rsp,%rbp
	LOG_ERR("Spurious interrupt, vector %d\n", (uint32_t)(uint64_t)arg);
  109998:	e8 29 97 ff ff       	callq  1030c6 <z_log_minimal_printk>
	z_fatal_error(K_ERR_SPURIOUS_IRQ, NULL);
  10999d:	31 f6                	xor    %esi,%esi
  10999f:	bf 01 00 00 00       	mov    $0x1,%edi
}
  1099a4:	5d                   	pop    %rbp
	z_fatal_error(K_ERR_SPURIOUS_IRQ, NULL);
  1099a5:	e9 29 37 00 00       	jmpq   10d0d3 <z_fatal_error>

00000000001099aa <x86_64_irq_init>:

void x86_64_irq_init(void)
{
  1099aa:	b8 20 00 00 00       	mov    $0x20,%eax
	for (int i = 0; i < NR_IRQ_VECTORS; i++) {
		x86_irq_funcs[i] = irq_spurious;
  1099af:	48 c7 04 c5 20 73 12 	movq   $0x109985,0x127320(,%rax,8)
  1099b6:	00 85 99 10 00 
		x86_irq_args[i] = (const void *)(long)(i + IV_IRQS);
  1099bb:	48 89 04 c5 20 6c 12 	mov    %rax,0x126c20(,%rax,8)
  1099c2:	00 
	for (int i = 0; i < NR_IRQ_VECTORS; i++) {
  1099c3:	48 ff c0             	inc    %rax
  1099c6:	48 3d 00 01 00 00    	cmp    $0x100,%rax
  1099cc:	75 e1                	jne    1099af <x86_64_irq_init+0x5>
	}
}
  1099ce:	c3                   	retq   

00000000001099cf <z_x86_allocate_vector>:

	if (priority >= MAX_PRIORITY) {
		priority = MAX_PRIORITY;
	}

	if (vector == -1) {
  1099cf:	89 f0                	mov    %esi,%eax
  1099d1:	83 fe ff             	cmp    $0xffffffff,%esi
  1099d4:	75 11                	jne    1099e7 <z_x86_allocate_vector+0x18>
		vector = (priority * VECTORS_PER_PRIORITY) + IV_IRQS;
  1099d6:	83 ff 0d             	cmp    $0xd,%edi
  1099d9:	b8 0d 00 00 00       	mov    $0xd,%eax
  1099de:	0f 46 c7             	cmovbe %edi,%eax
  1099e1:	83 c0 02             	add    $0x2,%eax
  1099e4:	c1 e0 04             	shl    $0x4,%eax
  1099e7:	8d 48 10             	lea    0x10(%rax),%ecx
	}

	for (i = 0; i < VECTORS_PER_PRIORITY; ++i, ++vector) {
		if (prev_vector != 1 && vector == prev_vector) {
  1099ea:	83 fe 01             	cmp    $0x1,%esi
  1099ed:	40 0f 95 c7          	setne  %dil
  1099f1:	39 c6                	cmp    %eax,%esi
  1099f3:	0f 94 c2             	sete   %dl
#ifdef CONFIG_IRQ_OFFLOAD
		if (vector == CONFIG_IRQ_OFFLOAD_VECTOR) {
			continue;
		}
#endif
		if (vector == Z_X86_OOPS_VECTOR) {
  1099f6:	40 84 d7             	test   %dl,%dil
  1099f9:	75 19                	jne    109a14 <z_x86_allocate_vector+0x45>
  1099fb:	83 f8 20             	cmp    $0x20,%eax
  1099fe:	74 14                	je     109a14 <z_x86_allocate_vector+0x45>
			continue;
		}

		if (x86_irq_funcs[vector - IV_IRQS] == irq_spurious) {
  109a00:	8d 50 e0             	lea    -0x20(%rax),%edx
  109a03:	48 63 d2             	movslq %edx,%rdx
  109a06:	48 81 3c d5 20 74 12 	cmpq   $0x109985,0x127420(,%rdx,8)
  109a0d:	00 85 99 10 00 
  109a12:	74 09                	je     109a1d <z_x86_allocate_vector+0x4e>
	for (i = 0; i < VECTORS_PER_PRIORITY; ++i, ++vector) {
  109a14:	ff c0                	inc    %eax
  109a16:	39 c8                	cmp    %ecx,%eax
  109a18:	75 d0                	jne    1099ea <z_x86_allocate_vector+0x1b>
			return vector;
		}
	}

	return -1;
  109a1a:	83 c8 ff             	or     $0xffffffff,%eax
}
  109a1d:	c3                   	retq   

0000000000109a1e <z_x86_irq_connect_on_vector>:

void z_x86_irq_connect_on_vector(unsigned int irq,
				 uint8_t vector,
				 void (*func)(const void *arg),
				 const void *arg, uint32_t flags)
{
  109a1e:	55                   	push   %rbp
  109a1f:	48 89 e5             	mov    %rsp,%rbp
  109a22:	41 55                	push   %r13
  109a24:	49 89 d5             	mov    %rdx,%r13
  109a27:	44 89 c2             	mov    %r8d,%edx
  109a2a:	41 54                	push   %r12
  109a2c:	49 89 cc             	mov    %rcx,%r12
  109a2f:	53                   	push   %rbx
	_irq_to_interrupt_vector[irq] = vector;
	z_irq_controller_irq_config(vector, irq, flags);
  109a30:	40 0f b6 de          	movzbl %sil,%ebx
{
  109a34:	50                   	push   %rax
  109a35:	89 f8                	mov    %edi,%eax
	z_irq_controller_irq_config(vector, irq, flags);
  109a37:	89 df                	mov    %ebx,%edi
	_irq_to_interrupt_vector[irq] = vector;
  109a39:	40 88 b0 20 7b 12 00 	mov    %sil,0x127b20(%rax)
	z_irq_controller_irq_config(vector, irq, flags);
  109a40:	89 c6                	mov    %eax,%esi
  109a42:	e8 fe 0f 00 00       	callq  10aa45 <z_irq_controller_irq_config>
	x86_irq_funcs[vector - IV_IRQS] = func;
  109a47:	8d 73 e0             	lea    -0x20(%rbx),%esi
  109a4a:	48 63 f6             	movslq %esi,%rsi
  109a4d:	4c 89 2c f5 20 74 12 	mov    %r13,0x127420(,%rsi,8)
  109a54:	00 
	x86_irq_args[vector - IV_IRQS] = arg;
  109a55:	4c 89 24 f5 20 6d 12 	mov    %r12,0x126d20(,%rsi,8)
  109a5c:	00 
}
  109a5d:	5a                   	pop    %rdx
  109a5e:	5b                   	pop    %rbx
  109a5f:	41 5c                	pop    %r12
  109a61:	41 5d                	pop    %r13
  109a63:	5d                   	pop    %rbp
  109a64:	c3                   	retq   

0000000000109a65 <arch_irq_connect_dynamic>:
 */

int arch_irq_connect_dynamic(unsigned int irq, unsigned int priority,
			     void (*func)(const void *arg),
			     const void *arg, uint32_t flags)
{
  109a65:	55                   	push   %rbp
  109a66:	48 89 e5             	mov    %rsp,%rbp
  109a69:	41 57                	push   %r15
  109a6b:	49 89 cf             	mov    %rcx,%r15
  109a6e:	41 56                	push   %r14
  109a70:	49 89 d6             	mov    %rdx,%r14
  109a73:	41 55                	push   %r13
  109a75:	41 89 fd             	mov    %edi,%r13d
  109a78:	41 54                	push   %r12
  109a7a:	41 89 f4             	mov    %esi,%r12d
  109a7d:	53                   	push   %rbx
  109a7e:	48 83 ec 18          	sub    $0x18,%rsp
	uint32_t key;
	int vector;

	__ASSERT(irq <= CONFIG_MAX_IRQ_LINES, "IRQ %u out of range", irq);
  109a82:	81 ff 80 00 00 00    	cmp    $0x80,%edi
  109a88:	76 41                	jbe    109acb <arch_irq_connect_dynamic+0x66>
  109a8a:	b9 6b 00 00 00       	mov    $0x6b,%ecx
  109a8f:	ba e8 eb 11 00       	mov    $0x11ebe8,%edx
  109a94:	31 c0                	xor    %eax,%eax
  109a96:	44 89 45 cc          	mov    %r8d,-0x34(%rbp)
  109a9a:	be 17 ec 11 00       	mov    $0x11ec17,%esi
  109a9f:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  109aa4:	e8 4f 6b ff ff       	callq  1005f8 <printk>
  109aa9:	44 89 ee             	mov    %r13d,%esi
  109aac:	bf 22 ec 11 00       	mov    $0x11ec22,%edi
  109ab1:	31 c0                	xor    %eax,%eax
  109ab3:	e8 40 6b ff ff       	callq  1005f8 <printk>
  109ab8:	be 6b 00 00 00       	mov    $0x6b,%esi
  109abd:	bf e8 eb 11 00       	mov    $0x11ebe8,%edi
  109ac2:	e8 d1 90 ff ff       	callq  102b98 <assert_post_action>
  109ac7:	44 8b 45 cc          	mov    -0x34(%rbp),%r8d
  109acb:	9c                   	pushfq 
  109acc:	fa                   	cli    
  109acd:	5b                   	pop    %rbx

	key = irq_lock();

	vector = z_x86_allocate_vector(priority, -1);
  109ace:	83 ce ff             	or     $0xffffffff,%esi
  109ad1:	44 89 e7             	mov    %r12d,%edi
  109ad4:	e8 f6 fe ff ff       	callq  1099cf <z_x86_allocate_vector>
	if (vector >= 0) {
  109ad9:	85 c0                	test   %eax,%eax
  109adb:	78 17                	js     109af4 <arch_irq_connect_dynamic+0x8f>
		z_x86_irq_connect_on_vector(irq, vector, func, arg, flags);
  109add:	0f b6 f0             	movzbl %al,%esi
  109ae0:	4c 89 f9             	mov    %r15,%rcx
  109ae3:	4c 89 f2             	mov    %r14,%rdx
  109ae6:	44 89 ef             	mov    %r13d,%edi
  109ae9:	89 45 cc             	mov    %eax,-0x34(%rbp)
  109aec:	e8 2d ff ff ff       	callq  109a1e <z_x86_irq_connect_on_vector>
  109af1:	8b 45 cc             	mov    -0x34(%rbp),%eax
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  109af4:	0f ba e3 09          	bt     $0x9,%ebx
  109af8:	73 01                	jae    109afb <arch_irq_connect_dynamic+0x96>
		__asm__ volatile ("sti" ::: "memory");
  109afa:	fb                   	sti    
	}

	irq_unlock(key);
	return vector;
}
  109afb:	48 83 c4 18          	add    $0x18,%rsp
  109aff:	5b                   	pop    %rbx
  109b00:	41 5c                	pop    %r12
  109b02:	41 5d                	pop    %r13
  109b04:	41 5e                	pop    %r14
  109b06:	41 5f                	pop    %r15
  109b08:	5d                   	pop    %rbp
  109b09:	c3                   	retq   

0000000000109b0a <arch_new_thread>:
};

void arch_new_thread(struct k_thread *thread, k_thread_stack_t *stack,
		     char *stack_ptr, k_thread_entry_t entry,
		     void *p1, void *p2, void *p3)
{
  109b0a:	55                   	push   %rbp
  109b0b:	48 89 e5             	mov    %rsp,%rbp
  109b0e:	41 57                	push   %r15
  109b10:	49 89 cf             	mov    %rcx,%r15
  109b13:	41 56                	push   %r14
  109b15:	4d 89 c6             	mov    %r8,%r14
  109b18:	41 55                	push   %r13
  109b1a:	4d 89 cd             	mov    %r9,%r13
  109b1d:	41 54                	push   %r12
  109b1f:	49 89 d4             	mov    %rdx,%r12
  109b22:	53                   	push   %rbx
  109b23:	48 89 fb             	mov    %rdi,%rbx
  109b26:	48 89 f7             	mov    %rsi,%rdi
	thread->arch.cs = X86_KERNEL_CS;
	thread->arch.ss = X86_KERNEL_DS;
#else
	switch_entry = z_thread_entry;
#endif
	iframe = Z_STACK_PTR_TO_FRAME(struct x86_initial_frame, stack_ptr);
  109b29:	49 83 ec 08          	sub    $0x8,%r12
{
  109b2d:	50                   	push   %rax
	z_x86_set_stack_guard(stack);
  109b2e:	e8 63 f8 ff ff       	callq  109396 <z_x86_set_stack_guard>
	switch_entry = z_x86_userspace_prepare_thread(thread);
  109b33:	48 89 df             	mov    %rbx,%rdi
  109b36:	e8 ff fc ff ff       	callq  10983a <z_x86_userspace_prepare_thread>
	thread->arch.rdi = (long) entry;
	thread->arch.rsi = (long) p1;
	thread->arch.rdx = (long) p2;
	thread->arch.rcx = (long) p3;

	x86_sse_init(thread);
  109b3b:	48 89 df             	mov    %rbx,%rdi
	thread->arch.cs = X86_KERNEL_CS;
  109b3e:	48 c7 83 90 01 00 00 	movq   $0x18,0x190(%rbx)
  109b45:	18 00 00 00 
	thread->arch.ss = X86_KERNEL_DS;
  109b49:	48 c7 83 88 01 00 00 	movq   $0x20,0x188(%rbx)
  109b50:	20 00 00 00 
	iframe->rip = 0U;
  109b54:	49 c7 04 24 00 00 00 	movq   $0x0,(%r12)
  109b5b:	00 
	thread->callee_saved.rip = (long) switch_entry;
  109b5c:	48 89 83 80 00 00 00 	mov    %rax,0x80(%rbx)
	thread->arch.rcx = (long) p3;
  109b63:	48 8b 45 10          	mov    0x10(%rbp),%rax
	iframe = Z_STACK_PTR_TO_FRAME(struct x86_initial_frame, stack_ptr);
  109b67:	4c 89 63 48          	mov    %r12,0x48(%rbx)
	thread->arch.rdi = (long) entry;
  109b6b:	4c 89 bb b8 01 00 00 	mov    %r15,0x1b8(%rbx)
	thread->arch.rsi = (long) p1;
  109b72:	4c 89 b3 b0 01 00 00 	mov    %r14,0x1b0(%rbx)
	thread->arch.rdx = (long) p2;
  109b79:	4c 89 ab a8 01 00 00 	mov    %r13,0x1a8(%rbx)
	thread->callee_saved.rflags = EFLAGS_INITIAL;
  109b80:	48 c7 83 88 00 00 00 	movq   $0x200,0x88(%rbx)
  109b87:	00 02 00 00 
	thread->arch.rcx = (long) p3;
  109b8b:	48 89 83 a0 01 00 00 	mov    %rax,0x1a0(%rbx)
	x86_sse_init(thread);
  109b92:	e8 d1 75 ef ff       	callq  1168 <x86_sse_init>

	thread->arch.flags = X86_THREAD_FLAG_ALL;
  109b97:	c6 83 70 01 00 00 01 	movb   $0x1,0x170(%rbx)
	thread->switch_handle = thread;
  109b9e:	48 89 9b 50 01 00 00 	mov    %rbx,0x150(%rbx)
}
  109ba5:	5a                   	pop    %rdx
  109ba6:	5b                   	pop    %rbx
  109ba7:	41 5c                	pop    %r12
  109ba9:	41 5d                	pop    %r13
  109bab:	41 5e                	pop    %r14
  109bad:	41 5f                	pop    %r15
  109baf:	5d                   	pop    %rbp
  109bb0:	c3                   	retq   

0000000000109bb1 <z_x86_do_kernel_nmi>:
 * return true if NMI is handled, false otherwise
 */
__weak bool z_x86_do_kernel_nmi(const z_arch_esf_t *esf)
{
	return false;
}
  109bb1:	31 c0                	xor    %eax,%eax
  109bb3:	c3                   	retq   

0000000000109bb4 <z_x86_exception>:

void z_x86_exception(z_arch_esf_t *esf)
{
  109bb4:	55                   	push   %rbp
  109bb5:	48 89 e5             	mov    %rsp,%rbp
  109bb8:	53                   	push   %rbx
  109bb9:	48 89 fb             	mov    %rdi,%rbx
  109bbc:	56                   	push   %rsi
	switch (esf->vector) {
  109bbd:	48 8b bf 78 02 00 00 	mov    0x278(%rdi),%rdi
  109bc4:	48 83 ff 0e          	cmp    $0xe,%rdi
  109bc8:	74 19                	je     109be3 <z_x86_exception+0x2f>
  109bca:	48 83 ff 20          	cmp    $0x20,%rdi
  109bce:	74 08                	je     109bd8 <z_x86_exception+0x24>
  109bd0:	48 83 ff 02          	cmp    $0x2,%rdi
  109bd4:	75 2b                	jne    109c01 <z_x86_exception+0x4d>
  109bd6:	eb 16                	jmp    109bee <z_x86_exception+0x3a>
		break;
	default:
		z_x86_unhandled_cpu_exception(esf->vector, esf);
		CODE_UNREACHABLE;
	}
}
  109bd8:	59                   	pop    %rcx
		z_x86_do_kernel_oops(esf);
  109bd9:	48 89 df             	mov    %rbx,%rdi
}
  109bdc:	5b                   	pop    %rbx
  109bdd:	5d                   	pop    %rbp
		z_x86_do_kernel_oops(esf);
  109bde:	e9 ca e9 ff ff       	jmpq   1085ad <z_x86_do_kernel_oops>
}
  109be3:	5a                   	pop    %rdx
		z_x86_page_fault_handler(esf);
  109be4:	48 89 df             	mov    %rbx,%rdi
}
  109be7:	5b                   	pop    %rbx
  109be8:	5d                   	pop    %rbp
		z_x86_page_fault_handler(esf);
  109be9:	e9 40 e8 ff ff       	jmpq   10842e <z_x86_page_fault_handler>
		if (!z_x86_do_kernel_nmi(esf)) {
  109bee:	48 89 df             	mov    %rbx,%rdi
  109bf1:	e8 bb ff ff ff       	callq  109bb1 <z_x86_do_kernel_nmi>
  109bf6:	84 c0                	test   %al,%al
  109bf8:	75 0f                	jne    109c09 <z_x86_exception+0x55>
			z_x86_unhandled_cpu_exception(esf->vector, esf);
  109bfa:	48 8b bb 78 02 00 00 	mov    0x278(%rbx),%rdi
		z_x86_unhandled_cpu_exception(esf->vector, esf);
  109c01:	48 89 de             	mov    %rbx,%rsi
  109c04:	e8 4c e7 ff ff       	callq  108355 <z_x86_unhandled_cpu_exception>
}
  109c09:	58                   	pop    %rax
  109c0a:	5b                   	pop    %rbx
  109c0b:	5d                   	pop    %rbp
  109c0c:	c3                   	retq   

0000000000109c0d <arch_syscall_oops>:

#ifdef CONFIG_USERSPACE
void arch_syscall_oops(void *ssf_ptr)
{
  109c0d:	55                   	push   %rbp
	struct x86_ssf *ssf = ssf_ptr;

	LOG_ERR("Bad system call from RIP 0x%lx", ssf->rip);
  109c0e:	48 8b 17             	mov    (%rdi),%rdx
  109c11:	be 45 00 00 00       	mov    $0x45,%esi
  109c16:	bf 38 ec 11 00       	mov    $0x11ec38,%edi
  109c1b:	31 c0                	xor    %eax,%eax
{
  109c1d:	48 89 e5             	mov    %rsp,%rbp
	LOG_ERR("Bad system call from RIP 0x%lx", ssf->rip);
  109c20:	e8 a1 94 ff ff       	callq  1030c6 <z_log_minimal_printk>

	z_x86_fatal_error(K_ERR_KERNEL_OOPS, NULL);
  109c25:	31 f6                	xor    %esi,%esi
  109c27:	bf 03 00 00 00       	mov    $0x3,%edi
  109c2c:	e8 e8 e5 ff ff       	callq  108219 <z_x86_fatal_error>

0000000000109c31 <strtol>:
 *
 * Ignores `locale' stuff.  Assumes that the upper and lower case
 * alphabets and digits are each contiguous.
 */
long strtol(const char *nptr, char **endptr, register int base)
{
  109c31:	55                   	push   %rbp
  109c32:	49 89 f9             	mov    %rdi,%r9
  109c35:	48 89 e5             	mov    %rsp,%rbp
  109c38:	41 56                	push   %r14
  109c3a:	41 55                	push   %r13
  109c3c:	49 89 f5             	mov    %rsi,%r13
  109c3f:	89 d6                	mov    %edx,%esi
  109c41:	41 54                	push   %r12
  109c43:	53                   	push   %rbx
	register const char *s = nptr;
  109c44:	48 89 fb             	mov    %rdi,%rbx
	 * Skip white space and pick up leading +/- sign if any.
	 * If base is 0, allow 0x for hex and 0 for octal, else
	 * assume decimal; if base is already 16, allow 0x.
	 */
	do {
		c = *s++;
  109c47:	48 89 d8             	mov    %rbx,%rax
  109c4a:	0f be 0b             	movsbl (%rbx),%ecx
  109c4d:	48 ff c3             	inc    %rbx
  109c50:	8d 51 f7             	lea    -0x9(%rcx),%edx
	} while (isspace(c));
  109c53:	83 fa 04             	cmp    $0x4,%edx
  109c56:	76 ef                	jbe    109c47 <strtol+0x16>
  109c58:	83 f9 20             	cmp    $0x20,%ecx
  109c5b:	74 ea                	je     109c47 <strtol+0x16>
	if (c == '-') {
  109c5d:	83 f9 2d             	cmp    $0x2d,%ecx
  109c60:	75 0f                	jne    109c71 <strtol+0x40>
		neg = 1;
		c = *s++;
  109c62:	0f be 0b             	movsbl (%rbx),%ecx
		neg = 1;
  109c65:	41 ba 01 00 00 00    	mov    $0x1,%r10d
		c = *s++;
  109c6b:	48 8d 58 02          	lea    0x2(%rax),%rbx
  109c6f:	eb 0f                	jmp    109c80 <strtol+0x4f>
	register int neg = 0, any, cutlim;
  109c71:	45 31 d2             	xor    %r10d,%r10d
	} else if (c == '+') {
  109c74:	83 f9 2b             	cmp    $0x2b,%ecx
  109c77:	75 07                	jne    109c80 <strtol+0x4f>
		c = *s++;
  109c79:	0f be 0b             	movsbl (%rbx),%ecx
  109c7c:	48 8d 58 02          	lea    0x2(%rax),%rbx
	}

	if ((base == 0 || base == 16) &&
  109c80:	f7 c6 ef ff ff ff    	test   $0xffffffef,%esi
  109c86:	75 23                	jne    109cab <strtol+0x7a>
  109c88:	83 f9 30             	cmp    $0x30,%ecx
  109c8b:	0f 85 e1 00 00 00    	jne    109d72 <strtol+0x141>
	    c == '0' && (*s == 'x' || *s == 'X')) {
  109c91:	8a 03                	mov    (%rbx),%al
  109c93:	83 e0 df             	and    $0xffffffdf,%eax
  109c96:	3c 58                	cmp    $0x58,%al
  109c98:	0f 85 e6 00 00 00    	jne    109d84 <strtol+0x153>
		c = s[1];
  109c9e:	0f be 4b 01          	movsbl 0x1(%rbx),%ecx
		s += 2;
		base = 16;
  109ca2:	be 10 00 00 00       	mov    $0x10,%esi
		s += 2;
  109ca7:	48 83 c3 02          	add    $0x2,%rbx
	 * the number is too big, and we will return a range error.
	 *
	 * Set any if any `digits' consumed; make it negative to indicate
	 * overflow.
	 */
	cutoff = neg ? -(unsigned long)LONG_MIN : LONG_MAX;
  109cab:	4d 63 e2             	movslq %r10d,%r12
	cutlim = cutoff % (unsigned long)base;
  109cae:	4c 63 de             	movslq %esi,%r11
  109cb1:	31 d2                	xor    %edx,%edx
	cutoff /= (unsigned long)base;
	for (acc = 0, any = 0;; c = *s++) {
  109cb3:	45 31 f6             	xor    %r14d,%r14d
	cutoff = neg ? -(unsigned long)LONG_MIN : LONG_MAX;
  109cb6:	48 b8 ff ff ff ff ff 	movabs $0x7fffffffffffffff,%rax
  109cbd:	ff ff 7f 
	for (acc = 0, any = 0;; c = *s++) {
  109cc0:	45 31 c0             	xor    %r8d,%r8d
	cutoff = neg ? -(unsigned long)LONG_MIN : LONG_MAX;
  109cc3:	49 01 c4             	add    %rax,%r12
	cutlim = cutoff % (unsigned long)base;
  109cc6:	4c 89 e0             	mov    %r12,%rax
  109cc9:	49 f7 f3             	div    %r11
	return (int)(((unsigned)(a)-(unsigned)'0') < 10U);
  109ccc:	8d 79 d0             	lea    -0x30(%rcx),%edi
		if (isdigit(c)) {
  109ccf:	83 ff 09             	cmp    $0x9,%edi
  109cd2:	77 04                	ja     109cd8 <strtol+0xa7>
			c -= '0';
  109cd4:	89 f9                	mov    %edi,%ecx
  109cd6:	eb 1d                	jmp    109cf5 <strtol+0xc4>
	return (int)((((unsigned)c|32u)-(unsigned)'a') < 26U);
  109cd8:	89 cf                	mov    %ecx,%edi
  109cda:	83 cf 20             	or     $0x20,%edi
  109cdd:	83 ef 61             	sub    $0x61,%edi
		} else if (isalpha(c)) {
  109ce0:	83 ff 19             	cmp    $0x19,%edi
  109ce3:	77 47                	ja     109d2c <strtol+0xfb>
	return (int)(((unsigned)(a)-(unsigned)'A') < 26U);
  109ce5:	8d 79 bf             	lea    -0x41(%rcx),%edi
			c -= isupper(c) ? 'A' - 10 : 'a' - 10;
  109ce8:	83 ff 1a             	cmp    $0x1a,%edi
  109ceb:	19 ff                	sbb    %edi,%edi
  109ced:	83 e7 e0             	and    $0xffffffe0,%edi
  109cf0:	83 c7 57             	add    $0x57,%edi
  109cf3:	29 f9                	sub    %edi,%ecx
		} else {
			break;
		}
		if (c >= base) {
  109cf5:	39 ce                	cmp    %ecx,%esi
  109cf7:	7e 33                	jle    109d2c <strtol+0xfb>
			break;
		}
		if (any < 0 || acc > cutoff || (acc == cutoff && c > cutlim)) {
  109cf9:	45 85 f6             	test   %r14d,%r14d
  109cfc:	78 21                	js     109d1f <strtol+0xee>
  109cfe:	49 39 c0             	cmp    %rax,%r8
  109d01:	77 1c                	ja     109d1f <strtol+0xee>
  109d03:	75 08                	jne    109d0d <strtol+0xdc>
			any = -1;
  109d05:	41 83 ce ff          	or     $0xffffffff,%r14d
		if (any < 0 || acc > cutoff || (acc == cutoff && c > cutlim)) {
  109d09:	39 d1                	cmp    %edx,%ecx
  109d0b:	7f 16                	jg     109d23 <strtol+0xf2>
		} else {
			any = 1;
			acc *= base;
  109d0d:	4d 0f af c3          	imul   %r11,%r8
			acc += c;
  109d11:	48 63 c9             	movslq %ecx,%rcx
			any = 1;
  109d14:	41 be 01 00 00 00    	mov    $0x1,%r14d
			acc += c;
  109d1a:	49 01 c8             	add    %rcx,%r8
  109d1d:	eb 04                	jmp    109d23 <strtol+0xf2>
			any = -1;
  109d1f:	41 83 ce ff          	or     $0xffffffff,%r14d
	for (acc = 0, any = 0;; c = *s++) {
  109d23:	48 ff c3             	inc    %rbx
  109d26:	0f be 4b ff          	movsbl -0x1(%rbx),%ecx
		if (isdigit(c)) {
  109d2a:	eb a0                	jmp    109ccc <strtol+0x9b>
		}
	}

	if (any < 0) {
  109d2c:	41 83 fe ff          	cmp    $0xffffffff,%r14d
  109d30:	75 24                	jne    109d56 <strtol+0x125>
	__asm__ volatile ("mov %%cs, %[cs_val]" : [cs_val] "=r" (cs));
  109d32:	8c c8                	mov    %cs,%eax
	if (z_syscall_trap()) {
  109d34:	a8 03                	test   $0x3,%al
  109d36:	74 09                	je     109d41 <strtol+0x110>
	register uintptr_t rax __asm__("%rax") = call_id;
  109d38:	b8 49 01 00 00       	mov    $0x149,%eax
	__asm__ volatile("syscall\n\t"
  109d3d:	0f 05                	syscall 
		return (int *) arch_syscall_invoke0(K_SYSCALL_Z_ERRNO);
  109d3f:	eb 05                	jmp    109d46 <strtol+0x115>
	return z_impl_z_errno();
  109d41:	e8 3c 33 00 00       	callq  10d082 <z_impl_z_errno>
		acc = neg ? LONG_MIN : LONG_MAX;
		errno = ERANGE;
  109d46:	c7 00 22 00 00 00    	movl   $0x22,(%rax)
		acc = neg ? LONG_MIN : LONG_MAX;
  109d4c:	4d 89 e0             	mov    %r12,%r8
	} else if (neg) {
		acc = -acc;
	}

	if (endptr != NULL) {
  109d4f:	4d 85 ed             	test   %r13,%r13
  109d52:	75 14                	jne    109d68 <strtol+0x137>
  109d54:	eb 40                	jmp    109d96 <strtol+0x165>
	} else if (neg) {
  109d56:	45 85 d2             	test   %r10d,%r10d
  109d59:	74 03                	je     109d5e <strtol+0x12d>
		acc = -acc;
  109d5b:	49 f7 d8             	neg    %r8
	if (endptr != NULL) {
  109d5e:	4d 85 ed             	test   %r13,%r13
  109d61:	74 33                	je     109d96 <strtol+0x165>
		*endptr = (char *)(any ? s - 1 : nptr);
  109d63:	45 85 f6             	test   %r14d,%r14d
  109d66:	74 04                	je     109d6c <strtol+0x13b>
  109d68:	4c 8d 4b ff          	lea    -0x1(%rbx),%r9
  109d6c:	4d 89 4d 00          	mov    %r9,0x0(%r13)
	}
	return acc;
  109d70:	eb 24                	jmp    109d96 <strtol+0x165>
	if (base == 0) {
  109d72:	85 f6                	test   %esi,%esi
  109d74:	0f 85 31 ff ff ff    	jne    109cab <strtol+0x7a>
		base = c == '0' ? 8 : 10;
  109d7a:	be 0a 00 00 00       	mov    $0xa,%esi
  109d7f:	e9 27 ff ff ff       	jmpq   109cab <strtol+0x7a>
	if (base == 0) {
  109d84:	85 f6                	test   %esi,%esi
  109d86:	0f 85 1f ff ff ff    	jne    109cab <strtol+0x7a>
		base = c == '0' ? 8 : 10;
  109d8c:	be 08 00 00 00       	mov    $0x8,%esi
  109d91:	e9 15 ff ff ff       	jmpq   109cab <strtol+0x7a>
}
  109d96:	5b                   	pop    %rbx
  109d97:	4c 89 c0             	mov    %r8,%rax
  109d9a:	41 5c                	pop    %r12
  109d9c:	41 5d                	pop    %r13
  109d9e:	41 5e                	pop    %r14
  109da0:	5d                   	pop    %rbp
  109da1:	c3                   	retq   

0000000000109da2 <strtoul>:
 *
 * Ignores `locale' stuff.  Assumes that the upper and lower case
 * alphabets and digits are each contiguous.
 */
unsigned long strtoul(const char *nptr, char **endptr, register int base)
{
  109da2:	55                   	push   %rbp
  109da3:	49 89 fa             	mov    %rdi,%r10
  109da6:	48 89 e5             	mov    %rsp,%rbp
  109da9:	41 55                	push   %r13
  109dab:	41 54                	push   %r12
  109dad:	49 89 f4             	mov    %rsi,%r12
  109db0:	89 d6                	mov    %edx,%esi
  109db2:	53                   	push   %rbx
	register const char *s = nptr;
  109db3:	48 89 fb             	mov    %rdi,%rbx
{
  109db6:	51                   	push   %rcx

	/*
	 * See strtol for comments as to the logic used.
	 */
	do {
		c = *s++;
  109db7:	48 89 d8             	mov    %rbx,%rax
  109dba:	0f be 0b             	movsbl (%rbx),%ecx
  109dbd:	48 ff c3             	inc    %rbx
	return (int)(c == (int)' ' || ((unsigned)c-(unsigned)'\t') < 5U);
  109dc0:	8d 51 f7             	lea    -0x9(%rcx),%edx
	} while (isspace(c));
  109dc3:	83 fa 04             	cmp    $0x4,%edx
  109dc6:	76 ef                	jbe    109db7 <strtoul+0x15>
  109dc8:	83 f9 20             	cmp    $0x20,%ecx
  109dcb:	74 ea                	je     109db7 <strtoul+0x15>
	if (c == '-') {
  109dcd:	83 f9 2d             	cmp    $0x2d,%ecx
  109dd0:	75 0f                	jne    109de1 <strtoul+0x3f>
		neg = 1;
		c = *s++;
  109dd2:	0f be 0b             	movsbl (%rbx),%ecx
		neg = 1;
  109dd5:	41 bd 01 00 00 00    	mov    $0x1,%r13d
		c = *s++;
  109ddb:	48 8d 58 02          	lea    0x2(%rax),%rbx
  109ddf:	eb 0f                	jmp    109df0 <strtoul+0x4e>
	register int neg = 0, any, cutlim;
  109de1:	45 31 ed             	xor    %r13d,%r13d
	} else if (c == '+') {
  109de4:	83 f9 2b             	cmp    $0x2b,%ecx
  109de7:	75 07                	jne    109df0 <strtoul+0x4e>
		c = *s++;
  109de9:	0f be 0b             	movsbl (%rbx),%ecx
  109dec:	48 8d 58 02          	lea    0x2(%rax),%rbx
	}

	if ((base == 0 || base == 16) &&
  109df0:	f7 c6 ef ff ff ff    	test   $0xffffffef,%esi
  109df6:	75 23                	jne    109e1b <strtoul+0x79>
  109df8:	83 f9 30             	cmp    $0x30,%ecx
  109dfb:	0f 85 d3 00 00 00    	jne    109ed4 <strtoul+0x132>
	    c == '0' && (*s == 'x' || *s == 'X')) {
  109e01:	8a 03                	mov    (%rbx),%al
  109e03:	83 e0 df             	and    $0xffffffdf,%eax
  109e06:	3c 58                	cmp    $0x58,%al
  109e08:	0f 85 d8 00 00 00    	jne    109ee6 <strtoul+0x144>
		c = s[1];
  109e0e:	0f be 4b 01          	movsbl 0x1(%rbx),%ecx
		s += 2;
		base = 16;
  109e12:	be 10 00 00 00       	mov    $0x10,%esi
		s += 2;
  109e17:	48 83 c3 02          	add    $0x2,%rbx

	if (base == 0) {
		base = c == '0' ? 8 : 10;
	}

	cutoff = (unsigned long)ULONG_MAX / (unsigned long)base;
  109e1b:	4c 63 de             	movslq %esi,%r11
  109e1e:	48 83 c8 ff          	or     $0xffffffffffffffff,%rax
  109e22:	31 d2                	xor    %edx,%edx
	cutlim = (unsigned long)ULONG_MAX % (unsigned long)base;
	for (acc = 0, any = 0;; c = *s++) {
  109e24:	45 31 c9             	xor    %r9d,%r9d
	cutoff = (unsigned long)ULONG_MAX / (unsigned long)base;
  109e27:	49 f7 f3             	div    %r11
	for (acc = 0, any = 0;; c = *s++) {
  109e2a:	45 31 c0             	xor    %r8d,%r8d
	return (int)(((unsigned)(a)-(unsigned)'0') < 10U);
  109e2d:	8d 79 d0             	lea    -0x30(%rcx),%edi
		if (isdigit(c)) {
  109e30:	83 ff 09             	cmp    $0x9,%edi
  109e33:	77 04                	ja     109e39 <strtoul+0x97>
			c -= '0';
  109e35:	89 f9                	mov    %edi,%ecx
  109e37:	eb 1d                	jmp    109e56 <strtoul+0xb4>
	return (int)((((unsigned)c|32u)-(unsigned)'a') < 26U);
  109e39:	89 cf                	mov    %ecx,%edi
  109e3b:	83 cf 20             	or     $0x20,%edi
  109e3e:	83 ef 61             	sub    $0x61,%edi
		} else if (isalpha(c)) {
  109e41:	83 ff 19             	cmp    $0x19,%edi
  109e44:	77 47                	ja     109e8d <strtoul+0xeb>
	return (int)(((unsigned)(a)-(unsigned)'A') < 26U);
  109e46:	8d 79 bf             	lea    -0x41(%rcx),%edi
			c -= isupper(c) ? 'A' - 10 : 'a' - 10;
  109e49:	83 ff 1a             	cmp    $0x1a,%edi
  109e4c:	19 ff                	sbb    %edi,%edi
  109e4e:	83 e7 e0             	and    $0xffffffe0,%edi
  109e51:	83 c7 57             	add    $0x57,%edi
  109e54:	29 f9                	sub    %edi,%ecx
		} else {
			break;
		}
		if (c >= base) {
  109e56:	39 ce                	cmp    %ecx,%esi
  109e58:	7e 33                	jle    109e8d <strtoul+0xeb>
			break;
		}
		if (any < 0 || acc > cutoff || (acc == cutoff && c > cutlim)) {
  109e5a:	45 85 c9             	test   %r9d,%r9d
  109e5d:	78 21                	js     109e80 <strtoul+0xde>
  109e5f:	49 39 c0             	cmp    %rax,%r8
  109e62:	77 1c                	ja     109e80 <strtoul+0xde>
  109e64:	75 08                	jne    109e6e <strtoul+0xcc>
			any = -1;
  109e66:	41 83 c9 ff          	or     $0xffffffff,%r9d
		if (any < 0 || acc > cutoff || (acc == cutoff && c > cutlim)) {
  109e6a:	39 d1                	cmp    %edx,%ecx
  109e6c:	7f 16                	jg     109e84 <strtoul+0xe2>
		} else {
			any = 1;
			acc *= base;
  109e6e:	4d 0f af c3          	imul   %r11,%r8
			acc += c;
  109e72:	48 63 c9             	movslq %ecx,%rcx
			any = 1;
  109e75:	41 b9 01 00 00 00    	mov    $0x1,%r9d
			acc += c;
  109e7b:	49 01 c8             	add    %rcx,%r8
  109e7e:	eb 04                	jmp    109e84 <strtoul+0xe2>
			any = -1;
  109e80:	41 83 c9 ff          	or     $0xffffffff,%r9d
	for (acc = 0, any = 0;; c = *s++) {
  109e84:	48 ff c3             	inc    %rbx
  109e87:	0f be 4b ff          	movsbl -0x1(%rbx),%ecx
		if (isdigit(c)) {
  109e8b:	eb a0                	jmp    109e2d <strtoul+0x8b>
		}
	}
	if (any < 0) {
  109e8d:	41 83 f9 ff          	cmp    $0xffffffff,%r9d
  109e91:	75 25                	jne    109eb8 <strtoul+0x116>
	__asm__ volatile ("mov %%cs, %[cs_val]" : [cs_val] "=r" (cs));
  109e93:	8c c8                	mov    %cs,%eax
	if (z_syscall_trap()) {
  109e95:	a8 03                	test   $0x3,%al
  109e97:	74 09                	je     109ea2 <strtoul+0x100>
	register uintptr_t rax __asm__("%rax") = call_id;
  109e99:	b8 49 01 00 00       	mov    $0x149,%eax
	__asm__ volatile("syscall\n\t"
  109e9e:	0f 05                	syscall 
		return (int *) arch_syscall_invoke0(K_SYSCALL_Z_ERRNO);
  109ea0:	eb 05                	jmp    109ea7 <strtoul+0x105>
	return z_impl_z_errno();
  109ea2:	e8 db 31 00 00       	callq  10d082 <z_impl_z_errno>
		acc = ULONG_MAX;
		errno = ERANGE;
  109ea7:	c7 00 22 00 00 00    	movl   $0x22,(%rax)
		acc = ULONG_MAX;
  109ead:	49 83 c8 ff          	or     $0xffffffffffffffff,%r8
	} else if (neg) {
		acc = -acc;
	}
	if (endptr != NULL) {
  109eb1:	4d 85 e4             	test   %r12,%r12
  109eb4:	75 14                	jne    109eca <strtoul+0x128>
  109eb6:	eb 40                	jmp    109ef8 <strtoul+0x156>
	} else if (neg) {
  109eb8:	45 85 ed             	test   %r13d,%r13d
  109ebb:	74 03                	je     109ec0 <strtoul+0x11e>
		acc = -acc;
  109ebd:	49 f7 d8             	neg    %r8
	if (endptr != NULL) {
  109ec0:	4d 85 e4             	test   %r12,%r12
  109ec3:	74 33                	je     109ef8 <strtoul+0x156>
		*endptr = (char *)(any ? s - 1 : nptr);
  109ec5:	45 85 c9             	test   %r9d,%r9d
  109ec8:	74 04                	je     109ece <strtoul+0x12c>
  109eca:	4c 8d 53 ff          	lea    -0x1(%rbx),%r10
  109ece:	4d 89 14 24          	mov    %r10,(%r12)
	}
	return acc;
  109ed2:	eb 24                	jmp    109ef8 <strtoul+0x156>
	if (base == 0) {
  109ed4:	85 f6                	test   %esi,%esi
  109ed6:	0f 85 3f ff ff ff    	jne    109e1b <strtoul+0x79>
		base = c == '0' ? 8 : 10;
  109edc:	be 0a 00 00 00       	mov    $0xa,%esi
  109ee1:	e9 35 ff ff ff       	jmpq   109e1b <strtoul+0x79>
	if (base == 0) {
  109ee6:	85 f6                	test   %esi,%esi
  109ee8:	0f 85 2d ff ff ff    	jne    109e1b <strtoul+0x79>
		base = c == '0' ? 8 : 10;
  109eee:	be 08 00 00 00       	mov    $0x8,%esi
  109ef3:	e9 23 ff ff ff       	jmpq   109e1b <strtoul+0x79>
}
  109ef8:	5a                   	pop    %rdx
  109ef9:	4c 89 c0             	mov    %r8,%rax
  109efc:	5b                   	pop    %rbx
  109efd:	41 5c                	pop    %r12
  109eff:	41 5d                	pop    %r13
  109f01:	5d                   	pop    %rbp
  109f02:	c3                   	retq   

0000000000109f03 <strstr>:
/*
 * Find the first occurrence of find in s.
 */
char *
strstr(const char *s, const char *find)
{
  109f03:	55                   	push   %rbp
  109f04:	48 89 e5             	mov    %rsp,%rbp
  109f07:	41 57                	push   %r15
  109f09:	41 56                	push   %r14
  109f0b:	41 55                	push   %r13
  109f0d:	41 54                	push   %r12
  109f0f:	49 89 fc             	mov    %rdi,%r12
  109f12:	53                   	push   %rbx
  109f13:	51                   	push   %rcx
	char c, sc;
	size_t len;

	c = *find++;
  109f14:	44 8a 36             	mov    (%rsi),%r14b
	if (c != 0) {
  109f17:	45 84 f6             	test   %r14b,%r14b
  109f1a:	74 3d                	je     109f59 <strstr+0x56>
	c = *find++;
  109f1c:	48 8d 5e 01          	lea    0x1(%rsi),%rbx
		len = strlen(find);
  109f20:	48 89 df             	mov    %rbx,%rdi
  109f23:	e8 b4 00 00 00       	callq  109fdc <strlen>
  109f28:	49 89 c7             	mov    %rax,%r15
		do {
			do {
				sc = *s++;
  109f2b:	41 8a 04 24          	mov    (%r12),%al
  109f2f:	4d 8d 6c 24 01       	lea    0x1(%r12),%r13
				if (sc == 0) {
  109f34:	84 c0                	test   %al,%al
  109f36:	74 1e                	je     109f56 <strstr+0x53>
					return NULL;
				}
			} while (sc != c);
  109f38:	41 38 c6             	cmp    %al,%r14b
  109f3b:	74 05                	je     109f42 <strstr+0x3f>
{
  109f3d:	4d 89 ec             	mov    %r13,%r12
  109f40:	eb e9                	jmp    109f2b <strstr+0x28>
		} while (strncmp(s, find, len) != 0);
  109f42:	4c 89 fa             	mov    %r15,%rdx
  109f45:	48 89 de             	mov    %rbx,%rsi
  109f48:	4c 89 ef             	mov    %r13,%rdi
  109f4b:	e8 c5 00 00 00       	callq  10a015 <strncmp>
  109f50:	85 c0                	test   %eax,%eax
  109f52:	75 e9                	jne    109f3d <strstr+0x3a>
  109f54:	eb 03                	jmp    109f59 <strstr+0x56>
					return NULL;
  109f56:	45 31 e4             	xor    %r12d,%r12d
	s--;
	}
	return (char *)s;
}
  109f59:	5a                   	pop    %rdx
  109f5a:	4c 89 e0             	mov    %r12,%rax
  109f5d:	5b                   	pop    %rbx
  109f5e:	41 5c                	pop    %r12
  109f60:	41 5d                	pop    %r13
  109f62:	41 5e                	pop    %r14
  109f64:	41 5f                	pop    %r15
  109f66:	5d                   	pop    %rbp
  109f67:	c3                   	retq   

0000000000109f68 <strcpy>:
 *
 * @return pointer to destination buffer <d>
 */

char *strcpy(char *_MLIBC_RESTRICT d, const char *_MLIBC_RESTRICT s)
{
  109f68:	48 89 f8             	mov    %rdi,%rax
	char *dest = d;

	while (*s != '\0') {
  109f6b:	31 d2                	xor    %edx,%edx
  109f6d:	8a 0c 16             	mov    (%rsi,%rdx,1),%cl
  109f70:	48 8d 3c 10          	lea    (%rax,%rdx,1),%rdi
  109f74:	84 c9                	test   %cl,%cl
  109f76:	74 08                	je     109f80 <strcpy+0x18>
		*d = *s;
  109f78:	88 0c 10             	mov    %cl,(%rax,%rdx,1)
		d++;
		s++;
  109f7b:	48 ff c2             	inc    %rdx
  109f7e:	eb ed                	jmp    109f6d <strcpy+0x5>
	}

	*d = '\0';
  109f80:	c6 07 00             	movb   $0x0,(%rdi)

	return dest;
}
  109f83:	c3                   	retq   

0000000000109f84 <strncpy>:
 *
 * @return pointer to destination buffer <d>
 */

char *strncpy(char *_MLIBC_RESTRICT d, const char *_MLIBC_RESTRICT s, size_t n)
{
  109f84:	49 89 f8             	mov    %rdi,%r8
	char *dest = d;

	while ((n > 0) && *s != '\0') {
  109f87:	31 c0                	xor    %eax,%eax
  109f89:	48 89 d7             	mov    %rdx,%rdi
  109f8c:	4d 8d 0c 00          	lea    (%r8,%rax,1),%r9
  109f90:	48 29 c7             	sub    %rax,%rdi
  109f93:	48 39 d0             	cmp    %rdx,%rax
  109f96:	74 1f                	je     109fb7 <strncpy+0x33>
  109f98:	8a 0c 06             	mov    (%rsi,%rax,1),%cl
  109f9b:	84 c9                	test   %cl,%cl
  109f9d:	74 09                	je     109fa8 <strncpy+0x24>
		*d = *s;
  109f9f:	41 88 0c 00          	mov    %cl,(%r8,%rax,1)
		s++;
		d++;
		n--;
  109fa3:	48 ff c0             	inc    %rax
  109fa6:	eb e1                	jmp    109f89 <strncpy+0x5>
  109fa8:	31 c0                	xor    %eax,%eax
	}

	while (n > 0) {
		*d = '\0';
  109faa:	41 c6 04 01 00       	movb   $0x0,(%r9,%rax,1)
	while (n > 0) {
  109faf:	48 ff c0             	inc    %rax
  109fb2:	48 39 f8             	cmp    %rdi,%rax
  109fb5:	75 f3                	jne    109faa <strncpy+0x26>
		d++;
		n--;
	}

	return dest;
}
  109fb7:	4c 89 c0             	mov    %r8,%rax
  109fba:	c3                   	retq   

0000000000109fbb <strchr>:
 * @return pointer to 1st instance of found byte, or NULL if not found
 */

char *strchr(const char *s, int c)
{
	char tmp = (char) c;
  109fbb:	89 f1                	mov    %esi,%ecx

	while ((*s != tmp) && (*s != '\0')) {
  109fbd:	48 89 f8             	mov    %rdi,%rax
  109fc0:	8a 10                	mov    (%rax),%dl
  109fc2:	38 ca                	cmp    %cl,%dl
  109fc4:	74 15                	je     109fdb <strchr+0x20>
  109fc6:	84 d2                	test   %dl,%dl
  109fc8:	74 05                	je     109fcf <strchr+0x14>
		s++;
  109fca:	48 ff c0             	inc    %rax
  109fcd:	eb f1                	jmp    109fc0 <strchr+0x5>
	}

	return (*s == tmp) ? (char *) s : NULL;
  109fcf:	40 84 f6             	test   %sil,%sil
  109fd2:	ba 00 00 00 00       	mov    $0x0,%edx
  109fd7:	48 0f 45 c2          	cmovne %rdx,%rax
}
  109fdb:	c3                   	retq   

0000000000109fdc <strlen>:
 * @return number of bytes in string <s>
 */

size_t strlen(const char *s)
{
	size_t n = 0;
  109fdc:	31 c0                	xor    %eax,%eax

	while (*s != '\0') {
  109fde:	80 3c 07 00          	cmpb   $0x0,(%rdi,%rax,1)
  109fe2:	74 05                	je     109fe9 <strlen+0xd>
		s++;
		n++;
  109fe4:	48 ff c0             	inc    %rax
  109fe7:	eb f5                	jmp    109fde <strlen+0x2>
	}

	return n;
}
  109fe9:	c3                   	retq   

0000000000109fea <strnlen>:
 * @return number of bytes in fixed-size string <s>
 */

size_t strnlen(const char *s, size_t maxlen)
{
	size_t n = 0;
  109fea:	31 c0                	xor    %eax,%eax

	while (*s != '\0' && n < maxlen) {
  109fec:	80 3c 07 00          	cmpb   $0x0,(%rdi,%rax,1)
  109ff0:	74 0a                	je     109ffc <strnlen+0x12>
  109ff2:	48 39 f0             	cmp    %rsi,%rax
  109ff5:	73 05                	jae    109ffc <strnlen+0x12>
		s++;
		n++;
  109ff7:	48 ff c0             	inc    %rax
  109ffa:	eb f0                	jmp    109fec <strnlen+0x2>
	}

	return n;
}
  109ffc:	c3                   	retq   

0000000000109ffd <strcmp>:
 * @return negative # if <s1> < <s2>, 0 if <s1> == <s2>, else positive #
 */

int strcmp(const char *s1, const char *s2)
{
	while ((*s1 == *s2) && (*s1 != '\0')) {
  109ffd:	31 c9                	xor    %ecx,%ecx
  109fff:	0f be 04 0f          	movsbl (%rdi,%rcx,1),%eax
  10a003:	0f be 14 0e          	movsbl (%rsi,%rcx,1),%edx
  10a007:	38 d0                	cmp    %dl,%al
  10a009:	75 07                	jne    10a012 <strcmp+0x15>
  10a00b:	48 ff c1             	inc    %rcx
  10a00e:	84 c0                	test   %al,%al
  10a010:	75 ed                	jne    109fff <strcmp+0x2>
		s1++;
		s2++;
	}

	return *s1 - *s2;
  10a012:	29 d0                	sub    %edx,%eax
}
  10a014:	c3                   	retq   

000000000010a015 <strncmp>:
 *
 * @return negative # if <s1> < <s2>, 0 if <s1> == <s2>, else positive #
 */

int strncmp(const char *s1, const char *s2, size_t n)
{
  10a015:	49 89 d0             	mov    %rdx,%r8
	while ((n > 0) && (*s1 == *s2) && (*s1 != '\0')) {
  10a018:	31 d2                	xor    %edx,%edx
  10a01a:	49 39 d0             	cmp    %rdx,%r8
  10a01d:	74 15                	je     10a034 <strncmp+0x1f>
  10a01f:	0f be 04 17          	movsbl (%rdi,%rdx,1),%eax
  10a023:	0f be 0c 16          	movsbl (%rsi,%rdx,1),%ecx
  10a027:	48 ff c2             	inc    %rdx
  10a02a:	84 c0                	test   %al,%al
  10a02c:	74 09                	je     10a037 <strncmp+0x22>
  10a02e:	38 c8                	cmp    %cl,%al
  10a030:	74 e8                	je     10a01a <strncmp+0x5>
  10a032:	eb 03                	jmp    10a037 <strncmp+0x22>
		s1++;
		s2++;
		n--;
	}

	return (n == 0) ? 0 : (*s1 - *s2);
  10a034:	31 c0                	xor    %eax,%eax
  10a036:	c3                   	retq   
  10a037:	29 c8                	sub    %ecx,%eax
}
  10a039:	c3                   	retq   

000000000010a03a <memcmp>:
 * @brief Compare two memory areas
 *
 * @return negative # if <m1> < <m2>, 0 if <m1> == <m2>, else positive #
 */
int memcmp(const void *m1, const void *m2, size_t n)
{
  10a03a:	49 89 f0             	mov    %rsi,%r8
	const char *c1 = m1;
	const char *c2 = m2;

	if (!n) {
		return 0;
  10a03d:	31 c0                	xor    %eax,%eax
	if (!n) {
  10a03f:	48 85 d2             	test   %rdx,%rdx
  10a042:	74 1d                	je     10a061 <memcmp+0x27>
  10a044:	48 ff ca             	dec    %rdx
  10a047:	31 c9                	xor    %ecx,%ecx
	}

	while ((--n > 0) && (*c1 == *c2)) {
  10a049:	0f be 04 0f          	movsbl (%rdi,%rcx,1),%eax
  10a04d:	41 0f be 34 08       	movsbl (%r8,%rcx,1),%esi
  10a052:	48 39 ca             	cmp    %rcx,%rdx
  10a055:	74 08                	je     10a05f <memcmp+0x25>
  10a057:	48 ff c1             	inc    %rcx
  10a05a:	40 38 f0             	cmp    %sil,%al
  10a05d:	74 ea                	je     10a049 <memcmp+0xf>
		c1++;
		c2++;
	}

	return *c1 - *c2;
  10a05f:	29 f0                	sub    %esi,%eax
}
  10a061:	c3                   	retq   

000000000010a062 <memmove>:
void *memmove(void *d, const void *s, size_t n)
{
	char *dest = d;
	const char *src  = s;

	if ((size_t) (dest - src) < n) {
  10a062:	48 89 f9             	mov    %rdi,%rcx
{
  10a065:	48 89 f8             	mov    %rdi,%rax
	if ((size_t) (dest - src) < n) {
  10a068:	48 29 f1             	sub    %rsi,%rcx
  10a06b:	48 39 d1             	cmp    %rdx,%rcx
  10a06e:	72 04                	jb     10a074 <memmove+0x12>
  10a070:	31 c9                	xor    %ecx,%ecx
  10a072:	eb 11                	jmp    10a085 <memmove+0x23>
		/*
		 * The <src> buffer overlaps with the start of the <dest> buffer.
		 * Copy backwards to prevent the premature corruption of <src>.
		 */

		while (n > 0) {
  10a074:	48 85 d2             	test   %rdx,%rdx
  10a077:	74 0b                	je     10a084 <memmove+0x22>
			n--;
  10a079:	48 ff ca             	dec    %rdx
			dest[n] = src[n];
  10a07c:	8a 0c 16             	mov    (%rsi,%rdx,1),%cl
  10a07f:	88 0c 10             	mov    %cl,(%rax,%rdx,1)
  10a082:	eb f0                	jmp    10a074 <memmove+0x12>
  10a084:	c3                   	retq   
		}
	} else {
		/* It is safe to perform a forward-copy */
		while (n > 0) {
  10a085:	48 39 ca             	cmp    %rcx,%rdx
  10a088:	74 0d                	je     10a097 <memmove+0x35>
			*dest = *src;
  10a08a:	40 8a 3c 0e          	mov    (%rsi,%rcx,1),%dil
  10a08e:	40 88 3c 08          	mov    %dil,(%rax,%rcx,1)
			dest++;
			src++;
			n--;
  10a092:	48 ff c1             	inc    %rcx
  10a095:	eb ee                	jmp    10a085 <memmove+0x23>
		}
	}

	return d;
}
  10a097:	c3                   	retq   

000000000010a098 <memcpy>:
 *
 * @return pointer to start of destination buffer
 */

void *memcpy(void *_MLIBC_RESTRICT d, const void *_MLIBC_RESTRICT s, size_t n)
{
  10a098:	49 89 f8             	mov    %rdi,%r8
	}
#endif

	/* do byte-sized copying until finished */

	while (n > 0) {
  10a09b:	31 c0                	xor    %eax,%eax
  10a09d:	48 39 c2             	cmp    %rax,%rdx
  10a0a0:	74 0c                	je     10a0ae <memcpy+0x16>
		*(d_byte++) = *(s_byte++);
  10a0a2:	8a 0c 06             	mov    (%rsi,%rax,1),%cl
  10a0a5:	41 88 0c 00          	mov    %cl,(%r8,%rax,1)
		n--;
  10a0a9:	48 ff c0             	inc    %rax
  10a0ac:	eb ef                	jmp    10a09d <memcpy+0x5>
	}

	return d;
}
  10a0ae:	4c 89 c0             	mov    %r8,%rax
  10a0b1:	c3                   	retq   

000000000010a0b2 <memset>:
 *
 * @return pointer to start of buffer
 */

void *memset(void *buf, int c, size_t n)
{
  10a0b2:	48 89 d1             	mov    %rdx,%rcx
  10a0b5:	48 89 f8             	mov    %rdi,%rax
	/* do byte-sized initialization until finished */

	d_byte = (unsigned char *)d_word;
#endif

	while (n > 0) {
  10a0b8:	31 d2                	xor    %edx,%edx
  10a0ba:	48 39 d1             	cmp    %rdx,%rcx
  10a0bd:	74 09                	je     10a0c8 <memset+0x16>
		*(d_byte++) = c_byte;
  10a0bf:	40 88 34 10          	mov    %sil,(%rax,%rdx,1)
		n--;
  10a0c3:	48 ff c2             	inc    %rdx
  10a0c6:	eb f2                	jmp    10a0ba <memset+0x8>
	}

	return buf;
}
  10a0c8:	c3                   	retq   

000000000010a0c9 <_stdout_hook_default>:
static int _stdout_hook_default(int c)
{
	(void)(c);  /* Prevent warning about unused argument */

	return EOF;
}
  10a0c9:	83 c8 ff             	or     $0xffffffff,%eax
  10a0cc:	c3                   	retq   

000000000010a0cd <__stdout_hook_install>:

static int (*_stdout_hook)(int) = _stdout_hook_default;

void __stdout_hook_install(int (*hook)(int))
{
	_stdout_hook = hook;
  10a0cd:	48 89 3d 74 73 4d 00 	mov    %rdi,0x4d7374(%rip)        # 5e1448 <_stdout_hook>
}
  10a0d4:	c3                   	retq   

000000000010a0d5 <z_impl_zephyr_fputc>:

int z_impl_zephyr_fputc(int c, FILE *stream)
{
	return (stream == stdout || stream == stderr) ? _stdout_hook(c) : EOF;
  10a0d5:	48 83 ee 02          	sub    $0x2,%rsi
  10a0d9:	48 83 fe 01          	cmp    $0x1,%rsi
  10a0dd:	77 06                	ja     10a0e5 <z_impl_zephyr_fputc+0x10>
  10a0df:	ff 25 63 73 4d 00    	jmpq   *0x4d7363(%rip)        # 5e1448 <_stdout_hook>
}
  10a0e5:	83 c8 ff             	or     $0xffffffff,%eax
  10a0e8:	c3                   	retq   

000000000010a0e9 <z_mrsh_zephyr_fputc>:
#include <syscalls/libc-hooks.h>

extern int z_vrfy_zephyr_fputc(int c, FILE * stream);
uintptr_t z_mrsh_zephyr_fputc(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
  10a0e9:	55                   	push   %rbp
	_current->syscall_frame = ssf;
  10a0ea:	48 8b 05 5f e6 01 00 	mov    0x1e65f(%rip),%rax        # 128750 <_kernel+0x10>
{
  10a0f1:	48 89 e5             	mov    %rsp,%rbp
	_current->syscall_frame = ssf;
  10a0f4:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  10a0f8:	48 89 90 40 01 00 00 	mov    %rdx,0x140(%rax)

#ifdef CONFIG_USERSPACE
static inline int z_vrfy_zephyr_fputc(int c, FILE *stream)
{
	return z_impl_zephyr_fputc(c, stream);
  10a0ff:	e8 d1 ff ff ff       	callq  10a0d5 <z_impl_zephyr_fputc>
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	int ret = z_vrfy_zephyr_fputc(*(int*)&arg0, *(FILE **)&arg1)
;
	_current->syscall_frame = NULL;
  10a104:	48 8b 15 45 e6 01 00 	mov    0x1e645(%rip),%rdx        # 128750 <_kernel+0x10>
	return (uintptr_t) ret;
  10a10b:	48 98                	cltq   
	_current->syscall_frame = NULL;
  10a10d:	48 c7 82 40 01 00 00 	movq   $0x0,0x140(%rdx)
  10a114:	00 00 00 00 
}
  10a118:	5d                   	pop    %rbp
  10a119:	c3                   	retq   

000000000010a11a <z_impl_zephyr_fwrite>:
{
	size_t i;
	size_t j;
	const unsigned char *p;

	if ((stream != stdout && stream != stderr) ||
  10a11a:	48 83 e9 02          	sub    $0x2,%rcx
	    (nitems == 0) || (size == 0)) {
		return 0;
  10a11e:	31 c0                	xor    %eax,%eax
	if ((stream != stdout && stream != stderr) ||
  10a120:	48 83 f9 01          	cmp    $0x1,%rcx
  10a124:	77 58                	ja     10a17e <z_impl_zephyr_fwrite+0x64>
{
  10a126:	55                   	push   %rbp
  10a127:	48 89 e5             	mov    %rsp,%rbp
  10a12a:	41 57                	push   %r15
  10a12c:	41 56                	push   %r14
  10a12e:	41 55                	push   %r13
  10a130:	41 54                	push   %r12
  10a132:	49 89 d4             	mov    %rdx,%r12
  10a135:	53                   	push   %rbx
  10a136:	51                   	push   %rcx
	    (nitems == 0) || (size == 0)) {
  10a137:	48 85 d2             	test   %rdx,%rdx
  10a13a:	74 34                	je     10a170 <z_impl_zephyr_fwrite+0x56>
  10a13c:	49 89 f6             	mov    %rsi,%r14
  10a13f:	48 85 f6             	test   %rsi,%rsi
  10a142:	74 2c                	je     10a170 <z_impl_zephyr_fwrite+0x56>
  10a144:	48 89 fb             	mov    %rdi,%rbx
  10a147:	49 89 d5             	mov    %rdx,%r13
	}

	p = ptr;
	i = nitems;
	do {
		j = size;
  10a14a:	4e 8d 3c 33          	lea    (%rbx,%r14,1),%r15
		do {
			if (_stdout_hook((int) *p++) == EOF) {
  10a14e:	0f b6 3b             	movzbl (%rbx),%edi
  10a151:	48 ff c3             	inc    %rbx
  10a154:	ff 15 ee 72 4d 00    	callq  *0x4d72ee(%rip)        # 5e1448 <_stdout_hook>
  10a15a:	ff c0                	inc    %eax
  10a15c:	74 0a                	je     10a168 <z_impl_zephyr_fwrite+0x4e>
				goto done;
			}
			j--;
		} while (j > 0);
  10a15e:	49 39 df             	cmp    %rbx,%r15
  10a161:	75 eb                	jne    10a14e <z_impl_zephyr_fwrite+0x34>

		i--;
	} while (i > 0);
  10a163:	49 ff cd             	dec    %r13
  10a166:	75 e2                	jne    10a14a <z_impl_zephyr_fwrite+0x30>

done:
	return (nitems - i);
  10a168:	4c 89 e0             	mov    %r12,%rax
  10a16b:	4c 29 e8             	sub    %r13,%rax
  10a16e:	eb 02                	jmp    10a172 <z_impl_zephyr_fwrite+0x58>
		return 0;
  10a170:	31 c0                	xor    %eax,%eax
}
  10a172:	5a                   	pop    %rdx
  10a173:	5b                   	pop    %rbx
  10a174:	41 5c                	pop    %r12
  10a176:	41 5d                	pop    %r13
  10a178:	41 5e                	pop    %r14
  10a17a:	41 5f                	pop    %r15
  10a17c:	5d                   	pop    %rbp
  10a17d:	c3                   	retq   
  10a17e:	c3                   	retq   

000000000010a17f <z_mrsh_zephyr_fwrite>:
#include <syscalls/libc-hooks.h>

extern size_t z_vrfy_zephyr_fwrite(const void *_MLIBC_RESTRICT ptr, size_t size, size_t nitems, FILE *_MLIBC_RESTRICT stream);
uintptr_t z_mrsh_zephyr_fwrite(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
  10a17f:	55                   	push   %rbp
  10a180:	48 89 e5             	mov    %rsp,%rbp
  10a183:	41 56                	push   %r14
  10a185:	41 55                	push   %r13
  10a187:	49 89 d5             	mov    %rdx,%r13
  10a18a:	41 54                	push   %r12
  10a18c:	49 89 f4             	mov    %rsi,%r12
  10a18f:	48 83 ec 18          	sub    $0x18,%rsp
	_current->syscall_frame = ssf;
  10a193:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  10a197:	48 8b 05 b2 e5 01 00 	mov    0x1e5b2(%rip),%rax        # 128750 <_kernel+0x10>
{
  10a19e:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
	_current->syscall_frame = ssf;
  10a1a2:	48 89 90 40 01 00 00 	mov    %rdx,0x140(%rax)
	return __builtin_mul_overflow(a, b, result);
}

static inline bool size_mul_overflow(size_t a, size_t b, size_t *result)
{
	return __builtin_mul_overflow(a, b, result);
  10a1a9:	4c 89 e8             	mov    %r13,%rax
  10a1ac:	48 f7 e6             	mul    %rsi
  10a1af:	70 3e                	jo     10a1ef <z_mrsh_zephyr_fwrite+0x70>
static inline size_t z_vrfy_zephyr_fwrite(const void *_MLIBC_RESTRICT ptr,
					  size_t size, size_t nitems,
					  FILE *_MLIBC_RESTRICT stream)
{

	Z_OOPS(Z_SYSCALL_MEMORY_ARRAY_READ(ptr, nitems, size));
  10a1b1:	31 d2                	xor    %edx,%edx
  10a1b3:	48 89 c6             	mov    %rax,%rsi
  10a1b6:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  10a1ba:	49 89 fe             	mov    %rdi,%r14
  10a1bd:	e8 fa f1 ff ff       	callq  1093bc <arch_buffer_validate>
  10a1c2:	4c 8b 45 d8          	mov    -0x28(%rbp),%r8
  10a1c6:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
  10a1ca:	85 c0                	test   %eax,%eax
  10a1cc:	74 50                	je     10a21e <z_mrsh_zephyr_fwrite+0x9f>
  10a1ce:	41 b9 de 0d 12 00    	mov    $0x120dde,%r9d
  10a1d4:	4c 89 f1             	mov    %r14,%rcx
  10a1d7:	ba 30 bf 11 00       	mov    $0x11bf30,%edx
  10a1dc:	31 c0                	xor    %eax,%eax
  10a1de:	be 45 00 00 00       	mov    $0x45,%esi
  10a1e3:	bf 1e cf 11 00       	mov    $0x11cf1e,%edi
  10a1e8:	e8 d9 8e ff ff       	callq  1030c6 <z_log_minimal_printk>
  10a1ed:	eb 1c                	jmp    10a20b <z_mrsh_zephyr_fwrite+0x8c>
  10a1ef:	49 89 f0             	mov    %rsi,%r8
  10a1f2:	4c 89 e9             	mov    %r13,%rcx
  10a1f5:	ba 30 bf 11 00       	mov    $0x11bf30,%edx
  10a1fa:	be 45 00 00 00       	mov    $0x45,%esi
  10a1ff:	bf 5c ec 11 00       	mov    $0x11ec5c,%edi
  10a204:	31 c0                	xor    %eax,%eax
  10a206:	e8 bb 8e ff ff       	callq  1030c6 <z_log_minimal_printk>
  10a20b:	48 8b 05 3e e5 01 00 	mov    0x1e53e(%rip),%rax        # 128750 <_kernel+0x10>
  10a212:	48 8b b8 40 01 00 00 	mov    0x140(%rax),%rdi
  10a219:	e8 ef f9 ff ff       	callq  109c0d <arch_syscall_oops>
	return z_impl_zephyr_fwrite((const void *_MLIBC_RESTRICT)ptr, size,
  10a21e:	4c 89 ea             	mov    %r13,%rdx
  10a221:	4c 89 e6             	mov    %r12,%rsi
  10a224:	4c 89 f7             	mov    %r14,%rdi
  10a227:	e8 ee fe ff ff       	callq  10a11a <z_impl_zephyr_fwrite>
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	size_t ret = z_vrfy_zephyr_fwrite(*(const void *_MLIBC_RESTRICT*)&arg0, *(size_t*)&arg1, *(size_t*)&arg2, *(FILE *_MLIBC_RESTRICT*)&arg3)
;
	_current->syscall_frame = NULL;
  10a22c:	48 8b 15 1d e5 01 00 	mov    0x1e51d(%rip),%rdx        # 128750 <_kernel+0x10>
  10a233:	48 c7 82 40 01 00 00 	movq   $0x0,0x140(%rdx)
  10a23a:	00 00 00 00 
	return (uintptr_t) ret;
}
  10a23e:	48 83 c4 18          	add    $0x18,%rsp
  10a242:	41 5c                	pop    %r12
  10a244:	41 5d                	pop    %r13
  10a246:	41 5e                	pop    %r14
  10a248:	5d                   	pop    %rbp
  10a249:	c3                   	retq   

000000000010a24a <sprintf_out>:
	int len;
};

static int sprintf_out(int c, struct emitter *p)
{
	if (p->len > 1) { /* need to reserve a byte for EOS */
  10a24a:	83 7e 08 01          	cmpl   $0x1,0x8(%rsi)
  10a24e:	7e 0c                	jle    10a25c <sprintf_out+0x12>
		*(p->ptr) = c;
  10a250:	48 8b 06             	mov    (%rsi),%rax
  10a253:	40 88 38             	mov    %dil,(%rax)
		p->ptr += 1;
  10a256:	48 ff 06             	incq   (%rsi)
		p->len -= 1;
  10a259:	ff 4e 08             	decl   0x8(%rsi)
	}
	return 0; /* indicate keep going so we get the total count */
}
  10a25c:	31 c0                	xor    %eax,%eax
  10a25e:	c3                   	retq   

000000000010a25f <snprintf>:

int snprintf(char *_MLIBC_RESTRICT str, size_t len,
	     const char *_MLIBC_RESTRICT format, ...)
{
  10a25f:	55                   	push   %rbp
  10a260:	48 89 e5             	mov    %rsp,%rbp
  10a263:	48 81 ec e0 00 00 00 	sub    $0xe0,%rsp
  10a26a:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  10a271:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  10a278:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  10a27f:	84 c0                	test   %al,%al
  10a281:	74 20                	je     10a2a3 <snprintf+0x44>
  10a283:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  10a287:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  10a28b:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  10a28f:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  10a293:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  10a297:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  10a29b:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  10a29f:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)

	struct emitter p;
	int     r;
	char    dummy;

	if (len == 0) {
  10a2a3:	48 85 f6             	test   %rsi,%rsi
  10a2a6:	75 07                	jne    10a2af <snprintf+0x50>
		str = &dummy; /* write final NUL to dummy, can't change *s */
  10a2a8:	48 8d bd 27 ff ff ff 	lea    -0xd9(%rbp),%rdi
	}

	p.ptr = str;
	p.len = (int) len;

	va_start(vargs, format);
  10a2af:	48 8d 45 10          	lea    0x10(%rbp),%rax
	p.ptr = str;
  10a2b3:	48 89 bd 28 ff ff ff 	mov    %rdi,-0xd8(%rbp)
	r = cbvprintf(sprintf_out, (void *) (&p), format, vargs);
  10a2ba:	48 8d 8d 38 ff ff ff 	lea    -0xc8(%rbp),%rcx
  10a2c1:	bf 4a a2 10 00       	mov    $0x10a24a,%edi
	p.len = (int) len;
  10a2c6:	89 b5 30 ff ff ff    	mov    %esi,-0xd0(%rbp)
	r = cbvprintf(sprintf_out, (void *) (&p), format, vargs);
  10a2cc:	48 8d b5 28 ff ff ff 	lea    -0xd8(%rbp),%rsi
	va_start(vargs, format);
  10a2d3:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  10a2da:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  10a2e1:	c7 85 38 ff ff ff 18 	movl   $0x18,-0xc8(%rbp)
  10a2e8:	00 00 00 
  10a2eb:	c7 85 3c ff ff ff 30 	movl   $0x30,-0xc4(%rbp)
  10a2f2:	00 00 00 
  10a2f5:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
	r = cbvprintf(sprintf_out, (void *) (&p), format, vargs);
  10a2fc:	e8 0a 7c ff ff       	callq  101f0b <cbvprintf>
	va_end(vargs);

	*(p.ptr) = 0;
  10a301:	48 8b 95 28 ff ff ff 	mov    -0xd8(%rbp),%rdx
  10a308:	c6 02 00             	movb   $0x0,(%rdx)
	return r;
}
  10a30b:	c9                   	leaveq 
  10a30c:	c3                   	retq   

000000000010a30d <gmtime_r>:
 * due to time zone, leap seconds, or a different epoch must be
 * applied to @p time before invoking this function.
 */
struct tm *gmtime_r(const time_t *_MLIBC_RESTRICT timep,
		    struct tm *_MLIBC_RESTRICT result)
{
  10a30d:	55                   	push   %rbp
  10a30e:	49 89 f0             	mov    %rsi,%r8
  10a311:	48 89 e5             	mov    %rsp,%rbp
  10a314:	41 56                	push   %r14
  10a316:	41 55                	push   %r13
  10a318:	41 54                	push   %r12
  10a31a:	53                   	push   %rbx
	time_t z = *timep;
  10a31b:	48 8b 0f             	mov    (%rdi),%rcx
	bigint_type days = (z >= 0 ? z : z - 86399) / 86400;
  10a31e:	48 85 c9             	test   %rcx,%rcx
  10a321:	79 13                	jns    10a336 <gmtime_r+0x29>
  10a323:	48 8d 81 81 ae fe ff 	lea    -0x1517f(%rcx),%rax
  10a32a:	bf 80 51 01 00       	mov    $0x15180,%edi
  10a32f:	48 99                	cqto   
  10a331:	48 f7 ff             	idiv   %rdi
  10a334:	eb 0d                	jmp    10a343 <gmtime_r+0x36>
  10a336:	48 89 c8             	mov    %rcx,%rax
  10a339:	be 80 51 01 00       	mov    $0x15180,%esi
  10a33e:	48 99                	cqto   
  10a340:	48 f7 fe             	idiv   %rsi
	unsigned int rem = z - days * 86400;
  10a343:	44 69 c8 80 ae fe ff 	imul   $0xfffeae80,%eax,%r9d
	bigint_type days = (z >= 0 ? z : z - 86399) / 86400;
  10a34a:	48 89 c6             	mov    %rax,%rsi

	*result = (struct tm){ 0 };
  10a34d:	4c 89 c7             	mov    %r8,%rdi
  10a350:	31 c0                	xor    %eax,%eax
	unsigned int rem = z - days * 86400;
  10a352:	41 01 c9             	add    %ecx,%r9d
	*result = (struct tm){ 0 };
  10a355:	b9 09 00 00 00       	mov    $0x9,%ecx
  10a35a:	f3 ab                	rep stos %eax,%es:(%rdi)
	tp->tm_wday = (z >= -4) ? ((z + 4) % 7) : ((z + 5) % 7 + 6);
  10a35c:	48 83 fe fc          	cmp    $0xfffffffffffffffc,%rsi
  10a360:	7c 10                	jl     10a372 <gmtime_r+0x65>
  10a362:	48 8d 46 04          	lea    0x4(%rsi),%rax
  10a366:	b9 07 00 00 00       	mov    $0x7,%ecx
  10a36b:	48 99                	cqto   
  10a36d:	48 f7 f9             	idiv   %rcx
  10a370:	eb 11                	jmp    10a383 <gmtime_r+0x76>
  10a372:	48 8d 46 05          	lea    0x5(%rsi),%rax
  10a376:	b9 07 00 00 00       	mov    $0x7,%ecx
  10a37b:	48 99                	cqto   
  10a37d:	48 f7 f9             	idiv   %rcx
  10a380:	83 c2 06             	add    $0x6,%edx
	bigint_type era = ((z >= 0) ? z : (z - 146096)) / 146097;
  10a383:	48 89 f1             	mov    %rsi,%rcx
	tp->tm_wday = (z >= -4) ? ((z + 4) % 7) : ((z + 5) % 7 + 6);
  10a386:	41 89 50 18          	mov    %edx,0x18(%r8)
	bigint_type era = ((z >= 0) ? z : (z - 146096)) / 146097;
  10a38a:	48 81 c1 6c fa 0a 00 	add    $0xafa6c,%rcx
  10a391:	79 16                	jns    10a3a9 <gmtime_r+0x9c>
  10a393:	48 81 c6 bc bf 08 00 	add    $0x8bfbc,%rsi
  10a39a:	bf b1 3a 02 00       	mov    $0x23ab1,%edi
  10a39f:	48 89 f0             	mov    %rsi,%rax
  10a3a2:	48 99                	cqto   
  10a3a4:	48 f7 ff             	idiv   %rdi
  10a3a7:	eb 0d                	jmp    10a3b6 <gmtime_r+0xa9>
  10a3a9:	48 89 c8             	mov    %rcx,%rax
  10a3ac:	be b1 3a 02 00       	mov    $0x23ab1,%esi
  10a3b1:	48 99                	cqto   
  10a3b3:	48 f7 fe             	idiv   %rsi
  10a3b6:	48 89 c6             	mov    %rax,%rsi
	unsigned int yoe = (doe - doe / 1460U + doe / 36524U - doe / 146096U)
  10a3b9:	31 d2                	xor    %edx,%edx
  10a3bb:	bb b4 05 00 00       	mov    $0x5b4,%ebx
	unsigned int d = doy - (153U * mp + 2U) / 5U + 1U;
  10a3c0:	41 be 05 00 00 00    	mov    $0x5,%r14d
	unsigned int doe = (z - era * (bigint_type)146097);
  10a3c6:	44 69 d0 4f c5 fd ff 	imul   $0xfffdc54f,%eax,%r10d
	bigint_type y = (time_t)yoe + era * 400;
  10a3cd:	48 69 f6 90 01 00 00 	imul   $0x190,%rsi,%rsi
	unsigned int doe = (z - era * (bigint_type)146097);
  10a3d4:	41 01 ca             	add    %ecx,%r10d
	unsigned int yoe = (doe - doe / 1460U + doe / 36524U - doe / 146096U)
  10a3d7:	b9 ac 8e 00 00       	mov    $0x8eac,%ecx
  10a3dc:	44 89 d0             	mov    %r10d,%eax
  10a3df:	f7 f1                	div    %ecx
  10a3e1:	31 d2                	xor    %edx,%edx
  10a3e3:	b9 b0 3a 02 00       	mov    $0x23ab0,%ecx
  10a3e8:	42 8d 3c 10          	lea    (%rax,%r10,1),%edi
  10a3ec:	44 89 d0             	mov    %r10d,%eax
  10a3ef:	f7 f3                	div    %ebx
  10a3f1:	31 d2                	xor    %edx,%edx
  10a3f3:	29 c7                	sub    %eax,%edi
  10a3f5:	44 89 d0             	mov    %r10d,%eax
  10a3f8:	f7 f1                	div    %ecx
  10a3fa:	b9 6d 01 00 00       	mov    $0x16d,%ecx
  10a3ff:	31 d2                	xor    %edx,%edx
  10a401:	29 c7                	sub    %eax,%edi
  10a403:	89 f8                	mov    %edi,%eax
  10a405:	f7 f1                	div    %ecx
	unsigned int doy = doe - (365U * yoe + yoe / 4U - yoe / 100U);
  10a407:	b9 64 00 00 00       	mov    $0x64,%ecx
  10a40c:	31 d2                	xor    %edx,%edx
	unsigned int yoe = (doe - doe / 1460U + doe / 36524U - doe / 146096U)
  10a40e:	41 89 c3             	mov    %eax,%r11d
	unsigned int doy = doe - (365U * yoe + yoe / 4U - yoe / 100U);
  10a411:	f7 f1                	div    %ecx
	tp->tm_year = y + (m <= 2) - 1900;
  10a413:	41 8d b4 33 94 f8 ff 	lea    -0x76c(%r11,%rsi,1),%esi
  10a41a:	ff 
	unsigned int doy = doe - (365U * yoe + yoe / 4U - yoe / 100U);
  10a41b:	89 c1                	mov    %eax,%ecx
  10a41d:	41 89 d4             	mov    %edx,%r12d
  10a420:	89 f8                	mov    %edi,%eax
  10a422:	31 d2                	xor    %edx,%edx
  10a424:	f7 f3                	div    %ebx
	unsigned int mp = (5U * doy + 2U) / 153U;
  10a426:	bb 99 00 00 00       	mov    $0x99,%ebx
  10a42b:	31 d2                	xor    %edx,%edx
	unsigned int doy = doe - (365U * yoe + yoe / 4U - yoe / 100U);
  10a42d:	29 c1                	sub    %eax,%ecx
  10a42f:	41 69 c3 6d 01 00 00 	imul   $0x16d,%r11d,%eax
  10a436:	44 01 d1             	add    %r10d,%ecx
  10a439:	29 c1                	sub    %eax,%ecx
	unsigned int mp = (5U * doy + 2U) / 153U;
  10a43b:	44 8d 14 89          	lea    (%rcx,%rcx,4),%r10d
  10a43f:	41 83 c2 02          	add    $0x2,%r10d
  10a443:	44 89 d0             	mov    %r10d,%eax
  10a446:	f7 f3                	div    %ebx
	unsigned int d = doy - (153U * mp + 2U) / 5U + 1U;
  10a448:	31 d2                	xor    %edx,%edx
  10a44a:	8d 59 01             	lea    0x1(%rcx),%ebx
	unsigned int mp = (5U * doy + 2U) / 153U;
  10a44d:	41 89 c5             	mov    %eax,%r13d
	unsigned int d = doy - (153U * mp + 2U) / 5U + 1U;
  10a450:	69 c0 99 00 00 00    	imul   $0x99,%eax,%eax
  10a456:	83 c0 02             	add    $0x2,%eax
  10a459:	41 f7 f6             	div    %r14d
  10a45c:	29 c3                	sub    %eax,%ebx
	unsigned int m = mp + ((mp < 10) ? 3 : -9);
  10a45e:	41 81 fa fa 05 00 00 	cmp    $0x5fa,%r10d
  10a465:	19 c0                	sbb    %eax,%eax
	tp->tm_year = y + (m <= 2) - 1900;
  10a467:	31 d2                	xor    %edx,%edx
	tp->tm_mday = d;
  10a469:	41 89 58 0c          	mov    %ebx,0xc(%r8)
	unsigned int m = mp + ((mp < 10) ? 3 : -9);
  10a46d:	83 e0 0c             	and    $0xc,%eax
  10a470:	42 8d 44 28 f7       	lea    -0x9(%rax,%r13,1),%eax
	tp->tm_year = y + (m <= 2) - 1900;
  10a475:	83 f8 02             	cmp    $0x2,%eax
  10a478:	0f 96 c2             	setbe  %dl
	tp->tm_mon = m - 1;
  10a47b:	ff c8                	dec    %eax
	tp->tm_year = y + (m <= 2) - 1900;
  10a47d:	01 f2                	add    %esi,%edx
	tp->tm_mon = m - 1;
  10a47f:	41 89 40 10          	mov    %eax,0x10(%r8)
	tp->tm_year = y + (m <= 2) - 1900;
  10a483:	41 89 50 14          	mov    %edx,0x14(%r8)
	if (doy >= 306U) {
  10a487:	81 f9 31 01 00 00    	cmp    $0x131,%ecx
  10a48d:	76 0c                	jbe    10a49b <gmtime_r+0x18e>
		tp->tm_yday = doy - 306U;
  10a48f:	81 e9 32 01 00 00    	sub    $0x132,%ecx
  10a495:	41 89 48 1c          	mov    %ecx,0x1c(%r8)
  10a499:	eb 23                	jmp    10a4be <gmtime_r+0x1b1>
		tp->tm_yday = doy + 59U + (((yoe % 4U == 0U) && (yoe % 100U != 0U)) || (yoe == 0U));
  10a49b:	41 80 e3 03          	and    $0x3,%r11b
  10a49f:	75 0a                	jne    10a4ab <gmtime_r+0x19e>
  10a4a1:	b8 01 00 00 00       	mov    $0x1,%eax
  10a4a6:	45 85 e4             	test   %r12d,%r12d
  10a4a9:	75 0b                	jne    10a4b6 <gmtime_r+0x1a9>
  10a4ab:	31 c0                	xor    %eax,%eax
  10a4ad:	81 ff 6c 01 00 00    	cmp    $0x16c,%edi
  10a4b3:	0f 96 c0             	setbe  %al
  10a4b6:	8d 44 01 3b          	lea    0x3b(%rcx,%rax,1),%eax
  10a4ba:	41 89 40 1c          	mov    %eax,0x1c(%r8)

	time_civil_from_days(days, result);

	result->tm_hour = rem / 60U / 60U;
  10a4be:	b9 10 0e 00 00       	mov    $0xe10,%ecx
  10a4c3:	44 89 c8             	mov    %r9d,%eax
  10a4c6:	31 d2                	xor    %edx,%edx
	rem -= result->tm_hour * 60 * 60;
	result->tm_min = rem / 60;
	result->tm_sec = rem - result->tm_min * 60;

	return result;
}
  10a4c8:	5b                   	pop    %rbx
	result->tm_hour = rem / 60U / 60U;
  10a4c9:	f7 f1                	div    %ecx
	result->tm_min = rem / 60;
  10a4cb:	b9 3c 00 00 00       	mov    $0x3c,%ecx
  10a4d0:	31 d2                	xor    %edx,%edx
}
  10a4d2:	41 5c                	pop    %r12
  10a4d4:	41 5d                	pop    %r13
  10a4d6:	41 5e                	pop    %r14
  10a4d8:	5d                   	pop    %rbp
	result->tm_hour = rem / 60U / 60U;
  10a4d9:	41 89 40 08          	mov    %eax,0x8(%r8)
	rem -= result->tm_hour * 60 * 60;
  10a4dd:	69 c0 10 0e 00 00    	imul   $0xe10,%eax,%eax
  10a4e3:	41 29 c1             	sub    %eax,%r9d
	result->tm_min = rem / 60;
  10a4e6:	44 89 c8             	mov    %r9d,%eax
  10a4e9:	f7 f1                	div    %ecx
  10a4eb:	41 89 40 04          	mov    %eax,0x4(%r8)
	result->tm_sec = rem - result->tm_min * 60;
  10a4ef:	6b c0 3c             	imul   $0x3c,%eax,%eax
  10a4f2:	41 29 c1             	sub    %eax,%r9d
}
  10a4f5:	4c 89 c0             	mov    %r8,%rax
	result->tm_sec = rem - result->tm_min * 60;
  10a4f8:	45 89 08             	mov    %r9d,(%r8)
}
  10a4fb:	c3                   	retq   

000000000010a4fc <z_errno>:
	__asm__ volatile ("mov %%cs, %[cs_val]" : [cs_val] "=r" (cs));
  10a4fc:	8c c8                	mov    %cs,%eax
	if (z_syscall_trap()) {
  10a4fe:	a8 03                	test   $0x3,%al
  10a500:	75 05                	jne    10a507 <z_errno+0xb>
	return z_impl_z_errno();
  10a502:	e9 7b 2b 00 00       	jmpq   10d082 <z_impl_z_errno>
	register uintptr_t rax __asm__("%rax") = call_id;
  10a507:	b8 49 01 00 00       	mov    $0x149,%eax
	__asm__ volatile("syscall\n\t"
  10a50c:	0f 05                	syscall 
}
  10a50e:	c3                   	retq   

000000000010a50f <k_uptime_ticks>:
	__asm__ volatile ("mov %%cs, %[cs_val]" : [cs_val] "=r" (cs));
  10a50f:	8c c8                	mov    %cs,%eax
	if (z_syscall_trap()) {
  10a511:	a8 03                	test   $0x3,%al
  10a513:	75 05                	jne    10a51a <k_uptime_ticks+0xb>
	return z_impl_k_uptime_ticks();
  10a515:	e9 bd 90 00 00       	jmpq   1135d7 <z_impl_k_uptime_ticks>
	register uintptr_t rax __asm__("%rax") = call_id;
  10a51a:	b8 ce 00 00 00       	mov    $0xce,%eax
	__asm__ volatile("syscall\n\t"
  10a51f:	0f 05                	syscall 
}
  10a521:	c3                   	retq   

000000000010a522 <z_impl_clock_gettime>:
 * @brief Get clock time specified by clock_id.
 *
 * See IEEE 1003.1
 */
int z_impl_clock_gettime(clockid_t clock_id, struct timespec *ts)
{
  10a522:	55                   	push   %rbp
  10a523:	48 89 e5             	mov    %rsp,%rbp
  10a526:	41 56                	push   %r14
  10a528:	41 55                	push   %r13
  10a52a:	41 54                	push   %r12
  10a52c:	53                   	push   %rbx
  10a52d:	48 89 f3             	mov    %rsi,%rbx
	uint64_t elapsed_nsecs;
	struct timespec base;
	k_spinlock_key_t key;

	switch (clock_id) {
  10a530:	83 ff 01             	cmp    $0x1,%edi
  10a533:	74 1d                	je     10a552 <z_impl_clock_gettime+0x30>
  10a535:	83 ff 04             	cmp    $0x4,%edi
  10a538:	0f 84 c8 00 00 00    	je     10a606 <z_impl_clock_gettime+0xe4>
		base = rt_clock_base;
		k_spin_unlock(&rt_clock_base_lock, key);
		break;

	default:
		errno = EINVAL;
  10a53e:	e8 b9 ff ff ff       	callq  10a4fc <z_errno>
		return -1;
  10a543:	41 83 c8 ff          	or     $0xffffffff,%r8d
		errno = EINVAL;
  10a547:	c7 00 16 00 00 00    	movl   $0x16,(%rax)
		return -1;
  10a54d:	e9 fc 00 00 00       	jmpq   10a64e <z_impl_clock_gettime+0x12c>
  10a552:	9c                   	pushfq 
  10a553:	fa                   	cli    
  10a554:	41 5e                	pop    %r14
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  10a556:	bf 70 cd 1b 00       	mov    $0x1bcd70,%edi
  10a55b:	e8 19 33 00 00       	callq  10d879 <z_spin_lock_valid>
  10a560:	84 c0                	test   %al,%al
  10a562:	75 39                	jne    10a59d <z_impl_clock_gettime+0x7b>
  10a564:	b9 8e 00 00 00       	mov    $0x8e,%ecx
  10a569:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  10a56e:	be fd d1 11 00       	mov    $0x11d1fd,%esi
  10a573:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  10a578:	e8 7b 60 ff ff       	callq  1005f8 <printk>
  10a57d:	be 70 cd 1b 00       	mov    $0x1bcd70,%esi
  10a582:	bf 12 d2 11 00       	mov    $0x11d212,%edi
  10a587:	31 c0                	xor    %eax,%eax
  10a589:	e8 6a 60 ff ff       	callq  1005f8 <printk>
  10a58e:	be 8e 00 00 00       	mov    $0x8e,%esi
  10a593:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  10a598:	e8 fb 85 ff ff       	callq  102b98 <assert_post_action>
	z_spin_lock_set_owner(l);
  10a59d:	bf 70 cd 1b 00       	mov    $0x1bcd70,%edi
  10a5a2:	e8 16 33 00 00       	callq  10d8bd <z_spin_lock_set_owner>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  10a5a7:	bf 70 cd 1b 00       	mov    $0x1bcd70,%edi
		base = rt_clock_base;
  10a5ac:	4c 8b 2d 5d 27 0b 00 	mov    0xb275d(%rip),%r13        # 1bcd10 <rt_clock_base>
  10a5b3:	4c 8b 25 5e 27 0b 00 	mov    0xb275e(%rip),%r12        # 1bcd18 <rt_clock_base+0x8>
  10a5ba:	e8 da 32 00 00       	callq  10d899 <z_spin_unlock_valid>
  10a5bf:	84 c0                	test   %al,%al
  10a5c1:	75 39                	jne    10a5fc <z_impl_clock_gettime+0xda>
  10a5c3:	b9 b9 00 00 00       	mov    $0xb9,%ecx
  10a5c8:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  10a5cd:	be 41 d2 11 00       	mov    $0x11d241,%esi
  10a5d2:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  10a5d7:	e8 1c 60 ff ff       	callq  1005f8 <printk>
  10a5dc:	be 70 cd 1b 00       	mov    $0x1bcd70,%esi
  10a5e1:	bf 58 d2 11 00       	mov    $0x11d258,%edi
  10a5e6:	31 c0                	xor    %eax,%eax
  10a5e8:	e8 0b 60 ff ff       	callq  1005f8 <printk>
  10a5ed:	be b9 00 00 00       	mov    $0xb9,%esi
  10a5f2:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  10a5f7:	e8 9c 85 ff ff       	callq  102b98 <assert_post_action>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  10a5fc:	41 0f ba e6 09       	bt     $0x9,%r14d
  10a601:	73 09                	jae    10a60c <z_impl_clock_gettime+0xea>
		__asm__ volatile ("sti" ::: "memory");
  10a603:	fb                   	sti    
  10a604:	eb 06                	jmp    10a60c <z_impl_clock_gettime+0xea>
	switch (clock_id) {
  10a606:	45 31 e4             	xor    %r12d,%r12d
  10a609:	45 31 ed             	xor    %r13d,%r13d
	}

	elapsed_nsecs = k_ticks_to_ns_floor64(k_uptime_ticks());
  10a60c:	e8 fe fe ff ff       	callq  10a50f <k_uptime_ticks>
	ts->tv_sec = (int32_t) (elapsed_nsecs / NSEC_PER_SEC);
  10a611:	b9 00 ca 9a 3b       	mov    $0x3b9aca00,%ecx
  10a616:	31 d2                	xor    %edx,%edx
	if (ts->tv_nsec >= NSEC_PER_SEC) {
		ts->tv_sec++;
		ts->tv_nsec -= NSEC_PER_SEC;
	}

	return 0;
  10a618:	45 31 c0             	xor    %r8d,%r8d
		}
	} else if (mul_ratio) {
		if (result32) {
			return ((uint32_t)t) * (to_hz / from_hz);
		} else {
			return t * ((uint64_t)to_hz / from_hz);
  10a61b:	48 69 c0 a0 86 01 00 	imul   $0x186a0,%rax,%rax
	ts->tv_sec = (int32_t) (elapsed_nsecs / NSEC_PER_SEC);
  10a622:	48 f7 f1             	div    %rcx
  10a625:	48 98                	cltq   
	ts->tv_nsec += base.tv_nsec;
  10a627:	49 01 d4             	add    %rdx,%r12
	ts->tv_sec += base.tv_sec;
  10a62a:	4c 01 e8             	add    %r13,%rax
	ts->tv_nsec += base.tv_nsec;
  10a62d:	4c 89 63 08          	mov    %r12,0x8(%rbx)
	ts->tv_sec += base.tv_sec;
  10a631:	48 89 03             	mov    %rax,(%rbx)
	if (ts->tv_nsec >= NSEC_PER_SEC) {
  10a634:	49 81 fc ff c9 9a 3b 	cmp    $0x3b9ac9ff,%r12
  10a63b:	7e 11                	jle    10a64e <z_impl_clock_gettime+0x12c>
		ts->tv_sec++;
  10a63d:	48 ff c0             	inc    %rax
		ts->tv_nsec -= NSEC_PER_SEC;
  10a640:	49 81 ec 00 ca 9a 3b 	sub    $0x3b9aca00,%r12
		ts->tv_sec++;
  10a647:	48 89 03             	mov    %rax,(%rbx)
		ts->tv_nsec -= NSEC_PER_SEC;
  10a64a:	4c 89 63 08          	mov    %r12,0x8(%rbx)
}
  10a64e:	5b                   	pop    %rbx
  10a64f:	44 89 c0             	mov    %r8d,%eax
  10a652:	41 5c                	pop    %r12
  10a654:	41 5d                	pop    %r13
  10a656:	41 5e                	pop    %r14
  10a658:	5d                   	pop    %rbp
  10a659:	c3                   	retq   

000000000010a65a <z_vrfy_clock_gettime>:

#ifdef CONFIG_USERSPACE
int z_vrfy_clock_gettime(clockid_t clock_id, struct timespec *ts)
{
  10a65a:	55                   	push   %rbp
	Z_OOPS(Z_SYSCALL_MEMORY_WRITE(ts, sizeof(*ts)));
  10a65b:	ba 01 00 00 00       	mov    $0x1,%edx
{
  10a660:	48 89 e5             	mov    %rsp,%rbp
  10a663:	41 55                	push   %r13
  10a665:	41 89 fd             	mov    %edi,%r13d
  10a668:	41 54                	push   %r12
  10a66a:	49 89 f4             	mov    %rsi,%r12
	Z_OOPS(Z_SYSCALL_MEMORY_WRITE(ts, sizeof(*ts)));
  10a66d:	be 10 00 00 00       	mov    $0x10,%esi
  10a672:	4c 89 e7             	mov    %r12,%rdi
  10a675:	e8 42 ed ff ff       	callq  1093bc <arch_buffer_validate>
  10a67a:	85 c0                	test   %eax,%eax
  10a67c:	74 38                	je     10a6b6 <z_vrfy_clock_gettime+0x5c>
  10a67e:	bf 1e cf 11 00       	mov    $0x11cf1e,%edi
  10a683:	31 c0                	xor    %eax,%eax
  10a685:	41 b9 a4 d2 11 00    	mov    $0x11d2a4,%r9d
  10a68b:	4c 89 e1             	mov    %r12,%rcx
  10a68e:	41 b8 10 00 00 00    	mov    $0x10,%r8d
  10a694:	ba 50 bf 11 00       	mov    $0x11bf50,%edx
  10a699:	be 45 00 00 00       	mov    $0x45,%esi
  10a69e:	e8 23 8a ff ff       	callq  1030c6 <z_log_minimal_printk>
  10a6a3:	48 8b 05 a6 e0 01 00 	mov    0x1e0a6(%rip),%rax        # 128750 <_kernel+0x10>
  10a6aa:	48 8b b8 40 01 00 00 	mov    0x140(%rax),%rdi
  10a6b1:	e8 57 f5 ff ff       	callq  109c0d <arch_syscall_oops>
	return z_impl_clock_gettime(clock_id, ts);
  10a6b6:	4c 89 e6             	mov    %r12,%rsi
  10a6b9:	44 89 ef             	mov    %r13d,%edi
}
  10a6bc:	41 5c                	pop    %r12
  10a6be:	41 5d                	pop    %r13
  10a6c0:	5d                   	pop    %rbp
	return z_impl_clock_gettime(clock_id, ts);
  10a6c1:	e9 5c fe ff ff       	jmpq   10a522 <z_impl_clock_gettime>

000000000010a6c6 <z_mrsh_clock_gettime>:
#include <syscalls/time.h>

extern int z_vrfy_clock_gettime(clockid_t clock_id, struct timespec * ts);
uintptr_t z_mrsh_clock_gettime(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
  10a6c6:	55                   	push   %rbp
	_current->syscall_frame = ssf;
  10a6c7:	48 8b 05 82 e0 01 00 	mov    0x1e082(%rip),%rax        # 128750 <_kernel+0x10>
{
  10a6ce:	48 89 e5             	mov    %rsp,%rbp
	_current->syscall_frame = ssf;
  10a6d1:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  10a6d5:	48 89 90 40 01 00 00 	mov    %rdx,0x140(%rax)
	(void) arg2;	/* unused */
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	int ret = z_vrfy_clock_gettime(*(clockid_t*)&arg0, *(struct timespec **)&arg1)
  10a6dc:	e8 79 ff ff ff       	callq  10a65a <z_vrfy_clock_gettime>
;
	_current->syscall_frame = NULL;
  10a6e1:	48 8b 15 68 e0 01 00 	mov    0x1e068(%rip),%rdx        # 128750 <_kernel+0x10>
	return (uintptr_t) ret;
  10a6e8:	48 98                	cltq   
	_current->syscall_frame = NULL;
  10a6ea:	48 c7 82 40 01 00 00 	movq   $0x0,0x140(%rdx)
  10a6f1:	00 00 00 00 
}
  10a6f5:	5d                   	pop    %rbp
  10a6f6:	c3                   	retq   

000000000010a6f7 <clock_settime>:
 *
 * Note that only the `CLOCK_REALTIME` clock can be set using this
 * call.
 */
int clock_settime(clockid_t clock_id, const struct timespec *tp)
{
  10a6f7:	55                   	push   %rbp
	struct timespec base;
	k_spinlock_key_t key;

	if (clock_id != CLOCK_REALTIME) {
  10a6f8:	ff cf                	dec    %edi
{
  10a6fa:	48 89 e5             	mov    %rsp,%rbp
  10a6fd:	41 55                	push   %r13
  10a6ff:	41 54                	push   %r12
  10a701:	53                   	push   %rbx
  10a702:	51                   	push   %rcx
	if (clock_id != CLOCK_REALTIME) {
  10a703:	74 13                	je     10a718 <clock_settime+0x21>
		errno = EINVAL;
  10a705:	e8 f2 fd ff ff       	callq  10a4fc <z_errno>
  10a70a:	c7 00 16 00 00 00    	movl   $0x16,(%rax)
		return -1;
  10a710:	83 c8 ff             	or     $0xffffffff,%eax
  10a713:	e9 e4 00 00 00       	jmpq   10a7fc <clock_settime+0x105>
  10a718:	48 89 f3             	mov    %rsi,%rbx
	}

	uint64_t elapsed_nsecs = k_ticks_to_ns_floor64(k_uptime_ticks());
  10a71b:	e8 ef fd ff ff       	callq  10a50f <k_uptime_ticks>
	int64_t delta = (int64_t)NSEC_PER_SEC * tp->tv_sec + tp->tv_nsec
		- elapsed_nsecs;

	base.tv_sec = delta / NSEC_PER_SEC;
  10a720:	b9 00 ca 9a 3b       	mov    $0x3b9aca00,%ecx
	uint64_t elapsed_nsecs = k_ticks_to_ns_floor64(k_uptime_ticks());
  10a725:	49 89 c0             	mov    %rax,%r8
	int64_t delta = (int64_t)NSEC_PER_SEC * tp->tv_sec + tp->tv_nsec
  10a728:	48 69 03 00 ca 9a 3b 	imul   $0x3b9aca00,(%rbx),%rax
  10a72f:	48 03 43 08          	add    0x8(%rbx),%rax
  10a733:	49 69 d0 a0 86 01 00 	imul   $0x186a0,%r8,%rdx
		- elapsed_nsecs;
  10a73a:	48 29 d0             	sub    %rdx,%rax
	base.tv_sec = delta / NSEC_PER_SEC;
  10a73d:	48 99                	cqto   
  10a73f:	48 f7 f9             	idiv   %rcx
  10a742:	49 89 d5             	mov    %rdx,%r13
  10a745:	48 89 c3             	mov    %rax,%rbx
  10a748:	9c                   	pushfq 
  10a749:	fa                   	cli    
  10a74a:	41 5c                	pop    %r12
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  10a74c:	bf 70 cd 1b 00       	mov    $0x1bcd70,%edi
  10a751:	e8 23 31 00 00       	callq  10d879 <z_spin_lock_valid>
  10a756:	84 c0                	test   %al,%al
  10a758:	75 39                	jne    10a793 <clock_settime+0x9c>
  10a75a:	b9 8e 00 00 00       	mov    $0x8e,%ecx
  10a75f:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  10a764:	be fd d1 11 00       	mov    $0x11d1fd,%esi
  10a769:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  10a76e:	e8 85 5e ff ff       	callq  1005f8 <printk>
  10a773:	be 70 cd 1b 00       	mov    $0x1bcd70,%esi
  10a778:	bf 12 d2 11 00       	mov    $0x11d212,%edi
  10a77d:	31 c0                	xor    %eax,%eax
  10a77f:	e8 74 5e ff ff       	callq  1005f8 <printk>
  10a784:	be 8e 00 00 00       	mov    $0x8e,%esi
  10a789:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  10a78e:	e8 05 84 ff ff       	callq  102b98 <assert_post_action>
	z_spin_lock_set_owner(l);
  10a793:	bf 70 cd 1b 00       	mov    $0x1bcd70,%edi
  10a798:	e8 20 31 00 00       	callq  10d8bd <z_spin_lock_set_owner>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  10a79d:	bf 70 cd 1b 00       	mov    $0x1bcd70,%edi
	base.tv_nsec = delta % NSEC_PER_SEC;

	key = k_spin_lock(&rt_clock_base_lock);
	rt_clock_base = base;
  10a7a2:	48 89 1d 67 25 0b 00 	mov    %rbx,0xb2567(%rip)        # 1bcd10 <rt_clock_base>
  10a7a9:	4c 89 2d 68 25 0b 00 	mov    %r13,0xb2568(%rip)        # 1bcd18 <rt_clock_base+0x8>
  10a7b0:	e8 e4 30 00 00       	callq  10d899 <z_spin_unlock_valid>
  10a7b5:	84 c0                	test   %al,%al
  10a7b7:	75 39                	jne    10a7f2 <clock_settime+0xfb>
  10a7b9:	b9 b9 00 00 00       	mov    $0xb9,%ecx
  10a7be:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  10a7c3:	be 41 d2 11 00       	mov    $0x11d241,%esi
  10a7c8:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  10a7cd:	e8 26 5e ff ff       	callq  1005f8 <printk>
  10a7d2:	be 70 cd 1b 00       	mov    $0x1bcd70,%esi
  10a7d7:	bf 58 d2 11 00       	mov    $0x11d258,%edi
  10a7dc:	31 c0                	xor    %eax,%eax
  10a7de:	e8 15 5e ff ff       	callq  1005f8 <printk>
  10a7e3:	be b9 00 00 00       	mov    $0xb9,%esi
  10a7e8:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  10a7ed:	e8 a6 83 ff ff       	callq  102b98 <assert_post_action>
	k_spin_unlock(&rt_clock_base_lock, key);

	return 0;
  10a7f2:	31 c0                	xor    %eax,%eax
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  10a7f4:	41 0f ba e4 09       	bt     $0x9,%r12d
  10a7f9:	73 01                	jae    10a7fc <clock_settime+0x105>
		__asm__ volatile ("sti" ::: "memory");
  10a7fb:	fb                   	sti    
}
  10a7fc:	5a                   	pop    %rdx
  10a7fd:	5b                   	pop    %rbx
  10a7fe:	41 5c                	pop    %r12
  10a800:	41 5d                	pop    %r13
  10a802:	5d                   	pop    %rbp
  10a803:	c3                   	retq   

000000000010a804 <__IoApicGet>:
  10a804:	9c                   	pushfq 
  10a805:	fa                   	cli    
  10a806:	5a                   	pop    %rdx

	/* lock interrupts to ensure indirect addressing works "atomically" */

	key = irq_lock();

	*((volatile uint32_t *) (IOAPIC_REG + IOAPIC_IND)) = (char)offset;
  10a807:	48 8b 05 6a 25 0b 00 	mov    0xb256a(%rip),%rax        # 1bcd78 <z_mmio_ram__ioapic_regs>
  10a80e:	40 0f be ff          	movsbl %dil,%edi
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  10a812:	0f ba e2 09          	bt     $0x9,%edx
  10a816:	89 38                	mov    %edi,(%rax)
	value = *((volatile uint32_t *)(IOAPIC_REG + IOAPIC_DATA));
  10a818:	8b 40 10             	mov    0x10(%rax),%eax
  10a81b:	73 01                	jae    10a81e <__IoApicGet+0x1a>
		__asm__ volatile ("sti" ::: "memory");
  10a81d:	fb                   	sti    

	irq_unlock(key);

	return value;
}
  10a81e:	c3                   	retq   

000000000010a81f <__IoApicSet>:
  10a81f:	9c                   	pushfq 
  10a820:	fa                   	cli    
  10a821:	5a                   	pop    %rdx

	/* lock interrupts to ensure indirect addressing works "atomically" */

	key = irq_lock();

	*(volatile uint32_t *)(IOAPIC_REG + IOAPIC_IND) = (char)offset;
  10a822:	48 8b 05 4f 25 0b 00 	mov    0xb254f(%rip),%rax        # 1bcd78 <z_mmio_ram__ioapic_regs>
  10a829:	40 0f be ff          	movsbl %dil,%edi
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  10a82d:	0f ba e2 09          	bt     $0x9,%edx
  10a831:	89 38                	mov    %edi,(%rax)
	*((volatile uint32_t *)(IOAPIC_REG + IOAPIC_DATA)) = value;
  10a833:	89 70 10             	mov    %esi,0x10(%rax)
  10a836:	73 01                	jae    10a839 <__IoApicSet+0x1a>
		__asm__ volatile ("sti" ::: "memory");
  10a838:	fb                   	sti    

	irq_unlock(key);
}
  10a839:	c3                   	retq   

000000000010a83a <IoApicRedUpdateLo>:
 */
__pinned_func
static void IoApicRedUpdateLo(unsigned int irq,
				uint32_t value,
				uint32_t mask)
{
  10a83a:	55                   	push   %rbp
	int32_t offset = IOAPIC_REDTBL + (irq << 1); /* register offset */
  10a83b:	44 8d 44 3f 10       	lea    0x10(%rdi,%rdi,1),%r8d
{
  10a840:	89 d1                	mov    %edx,%ecx
	return __IoApicGet(offset);
  10a842:	44 89 c7             	mov    %r8d,%edi
{
  10a845:	48 89 e5             	mov    %rsp,%rbp
	return __IoApicGet(offset);
  10a848:	e8 b7 ff ff ff       	callq  10a804 <__IoApicGet>
	__IoApicSet(offset, lower32);
  10a84d:	44 89 c7             	mov    %r8d,%edi
	ioApicRedSetLo(irq, (ioApicRedGetLo(irq) & ~mask) | (value & mask));
}
  10a850:	5d                   	pop    %rbp
	ioApicRedSetLo(irq, (ioApicRedGetLo(irq) & ~mask) | (value & mask));
  10a851:	31 c6                	xor    %eax,%esi
  10a853:	21 ce                	and    %ecx,%esi
  10a855:	31 c6                	xor    %eax,%esi
	__IoApicSet(offset, lower32);
  10a857:	e9 c3 ff ff ff       	jmpq   10a81f <__IoApicSet>

000000000010a85c <ioapic_init>:
{
  10a85c:	55                   	push   %rbp
  10a85d:	ba 00 10 00 00       	mov    $0x1000,%edx
  10a862:	b9 0a 00 00 00       	mov    $0xa,%ecx
  10a867:	bf 78 cd 1b 00       	mov    $0x1bcd78,%edi
  10a86c:	be 00 00 c0 fe       	mov    $0xfec00000,%esi
  10a871:	48 89 e5             	mov    %rsp,%rbp
  10a874:	e8 87 9a 00 00       	callq  114300 <z_phys_map>
	ioapic_rtes = ((__IoApicGet(IOAPIC_VERS) &
  10a879:	bf 01 00 00 00       	mov    $0x1,%edi
  10a87e:	b9 11 00 00 00       	mov    $0x11,%ecx
  10a883:	e8 7c ff ff ff       	callq  10a804 <__IoApicGet>
			IOAPIC_MRE_MASK) >> IOAPIC_MRE_POS) + 1;
  10a888:	c1 e8 10             	shr    $0x10,%eax
  10a88b:	0f b6 c0             	movzbl %al,%eax
  10a88e:	8d 50 01             	lea    0x1(%rax),%edx
  10a891:	44 8d 44 00 13       	lea    0x13(%rax,%rax,1),%r8d
  10a896:	89 15 94 25 0b 00    	mov    %edx,0xb2594(%rip)        # 1bce30 <ioapic_rtes>
	__IoApicSet(offset, upper32);
  10a89c:	89 cf                	mov    %ecx,%edi
  10a89e:	be 00 00 00 ff       	mov    $0xff000000,%esi
  10a8a3:	e8 77 ff ff ff       	callq  10a81f <__IoApicSet>
	__IoApicSet(offset, lower32);
  10a8a8:	8d 79 ff             	lea    -0x1(%rcx),%edi
  10a8ab:	be 00 08 01 00       	mov    $0x10800,%esi
  10a8b0:	83 c1 02             	add    $0x2,%ecx
  10a8b3:	e8 67 ff ff ff       	callq  10a81f <__IoApicSet>
	for (ix = 0; ix < ioapic_rtes; ix++) {
  10a8b8:	41 39 c8             	cmp    %ecx,%r8d
  10a8bb:	75 df                	jne    10a89c <ioapic_init+0x40>
}
  10a8bd:	31 c0                	xor    %eax,%eax
  10a8bf:	5d                   	pop    %rbp
  10a8c0:	c3                   	retq   

000000000010a8c1 <z_ioapic_num_rtes>:
}
  10a8c1:	8b 05 69 25 0b 00    	mov    0xb2569(%rip),%eax        # 1bce30 <ioapic_rtes>
  10a8c7:	c3                   	retq   

000000000010a8c8 <z_ioapic_irq_enable>:
	IoApicRedUpdateLo(irq, 0, IOAPIC_INT_MASK);
  10a8c8:	ba 00 00 01 00       	mov    $0x10000,%edx
  10a8cd:	31 f6                	xor    %esi,%esi
  10a8cf:	e9 66 ff ff ff       	jmpq   10a83a <IoApicRedUpdateLo>

000000000010a8d4 <z_ioapic_irq_set>:
{
  10a8d4:	55                   	push   %rbp
	int32_t offset = IOAPIC_REDTBL + (irq << 1) + 1; /* register offset */
  10a8d5:	44 8d 04 3f          	lea    (%rdi,%rdi,1),%r8d
{
  10a8d9:	89 f1                	mov    %esi,%ecx
	__IoApicSet(offset, upper32);
  10a8db:	be 00 00 00 ff       	mov    $0xff000000,%esi
	int32_t offset = IOAPIC_REDTBL + (irq << 1) + 1; /* register offset */
  10a8e0:	41 8d 78 11          	lea    0x11(%r8),%edi
{
  10a8e4:	41 89 d1             	mov    %edx,%r9d
  10a8e7:	48 89 e5             	mov    %rsp,%rbp
	__IoApicSet(offset, upper32);
  10a8ea:	e8 30 ff ff ff       	callq  10a81f <__IoApicSet>
		   (vector & IOAPIC_VEC_MASK) | flags;
  10a8ef:	0f b6 f1             	movzbl %cl,%esi
	int32_t offset = IOAPIC_REDTBL + (irq << 1); /* register offset */
  10a8f2:	41 8d 78 10          	lea    0x10(%r8),%edi
}
  10a8f6:	5d                   	pop    %rbp
		   (vector & IOAPIC_VEC_MASK) | flags;
  10a8f7:	44 09 ce             	or     %r9d,%esi
	rteValue = IOAPIC_INT_MASK | IOAPIC_LOGICAL |
  10a8fa:	81 ce 00 08 01 00    	or     $0x10800,%esi
	__IoApicSet(offset, lower32);
  10a900:	e9 1a ff ff ff       	jmpq   10a81f <__IoApicSet>

000000000010a905 <loapic_init>:
__boot_func
static int loapic_init(const struct device *unused)
{
	ARG_UNUSED(unused);
	return 0;
}
  10a905:	31 c0                	xor    %eax,%eax
  10a907:	c3                   	retq   

000000000010a908 <z_loapic_enable>:
{
  10a908:	55                   	push   %rbp
  10a909:	b9 0a 00 00 00       	mov    $0xa,%ecx
  10a90e:	ba 00 10 00 00       	mov    $0x1000,%edx
  10a913:	be 00 00 e0 fe       	mov    $0xfee00000,%esi
  10a918:	bf 80 cd 1b 00       	mov    $0x1bcd80,%edi
  10a91d:	48 89 e5             	mov    %rsp,%rbp
  10a920:	e8 db 99 00 00       	callq  114300 <z_phys_map>
#ifdef DEVICE_MMIO_IS_IN_RAM
	base = z_loapic_regs;
#else
	base = CONFIG_LOAPIC_BASE_ADDRESS;
#endif
	return sys_read32(base + reg);
  10a925:	48 8b 05 54 24 0b 00 	mov    0xb2454(%rip),%rax        # 1bcd80 <z_loapic_regs>
	__asm__ volatile("movl %1, %0"
  10a92c:	8b 80 f0 00 00 00    	mov    0xf0(%rax),%eax
#ifdef DEVICE_MMIO_IS_IN_RAM
	base = z_loapic_regs;
#else
	base = CONFIG_LOAPIC_BASE_ADDRESS;
#endif
	sys_write32(val, base + reg);
  10a932:	48 8b 15 47 24 0b 00 	mov    0xb2447(%rip),%rdx        # 1bcd80 <z_loapic_regs>
	x86_write_xapic(LOAPIC_SVR,
  10a939:	80 cc 01             	or     $0x1,%ah
	__asm__ volatile("movl %0, %1"
  10a93c:	89 82 f0 00 00 00    	mov    %eax,0xf0(%rdx)
	__asm__ volatile ("rdmsr" : "=a" (rv.lo), "=d" (rv.hi) : "c" (msr));
  10a942:	b9 1b 00 00 00       	mov    $0x1b,%ecx
  10a947:	0f 32                	rdmsr  
  10a949:	48 89 d6             	mov    %rdx,%rsi
  10a94c:	89 c2                	mov    %eax,%edx
  10a94e:	48 c1 e6 20          	shl    $0x20,%rsi
  10a952:	48 09 f2             	or     %rsi,%rdx
	msr |= X86_APIC_BASE_MSR_X2APIC;
  10a955:	48 89 d0             	mov    %rdx,%rax
	uint32_t high = data >> 32;
  10a958:	48 c1 ea 20          	shr    $0x20,%rdx
  10a95c:	80 cc 04             	or     $0x4,%ah
	__asm__ volatile ("wrmsr" : : "c"(msr), "a"(low), "d"(high));
  10a95f:	0f 30                	wrmsr  
	__asm__ volatile ("rdmsr" : "=a" (rv.lo), "=d" (rv.hi) : "c" (msr));
  10a961:	b9 03 08 00 00       	mov    $0x803,%ecx
  10a966:	0f 32                	rdmsr  
	__asm__ volatile ("wrmsr" : : "c"(msr), "a"(low), "d"(high));
  10a968:	31 f6                	xor    %esi,%esi
	loApicMaxLvt = (x86_read_loapic(LOAPIC_VER) & LOAPIC_MAXLVT_MASK) >> 16;
  10a96a:	c1 e8 10             	shr    $0x10,%eax
  10a96d:	b9 08 08 00 00       	mov    $0x808,%ecx
  10a972:	89 c7                	mov    %eax,%edi
  10a974:	44 0f b6 c0          	movzbl %al,%r8d
  10a978:	89 f2                	mov    %esi,%edx
  10a97a:	89 f0                	mov    %esi,%eax
  10a97c:	0f 30                	wrmsr  
  10a97e:	b9 3e 08 00 00       	mov    $0x83e,%ecx
  10a983:	0f 30                	wrmsr  
  10a985:	b9 38 08 00 00       	mov    $0x838,%ecx
  10a98a:	0f 30                	wrmsr  
	__asm__ volatile ("rdmsr" : "=a" (rv.lo), "=d" (rv.hi) : "c" (msr));
  10a98c:	b9 35 08 00 00       	mov    $0x835,%ecx
  10a991:	0f 32                	rdmsr  
	x86_write_loapic(LOAPIC_LINT0, (x86_read_loapic(LOAPIC_LINT0) &
  10a993:	25 ff 58 fe ff       	and    $0xfffe58ff,%eax
	__asm__ volatile ("wrmsr" : : "c"(msr), "a"(low), "d"(high));
  10a998:	89 f2                	mov    %esi,%edx
  10a99a:	80 cc 07             	or     $0x7,%ah
  10a99d:	0f 30                	wrmsr  
	__asm__ volatile ("rdmsr" : "=a" (rv.lo), "=d" (rv.hi) : "c" (msr));
  10a99f:	b9 36 08 00 00       	mov    $0x836,%ecx
  10a9a4:	0f 32                	rdmsr  
	x86_write_loapic(LOAPIC_LINT1, (x86_read_loapic(LOAPIC_LINT1) &
  10a9a6:	25 ff 58 fe ff       	and    $0xfffe58ff,%eax
	__asm__ volatile ("wrmsr" : : "c"(msr), "a"(low), "d"(high));
  10a9ab:	89 f2                	mov    %esi,%edx
  10a9ad:	80 cc 04             	or     $0x4,%ah
  10a9b0:	0f 30                	wrmsr  
  10a9b2:	b8 00 00 01 00       	mov    $0x10000,%eax
  10a9b7:	b9 32 08 00 00       	mov    $0x832,%ecx
  10a9bc:	0f 30                	wrmsr  
  10a9be:	b9 37 08 00 00       	mov    $0x837,%ecx
  10a9c3:	0f 30                	wrmsr  
	if (loApicMaxLvt >= LOAPIC_LVT_P6) {
  10a9c5:	40 80 e7 fc          	and    $0xfc,%dil
  10a9c9:	74 07                	je     10a9d2 <z_loapic_enable+0xca>
  10a9cb:	b9 34 08 00 00       	mov    $0x834,%ecx
  10a9d0:	0f 30                	wrmsr  
	if (loApicMaxLvt >= LOAPIC_LVT_PENTIUM4) {
  10a9d2:	41 83 f8 04          	cmp    $0x4,%r8d
  10a9d6:	7e 0e                	jle    10a9e6 <z_loapic_enable+0xde>
  10a9d8:	b9 33 08 00 00       	mov    $0x833,%ecx
  10a9dd:	b8 00 00 01 00       	mov    $0x10000,%eax
  10a9e2:	31 d2                	xor    %edx,%edx
  10a9e4:	0f 30                	wrmsr  
  10a9e6:	31 c0                	xor    %eax,%eax
  10a9e8:	b9 0b 08 00 00       	mov    $0x80b,%ecx
  10a9ed:	89 c2                	mov    %eax,%edx
  10a9ef:	0f 30                	wrmsr  
}
  10a9f1:	5d                   	pop    %rbp
  10a9f2:	c3                   	retq   

000000000010a9f3 <z_loapic_irq_base>:


__pinned_func
uint32_t z_loapic_irq_base(void)
{
	return z_ioapic_num_rtes();
  10a9f3:	e9 c9 fe ff ff       	jmpq   10a8c1 <z_ioapic_num_rtes>

000000000010a9f8 <z_loapic_int_vec_set>:
  10a9f8:	9c                   	pushfq 
  10a9f9:	fa                   	cli    
  10a9fa:	41 58                	pop    %r8

	/* update the 'vector' bits in the LVT */

	oldLevel = irq_lock();
	x86_write_loapic(LOAPIC_TIMER + (irq * 0x10),
		     (x86_read_loapic(LOAPIC_TIMER + (irq * 0x10)) &
  10a9fc:	8d 4f 32             	lea    0x32(%rdi),%ecx
	reg >>= 4;
  10a9ff:	81 e1 ff ff ff 0f    	and    $0xfffffff,%ecx
	return z_x86_msr_read(X86_X2APIC_BASE_MSR + reg);
  10aa05:	8d 89 00 08 00 00    	lea    0x800(%rcx),%ecx
	__asm__ volatile ("rdmsr" : "=a" (rv.lo), "=d" (rv.hi) : "c" (msr));
  10aa0b:	0f 32                	rdmsr  
  10aa0d:	30 c0                	xor    %al,%al
	__asm__ volatile ("wrmsr" : : "c"(msr), "a"(low), "d"(high));
  10aa0f:	31 d2                	xor    %edx,%edx
	x86_write_loapic(LOAPIC_TIMER + (irq * 0x10),
  10aa11:	09 f0                	or     %esi,%eax
  10aa13:	0f 30                	wrmsr  
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  10aa15:	41 0f ba e0 09       	bt     $0x9,%r8d
  10aa1a:	73 01                	jae    10aa1d <z_loapic_int_vec_set+0x25>
		__asm__ volatile ("sti" ::: "memory");
  10aa1c:	fb                   	sti    
		      ~LOAPIC_VECTOR) | vector);
	irq_unlock(oldLevel);
}
  10aa1d:	c3                   	retq   

000000000010aa1e <z_loapic_irq_enable>:
 *
 * @return N/A
 */
__pinned_func
void z_loapic_irq_enable(unsigned int irq)
{
  10aa1e:	89 f9                	mov    %edi,%ecx
  10aa20:	9c                   	pushfq 
  10aa21:	fa                   	cli    
  10aa22:	5e                   	pop    %rsi

	/* clear the mask bit in the LVT */

	oldLevel = irq_lock();
	x86_write_loapic(LOAPIC_TIMER + (irq * 0x10),
		     x86_read_loapic(LOAPIC_TIMER + (irq * 0x10)) &
  10aa23:	83 c1 32             	add    $0x32,%ecx
	reg >>= 4;
  10aa26:	81 e1 ff ff ff 0f    	and    $0xfffffff,%ecx
	return z_x86_msr_read(X86_X2APIC_BASE_MSR + reg);
  10aa2c:	81 c1 00 08 00 00    	add    $0x800,%ecx
	__asm__ volatile ("rdmsr" : "=a" (rv.lo), "=d" (rv.hi) : "c" (msr));
  10aa32:	0f 32                	rdmsr  
	__asm__ volatile ("wrmsr" : : "c"(msr), "a"(low), "d"(high));
  10aa34:	31 d2                	xor    %edx,%edx
	x86_write_loapic(LOAPIC_TIMER + (irq * 0x10),
  10aa36:	25 ff ff fe ff       	and    $0xfffeffff,%eax
  10aa3b:	0f 30                	wrmsr  
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  10aa3d:	0f ba e6 09          	bt     $0x9,%esi
  10aa41:	73 01                	jae    10aa44 <z_loapic_irq_enable+0x26>
		__asm__ volatile ("sti" ::: "memory");
  10aa43:	fb                   	sti    
		     ~LOAPIC_LVT_MASKED);
	irq_unlock(oldLevel);
}
  10aa44:	c3                   	retq   

000000000010aa45 <z_irq_controller_irq_config>:
 *
 */
__boot_func
void z_irq_controller_irq_config(unsigned int vector, unsigned int irq,
				 uint32_t flags)
{
  10aa45:	55                   	push   %rbp
  10aa46:	48 89 e5             	mov    %rsp,%rbp
  10aa49:	41 56                	push   %r14
  10aa4b:	41 89 d6             	mov    %edx,%r14d
  10aa4e:	41 55                	push   %r13
  10aa50:	41 89 fd             	mov    %edi,%r13d
  10aa53:	41 54                	push   %r12
  10aa55:	41 89 f4             	mov    %esi,%r12d
  10aa58:	41 50                	push   %r8
	__ASSERT(irq <= HARDWARE_IRQ_LIMIT, "invalid irq line");
  10aa5a:	e8 94 ff ff ff       	callq  10a9f3 <z_loapic_irq_base>
  10aa5f:	83 c0 05             	add    $0x5,%eax
  10aa62:	44 39 e0             	cmp    %r12d,%eax
  10aa65:	73 36                	jae    10aa9d <z_irq_controller_irq_config+0x58>
  10aa67:	be d8 ec 11 00       	mov    $0x11ecd8,%esi
  10aa6c:	b9 33 00 00 00       	mov    $0x33,%ecx
  10aa71:	ba 95 ec 11 00       	mov    $0x11ec95,%edx
  10aa76:	31 c0                	xor    %eax,%eax
  10aa78:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  10aa7d:	e8 76 5b ff ff       	callq  1005f8 <printk>
  10aa82:	bf ff ec 11 00       	mov    $0x11ecff,%edi
  10aa87:	31 c0                	xor    %eax,%eax
  10aa89:	e8 6a 5b ff ff       	callq  1005f8 <printk>
  10aa8e:	be 33 00 00 00       	mov    $0x33,%esi
  10aa93:	bf 95 ec 11 00       	mov    $0x11ec95,%edi
  10aa98:	e8 fb 80 ff ff       	callq  102b98 <assert_post_action>

	if (IS_IOAPIC_IRQ(irq)) {
  10aa9d:	e8 51 ff ff ff       	callq  10a9f3 <z_loapic_irq_base>
  10aaa2:	44 39 e0             	cmp    %r12d,%eax
  10aaa5:	76 16                	jbe    10aabd <z_irq_controller_irq_config+0x78>
		z_ioapic_irq_set(irq, vector, flags);
	} else {
		z_loapic_int_vec_set(irq - z_loapic_irq_base(), vector);
	}
}
  10aaa7:	59                   	pop    %rcx
		z_ioapic_irq_set(irq, vector, flags);
  10aaa8:	44 89 f2             	mov    %r14d,%edx
  10aaab:	44 89 ee             	mov    %r13d,%esi
  10aaae:	44 89 e7             	mov    %r12d,%edi
}
  10aab1:	41 5c                	pop    %r12
  10aab3:	41 5d                	pop    %r13
  10aab5:	41 5e                	pop    %r14
  10aab7:	5d                   	pop    %rbp
		z_ioapic_irq_set(irq, vector, flags);
  10aab8:	e9 17 fe ff ff       	jmpq   10a8d4 <z_ioapic_irq_set>
		z_loapic_int_vec_set(irq - z_loapic_irq_base(), vector);
  10aabd:	e8 31 ff ff ff       	callq  10a9f3 <z_loapic_irq_base>
  10aac2:	44 89 e7             	mov    %r12d,%edi
  10aac5:	44 89 ee             	mov    %r13d,%esi
  10aac8:	29 c7                	sub    %eax,%edi
}
  10aaca:	58                   	pop    %rax
  10aacb:	41 5c                	pop    %r12
  10aacd:	41 5d                	pop    %r13
  10aacf:	41 5e                	pop    %r14
  10aad1:	5d                   	pop    %rbp
		z_loapic_int_vec_set(irq - z_loapic_irq_base(), vector);
  10aad2:	e9 21 ff ff ff       	jmpq   10a9f8 <z_loapic_int_vec_set>

000000000010aad7 <arch_irq_enable>:
 *
 * @return N/A
 */
__pinned_func
void arch_irq_enable(unsigned int irq)
{
  10aad7:	55                   	push   %rbp
  10aad8:	48 89 e5             	mov    %rsp,%rbp
  10aadb:	41 54                	push   %r12
  10aadd:	41 89 fc             	mov    %edi,%r12d
  10aae0:	51                   	push   %rcx
	if (IS_IOAPIC_IRQ(irq)) {
  10aae1:	e8 0d ff ff ff       	callq  10a9f3 <z_loapic_irq_base>
  10aae6:	44 39 e0             	cmp    %r12d,%eax
  10aae9:	76 0c                	jbe    10aaf7 <arch_irq_enable+0x20>
		z_ioapic_irq_enable(irq);
	} else {
		z_loapic_irq_enable(irq - z_loapic_irq_base());
	}
}
  10aaeb:	5a                   	pop    %rdx
		z_ioapic_irq_enable(irq);
  10aaec:	44 89 e7             	mov    %r12d,%edi
}
  10aaef:	41 5c                	pop    %r12
  10aaf1:	5d                   	pop    %rbp
		z_ioapic_irq_enable(irq);
  10aaf2:	e9 d1 fd ff ff       	jmpq   10a8c8 <z_ioapic_irq_enable>
		z_loapic_irq_enable(irq - z_loapic_irq_base());
  10aaf7:	e8 f7 fe ff ff       	callq  10a9f3 <z_loapic_irq_base>
  10aafc:	44 89 e7             	mov    %r12d,%edi
  10aaff:	29 c7                	sub    %eax,%edi
}
  10ab01:	58                   	pop    %rax
  10ab02:	41 5c                	pop    %r12
  10ab04:	5d                   	pop    %rbp
		z_loapic_irq_enable(irq - z_loapic_irq_base());
  10ab05:	e9 14 ff ff ff       	jmpq   10aa1e <z_loapic_irq_enable>

000000000010ab0a <atomic_set_bit.constprop.0>:
 * @param target Address of atomic variable or array.
 * @param bit Bit number (starting from 0).
 *
 * @return N/A
 */
static inline void atomic_set_bit(atomic_t *target, int bit)
  10ab0a:	48 63 c7             	movslq %edi,%rax
{
	atomic_val_t mask = ATOMIC_MASK(bit);
  10ab0d:	ba 01 00 00 00       	mov    $0x1,%edx
static inline void atomic_set_bit(atomic_t *target, int bit)
  10ab12:	48 89 c1             	mov    %rax,%rcx

	(void)atomic_or(ATOMIC_ELEM(target, bit), mask);
  10ab15:	48 c1 e8 05          	shr    $0x5,%rax
	atomic_val_t mask = ATOMIC_MASK(bit);
  10ab19:	d3 e2                	shl    %cl,%edx
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
  10ab1b:	f0 09 14 85 20 cd 1b 	lock or %edx,0x1bcd20(,%rax,4)
  10ab22:	00 
}
  10ab23:	c3                   	retq   

000000000010ab24 <pcie_set_cmd>:

	return (id == data);
}

void pcie_set_cmd(pcie_bdf_t bdf, uint32_t bits, bool on)
{
  10ab24:	55                   	push   %rbp
  10ab25:	48 89 e5             	mov    %rsp,%rbp
  10ab28:	41 55                	push   %r13
  10ab2a:	41 89 d5             	mov    %edx,%r13d
  10ab2d:	53                   	push   %rbx
  10ab2e:	89 f3                	mov    %esi,%ebx
	uint32_t cmdstat;

	cmdstat = pcie_conf_read(bdf, PCIE_CONF_CMDSTAT);
  10ab30:	be 01 00 00 00       	mov    $0x1,%esi
{
  10ab35:	48 83 ec 10          	sub    $0x10,%rsp
	cmdstat = pcie_conf_read(bdf, PCIE_CONF_CMDSTAT);
  10ab39:	89 7d ec             	mov    %edi,-0x14(%rbp)
  10ab3c:	e8 2a dc ff ff       	callq  10876b <pcie_conf_read>

	if (on) {
  10ab41:	45 84 ed             	test   %r13b,%r13b
  10ab44:	8b 7d ec             	mov    -0x14(%rbp),%edi
	cmdstat = pcie_conf_read(bdf, PCIE_CONF_CMDSTAT);
  10ab47:	89 c2                	mov    %eax,%edx
	if (on) {
  10ab49:	74 04                	je     10ab4f <pcie_set_cmd+0x2b>
		cmdstat |= bits;
  10ab4b:	09 da                	or     %ebx,%edx
  10ab4d:	eb 04                	jmp    10ab53 <pcie_set_cmd+0x2f>
	} else {
		cmdstat &= ~bits;
  10ab4f:	f7 d3                	not    %ebx
  10ab51:	21 da                	and    %ebx,%edx
	}

	pcie_conf_write(bdf, PCIE_CONF_CMDSTAT, cmdstat);
}
  10ab53:	58                   	pop    %rax
	pcie_conf_write(bdf, PCIE_CONF_CMDSTAT, cmdstat);
  10ab54:	be 01 00 00 00       	mov    $0x1,%esi
}
  10ab59:	59                   	pop    %rcx
  10ab5a:	5b                   	pop    %rbx
  10ab5b:	41 5d                	pop    %r13
  10ab5d:	5d                   	pop    %rbp
	pcie_conf_write(bdf, PCIE_CONF_CMDSTAT, cmdstat);
  10ab5e:	e9 27 dc ff ff       	jmpq   10878a <pcie_conf_write>

000000000010ab63 <pcie_get_cap>:

uint32_t pcie_get_cap(pcie_bdf_t bdf, uint32_t cap_id)
{
  10ab63:	55                   	push   %rbp
  10ab64:	48 89 e5             	mov    %rsp,%rbp
  10ab67:	41 55                	push   %r13
  10ab69:	41 89 f5             	mov    %esi,%r13d
	uint32_t reg = 0U;
	uint32_t data;

	data = pcie_conf_read(bdf, PCIE_CONF_CMDSTAT);
  10ab6c:	be 01 00 00 00       	mov    $0x1,%esi
{
  10ab71:	41 54                	push   %r12
  10ab73:	53                   	push   %rbx
  10ab74:	89 fb                	mov    %edi,%ebx
  10ab76:	51                   	push   %rcx
	data = pcie_conf_read(bdf, PCIE_CONF_CMDSTAT);
  10ab77:	e8 ef db ff ff       	callq  10876b <pcie_conf_read>
	if (data & PCIE_CONF_CMDSTAT_CAPS) {
  10ab7c:	0f ba e0 14          	bt     $0x14,%eax
  10ab80:	72 05                	jb     10ab87 <pcie_get_cap+0x24>
{
  10ab82:	45 31 e4             	xor    %r12d,%r12d
  10ab85:	eb 38                	jmp    10abbf <pcie_get_cap+0x5c>
		data = pcie_conf_read(bdf, PCIE_CONF_CAPPTR);
  10ab87:	be 0d 00 00 00       	mov    $0xd,%esi
  10ab8c:	89 df                	mov    %ebx,%edi
  10ab8e:	e8 d8 db ff ff       	callq  10876b <pcie_conf_read>
		reg = PCIE_CONF_CAPPTR_FIRST(data);
  10ab93:	c1 e8 02             	shr    $0x2,%eax
  10ab96:	41 89 c4             	mov    %eax,%r12d
  10ab99:	41 83 e4 3f          	and    $0x3f,%r12d
	}

	while (reg) {
  10ab9d:	45 85 e4             	test   %r12d,%r12d
  10aba0:	74 e0                	je     10ab82 <pcie_get_cap+0x1f>
		data = pcie_conf_read(bdf, reg);
  10aba2:	44 89 e6             	mov    %r12d,%esi
  10aba5:	89 df                	mov    %ebx,%edi
  10aba7:	e8 bf db ff ff       	callq  10876b <pcie_conf_read>

		if (PCIE_CONF_CAP_ID(data) == cap_id) {
  10abac:	0f b6 d0             	movzbl %al,%edx
  10abaf:	44 39 ea             	cmp    %r13d,%edx
  10abb2:	74 0b                	je     10abbf <pcie_get_cap+0x5c>
			break;
		}

		reg = PCIE_CONF_CAP_NEXT(data);
  10abb4:	c1 e8 0a             	shr    $0xa,%eax
  10abb7:	83 e0 3f             	and    $0x3f,%eax
  10abba:	41 89 c4             	mov    %eax,%r12d
  10abbd:	eb de                	jmp    10ab9d <pcie_get_cap+0x3a>
	}

	return reg;
}
  10abbf:	5a                   	pop    %rdx
  10abc0:	44 89 e0             	mov    %r12d,%eax
  10abc3:	5b                   	pop    %rbx
  10abc4:	41 5c                	pop    %r12
  10abc6:	41 5d                	pop    %r13
  10abc8:	5d                   	pop    %rbp
  10abc9:	c3                   	retq   

000000000010abca <pcie_get_mbar>:
}

bool pcie_get_mbar(pcie_bdf_t bdf,
		   unsigned int bar_index,
		   struct pcie_mbar *mbar)
{
  10abca:	55                   	push   %rbp
  10abcb:	48 89 e5             	mov    %rsp,%rbp
  10abce:	41 57                	push   %r15
	uint32_t reg = bar_index + PCIE_CONF_BAR0;
  10abd0:	44 8d 7e 04          	lea    0x4(%rsi),%r15d
{
  10abd4:	41 56                	push   %r14
  10abd6:	41 55                	push   %r13
  10abd8:	41 54                	push   %r12
  10abda:	53                   	push   %rbx
  10abdb:	48 83 ec 18          	sub    $0x18,%rsp
  10abdf:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
	uintptr_t phys_addr;
	size_t size;

	if (reg > PCIE_CONF_BAR5) {
  10abe3:	41 83 ff 09          	cmp    $0x9,%r15d
  10abe7:	76 07                	jbe    10abf0 <pcie_get_mbar+0x26>
		return false;
  10abe9:	31 c0                	xor    %eax,%eax
  10abeb:	e9 f1 00 00 00       	jmpq   10ace1 <pcie_get_mbar+0x117>
  10abf0:	89 f3                	mov    %esi,%ebx
	}

	phys_addr = pcie_conf_read(bdf, reg);
  10abf2:	44 89 fe             	mov    %r15d,%esi
  10abf5:	41 89 fc             	mov    %edi,%r12d
  10abf8:	e8 6e db ff ff       	callq  10876b <pcie_conf_read>
  10abfd:	41 89 c6             	mov    %eax,%r14d
	if (PCIE_CONF_BAR_IO(phys_addr)) {
		/* Discard I/O bars */
		return false;
	}

	if (PCIE_CONF_BAR_INVAL_FLAGS(phys_addr)) {
  10ac00:	a8 03                	test   $0x3,%al
  10ac02:	75 e5                	jne    10abe9 <pcie_get_mbar+0x1f>
		/* Discard on invalid flags */
		return false;
	}

	pcie_conf_write(bdf, reg, 0xFFFFFFFF);
  10ac04:	83 ca ff             	or     $0xffffffff,%edx
  10ac07:	44 89 fe             	mov    %r15d,%esi
  10ac0a:	44 89 e7             	mov    %r12d,%edi
	phys_addr = pcie_conf_read(bdf, reg);
  10ac0d:	41 89 c5             	mov    %eax,%r13d
	pcie_conf_write(bdf, reg, 0xFFFFFFFF);
  10ac10:	e8 75 db ff ff       	callq  10878a <pcie_conf_write>
	size = pcie_conf_read(bdf, reg);
  10ac15:	44 89 fe             	mov    %r15d,%esi
  10ac18:	44 89 e7             	mov    %r12d,%edi
  10ac1b:	e8 4b db ff ff       	callq  10876b <pcie_conf_read>
	pcie_conf_write(bdf, reg, (uint32_t)phys_addr);
  10ac20:	44 89 f2             	mov    %r14d,%edx
  10ac23:	44 89 fe             	mov    %r15d,%esi
  10ac26:	44 89 e7             	mov    %r12d,%edi
	size = pcie_conf_read(bdf, reg);
  10ac29:	89 c0                	mov    %eax,%eax

	if (IS_ENABLED(CONFIG_64BIT) && PCIE_CONF_BAR_64(phys_addr)) {
  10ac2b:	41 83 e6 06          	and    $0x6,%r14d
	size = pcie_conf_read(bdf, reg);
  10ac2f:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	pcie_conf_write(bdf, reg, (uint32_t)phys_addr);
  10ac33:	e8 52 db ff ff       	callq  10878a <pcie_conf_write>
	if (IS_ENABLED(CONFIG_64BIT) && PCIE_CONF_BAR_64(phys_addr)) {
  10ac38:	41 83 fe 04          	cmp    $0x4,%r14d
  10ac3c:	75 5d                	jne    10ac9b <pcie_get_mbar+0xd1>
		reg++;
  10ac3e:	44 8d 73 05          	lea    0x5(%rbx),%r14d
		phys_addr |= ((uint64_t)pcie_conf_read(bdf, reg)) << 32;
  10ac42:	44 89 e7             	mov    %r12d,%edi
  10ac45:	44 89 f6             	mov    %r14d,%esi
  10ac48:	e8 1e db ff ff       	callq  10876b <pcie_conf_read>
  10ac4d:	48 c1 e0 20          	shl    $0x20,%rax
  10ac51:	49 09 c5             	or     %rax,%r13

		if (PCIE_CONF_BAR_ADDR(phys_addr) == PCIE_CONF_BAR_INVAL64 ||
  10ac54:	4c 89 e8             	mov    %r13,%rax
  10ac57:	48 83 e0 f0          	and    $0xfffffffffffffff0,%rax
  10ac5b:	48 83 f8 f0          	cmp    $0xfffffffffffffff0,%rax
  10ac5f:	74 88                	je     10abe9 <pcie_get_mbar+0x1f>
  10ac61:	48 85 c0             	test   %rax,%rax
  10ac64:	74 83                	je     10abe9 <pcie_get_mbar+0x1f>
		    PCIE_CONF_BAR_ADDR(phys_addr) == PCIE_CONF_BAR_NONE) {
			/* Discard on invalid address */
			return false;
		}

		pcie_conf_write(bdf, reg, 0xFFFFFFFF);
  10ac66:	83 ca ff             	or     $0xffffffff,%edx
  10ac69:	44 89 f6             	mov    %r14d,%esi
  10ac6c:	44 89 e7             	mov    %r12d,%edi
  10ac6f:	e8 16 db ff ff       	callq  10878a <pcie_conf_write>
		size |= ((uint64_t)pcie_conf_read(bdf, reg)) << 32;
  10ac74:	44 89 f6             	mov    %r14d,%esi
  10ac77:	44 89 e7             	mov    %r12d,%edi
  10ac7a:	e8 ec da ff ff       	callq  10876b <pcie_conf_read>
		pcie_conf_write(bdf, reg, (uint32_t)((uint64_t)phys_addr >> 32));
  10ac7f:	4c 89 ea             	mov    %r13,%rdx
  10ac82:	44 89 f6             	mov    %r14d,%esi
  10ac85:	44 89 e7             	mov    %r12d,%edi
  10ac88:	48 c1 ea 20          	shr    $0x20,%rdx
		size |= ((uint64_t)pcie_conf_read(bdf, reg)) << 32;
  10ac8c:	48 c1 e0 20          	shl    $0x20,%rax
  10ac90:	48 09 45 c8          	or     %rax,-0x38(%rbp)
		pcie_conf_write(bdf, reg, (uint32_t)((uint64_t)phys_addr >> 32));
  10ac94:	e8 f1 da ff ff       	callq  10878a <pcie_conf_write>
  10ac99:	eb 1e                	jmp    10acb9 <pcie_get_mbar+0xef>
	} else if (PCIE_CONF_BAR_ADDR(phys_addr) == PCIE_CONF_BAR_INVAL ||
  10ac9b:	4c 89 e8             	mov    %r13,%rax
  10ac9e:	ba f0 ff ff ff       	mov    $0xfffffff0,%edx
  10aca3:	48 83 e0 f0          	and    $0xfffffffffffffff0,%rax
  10aca7:	48 39 d0             	cmp    %rdx,%rax
  10acaa:	0f 84 39 ff ff ff    	je     10abe9 <pcie_get_mbar+0x1f>
  10acb0:	48 85 c0             	test   %rax,%rax
  10acb3:	0f 84 30 ff ff ff    	je     10abe9 <pcie_get_mbar+0x1f>
		/* Discard on invalid address */
		return false;
	}

	size = PCIE_CONF_BAR_ADDR(size);
	if (size == 0) {
  10acb9:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  10acbd:	48 83 e0 f0          	and    $0xfffffffffffffff0,%rax
  10acc1:	0f 84 22 ff ff ff    	je     10abe9 <pcie_get_mbar+0x1f>
		/* Discard on invalid size */
		return false;
	}

	mbar->phys_addr = PCIE_CONF_BAR_ADDR(phys_addr);
  10acc7:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
	mbar->size = size & ~(size-1);
  10accb:	48 89 c2             	mov    %rax,%rdx
	mbar->phys_addr = PCIE_CONF_BAR_ADDR(phys_addr);
  10acce:	49 83 e5 f0          	and    $0xfffffffffffffff0,%r13
	mbar->size = size & ~(size-1);
  10acd2:	48 f7 da             	neg    %rdx
	mbar->phys_addr = PCIE_CONF_BAR_ADDR(phys_addr);
  10acd5:	4c 89 29             	mov    %r13,(%rcx)
	mbar->size = size & ~(size-1);
  10acd8:	48 21 d0             	and    %rdx,%rax
  10acdb:	48 89 41 08          	mov    %rax,0x8(%rcx)

	return true;
  10acdf:	b0 01                	mov    $0x1,%al
}
  10ace1:	48 83 c4 18          	add    $0x18,%rsp
  10ace5:	5b                   	pop    %rbx
  10ace6:	41 5c                	pop    %r12
  10ace8:	41 5d                	pop    %r13
  10acea:	41 5e                	pop    %r14
  10acec:	41 5f                	pop    %r15
  10acee:	5d                   	pop    %rbp
  10acef:	c3                   	retq   

000000000010acf0 <pcie_alloc_irq>:
		atomic_set_bit(irq_reserved, *irq);
	}
}

unsigned int pcie_alloc_irq(pcie_bdf_t bdf)
{
  10acf0:	55                   	push   %rbp
  10acf1:	48 89 e5             	mov    %rsp,%rbp
  10acf4:	41 55                	push   %r13
  10acf6:	41 89 fd             	mov    %edi,%r13d
  10acf9:	41 54                	push   %r12
  10acfb:	53                   	push   %rbx
  10acfc:	51                   	push   %rcx
  10acfd:	8b 05 1d 20 0b 00    	mov    0xb201d(%rip),%eax        # 1bcd20 <irq_reserved>
  10ad03:	89 c1                	mov    %eax,%ecx
  10ad05:	89 c2                	mov    %eax,%edx
  10ad07:	83 c9 01             	or     $0x1,%ecx
  10ad0a:	f0 0f b1 0d 0e 20 0b 	lock cmpxchg %ecx,0xb200e(%rip)        # 1bcd20 <irq_reserved>
  10ad11:	00 
  10ad12:	75 ef                	jne    10ad03 <pcie_alloc_irq+0x13>
	unsigned int irq;
	uint32_t data;

	if (!atomic_test_and_set_bit(irq_reserved, IRQ_LIST_INITIALIZED)) {
  10ad14:	80 e2 01             	and    $0x1,%dl
  10ad17:	74 15                	je     10ad2e <pcie_alloc_irq+0x3e>
		irq_init();
	}

	data = pcie_conf_read(bdf, PCIE_CONF_INTR);
  10ad19:	be 0f 00 00 00       	mov    $0xf,%esi
  10ad1e:	44 89 ef             	mov    %r13d,%edi
  10ad21:	e8 45 da ff ff       	callq  10876b <pcie_conf_read>
  10ad26:	89 c2                	mov    %eax,%edx
	irq = PCIE_CONF_INTR_IRQ(data);

	if (irq == PCIE_CONF_INTR_IRQ_NONE || irq >= CONFIG_MAX_IRQ_LINES ||
  10ad28:	a8 80                	test   $0x80,%al
  10ad2a:	75 67                	jne    10ad93 <pcie_alloc_irq+0xa3>
  10ad2c:	eb 4f                	jmp    10ad7d <pcie_alloc_irq+0x8d>
	for (irq = __irq_alloc_start; irq < __irq_alloc_end; irq++) {
  10ad2e:	41 bc a0 a2 11 00    	mov    $0x11a2a0,%r12d
  10ad34:	49 81 fc a0 a2 11 00 	cmp    $0x11a2a0,%r12
  10ad3b:	73 dc                	jae    10ad19 <pcie_alloc_irq+0x29>
		__ASSERT_NO_MSG(*irq < CONFIG_MAX_IRQ_LINES);
  10ad3d:	41 80 3c 24 00       	cmpb   $0x0,(%r12)
  10ad42:	79 2a                	jns    10ad6e <pcie_alloc_irq+0x7e>
  10ad44:	be 3e ed 11 00       	mov    $0x11ed3e,%esi
  10ad49:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  10ad4e:	b9 dd 00 00 00       	mov    $0xdd,%ecx
  10ad53:	31 c0                	xor    %eax,%eax
  10ad55:	ba 12 ed 11 00       	mov    $0x11ed12,%edx
  10ad5a:	e8 99 58 ff ff       	callq  1005f8 <printk>
  10ad5f:	be dd 00 00 00       	mov    $0xdd,%esi
  10ad64:	bf 12 ed 11 00       	mov    $0x11ed12,%edi
  10ad69:	e8 2a 7e ff ff       	callq  102b98 <assert_post_action>
		atomic_set_bit(irq_reserved, *irq);
  10ad6e:	41 0f b6 3c 24       	movzbl (%r12),%edi
	for (irq = __irq_alloc_start; irq < __irq_alloc_end; irq++) {
  10ad73:	49 ff c4             	inc    %r12
		atomic_set_bit(irq_reserved, *irq);
  10ad76:	e8 8f fd ff ff       	callq  10ab0a <atomic_set_bit.constprop.0>
	for (irq = __irq_alloc_start; irq < __irq_alloc_end; irq++) {
  10ad7b:	eb b7                	jmp    10ad34 <pcie_alloc_irq+0x44>
	irq = PCIE_CONF_INTR_IRQ(data);
  10ad7d:	0f b6 c0             	movzbl %al,%eax
  10ad80:	49 89 c4             	mov    %rax,%r12
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
  10ad83:	48 c1 e8 05          	shr    $0x5,%rax
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
  10ad87:	8b 04 85 20 cd 1b 00 	mov    0x1bcd20(,%rax,4),%eax
	if (irq == PCIE_CONF_INTR_IRQ_NONE || irq >= CONFIG_MAX_IRQ_LINES ||
  10ad8e:	0f a3 d0             	bt     %edx,%eax
  10ad91:	73 7f                	jae    10ae12 <pcie_alloc_irq+0x122>
  10ad93:	bf 20 cd 1b 00       	mov    $0x1bcd20,%edi
	for (irq = __irq_alloc_start; irq < __irq_alloc_end; irq++) {
  10ad98:	83 ce ff             	or     $0xffffffff,%esi
  10ad9b:	41 83 c9 ff          	or     $0xffffffff,%r9d
	atomic_val_t mask = ATOMIC_MASK(bit);
  10ad9f:	41 b8 01 00 00 00    	mov    $0x1,%r8d
  10ada5:	44 8b 27             	mov    (%rdi),%r12d
		while ((fz = find_lsb_set(~atomic_get(&irq_reserved[i])))) {
  10ada8:	41 f7 d4             	not    %r12d
  10adab:	45 0f bc e4          	bsf    %r12d,%r12d
  10adaf:	45 0f 44 e1          	cmove  %r9d,%r12d
  10adb3:	41 ff c4             	inc    %r12d
  10adb6:	74 46                	je     10adfe <pcie_alloc_irq+0x10e>
			irq = (fz - 1) + (i * sizeof(atomic_val_t) * 8);
  10adb8:	41 01 f4             	add    %esi,%r12d
  10adbb:	45 89 c2             	mov    %r8d,%r10d
  10adbe:	44 89 e1             	mov    %r12d,%ecx
  10adc1:	41 d3 e2             	shl    %cl,%r10d
	old = atomic_or(ATOMIC_ELEM(target, bit), mask);
  10adc4:	44 89 e1             	mov    %r12d,%ecx
  10adc7:	48 c1 e9 05          	shr    $0x5,%rcx
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
  10adcb:	8b 04 8d 20 cd 1b 00 	mov    0x1bcd20(,%rcx,4),%eax
  10add2:	89 c3                	mov    %eax,%ebx
  10add4:	41 89 c3             	mov    %eax,%r11d
  10add7:	44 09 d3             	or     %r10d,%ebx
  10adda:	f0 0f b1 1c 8d 20 cd 	lock cmpxchg %ebx,0x1bcd20(,%rcx,4)
  10ade1:	1b 00 
  10ade3:	75 ed                	jne    10add2 <pcie_alloc_irq+0xe2>
			if (!atomic_test_and_set_bit(irq_reserved, irq)) {
  10ade5:	45 85 da             	test   %r11d,%r10d
  10ade8:	75 bb                	jne    10ada5 <pcie_alloc_irq+0xb5>
		irq = irq_alloc();
		if (irq == PCIE_CONF_INTR_IRQ_NONE) {
			return irq;
		}

		data &= ~0xffU;
  10adea:	30 d2                	xor    %dl,%dl
		data |= irq;
		pcie_conf_write(bdf, PCIE_CONF_INTR, data);
  10adec:	be 0f 00 00 00       	mov    $0xf,%esi
  10adf1:	44 89 ef             	mov    %r13d,%edi
		data |= irq;
  10adf4:	44 09 e2             	or     %r12d,%edx
		pcie_conf_write(bdf, PCIE_CONF_INTR, data);
  10adf7:	e8 8e d9 ff ff       	callq  10878a <pcie_conf_write>
  10adfc:	eb 1c                	jmp    10ae1a <pcie_alloc_irq+0x12a>
	for (i = 0; i < ARRAY_SIZE(irq_reserved); i++) {
  10adfe:	83 c6 20             	add    $0x20,%esi
  10ae01:	48 83 c7 04          	add    $0x4,%rdi
  10ae05:	83 fe 7f             	cmp    $0x7f,%esi
  10ae08:	75 9b                	jne    10ada5 <pcie_alloc_irq+0xb5>
			return irq;
  10ae0a:	41 bc ff 00 00 00    	mov    $0xff,%r12d
  10ae10:	eb 08                	jmp    10ae1a <pcie_alloc_irq+0x12a>
	} else {
		atomic_set_bit(irq_reserved, irq);
  10ae12:	44 89 e7             	mov    %r12d,%edi
  10ae15:	e8 f0 fc ff ff       	callq  10ab0a <atomic_set_bit.constprop.0>
	}

	return irq;
}
  10ae1a:	5a                   	pop    %rdx
  10ae1b:	44 89 e0             	mov    %r12d,%eax
  10ae1e:	5b                   	pop    %rbx
  10ae1f:	41 5c                	pop    %r12
  10ae21:	41 5d                	pop    %r13
  10ae23:	5d                   	pop    %rbp
  10ae24:	c3                   	retq   

000000000010ae25 <pcie_get_irq>:

unsigned int pcie_get_irq(pcie_bdf_t bdf)
{
  10ae25:	55                   	push   %rbp
	uint32_t data = pcie_conf_read(bdf, PCIE_CONF_INTR);
  10ae26:	be 0f 00 00 00       	mov    $0xf,%esi
{
  10ae2b:	48 89 e5             	mov    %rsp,%rbp
	uint32_t data = pcie_conf_read(bdf, PCIE_CONF_INTR);
  10ae2e:	e8 38 d9 ff ff       	callq  10876b <pcie_conf_read>

	return PCIE_CONF_INTR_IRQ(data);
}
  10ae33:	5d                   	pop    %rbp
	return PCIE_CONF_INTR_IRQ(data);
  10ae34:	0f b6 c0             	movzbl %al,%eax
}
  10ae37:	c3                   	retq   

000000000010ae38 <pcie_bdf_lookup>:
#endif
	irq_enable(irq);
}

pcie_bdf_t pcie_bdf_lookup(pcie_id_t id)
{
  10ae38:	55                   	push   %rbp
  10ae39:	48 89 e5             	mov    %rsp,%rbp
  10ae3c:	41 57                	push   %r15
  10ae3e:	41 56                	push   %r14
  10ae40:	41 89 fe             	mov    %edi,%r14d
  10ae43:	41 55                	push   %r13
  10ae45:	41 54                	push   %r12
				}
			}
		}
	}

	return PCIE_BDF_NONE;
  10ae47:	45 31 e4             	xor    %r12d,%r12d
{
  10ae4a:	53                   	push   %rbx
  10ae4b:	48 83 ec 18          	sub    $0x18,%rsp
				pcie_bdf_t bdf = PCIE_BDF(bus, dev, func);
  10ae4f:	31 db                	xor    %ebx,%ebx
  10ae51:	89 d8                	mov    %ebx,%eax
  10ae53:	45 31 ed             	xor    %r13d,%r13d
  10ae56:	44 09 e0             	or     %r12d,%eax
  10ae59:	89 45 cc             	mov    %eax,-0x34(%rbp)
  10ae5c:	44 8b 7d cc          	mov    -0x34(%rbp),%r15d
				data = pcie_conf_read(bdf, PCIE_CONF_ID);
  10ae60:	31 f6                	xor    %esi,%esi
				pcie_bdf_t bdf = PCIE_BDF(bus, dev, func);
  10ae62:	45 09 ef             	or     %r13d,%r15d
				if (data == id) {
  10ae65:	41 81 c5 00 01 00 00 	add    $0x100,%r13d
				data = pcie_conf_read(bdf, PCIE_CONF_ID);
  10ae6c:	44 89 ff             	mov    %r15d,%edi
  10ae6f:	e8 f7 d8 ff ff       	callq  10876b <pcie_conf_read>
				if (data == id) {
  10ae74:	44 39 f0             	cmp    %r14d,%eax
  10ae77:	75 04                	jne    10ae7d <pcie_bdf_lookup+0x45>
  10ae79:	ff c0                	inc    %eax
  10ae7b:	75 2b                	jne    10aea8 <pcie_bdf_lookup+0x70>
			for (func = 0; func <= PCIE_MAX_FUNC; func++) {
  10ae7d:	41 81 fd 00 08 00 00 	cmp    $0x800,%r13d
  10ae84:	75 d6                	jne    10ae5c <pcie_bdf_lookup+0x24>
		for (dev = 0; dev <= PCIE_MAX_DEV; dev++) {
  10ae86:	81 c3 00 08 00 00    	add    $0x800,%ebx
  10ae8c:	81 fb 00 00 01 00    	cmp    $0x10000,%ebx
  10ae92:	75 bd                	jne    10ae51 <pcie_bdf_lookup+0x19>
	for (bus = 0; bus <= PCIE_MAX_BUS; bus++) {
  10ae94:	41 81 c4 00 00 01 00 	add    $0x10000,%r12d
  10ae9b:	41 81 fc 00 00 00 01 	cmp    $0x1000000,%r12d
  10aea2:	75 ab                	jne    10ae4f <pcie_bdf_lookup+0x17>
	return PCIE_BDF_NONE;
  10aea4:	41 83 cf ff          	or     $0xffffffff,%r15d
}
  10aea8:	48 83 c4 18          	add    $0x18,%rsp
  10aeac:	44 89 f8             	mov    %r15d,%eax
  10aeaf:	5b                   	pop    %rbx
  10aeb0:	41 5c                	pop    %r12
  10aeb2:	41 5d                	pop    %r13
  10aeb4:	41 5e                	pop    %r14
  10aeb6:	41 5f                	pop    %r15
  10aeb8:	5d                   	pop    %rbp
  10aeb9:	c3                   	retq   

000000000010aeba <pcie_msi_vectors_allocate>:

uint8_t pcie_msi_vectors_allocate(pcie_bdf_t bdf,
				  unsigned int priority,
				  msi_vector_t *vectors,
				  uint8_t n_vector)
{
  10aeba:	55                   	push   %rbp
  10aebb:	48 89 e5             	mov    %rsp,%rbp
  10aebe:	41 57                	push   %r15
  10aec0:	41 56                	push   %r14
  10aec2:	41 89 fe             	mov    %edi,%r14d
  10aec5:	41 55                	push   %r13
  10aec7:	41 89 cd             	mov    %ecx,%r13d
  10aeca:	41 54                	push   %r12
  10aecc:	49 89 d4             	mov    %rdx,%r12
  10aecf:	53                   	push   %rbx
  10aed0:	89 cb                	mov    %ecx,%ebx
			base = base_msix;
		}
	}

	if (IS_ENABLED(CONFIG_PCIE_MSI_X)) {
		set_msix(vectors, n_vector, !msi);
  10aed2:	0f b6 db             	movzbl %bl,%ebx
{
  10aed5:	48 83 ec 38          	sub    $0x38,%rsp
  10aed9:	89 75 a8             	mov    %esi,-0x58(%rbp)
	base = pcie_get_cap(bdf, PCI_CAP_ID_MSI);
  10aedc:	be 05 00 00 00       	mov    $0x5,%esi
  10aee1:	e8 7d fc ff ff       	callq  10ab63 <pcie_get_cap>
		base_msix = pcie_get_cap(bdf, PCI_CAP_ID_MSIX);
  10aee6:	be 11 00 00 00       	mov    $0x11,%esi
  10aeeb:	44 89 f7             	mov    %r14d,%edi
	base = pcie_get_cap(bdf, PCI_CAP_ID_MSI);
  10aeee:	41 89 c7             	mov    %eax,%r15d
		base_msix = pcie_get_cap(bdf, PCI_CAP_ID_MSIX);
  10aef1:	e8 6d fc ff ff       	callq  10ab63 <pcie_get_cap>
		if (base_msix != 0U) {
  10aef6:	85 c0                	test   %eax,%eax
  10aef8:	44 0f 45 f8          	cmovne %eax,%r15d
  10aefc:	83 f8 01             	cmp    $0x1,%eax
  10aeff:	0f 92 c2             	setb   %dl
		set_msix(vectors, n_vector, !msi);
  10af02:	0f 93 c1             	setae  %cl
	for (i = 0; i < n_vector; i++) {
  10af05:	31 c0                	xor    %eax,%eax
  10af07:	39 c3                	cmp    %eax,%ebx
  10af09:	7e 11                	jle    10af1c <pcie_msi_vectors_allocate+0x62>
		vectors[i].msix = msix;
  10af0b:	48 89 c6             	mov    %rax,%rsi
  10af0e:	48 ff c0             	inc    %rax
  10af11:	48 c1 e6 05          	shl    $0x5,%rsi
  10af15:	41 88 4c 34 18       	mov    %cl,0x18(%r12,%rsi,1)
	for (i = 0; i < n_vector; i++) {
  10af1a:	eb eb                	jmp    10af07 <pcie_msi_vectors_allocate+0x4d>
	mcr = pcie_conf_read(bdf, base + PCIE_MSIX_MCR);
  10af1c:	44 89 fe             	mov    %r15d,%esi
  10af1f:	44 89 f7             	mov    %r14d,%edi

		if (!msi) {
  10af22:	84 d2                	test   %dl,%dl
  10af24:	0f 85 a5 00 00 00    	jne    10afcf <pcie_msi_vectors_allocate+0x115>
	mcr = pcie_conf_read(bdf, base + PCIE_MSIX_MCR);
  10af2a:	e8 3c d8 ff ff       	callq  10876b <pcie_conf_read>
	table_offset = pcie_conf_read(bdf, base + PCIE_MSIX_TR);
  10af2f:	41 8d 77 01          	lea    0x1(%r15),%esi
  10af33:	44 89 f7             	mov    %r14d,%edi
	mcr = pcie_conf_read(bdf, base + PCIE_MSIX_MCR);
  10af36:	89 45 ac             	mov    %eax,-0x54(%rbp)
	table_offset = pcie_conf_read(bdf, base + PCIE_MSIX_TR);
  10af39:	e8 2d d8 ff ff       	callq  10876b <pcie_conf_read>
	if (!pcie_get_mbar(bdf, table_bir, &bar)) {
  10af3e:	48 8d 55 c0          	lea    -0x40(%rbp),%rdx
  10af42:	44 89 f7             	mov    %r14d,%edi
  10af45:	89 c6                	mov    %eax,%esi
	table_offset = pcie_conf_read(bdf, base + PCIE_MSIX_TR);
  10af47:	41 89 c7             	mov    %eax,%r15d
	if (!pcie_get_mbar(bdf, table_bir, &bar)) {
  10af4a:	83 e6 07             	and    $0x7,%esi
  10af4d:	e8 78 fc ff ff       	callq  10abca <pcie_get_mbar>
  10af52:	84 c0                	test   %al,%al
  10af54:	0f 84 8b 00 00 00    	je     10afe5 <pcie_msi_vectors_allocate+0x12b>
		   n_vector * PCIE_MSIR_TABLE_ENTRY_SIZE, K_MEM_PERM_RW);
  10af5a:	89 da                	mov    %ebx,%edx
	z_phys_map((uint8_t **)&mapped_table,
  10af5c:	44 89 fe             	mov    %r15d,%esi
  10af5f:	48 8d 7d b8          	lea    -0x48(%rbp),%rdi
  10af63:	b9 08 00 00 00       	mov    $0x8,%ecx
		   n_vector * PCIE_MSIR_TABLE_ENTRY_SIZE, K_MEM_PERM_RW);
  10af68:	c1 e2 04             	shl    $0x4,%edx
	z_phys_map((uint8_t **)&mapped_table,
  10af6b:	83 e6 f8             	and    $0xfffffff8,%esi
  10af6e:	48 03 75 c0          	add    -0x40(%rbp),%rsi
  10af72:	48 63 d2             	movslq %edx,%rdx
  10af75:	e8 86 93 00 00       	callq  114300 <z_phys_map>
			(mapped_table + (i * PCIE_MSIR_TABLE_ENTRY_SIZE));
  10af7a:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
	for (i = 0; i < n_vector; i++) {
  10af7e:	31 c0                	xor    %eax,%eax
  10af80:	39 c3                	cmp    %eax,%ebx
  10af82:	7e 15                	jle    10af99 <pcie_msi_vectors_allocate+0xdf>
		vectors[i].msix_vector = (struct msix_vector *)
  10af84:	48 89 c1             	mov    %rax,%rcx
  10af87:	48 ff c0             	inc    %rax
  10af8a:	48 c1 e1 05          	shl    $0x5,%rcx
  10af8e:	49 89 54 0c 10       	mov    %rdx,0x10(%r12,%rcx,1)
	for (i = 0; i < n_vector; i++) {
  10af93:	48 83 c2 10          	add    $0x10,%rdx
  10af97:	eb e7                	jmp    10af80 <pcie_msi_vectors_allocate+0xc6>
	return ((mcr & PCIE_MSIX_MCR_TSIZE) >> PCIE_MSIX_MCR_TSIZE_SHIFT) + 1;
  10af99:	44 8b 7d ac          	mov    -0x54(%rbp),%r15d
  10af9d:	41 c1 ef 10          	shr    $0x10,%r15d
  10afa1:	41 81 e7 ff 07 00 00 	and    $0x7ff,%r15d
  10afa8:	41 8d 47 01          	lea    0x1(%r15),%eax
	if (msi) {
		req_vectors = get_msi_mmc(bdf, base);
	}

	if (n_vector > req_vectors) {
		n_vector = req_vectors;
  10afac:	39 c3                	cmp    %eax,%ebx
	}

	return arch_pcie_msi_vectors_allocate(priority, vectors, n_vector);
  10afae:	8b 7d a8             	mov    -0x58(%rbp),%edi
  10afb1:	4c 89 e6             	mov    %r12,%rsi
		n_vector = req_vectors;
  10afb4:	44 0f 47 e8          	cmova  %eax,%r13d
}
  10afb8:	48 83 c4 38          	add    $0x38,%rsp
  10afbc:	5b                   	pop    %rbx
  10afbd:	41 5c                	pop    %r12
	return arch_pcie_msi_vectors_allocate(priority, vectors, n_vector);
  10afbf:	41 0f b6 d5          	movzbl %r13b,%edx
}
  10afc3:	41 5d                	pop    %r13
  10afc5:	41 5e                	pop    %r14
  10afc7:	41 5f                	pop    %r15
  10afc9:	5d                   	pop    %rbp
	return arch_pcie_msi_vectors_allocate(priority, vectors, n_vector);
  10afca:	e9 0c d8 ff ff       	jmpq   1087db <arch_pcie_msi_vectors_allocate>
	mcr = pcie_conf_read(bdf, base + PCIE_MSI_MCR);
  10afcf:	e8 97 d7 ff ff       	callq  10876b <pcie_conf_read>
	return 1 << ((mcr & PCIE_MSI_MCR_MMC) >> PCIE_MSI_MCR_MMC_SHIFT);
  10afd4:	c1 e8 11             	shr    $0x11,%eax
  10afd7:	89 c1                	mov    %eax,%ecx
  10afd9:	b8 01 00 00 00       	mov    $0x1,%eax
  10afde:	83 e1 07             	and    $0x7,%ecx
  10afe1:	d3 e0                	shl    %cl,%eax
  10afe3:	eb c7                	jmp    10afac <pcie_msi_vectors_allocate+0xf2>
}
  10afe5:	48 83 c4 38          	add    $0x38,%rsp
  10afe9:	31 c0                	xor    %eax,%eax
  10afeb:	5b                   	pop    %rbx
  10afec:	41 5c                	pop    %r12
  10afee:	41 5d                	pop    %r13
  10aff0:	41 5e                	pop    %r14
  10aff2:	41 5f                	pop    %r15
  10aff4:	5d                   	pop    %rbp
  10aff5:	c3                   	retq   

000000000010aff6 <pcie_msi_vector_connect>:
bool pcie_msi_vector_connect(pcie_bdf_t bdf,
			     msi_vector_t *vector,
			     void (*routine)(const void *parameter),
			     const void *parameter,
			     uint32_t flags)
{
  10aff6:	55                   	push   %rbp
  10aff7:	48 89 e5             	mov    %rsp,%rbp
  10affa:	41 57                	push   %r15
  10affc:	41 56                	push   %r14
  10affe:	49 89 ce             	mov    %rcx,%r14
  10b001:	41 55                	push   %r13
  10b003:	49 89 d5             	mov    %rdx,%r13
  10b006:	41 54                	push   %r12
  10b008:	49 89 f4             	mov    %rsi,%r12
	uint32_t base;

	base = pcie_get_cap(bdf, PCI_CAP_ID_MSI);
  10b00b:	be 05 00 00 00       	mov    $0x5,%esi
{
  10b010:	53                   	push   %rbx
  10b011:	89 fb                	mov    %edi,%ebx
  10b013:	48 83 ec 18          	sub    $0x18,%rsp
  10b017:	44 89 45 cc          	mov    %r8d,-0x34(%rbp)
	base = pcie_get_cap(bdf, PCI_CAP_ID_MSI);
  10b01b:	e8 43 fb ff ff       	callq  10ab63 <pcie_get_cap>

	if (IS_ENABLED(CONFIG_PCIE_MSI_X)) {
		uint32_t base_msix;

		base_msix = pcie_get_cap(bdf, PCI_CAP_ID_MSIX);
  10b020:	be 11 00 00 00       	mov    $0x11,%esi
  10b025:	89 df                	mov    %ebx,%edi
	base = pcie_get_cap(bdf, PCI_CAP_ID_MSI);
  10b027:	41 89 c7             	mov    %eax,%r15d
		base_msix = pcie_get_cap(bdf, PCI_CAP_ID_MSIX);
  10b02a:	e8 34 fb ff ff       	callq  10ab63 <pcie_get_cap>
		if (base_msix != 0U) {
			base = base_msix;
		}
	}

	if (base == 0U) {
  10b02f:	41 09 c7             	or     %eax,%r15d
  10b032:	74 23                	je     10b057 <pcie_msi_vector_connect+0x61>
		return false;
	}

	vector->bdf = bdf;
  10b034:	41 89 1c 24          	mov    %ebx,(%r12)

	return arch_pcie_msi_vector_connect(vector, routine, parameter, flags);
  10b038:	8b 4d cc             	mov    -0x34(%rbp),%ecx
}
  10b03b:	48 83 c4 18          	add    $0x18,%rsp
	return arch_pcie_msi_vector_connect(vector, routine, parameter, flags);
  10b03f:	4c 89 f2             	mov    %r14,%rdx
}
  10b042:	5b                   	pop    %rbx
	return arch_pcie_msi_vector_connect(vector, routine, parameter, flags);
  10b043:	4c 89 ee             	mov    %r13,%rsi
  10b046:	4c 89 e7             	mov    %r12,%rdi
}
  10b049:	41 5c                	pop    %r12
  10b04b:	41 5d                	pop    %r13
  10b04d:	41 5e                	pop    %r14
  10b04f:	41 5f                	pop    %r15
  10b051:	5d                   	pop    %rbp
	return arch_pcie_msi_vector_connect(vector, routine, parameter, flags);
  10b052:	e9 30 d8 ff ff       	jmpq   108887 <arch_pcie_msi_vector_connect>
}
  10b057:	48 83 c4 18          	add    $0x18,%rsp
  10b05b:	31 c0                	xor    %eax,%eax
  10b05d:	5b                   	pop    %rbx
  10b05e:	41 5c                	pop    %r12
  10b060:	41 5d                	pop    %r13
  10b062:	41 5e                	pop    %r14
  10b064:	41 5f                	pop    %r15
  10b066:	5d                   	pop    %rbp
  10b067:	c3                   	retq   

000000000010b068 <pcie_msi_enable>:

bool pcie_msi_enable(pcie_bdf_t bdf,
		     msi_vector_t *vectors,
		     uint8_t n_vector,
		     unsigned int irq)
{
  10b068:	55                   	push   %rbp
  10b069:	48 89 e5             	mov    %rsp,%rbp
  10b06c:	41 57                	push   %r15
  10b06e:	49 89 f7             	mov    %rsi,%r15
	bool msi = true;
	uint32_t base;

	base = pcie_get_cap(bdf, PCI_CAP_ID_MSI);
  10b071:	be 05 00 00 00       	mov    $0x5,%esi
{
  10b076:	41 56                	push   %r14
  10b078:	41 55                	push   %r13
  10b07a:	41 89 fd             	mov    %edi,%r13d
  10b07d:	41 54                	push   %r12
  10b07f:	53                   	push   %rbx
  10b080:	89 d3                	mov    %edx,%ebx
  10b082:	48 83 ec 18          	sub    $0x18,%rsp
  10b086:	88 55 c8             	mov    %dl,-0x38(%rbp)
  10b089:	89 4d cc             	mov    %ecx,-0x34(%rbp)
	base = pcie_get_cap(bdf, PCI_CAP_ID_MSI);
  10b08c:	e8 d2 fa ff ff       	callq  10ab63 <pcie_get_cap>

	if (IS_ENABLED(CONFIG_PCIE_MSI_X)) {
		uint32_t base_msix;

		base_msix = pcie_get_cap(bdf, PCI_CAP_ID_MSIX);
  10b091:	be 11 00 00 00       	mov    $0x11,%esi
  10b096:	44 89 ef             	mov    %r13d,%edi
	base = pcie_get_cap(bdf, PCI_CAP_ID_MSI);
  10b099:	41 89 c6             	mov    %eax,%r14d
		base_msix = pcie_get_cap(bdf, PCI_CAP_ID_MSIX);
  10b09c:	e8 c2 fa ff ff       	callq  10ab63 <pcie_get_cap>
		if ((base_msix != 0U) && (base != 0U)) {
  10b0a1:	85 c0                	test   %eax,%eax
		base_msix = pcie_get_cap(bdf, PCI_CAP_ID_MSIX);
  10b0a3:	41 89 c4             	mov    %eax,%r12d
		if ((base_msix != 0U) && (base != 0U)) {
  10b0a6:	0f 95 c0             	setne  %al
  10b0a9:	45 85 f6             	test   %r14d,%r14d
  10b0ac:	0f 95 c2             	setne  %dl
  10b0af:	20 d0                	and    %dl,%al
  10b0b1:	74 1f                	je     10b0d2 <pcie_msi_enable+0x6a>
	mcr = pcie_conf_read(bdf, base + PCIE_MSI_MCR);
  10b0b3:	44 89 f6             	mov    %r14d,%esi
  10b0b6:	44 89 ef             	mov    %r13d,%edi
  10b0b9:	e8 ad d6 ff ff       	callq  10876b <pcie_conf_read>
	pcie_conf_write(bdf, base + PCIE_MSI_MCR, mcr);
  10b0be:	44 89 f6             	mov    %r14d,%esi
  10b0c1:	44 89 ef             	mov    %r13d,%edi
	mcr &= ~PCIE_MSI_MCR_EN;
  10b0c4:	25 ff ff fe ff       	and    $0xfffeffff,%eax
  10b0c9:	89 c2                	mov    %eax,%edx
	pcie_conf_write(bdf, base + PCIE_MSI_MCR, mcr);
  10b0cb:	e8 ba d6 ff ff       	callq  10878a <pcie_conf_write>
			disable_msi(bdf, base);
		}
		if ((base_msix != 0U)) {
  10b0d0:	eb 09                	jmp    10b0db <pcie_msi_enable+0x73>
  10b0d2:	45 85 e4             	test   %r12d,%r12d
  10b0d5:	0f 84 8f 00 00 00    	je     10b16a <pcie_msi_enable+0x102>
	if (base == 0U) {
		return false;
	}

	if (!msi && IS_ENABLED(CONFIG_PCIE_MSI_X)) {
		enable_msix(bdf, vectors, n_vector, base, irq);
  10b0db:	0f b6 c3             	movzbl %bl,%eax
	for (i = 0; i < n_vector; i++) {
  10b0de:	31 db                	xor    %ebx,%ebx
		enable_msix(bdf, vectors, n_vector, base, irq);
  10b0e0:	89 45 c8             	mov    %eax,-0x38(%rbp)
	for (i = 0; i < n_vector; i++) {
  10b0e3:	39 5d c8             	cmp    %ebx,-0x38(%rbp)
  10b0e6:	7e 3c                	jle    10b124 <pcie_msi_enable+0xbc>
		uint32_t map = pcie_msi_map(irq, &vectors[i]);
  10b0e8:	8b 7d cc             	mov    -0x34(%rbp),%edi
  10b0eb:	4c 89 fe             	mov    %r15,%rsi
	for (i = 0; i < n_vector; i++) {
  10b0ee:	ff c3                	inc    %ebx
		uint32_t map = pcie_msi_map(irq, &vectors[i]);
  10b0f0:	e8 b0 d6 ff ff       	callq  1087a5 <pcie_msi_map>
		uint32_t mdr = pcie_msi_mdr(irq, &vectors[i]);
  10b0f5:	8b 7d cc             	mov    -0x34(%rbp),%edi
  10b0f8:	4c 89 fe             	mov    %r15,%rsi
  10b0fb:	49 83 c7 20          	add    $0x20,%r15
		uint32_t map = pcie_msi_map(irq, &vectors[i]);
  10b0ff:	41 89 c6             	mov    %eax,%r14d
		uint32_t mdr = pcie_msi_mdr(irq, &vectors[i]);
  10b102:	e8 b4 d6 ff ff       	callq  1087bb <pcie_msi_mdr>
  10b107:	0f b7 c8             	movzwl %ax,%ecx
		vectors[i].msix_vector->msg_addr = map;
  10b10a:	49 8b 47 f0          	mov    -0x10(%r15),%rax
  10b10e:	44 89 30             	mov    %r14d,(%rax)
		vectors[i].msix_vector->msg_up_addr = 0;
  10b111:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%rax)
		uint32_t mdr = pcie_msi_mdr(irq, &vectors[i]);
  10b118:	89 48 08             	mov    %ecx,0x8(%rax)
		vectors[i].msix_vector->vector_ctrl = 0;
  10b11b:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%rax)
	for (i = 0; i < n_vector; i++) {
  10b122:	eb bf                	jmp    10b0e3 <pcie_msi_enable+0x7b>
	mcr = pcie_conf_read(bdf, base + PCIE_MSIX_MCR);
  10b124:	44 89 e6             	mov    %r12d,%esi
  10b127:	44 89 ef             	mov    %r13d,%edi
  10b12a:	e8 3c d6 ff ff       	callq  10876b <pcie_conf_read>
	pcie_conf_write(bdf, base + PCIE_MSIX_MCR, mcr);
  10b12f:	44 89 e6             	mov    %r12d,%esi
	mcr |= PCIE_MSIX_MCR_EN;
  10b132:	0d 00 00 00 80       	or     $0x80000000,%eax
  10b137:	89 c2                	mov    %eax,%edx
  10b139:	eb 11                	jmp    10b14c <pcie_msi_enable+0xe4>
	mcr |= mme << PCIE_MSI_MCR_MME_SHIFT;
  10b13b:	44 89 e2             	mov    %r12d,%edx
	pcie_conf_write(bdf, base + PCIE_MSI_MCR, mcr);
  10b13e:	44 89 f6             	mov    %r14d,%esi
	mcr |= mme << PCIE_MSI_MCR_MME_SHIFT;
  10b141:	c1 e2 14             	shl    $0x14,%edx
  10b144:	09 da                	or     %ebx,%edx
	mcr |= PCIE_MSI_MCR_EN;
  10b146:	81 ca 00 00 01 00    	or     $0x10000,%edx
	pcie_conf_write(bdf, base + PCIE_MSI_MCR, mcr);
  10b14c:	44 89 ef             	mov    %r13d,%edi
  10b14f:	e8 36 d6 ff ff       	callq  10878a <pcie_conf_write>
	} else {
		enable_msi(bdf, vectors, n_vector, base, irq);
	}

	pcie_set_cmd(bdf, PCIE_CONF_CMDSTAT_MASTER, true);
  10b154:	ba 01 00 00 00       	mov    $0x1,%edx
  10b159:	be 04 00 00 00       	mov    $0x4,%esi
  10b15e:	44 89 ef             	mov    %r13d,%edi
  10b161:	e8 be f9 ff ff       	callq  10ab24 <pcie_set_cmd>

	return true;
  10b166:	b0 01                	mov    $0x1,%al
  10b168:	eb 6f                	jmp    10b1d9 <pcie_msi_enable+0x171>
	if (base == 0U) {
  10b16a:	45 85 f6             	test   %r14d,%r14d
  10b16d:	74 6a                	je     10b1d9 <pcie_msi_enable+0x171>
	map = pcie_msi_map(irq, vectors);
  10b16f:	8b 7d cc             	mov    -0x34(%rbp),%edi
  10b172:	4c 89 fe             	mov    %r15,%rsi
  10b175:	e8 2b d6 ff ff       	callq  1087a5 <pcie_msi_map>
	pcie_conf_write(bdf, base + PCIE_MSI_MAP0, map);
  10b17a:	41 8d 76 01          	lea    0x1(%r14),%esi
  10b17e:	44 89 ef             	mov    %r13d,%edi
	map = pcie_msi_map(irq, vectors);
  10b181:	89 c2                	mov    %eax,%edx
	pcie_conf_write(bdf, base + PCIE_MSI_MAP0, map);
  10b183:	e8 02 d6 ff ff       	callq  10878a <pcie_conf_write>
	mdr = pcie_msi_mdr(irq, vectors);
  10b188:	8b 7d cc             	mov    -0x34(%rbp),%edi
  10b18b:	4c 89 fe             	mov    %r15,%rsi
  10b18e:	e8 28 d6 ff ff       	callq  1087bb <pcie_msi_mdr>
	mcr = pcie_conf_read(bdf, base + PCIE_MSI_MCR);
  10b193:	44 89 f6             	mov    %r14d,%esi
  10b196:	44 89 ef             	mov    %r13d,%edi
	mdr = pcie_msi_mdr(irq, vectors);
  10b199:	44 0f b7 f8          	movzwl %ax,%r15d
	mcr = pcie_conf_read(bdf, base + PCIE_MSI_MCR);
  10b19d:	e8 c9 d5 ff ff       	callq  10876b <pcie_conf_read>
		pcie_conf_write(bdf, base + PCIE_MSI_MAP1_64, 0U);
  10b1a2:	41 8d 76 02          	lea    0x2(%r14),%esi
	if (mcr & PCIE_MSI_MCR_64) {
  10b1a6:	0f ba e0 17          	bt     $0x17,%eax
	mcr = pcie_conf_read(bdf, base + PCIE_MSI_MCR);
  10b1aa:	89 c3                	mov    %eax,%ebx
	if (mcr & PCIE_MSI_MCR_64) {
  10b1ac:	73 0e                	jae    10b1bc <pcie_msi_enable+0x154>
		pcie_conf_write(bdf, base + PCIE_MSI_MAP1_64, 0U);
  10b1ae:	31 d2                	xor    %edx,%edx
  10b1b0:	44 89 ef             	mov    %r13d,%edi
  10b1b3:	e8 d2 d5 ff ff       	callq  10878a <pcie_conf_write>
		pcie_conf_write(bdf, base + PCIE_MSI_MDR_64, mdr);
  10b1b8:	41 8d 76 03          	lea    0x3(%r14),%esi
		pcie_conf_write(bdf, base + PCIE_MSI_MDR_32, mdr);
  10b1bc:	44 89 fa             	mov    %r15d,%edx
  10b1bf:	44 89 ef             	mov    %r13d,%edi
  10b1c2:	e8 c3 d5 ff ff       	callq  10878a <pcie_conf_write>
	for (mme = 0; n_vector > 1; mme++) {
  10b1c7:	80 7d c8 01          	cmpb   $0x1,-0x38(%rbp)
  10b1cb:	0f 86 6a ff ff ff    	jbe    10b13b <pcie_msi_enable+0xd3>
		n_vector >>= 1;
  10b1d1:	d0 6d c8             	shrb   -0x38(%rbp)
	for (mme = 0; n_vector > 1; mme++) {
  10b1d4:	41 ff c4             	inc    %r12d
  10b1d7:	eb ee                	jmp    10b1c7 <pcie_msi_enable+0x15f>
}
  10b1d9:	48 83 c4 18          	add    $0x18,%rsp
  10b1dd:	5b                   	pop    %rbx
  10b1de:	41 5c                	pop    %r12
  10b1e0:	41 5d                	pop    %r13
  10b1e2:	41 5e                	pop    %r14
  10b1e4:	41 5f                	pop    %r15
  10b1e6:	5d                   	pop    %rbp
  10b1e7:	c3                   	retq   

000000000010b1e8 <cmd_pcie_ls>:
		}
	}
}

static int cmd_pcie_ls(const struct shell *shell, size_t argc, char **argv)
{
  10b1e8:	55                   	push   %rbp
  10b1e9:	48 89 e5             	mov    %rsp,%rbp
  10b1ec:	41 57                	push   %r15
  10b1ee:	41 56                	push   %r14
  10b1f0:	41 55                	push   %r13
  10b1f2:	41 54                	push   %r12
  10b1f4:	53                   	push   %rbx
  10b1f5:	48 89 fb             	mov    %rdi,%rbx
  10b1f8:	48 83 ec 18          	sub    $0x18,%rsp
		shell_fprintf(shell, SHELL_NORMAL,
  10b1fc:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%rbp)
  10b203:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%rbp)
	int func;

	for (bus = 0; bus <= PCIE_MAX_BUS; ++bus) {
		for (dev = 0; dev <= PCIE_MAX_DEV; ++dev) {
			for (func = 0; func <= PCIE_MAX_FUNC; ++func) {
				show(shell, PCIE_BDF(bus, dev, func));
  10b20a:	8b 45 cc             	mov    -0x34(%rbp),%eax
  10b20d:	0b 45 c8             	or     -0x38(%rbp),%eax
  10b210:	45 31 ff             	xor    %r15d,%r15d
  10b213:	89 45 c0             	mov    %eax,-0x40(%rbp)
  10b216:	44 8b 65 c0          	mov    -0x40(%rbp),%r12d
	data = pcie_conf_read(bdf, PCIE_CONF_ID);
  10b21a:	31 f6                	xor    %esi,%esi
				show(shell, PCIE_BDF(bus, dev, func));
  10b21c:	45 09 fc             	or     %r15d,%r12d
	data = pcie_conf_read(bdf, PCIE_CONF_ID);
  10b21f:	44 89 e7             	mov    %r12d,%edi
  10b222:	e8 44 d5 ff ff       	callq  10876b <pcie_conf_read>
	if (data == PCIE_ID_NONE) {
  10b227:	83 f8 ff             	cmp    $0xffffffff,%eax
  10b22a:	0f 84 86 02 00 00    	je     10b4b6 <cmd_pcie_ls+0x2ce>
	shell_fprintf(shell, SHELL_NORMAL, "%d:%x.%d ID %x:%x ",
  10b230:	89 c2                	mov    %eax,%edx
  10b232:	0f b7 c0             	movzwl %ax,%eax
		     PCIE_BDF_TO_FUNC(bdf),
  10b235:	45 89 e1             	mov    %r12d,%r9d
		     PCIE_BDF_TO_DEV(bdf),
  10b238:	45 89 e0             	mov    %r12d,%r8d
	shell_fprintf(shell, SHELL_NORMAL, "%d:%x.%d ID %x:%x ",
  10b23b:	c1 ea 10             	shr    $0x10,%edx
		     PCIE_BDF_TO_FUNC(bdf),
  10b23e:	41 c1 e9 08          	shr    $0x8,%r9d
		     PCIE_BDF_TO_BUS(bdf),
  10b242:	44 89 e1             	mov    %r12d,%ecx
	shell_fprintf(shell, SHELL_NORMAL, "%d:%x.%d ID %x:%x ",
  10b245:	31 f6                	xor    %esi,%esi
  10b247:	52                   	push   %rdx
		     PCIE_BDF_TO_DEV(bdf),
  10b248:	41 c1 e8 0b          	shr    $0xb,%r8d
		     PCIE_BDF_TO_BUS(bdf),
  10b24c:	c1 e9 10             	shr    $0x10,%ecx
	shell_fprintf(shell, SHELL_NORMAL, "%d:%x.%d ID %x:%x ",
  10b24f:	41 83 e1 07          	and    $0x7,%r9d
  10b253:	50                   	push   %rax
  10b254:	41 83 e0 1f          	and    $0x1f,%r8d
  10b258:	31 c0                	xor    %eax,%eax
  10b25a:	ba 6b ed 11 00       	mov    $0x11ed6b,%edx
  10b25f:	48 89 df             	mov    %rbx,%rdi
  10b262:	e8 2c a9 ff ff       	callq  105b93 <shell_fprintf>
  10b267:	58                   	pop    %rax
	data = pcie_conf_read(bdf, PCIE_CONF_CLASSREV);
  10b268:	be 02 00 00 00       	mov    $0x2,%esi
	shell_fprintf(shell, SHELL_NORMAL, "%d:%x.%d ID %x:%x ",
  10b26d:	5a                   	pop    %rdx
	data = pcie_conf_read(bdf, PCIE_CONF_CLASSREV);
  10b26e:	44 89 e7             	mov    %r12d,%edi
  10b271:	e8 f5 d4 ff ff       	callq  10876b <pcie_conf_read>
	shell_fprintf(shell, SHELL_NORMAL,
  10b276:	48 89 df             	mov    %rbx,%rdi
  10b279:	0f b6 d4             	movzbl %ah,%edx
		     PCIE_CONF_CLASSREV_SUBCLASS(data),
  10b27c:	41 89 c0             	mov    %eax,%r8d
	shell_fprintf(shell, SHELL_NORMAL,
  10b27f:	89 c1                	mov    %eax,%ecx
  10b281:	0f b6 c0             	movzbl %al,%eax
  10b284:	56                   	push   %rsi
		     PCIE_CONF_CLASSREV_SUBCLASS(data),
  10b285:	41 c1 e8 10          	shr    $0x10,%r8d
	shell_fprintf(shell, SHELL_NORMAL,
  10b289:	31 f6                	xor    %esi,%esi
  10b28b:	41 89 d1             	mov    %edx,%r9d
  10b28e:	50                   	push   %rax
  10b28f:	c1 e9 18             	shr    $0x18,%ecx
  10b292:	45 0f b6 c0          	movzbl %r8b,%r8d
  10b296:	31 c0                	xor    %eax,%eax
  10b298:	ba 7e ed 11 00       	mov    $0x11ed7e,%edx
  10b29d:	e8 f1 a8 ff ff       	callq  105b93 <shell_fprintf>
  10b2a2:	5f                   	pop    %rdi
	data = pcie_conf_read(bdf, PCIE_CONF_TYPE);
  10b2a3:	be 03 00 00 00       	mov    $0x3,%esi
	shell_fprintf(shell, SHELL_NORMAL,
  10b2a8:	41 58                	pop    %r8
	data = pcie_conf_read(bdf, PCIE_CONF_TYPE);
  10b2aa:	44 89 e7             	mov    %r12d,%edi
  10b2ad:	e8 b9 d4 ff ff       	callq  10876b <pcie_conf_read>
	if (PCIE_CONF_TYPE_BRIDGE(data)) {
  10b2b2:	a9 00 00 7f 00       	test   $0x7f0000,%eax
  10b2b7:	74 16                	je     10b2cf <cmd_pcie_ls+0xe7>
		shell_fprintf(shell, SHELL_NORMAL, " [bridge]\n");
  10b2b9:	ba a6 ed 11 00       	mov    $0x11eda6,%edx
  10b2be:	31 f6                	xor    %esi,%esi
  10b2c0:	48 89 df             	mov    %rbx,%rdi
  10b2c3:	31 c0                	xor    %eax,%eax
  10b2c5:	e8 c9 a8 ff ff       	callq  105b93 <shell_fprintf>
  10b2ca:	e9 e7 01 00 00       	jmpq   10b4b6 <cmd_pcie_ls+0x2ce>
		shell_fprintf(shell, SHELL_NORMAL, "\n");
  10b2cf:	ba 23 fc 11 00       	mov    $0x11fc23,%edx
  10b2d4:	31 f6                	xor    %esi,%esi
  10b2d6:	48 89 df             	mov    %rbx,%rdi
  10b2d9:	31 c0                	xor    %eax,%eax
  10b2db:	e8 b3 a8 ff ff       	callq  105b93 <shell_fprintf>
	for (bar = PCIE_CONF_BAR0; bar <= PCIE_CONF_BAR5; ++bar) {
  10b2e0:	41 bd 04 00 00 00    	mov    $0x4,%r13d
  10b2e6:	41 83 fd 09          	cmp    $0x9,%r13d
  10b2ea:	0f 8f ad 00 00 00    	jg     10b39d <cmd_pcie_ls+0x1b5>
		data = pcie_conf_read(bdf, bar);
  10b2f0:	44 89 ee             	mov    %r13d,%esi
  10b2f3:	44 89 e7             	mov    %r12d,%edi
  10b2f6:	e8 70 d4 ff ff       	callq  10876b <pcie_conf_read>
  10b2fb:	41 89 c6             	mov    %eax,%r14d
		if (data == PCIE_CONF_BAR_NONE) {
  10b2fe:	85 c0                	test   %eax,%eax
  10b300:	0f 84 8f 00 00 00    	je     10b395 <cmd_pcie_ls+0x1ad>
			      PCIE_CONF_BAR_64(data) ? ", 64-bit" : "");
  10b306:	83 e0 06             	and    $0x6,%eax
		shell_fprintf(shell, SHELL_NORMAL, "    bar %d: %s%s",
  10b309:	41 b9 24 fc 11 00    	mov    $0x11fc24,%r9d
  10b30f:	41 8d 4d fc          	lea    -0x4(%r13),%ecx
  10b313:	48 89 df             	mov    %rbx,%rdi
  10b316:	83 f8 04             	cmp    $0x4,%eax
			      PCIE_CONF_BAR_64(data) ? ", 64-bit" : "");
  10b319:	89 45 c4             	mov    %eax,-0x3c(%rbp)
		shell_fprintf(shell, SHELL_NORMAL, "    bar %d: %s%s",
  10b31c:	b8 49 ed 11 00       	mov    $0x11ed49,%eax
  10b321:	41 b8 52 ed 11 00    	mov    $0x11ed52,%r8d
  10b327:	4c 0f 44 c8          	cmove  %rax,%r9
  10b32b:	41 f6 c6 01          	test   $0x1,%r14b
  10b32f:	b8 c5 ce 11 00       	mov    $0x11cec5,%eax
  10b334:	ba b1 ed 11 00       	mov    $0x11edb1,%edx
  10b339:	4c 0f 44 c0          	cmove  %rax,%r8
  10b33d:	31 f6                	xor    %esi,%esi
  10b33f:	31 c0                	xor    %eax,%eax
  10b341:	e8 4d a8 ff ff       	callq  105b93 <shell_fprintf>
		shell_fprintf(shell, SHELL_NORMAL, " addr 0x");
  10b346:	31 f6                	xor    %esi,%esi
  10b348:	31 c0                	xor    %eax,%eax
  10b34a:	ba c2 ed 11 00       	mov    $0x11edc2,%edx
  10b34f:	48 89 df             	mov    %rbx,%rdi
  10b352:	e8 3c a8 ff ff       	callq  105b93 <shell_fprintf>
		if (PCIE_CONF_BAR_64(data)) {
  10b357:	83 7d c4 04          	cmpl   $0x4,-0x3c(%rbp)
  10b35b:	75 21                	jne    10b37e <cmd_pcie_ls+0x196>
			++bar;
  10b35d:	41 ff c5             	inc    %r13d
			shell_fprintf(shell, SHELL_NORMAL, "%08x",
  10b360:	44 89 e7             	mov    %r12d,%edi
  10b363:	44 89 ee             	mov    %r13d,%esi
  10b366:	e8 00 d4 ff ff       	callq  10876b <pcie_conf_read>
  10b36b:	ba cb ed 11 00       	mov    $0x11edcb,%edx
  10b370:	31 f6                	xor    %esi,%esi
  10b372:	48 89 df             	mov    %rbx,%rdi
  10b375:	89 c1                	mov    %eax,%ecx
  10b377:	31 c0                	xor    %eax,%eax
  10b379:	e8 15 a8 ff ff       	callq  105b93 <shell_fprintf>
		shell_fprintf(shell, SHELL_NORMAL, "%08x\n",
  10b37e:	44 89 f1             	mov    %r14d,%ecx
  10b381:	ba d0 ed 11 00       	mov    $0x11edd0,%edx
  10b386:	31 f6                	xor    %esi,%esi
  10b388:	48 89 df             	mov    %rbx,%rdi
  10b38b:	83 e1 f0             	and    $0xfffffff0,%ecx
  10b38e:	31 c0                	xor    %eax,%eax
  10b390:	e8 fe a7 ff ff       	callq  105b93 <shell_fprintf>
	for (bar = PCIE_CONF_BAR0; bar <= PCIE_CONF_BAR5; ++bar) {
  10b395:	41 ff c5             	inc    %r13d
  10b398:	e9 49 ff ff ff       	jmpq   10b2e6 <cmd_pcie_ls+0xfe>
	msi = pcie_get_cap(bdf, PCI_CAP_ID_MSI);
  10b39d:	be 05 00 00 00       	mov    $0x5,%esi
  10b3a2:	44 89 e7             	mov    %r12d,%edi
  10b3a5:	e8 b9 f7 ff ff       	callq  10ab63 <pcie_get_cap>
  10b3aa:	89 c6                	mov    %eax,%esi
	if (msi) {
  10b3ac:	85 c0                	test   %eax,%eax
  10b3ae:	74 40                	je     10b3f0 <cmd_pcie_ls+0x208>
		data = pcie_conf_read(bdf, msi + PCIE_MSI_MCR);
  10b3b0:	44 89 e7             	mov    %r12d,%edi
  10b3b3:	e8 b3 d3 ff ff       	callq  10876b <pcie_conf_read>
		shell_fprintf(shell, SHELL_NORMAL, "    MSI support%s%s\n",
  10b3b8:	ba 60 ed 11 00       	mov    $0x11ed60,%edx
  10b3bd:	b9 24 fc 11 00       	mov    $0x11fc24,%ecx
  10b3c2:	48 89 df             	mov    %rbx,%rdi
  10b3c5:	a9 00 00 01 00       	test   $0x10000,%eax
  10b3ca:	41 b8 56 ed 11 00    	mov    $0x11ed56,%r8d
  10b3d0:	4c 0f 44 c2          	cmove  %rdx,%r8
  10b3d4:	a9 00 00 80 00       	test   $0x800000,%eax
  10b3d9:	b8 49 ed 11 00       	mov    $0x11ed49,%eax
  10b3de:	ba d6 ed 11 00       	mov    $0x11edd6,%edx
  10b3e3:	48 0f 45 c8          	cmovne %rax,%rcx
  10b3e7:	31 f6                	xor    %esi,%esi
  10b3e9:	31 c0                	xor    %eax,%eax
  10b3eb:	e8 a3 a7 ff ff       	callq  105b93 <shell_fprintf>
	msi = pcie_get_cap(bdf, PCI_CAP_ID_MSIX);
  10b3f0:	be 11 00 00 00       	mov    $0x11,%esi
  10b3f5:	44 89 e7             	mov    %r12d,%edi
  10b3f8:	e8 66 f7 ff ff       	callq  10ab63 <pcie_get_cap>
  10b3fd:	41 89 c5             	mov    %eax,%r13d
	if (msi) {
  10b400:	85 c0                	test   %eax,%eax
  10b402:	0f 84 8c 00 00 00    	je     10b494 <cmd_pcie_ls+0x2ac>
		data = pcie_conf_read(bdf, msi + PCIE_MSIX_MCR);
  10b408:	89 c6                	mov    %eax,%esi
  10b40a:	44 89 e7             	mov    %r12d,%edi
  10b40d:	e8 59 d3 ff ff       	callq  10876b <pcie_conf_read>
		shell_fprintf(shell, SHELL_NORMAL,
  10b412:	b9 56 ed 11 00       	mov    $0x11ed56,%ecx
  10b417:	48 89 df             	mov    %rbx,%rdi
		table_size = ((data & PCIE_MSIX_MCR_TSIZE) >>
  10b41a:	89 c2                	mov    %eax,%edx
  10b41c:	c1 ea 10             	shr    $0x10,%edx
  10b41f:	81 e2 ff 07 00 00    	and    $0x7ff,%edx
		shell_fprintf(shell, SHELL_NORMAL,
  10b425:	85 c0                	test   %eax,%eax
  10b427:	b8 60 ed 11 00       	mov    $0x11ed60,%eax
  10b42c:	48 0f 49 c8          	cmovns %rax,%rcx
  10b430:	44 8d 42 01          	lea    0x1(%rdx),%r8d
  10b434:	31 f6                	xor    %esi,%esi
  10b436:	ba eb ed 11 00       	mov    $0x11edeb,%edx
  10b43b:	31 c0                	xor    %eax,%eax
  10b43d:	e8 51 a7 ff ff       	callq  105b93 <shell_fprintf>
		offset = pcie_conf_read(bdf, msi + PCIE_MSIX_TR);
  10b442:	41 8d 75 01          	lea    0x1(%r13),%esi
  10b446:	44 89 e7             	mov    %r12d,%edi
  10b449:	e8 1d d3 ff ff       	callq  10876b <pcie_conf_read>
		shell_fprintf(shell, SHELL_NORMAL,
  10b44e:	ba 0e ee 11 00       	mov    $0x11ee0e,%edx
  10b453:	31 f6                	xor    %esi,%esi
  10b455:	48 89 df             	mov    %rbx,%rdi
		offset = pcie_conf_read(bdf, msi + PCIE_MSIX_TR);
  10b458:	41 89 c0             	mov    %eax,%r8d
		offset &= PCIE_MSIX_TR_OFFSET;
  10b45b:	89 c1                	mov    %eax,%ecx
		shell_fprintf(shell, SHELL_NORMAL,
  10b45d:	31 c0                	xor    %eax,%eax
		offset &= PCIE_MSIX_TR_OFFSET;
  10b45f:	83 e1 f8             	and    $0xfffffff8,%ecx
		shell_fprintf(shell, SHELL_NORMAL,
  10b462:	41 83 e0 07          	and    $0x7,%r8d
  10b466:	e8 28 a7 ff ff       	callq  105b93 <shell_fprintf>
		offset = pcie_conf_read(bdf, msi + PCIE_MSIX_PBA);
  10b46b:	41 8d 75 02          	lea    0x2(%r13),%esi
  10b46f:	44 89 e7             	mov    %r12d,%edi
  10b472:	e8 f4 d2 ff ff       	callq  10876b <pcie_conf_read>
		shell_fprintf(shell, SHELL_NORMAL,
  10b477:	ba 29 ee 11 00       	mov    $0x11ee29,%edx
  10b47c:	31 f6                	xor    %esi,%esi
  10b47e:	48 89 df             	mov    %rbx,%rdi
		offset = pcie_conf_read(bdf, msi + PCIE_MSIX_PBA);
  10b481:	41 89 c0             	mov    %eax,%r8d
		offset &= PCIE_MSIX_PBA_OFFSET;
  10b484:	89 c1                	mov    %eax,%ecx
		shell_fprintf(shell, SHELL_NORMAL,
  10b486:	31 c0                	xor    %eax,%eax
		offset &= PCIE_MSIX_PBA_OFFSET;
  10b488:	83 e1 f8             	and    $0xfffffff8,%ecx
		shell_fprintf(shell, SHELL_NORMAL,
  10b48b:	41 83 e0 07          	and    $0x7,%r8d
  10b48f:	e8 ff a6 ff ff       	callq  105b93 <shell_fprintf>
		irq = pcie_get_irq(bdf);
  10b494:	44 89 e7             	mov    %r12d,%edi
  10b497:	e8 89 f9 ff ff       	callq  10ae25 <pcie_get_irq>
  10b49c:	89 c1                	mov    %eax,%ecx
		if (irq != PCIE_CONF_INTR_IRQ_NONE) {
  10b49e:	3d ff 00 00 00       	cmp    $0xff,%eax
  10b4a3:	74 11                	je     10b4b6 <cmd_pcie_ls+0x2ce>
			shell_fprintf(shell, SHELL_NORMAL,
  10b4a5:	ba 42 ee 11 00       	mov    $0x11ee42,%edx
  10b4aa:	31 f6                	xor    %esi,%esi
  10b4ac:	48 89 df             	mov    %rbx,%rdi
  10b4af:	31 c0                	xor    %eax,%eax
  10b4b1:	e8 dd a6 ff ff       	callq  105b93 <shell_fprintf>
			for (func = 0; func <= PCIE_MAX_FUNC; ++func) {
  10b4b6:	41 81 c7 00 01 00 00 	add    $0x100,%r15d
  10b4bd:	41 81 ff 00 08 00 00 	cmp    $0x800,%r15d
  10b4c4:	0f 85 4c fd ff ff    	jne    10b216 <cmd_pcie_ls+0x2e>
		for (dev = 0; dev <= PCIE_MAX_DEV; ++dev) {
  10b4ca:	81 45 cc 00 08 00 00 	addl   $0x800,-0x34(%rbp)
  10b4d1:	81 7d cc 00 00 01 00 	cmpl   $0x10000,-0x34(%rbp)
  10b4d8:	0f 85 2c fd ff ff    	jne    10b20a <cmd_pcie_ls+0x22>
	for (bus = 0; bus <= PCIE_MAX_BUS; ++bus) {
  10b4de:	81 45 c8 00 00 01 00 	addl   $0x10000,-0x38(%rbp)
  10b4e5:	81 7d c8 00 00 00 01 	cmpl   $0x1000000,-0x38(%rbp)
  10b4ec:	0f 85 11 fd ff ff    	jne    10b203 <cmd_pcie_ls+0x1b>
			}
		}
	}

	return 0;
}
  10b4f2:	48 8d 65 d8          	lea    -0x28(%rbp),%rsp
  10b4f6:	31 c0                	xor    %eax,%eax
  10b4f8:	5b                   	pop    %rbx
  10b4f9:	41 5c                	pop    %r12
  10b4fb:	41 5d                	pop    %r13
  10b4fd:	41 5e                	pop    %r14
  10b4ff:	41 5f                	pop    %r15
  10b501:	5d                   	pop    %rbp
  10b502:	c3                   	retq   

000000000010b503 <uart_console_init>:
 * @brief Initialize one UART as the console/debug port
 *
 * @return 0 if successful, otherwise failed.
 */
static int uart_console_init(const struct device *arg)
{
  10b503:	55                   	push   %rbp

	ARG_UNUSED(arg);

	/* Claim console device */
	uart_console_dev = DEVICE_DT_GET(DT_CHOSEN(zephyr_console));
  10b504:	48 c7 05 79 18 0b 00 	movq   $0x11a150,0xb1879(%rip)        # 1bcd88 <uart_console_dev>
  10b50b:	50 a1 11 00 
{
  10b50f:	48 89 e5             	mov    %rsp,%rbp
  10b512:	bf 50 a1 11 00       	mov    $0x11a150,%edi
  10b517:	e8 39 19 00 00       	callq  10ce55 <z_device_ready>
  10b51c:	41 89 c0             	mov    %eax,%r8d
  10b51f:	b8 ed ff ff ff       	mov    $0xffffffed,%eax
  10b524:	45 84 c0             	test   %r8b,%r8b
  10b527:	74 16                	je     10b53f <uart_console_init+0x3c>
	__stdout_hook_install(console_out);
  10b529:	bf 41 b5 10 00       	mov    $0x10b541,%edi
  10b52e:	e8 9a eb ff ff       	callq  10a0cd <__stdout_hook_install>
	__printk_hook_install(console_out);
  10b533:	bf 41 b5 10 00       	mov    $0x10b541,%edi
  10b538:	e8 42 4f ff ff       	callq  10047f <__printk_hook_install>
		return -ENODEV;
	}

	uart_console_hook_install();

	return 0;
  10b53d:	31 c0                	xor    %eax,%eax
}
  10b53f:	5d                   	pop    %rbp
  10b540:	c3                   	retq   

000000000010b541 <console_out>:
{
  10b541:	55                   	push   %rbp
  10b542:	48 89 e5             	mov    %rsp,%rbp
  10b545:	41 54                	push   %r12
  10b547:	41 89 fc             	mov    %edi,%r12d
  10b54a:	51                   	push   %rcx
	if ('\n' == c) {
  10b54b:	83 ff 0a             	cmp    $0xa,%edi
  10b54e:	75 13                	jne    10b563 <console_out+0x22>
		uart_poll_out(uart_console_dev, '\r');
  10b550:	48 8b 3d 31 18 0b 00 	mov    0xb1831(%rip),%rdi        # 1bcd88 <uart_console_dev>
	api->poll_out(dev, out_char);
  10b557:	48 8b 47 10          	mov    0x10(%rdi),%rax
  10b55b:	be 0d 00 00 00       	mov    $0xd,%esi
  10b560:	ff 50 08             	callq  *0x8(%rax)
	uart_poll_out(uart_console_dev, c);
  10b563:	48 8b 3d 1e 18 0b 00 	mov    0xb181e(%rip),%rdi        # 1bcd88 <uart_console_dev>
  10b56a:	48 8b 47 10          	mov    0x10(%rdi),%rax
  10b56e:	41 0f b6 f4          	movzbl %r12b,%esi
  10b572:	ff 50 08             	callq  *0x8(%rax)
}
  10b575:	44 89 e0             	mov    %r12d,%eax
  10b578:	5a                   	pop    %rdx
  10b579:	41 5c                	pop    %r12
  10b57b:	5d                   	pop    %rbp
  10b57c:	c3                   	retq   

000000000010b57d <ivshmem_api_get_mem>:
	return ivshmem_configure_interrupts(dev);
}

static size_t ivshmem_api_get_mem(const struct device *dev, uintptr_t *memmap)
{
	struct ivshmem *data = dev->data;
  10b57d:	48 8b 47 20          	mov    0x20(%rdi),%rax

	*memmap = data->shmem;
  10b581:	48 8b 50 10          	mov    0x10(%rax),%rdx
  10b585:	48 89 16             	mov    %rdx,(%rsi)

	return data->size;
  10b588:	48 8b 40 18          	mov    0x18(%rax),%rax
}
  10b58c:	c3                   	retq   

000000000010b58d <ivshmem_api_get_id>:

static uint32_t ivshmem_api_get_id(const struct device *dev)
{
	struct ivshmem_reg *regs = (struct ivshmem_reg *)DEVICE_MMIO_GET(dev);
  10b58d:	48 8b 47 20          	mov    0x20(%rdi),%rax

	return regs->iv_position;
  10b591:	48 8b 00             	mov    (%rax),%rax
  10b594:	8b 40 08             	mov    0x8(%rax),%eax
}
  10b597:	c3                   	retq   

000000000010b598 <ivshmem_api_get_vectors>:
static uint16_t ivshmem_api_get_vectors(const struct device *dev)
{
#if CONFIG_IVSHMEM_DOORBELL
	struct ivshmem *data = dev->data;

	return data->n_vectors;
  10b598:	48 8b 47 20          	mov    0x20(%rdi),%rax
  10b59c:	8b 40 60             	mov    0x60(%rax),%eax
#else
	return 0;
#endif
}
  10b59f:	c3                   	retq   

000000000010b5a0 <ivshmem_api_int_peer>:

static int ivshmem_api_int_peer(const struct device *dev, uint32_t peer_id, uint16_t vector)
{
#if CONFIG_IVSHMEM_DOORBELL
	struct ivshmem_reg *regs = (struct ivshmem_reg *)DEVICE_MMIO_GET(dev);
  10b5a0:	48 8b 4f 20          	mov    0x20(%rdi),%rcx
	struct ivshmem *data = dev->data;
	uint32_t doorbell;

	if (vector >= data->n_vectors) {
		return -EINVAL;
  10b5a4:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
	struct ivshmem_reg *regs = (struct ivshmem_reg *)DEVICE_MMIO_GET(dev);
  10b5a9:	48 8b 39             	mov    (%rcx),%rdi
	if (vector >= data->n_vectors) {
  10b5ac:	66 39 51 60          	cmp    %dx,0x60(%rcx)
  10b5b0:	76 0d                	jbe    10b5bf <ivshmem_api_int_peer+0x1f>
	}

	doorbell = IVSHMEM_GEN_DOORBELL(peer_id, vector);
  10b5b2:	c1 e6 10             	shl    $0x10,%esi
  10b5b5:	0f b7 d2             	movzwl %dx,%edx
	regs->doorbell = doorbell;

	return 0;
  10b5b8:	31 c0                	xor    %eax,%eax
	doorbell = IVSHMEM_GEN_DOORBELL(peer_id, vector);
  10b5ba:	09 d6                	or     %edx,%esi
  10b5bc:	89 77 0c             	mov    %esi,0xc(%rdi)
#else
	return -ENOSYS;
#endif
}
  10b5bf:	c3                   	retq   

000000000010b5c0 <ivshmem_api_register_handler>:

static int ivshmem_api_register_handler(const struct device *dev, struct k_poll_signal *signal,
					uint16_t vector)
{
#if CONFIG_IVSHMEM_DOORBELL
	struct ivshmem *data = dev->data;
  10b5c0:	48 8b 4f 20          	mov    0x20(%rdi),%rcx

	if (vector >= data->n_vectors) {
		return -EINVAL;
  10b5c4:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
	if (vector >= data->n_vectors) {
  10b5c9:	66 39 51 60          	cmp    %dx,0x60(%rcx)
  10b5cd:	76 0e                	jbe    10b5dd <ivshmem_api_register_handler+0x1d>
	data->params[vector].signal = signal;
  10b5cf:	0f b7 d2             	movzwl %dx,%edx
	}

	register_signal(dev, signal, vector);

	return 0;
  10b5d2:	31 c0                	xor    %eax,%eax
	data->params[vector].signal = signal;
  10b5d4:	48 6b d2 18          	imul   $0x18,%rdx,%rdx
  10b5d8:	48 89 74 11 50       	mov    %rsi,0x50(%rcx,%rdx,1)
#else
	return -ENOSYS;
#endif
}
  10b5dd:	c3                   	retq   

000000000010b5de <ivshmem_api_get_semaphore>:

// eigenbau
static int ivshmem_api_get_semaphore(const struct device *dev)
{
  10b5de:	55                   	push   %rbp
	struct ivshmem *data = dev->data;
	struct sys_sem *sem = &data->sem_isr;
  10b5df:	48 8b 7f 20          	mov    0x20(%rdi),%rdi

	// take the semaphore from the isr
	//LOG_DBG("test 200 ivshmem_get_semaphore Adresse sem: %p", sem);
	sys_sem_take(sem, K_FOREVER);
  10b5e3:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
	struct sys_sem *sem = &data->sem_isr;
  10b5e7:	48 83 c7 20          	add    $0x20,%rdi
{
  10b5eb:	48 89 e5             	mov    %rsp,%rbp
	sys_sem_take(sem, K_FOREVER);
  10b5ee:	e8 40 59 ff ff       	callq  100f33 <sys_sem_take>

	return 0;
}
  10b5f3:	31 c0                	xor    %eax,%eax
  10b5f5:	5d                   	pop    %rbp
  10b5f6:	c3                   	retq   

000000000010b5f7 <ivshmem_init>:
	.register_handler = ivshmem_api_register_handler,
};*/

// eigenbau
static int ivshmem_init(const struct device *dev)
{
  10b5f7:	55                   	push   %rbp
  10b5f8:	48 89 e5             	mov    %rsp,%rbp
  10b5fb:	41 57                	push   %r15
  10b5fd:	41 56                	push   %r14
  10b5ff:	41 55                	push   %r13
  10b601:	41 54                	push   %r12
  10b603:	49 89 fc             	mov    %rdi,%r12
  10b606:	53                   	push   %rbx
  10b607:	48 83 ec 38          	sub    $0x38,%rsp
	struct ivshmem *data = dev->data;
  10b60b:	48 8b 5f 20          	mov    0x20(%rdi),%rbx
		LOG_WRN("ivshmem device not found");
		return -ENOTSUP;
	}*/
	//////////////////////////////////////////////////////////////////////////////

	if ((data->bdf == PCIE_BDF_NONE) && !bdf_lookup_done) {
  10b60f:	83 7b 08 ff          	cmpl   $0xffffffff,0x8(%rbx)
	struct sys_sem *sem = &data->sem_isr;
  10b613:	4c 8d 6b 20          	lea    0x20(%rbx),%r13
	if ((data->bdf == PCIE_BDF_NONE) && !bdf_lookup_done) {
  10b617:	75 3e                	jne    10b657 <ivshmem_init+0x60>
  10b619:	80 3d 2a 18 0b 00 00 	cmpb   $0x0,0xb182a(%rip)        # 1bce4a <bdf_lookup_done.0>
  10b620:	75 35                	jne    10b657 <ivshmem_init+0x60>
		if (data->dev_ven_id) {
  10b622:	8b 7b 0c             	mov    0xc(%rbx),%edi
  10b625:	85 ff                	test   %edi,%edi
  10b627:	75 05                	jne    10b62e <ivshmem_init+0x37>
			data->bdf = pcie_bdf_lookup(data->dev_ven_id);
		}

		else {
			data->bdf = pcie_bdf_lookup(PCIE_ID(IVSHMEM_VENDOR_ID, IVSHMEM_DEVICE_ID));
  10b629:	bf f4 1a 10 11       	mov    $0x11101af4,%edi
  10b62e:	e8 05 f8 ff ff       	callq  10ae38 <pcie_bdf_lookup>
  10b633:	89 43 08             	mov    %eax,0x8(%rbx)
		}

		if (data->bdf == PCIE_BDF_NONE) {
  10b636:	83 7b 08 ff          	cmpl   $0xffffffff,0x8(%rbx)
  10b63a:	75 1b                	jne    10b657 <ivshmem_init+0x60>
			LOG_WRN("ivshmem device not found");
  10b63c:	31 c0                	xor    %eax,%eax
  10b63e:	be 57 00 00 00       	mov    $0x57,%esi
  10b643:	bf 92 ee 11 00       	mov    $0x11ee92,%edi
  10b648:	e8 79 7a ff ff       	callq  1030c6 <z_log_minimal_printk>
			return -ENOTSUP;
  10b64d:	b8 7a ff ff ff       	mov    $0xffffff7a,%eax
  10b652:	e9 04 02 00 00       	jmpq   10b85b <ivshmem_init+0x264>
		}
	}

	LOG_DBG("ivshmem found at bdf 0x%x", data->bdf);
  10b657:	8b 53 08             	mov    0x8(%rbx),%edx
  10b65a:	31 c0                	xor    %eax,%eax
  10b65c:	be 44 00 00 00       	mov    $0x44,%esi
  10b661:	bf b0 ee 11 00       	mov    $0x11eeb0,%edi
  10b666:	e8 5b 7a ff ff       	callq  1030c6 <z_log_minimal_printk>

	bdf_lookup_done = true; ///////////////////////////////////////////////

	test = sys_sem_init(sem, 0, 1);
  10b66b:	31 f6                	xor    %esi,%esi
  10b66d:	ba 01 00 00 00       	mov    $0x1,%edx
  10b672:	4c 89 ef             	mov    %r13,%rdi
	bdf_lookup_done = true; ///////////////////////////////////////////////
  10b675:	c6 05 ce 17 0b 00 01 	movb   $0x1,0xb17ce(%rip)        # 1bce4a <bdf_lookup_done.0>
	test = sys_sem_init(sem, 0, 1);
  10b67c:	e8 2d 58 ff ff       	callq  100eae <sys_sem_init>
	struct ivshmem *data = dev->data;
  10b681:	49 8b 5c 24 20       	mov    0x20(%r12),%rbx
	if (!pcie_get_mbar(data->bdf, IVSHMEM_PCIE_REG_BAR_IDX, &mbar_regs)) {
  10b686:	31 f6                	xor    %esi,%esi
  10b688:	48 8d 55 b0          	lea    -0x50(%rbp),%rdx
  10b68c:	8b 7b 08             	mov    0x8(%rbx),%edi
  10b68f:	e8 36 f5 ff ff       	callq  10abca <pcie_get_mbar>
  10b694:	84 c0                	test   %al,%al
  10b696:	75 0c                	jne    10b6a4 <ivshmem_init+0xad>
		LOG_ERR("ivshmem regs bar not found");
  10b698:	be 45 00 00 00       	mov    $0x45,%esi
  10b69d:	bf cf ee 11 00       	mov    $0x11eecf,%edi
  10b6a2:	eb 48                	jmp    10b6ec <ivshmem_init+0xf5>
		pcie_set_cmd(data->bdf, PCIE_CONF_CMDSTAT_MEM, true);
  10b6a4:	8b 7b 08             	mov    0x8(%rbx),%edi
  10b6a7:	ba 01 00 00 00       	mov    $0x1,%edx
  10b6ac:	be 02 00 00 00       	mov    $0x2,%esi
  10b6b1:	e8 6e f4 ff ff       	callq  10ab24 <pcie_set_cmd>
  10b6b6:	49 8b 7c 24 20       	mov    0x20(%r12),%rdi
  10b6bb:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  10b6bf:	b9 0a 00 00 00       	mov    $0xa,%ecx
  10b6c4:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  10b6c8:	e8 33 8c 00 00       	callq  114300 <z_phys_map>
	if (!pcie_get_mbar(data->bdf, IVSHMEM_PCIE_SHMEM_BAR_IDX, &mbar_mem)) {
  10b6cd:	8b 7b 08             	mov    0x8(%rbx),%edi
  10b6d0:	48 8d 55 c0          	lea    -0x40(%rbp),%rdx
  10b6d4:	be 02 00 00 00       	mov    $0x2,%esi
  10b6d9:	e8 ec f4 ff ff       	callq  10abca <pcie_get_mbar>
  10b6de:	84 c0                	test   %al,%al
  10b6e0:	75 19                	jne    10b6fb <ivshmem_init+0x104>
		LOG_ERR("ivshmem mem bar not found");
  10b6e2:	be 45 00 00 00       	mov    $0x45,%esi
  10b6e7:	bf ef ee 11 00       	mov    $0x11eeef,%edi
  10b6ec:	e8 d5 79 ff ff       	callq  1030c6 <z_log_minimal_printk>
	//LOG_DBG("sem init: %d", test);
	//LOG_DBG("sem init Adresse sem: %p", sem);

	if (!ivshmem_configure(dev)) {
		return -EIO;
  10b6f1:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
  10b6f6:	e9 60 01 00 00       	jmpq   10b85b <ivshmem_init+0x264>
	data->size = mbar_mem.size;
  10b6fb:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
	z_phys_map((uint8_t **)&data->shmem, mbar_mem.phys_addr, data->size,
  10b6ff:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  10b703:	48 8d 7b 10          	lea    0x10(%rbx),%rdi
  10b707:	b9 28 00 00 00       	mov    $0x28,%ecx
	data->size = mbar_mem.size;
  10b70c:	48 89 53 18          	mov    %rdx,0x18(%rbx)
	z_phys_map((uint8_t **)&data->shmem, mbar_mem.phys_addr, data->size,
  10b710:	e8 eb 8b 00 00       	callq  114300 <z_phys_map>
	LOG_DBG("ivshmem configured:");
  10b715:	31 c0                	xor    %eax,%eax
  10b717:	be 44 00 00 00       	mov    $0x44,%esi
  10b71c:	bf 0e ef 11 00       	mov    $0x11ef0e,%edi
  10b721:	e8 a0 79 ff ff       	callq  1030c6 <z_log_minimal_printk>
	LOG_DBG("- Registers at 0x%lx (mapped to 0x%lx)", mbar_regs.phys_addr,
  10b726:	49 8b 44 24 20       	mov    0x20(%r12),%rax
  10b72b:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  10b72f:	be 44 00 00 00       	mov    $0x44,%esi
  10b734:	bf 27 ef 11 00       	mov    $0x11ef27,%edi
  10b739:	48 8b 08             	mov    (%rax),%rcx
  10b73c:	31 c0                	xor    %eax,%eax
  10b73e:	e8 83 79 ff ff       	callq  1030c6 <z_log_minimal_printk>
	LOG_DBG("- Shared memory of %lu bytes at 0x%lx (mapped to 0x%lx)", data->size,
  10b743:	48 8b 53 18          	mov    0x18(%rbx),%rdx
  10b747:	4c 8b 43 10          	mov    0x10(%rbx),%r8
  10b74b:	31 c0                	xor    %eax,%eax
  10b74d:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  10b751:	be 44 00 00 00       	mov    $0x44,%esi
  10b756:	bf 53 ef 11 00       	mov    $0x11ef53,%edi
  10b75b:	e8 66 79 ff ff       	callq  1030c6 <z_log_minimal_printk>
	struct ivshmem *data = dev->data;
  10b760:	4d 8b 7c 24 20       	mov    0x20(%r12),%r15
  10b765:	9c                   	pushfq 
  10b766:	fa                   	cli    
  10b767:	8f 45 a8             	popq   -0x58(%rbp)
	n_vectors = pcie_msi_vectors_allocate(data->bdf, CONFIG_IVSHMEM_INT_PRIORITY, data->vectors,
  10b76a:	41 8b 7f 08          	mov    0x8(%r15),%edi
  10b76e:	4d 8d 77 28          	lea    0x28(%r15),%r14
  10b772:	b9 01 00 00 00       	mov    $0x1,%ecx
  10b777:	be 02 00 00 00       	mov    $0x2,%esi
  10b77c:	4c 89 f2             	mov    %r14,%rdx
  10b77f:	e8 36 f7 ff ff       	callq  10aeba <pcie_msi_vectors_allocate>
  10b784:	44 0f b6 e8          	movzbl %al,%r13d
	if (n_vectors == 0) {
  10b788:	45 84 ed             	test   %r13b,%r13b
  10b78b:	75 1d                	jne    10b7aa <ivshmem_init+0x1b3>
		LOG_ERR("Could not allocate %u MSI-X vectors", CONFIG_IVSHMEM_MSI_X_VECTORS);
  10b78d:	ba 01 00 00 00       	mov    $0x1,%edx
  10b792:	be 45 00 00 00       	mov    $0x45,%esi
  10b797:	31 c0                	xor    %eax,%eax
	bool ret = false;
  10b799:	31 db                	xor    %ebx,%ebx
		LOG_ERR("Could not allocate %u MSI-X vectors", CONFIG_IVSHMEM_MSI_X_VECTORS);
  10b79b:	bf 90 ef 11 00       	mov    $0x11ef90,%edi
  10b7a0:	e8 21 79 ff ff       	callq  1030c6 <z_log_minimal_printk>
		goto out;
  10b7a5:	e9 a1 00 00 00       	jmpq   10b84b <ivshmem_init+0x254>
	LOG_DBG("Allocated %u vectors", n_vectors);
  10b7aa:	41 0f b6 d5          	movzbl %r13b,%edx
  10b7ae:	be 44 00 00 00       	mov    $0x44,%esi
  10b7b3:	bf b9 ef 11 00       	mov    $0x11efb9,%edi
  10b7b8:	31 c0                	xor    %eax,%eax
  10b7ba:	e8 07 79 ff ff       	callq  1030c6 <z_log_minimal_printk>
		data->params[i].dev = dev;
  10b7bf:	4d 89 67 48          	mov    %r12,0x48(%r15)
		if (!pcie_msi_vector_connect(data->bdf, &data->vectors[i], ivshmem_doorbell, dev,
  10b7c3:	41 8b 7f 08          	mov    0x8(%r15),%edi
  10b7c7:	45 31 c0             	xor    %r8d,%r8d
		data->params[i].vector = i;
  10b7ca:	41 c6 47 58 00       	movb   $0x0,0x58(%r15)
		if (!pcie_msi_vector_connect(data->bdf, &data->vectors[i], ivshmem_doorbell, dev,
  10b7cf:	4c 89 e1             	mov    %r12,%rcx
  10b7d2:	ba 6a b8 10 00       	mov    $0x10b86a,%edx
  10b7d7:	4c 89 f6             	mov    %r14,%rsi
  10b7da:	e8 17 f8 ff ff       	callq  10aff6 <pcie_msi_vector_connect>
  10b7df:	89 c3                	mov    %eax,%ebx
  10b7e1:	84 c0                	test   %al,%al
  10b7e3:	75 15                	jne    10b7fa <ivshmem_init+0x203>
			LOG_ERR("Failed to connect MSI-X vector %u", i);
  10b7e5:	31 d2                	xor    %edx,%edx
  10b7e7:	be 45 00 00 00       	mov    $0x45,%esi
  10b7ec:	bf d3 ef 11 00       	mov    $0x11efd3,%edi
  10b7f1:	31 c0                	xor    %eax,%eax
  10b7f3:	e8 ce 78 ff ff       	callq  1030c6 <z_log_minimal_printk>
			goto out;
  10b7f8:	eb 51                	jmp    10b84b <ivshmem_init+0x254>
	LOG_DBG("%u MSI-X Vectors connected", n_vectors);
  10b7fa:	ba 01 00 00 00       	mov    $0x1,%edx
  10b7ff:	be 44 00 00 00       	mov    $0x44,%esi
  10b804:	bf fa ef 11 00       	mov    $0x11effa,%edi
  10b809:	31 c0                	xor    %eax,%eax
  10b80b:	e8 b6 78 ff ff       	callq  1030c6 <z_log_minimal_printk>
	if (!pcie_msi_enable(data->bdf, data->vectors, n_vectors, 0)) {
  10b810:	41 8b 7f 08          	mov    0x8(%r15),%edi
  10b814:	31 c9                	xor    %ecx,%ecx
  10b816:	ba 01 00 00 00       	mov    $0x1,%edx
  10b81b:	4c 89 f6             	mov    %r14,%rsi
  10b81e:	e8 45 f8 ff ff       	callq  10b068 <pcie_msi_enable>
  10b823:	89 c3                	mov    %eax,%ebx
  10b825:	84 c0                	test   %al,%al
  10b827:	75 0c                	jne    10b835 <ivshmem_init+0x23e>
		LOG_ERR("Could not enable MSI-X");
  10b829:	be 45 00 00 00       	mov    $0x45,%esi
  10b82e:	bf 1a f0 11 00       	mov    $0x11f01a,%edi
  10b833:	eb 0f                	jmp    10b844 <ivshmem_init+0x24d>
	data->n_vectors = n_vectors;
  10b835:	66 45 89 6f 60       	mov    %r13w,0x60(%r15)
	LOG_DBG("MSI-X configured");
  10b83a:	be 44 00 00 00       	mov    $0x44,%esi
  10b83f:	bf 36 f0 11 00       	mov    $0x11f036,%edi
  10b844:	31 c0                	xor    %eax,%eax
  10b846:	e8 7b 78 ff ff       	callq  1030c6 <z_log_minimal_printk>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  10b84b:	0f ba 65 a8 09       	btl    $0x9,-0x58(%rbp)
  10b850:	73 01                	jae    10b853 <ivshmem_init+0x25c>
		__asm__ volatile ("sti" ::: "memory");
  10b852:	fb                   	sti    
		return -EIO;
  10b853:	80 fb 01             	cmp    $0x1,%bl
  10b856:	19 c0                	sbb    %eax,%eax
  10b858:	83 e0 fb             	and    $0xfffffffb,%eax
	}

	return 0;
}
  10b85b:	48 83 c4 38          	add    $0x38,%rsp
  10b85f:	5b                   	pop    %rbx
  10b860:	41 5c                	pop    %r12
  10b862:	41 5d                	pop    %r13
  10b864:	41 5e                	pop    %r14
  10b866:	41 5f                	pop    %r15
  10b868:	5d                   	pop    %rbp
  10b869:	c3                   	retq   

000000000010b86a <ivshmem_doorbell>:
{
  10b86a:	55                   	push   %rbp
  10b86b:	48 89 e5             	mov    %rsp,%rbp
  10b86e:	53                   	push   %rbx
  10b86f:	51                   	push   %rcx
	struct ivshmem *data = dev->data;
  10b870:	48 8b 5f 20          	mov    0x20(%rdi),%rbx
	struct sys_sem *sem = &data->sem_isr;
  10b874:	48 8d 7b 20          	lea    0x20(%rbx),%rdi
	sys_sem_give(sem);
  10b878:	e8 50 56 ff ff       	callq  100ecd <sys_sem_give>
	if (data->params[0].signal != NULL) {
  10b87d:	48 8b 7b 50          	mov    0x50(%rbx),%rdi
  10b881:	48 85 ff             	test   %rdi,%rdi
  10b884:	74 0c                	je     10b892 <ivshmem_doorbell+0x28>
		k_poll_signal_raise(data->params[0].signal, data->params[0].vector);
  10b886:	0f b6 73 58          	movzbl 0x58(%rbx),%esi
}
  10b88a:	5a                   	pop    %rdx
  10b88b:	5b                   	pop    %rbx
  10b88c:	5d                   	pop    %rbp
	return z_impl_k_poll_signal_raise(sig, result);
  10b88d:	e9 2d 9f 00 00       	jmpq   1157bf <z_impl_k_poll_signal_raise>
  10b892:	58                   	pop    %rax
  10b893:	5b                   	pop    %rbx
  10b894:	5d                   	pop    %rbp
  10b895:	c3                   	retq   

000000000010b896 <get_ivshmem>:

#endif /* CONFIG_IVSHMEM_DOORBELL */

static bool get_ivshmem(const struct shell *shell)
{
	if (ivshmem == NULL) {
  10b896:	48 83 3d f2 14 0b 00 	cmpq   $0x0,0xb14f2(%rip)        # 1bcd90 <ivshmem>
  10b89d:	00 
  10b89e:	75 42                	jne    10b8e2 <get_ivshmem+0x4c>
{
  10b8a0:	55                   	push   %rbp
  10b8a1:	48 89 e5             	mov    %rsp,%rbp
  10b8a4:	41 54                	push   %r12
  10b8a6:	49 89 fc             	mov    %rdi,%r12
  10b8a9:	51                   	push   %rcx
	return z_impl_device_get_binding(name);
  10b8aa:	bf c1 ce 11 00       	mov    $0x11cec1,%edi
  10b8af:	e8 ba 15 00 00       	callq  10ce6e <z_impl_device_get_binding>
		ivshmem = device_get_binding(CONFIG_IVSHMEM_DEV_NAME);
  10b8b4:	48 89 05 d5 14 0b 00 	mov    %rax,0xb14d5(%rip)        # 1bcd90 <ivshmem>
		if (!ivshmem) {
  10b8bb:	48 85 c0             	test   %rax,%rax
  10b8be:	75 12                	jne    10b8d2 <get_ivshmem+0x3c>
			shell_error(shell, "IVshmem device cannot be found");
  10b8c0:	ba 72 f0 11 00       	mov    $0x11f072,%edx
  10b8c5:	be 02 00 00 00       	mov    $0x2,%esi
  10b8ca:	4c 89 e7             	mov    %r12,%rdi
  10b8cd:	e8 c1 a2 ff ff       	callq  105b93 <shell_fprintf>
		}
	}

	return ivshmem != NULL ? true : false;
  10b8d2:	48 83 3d b6 14 0b 00 	cmpq   $0x0,0xb14b6(%rip)        # 1bcd90 <ivshmem>
  10b8d9:	00 
}
  10b8da:	5a                   	pop    %rdx
	return ivshmem != NULL ? true : false;
  10b8db:	0f 95 c0             	setne  %al
}
  10b8de:	41 5c                	pop    %r12
  10b8e0:	5d                   	pop    %rbp
  10b8e1:	c3                   	retq   
	return ivshmem != NULL ? true : false;
  10b8e2:	48 83 3d a6 14 0b 00 	cmpq   $0x0,0xb14a6(%rip)        # 1bcd90 <ivshmem>
  10b8e9:	00 
  10b8ea:	0f 95 c0             	setne  %al
}
  10b8ed:	c3                   	retq   

000000000010b8ee <cmd_ivshmem_int>:
	return 0;
}

static int cmd_ivshmem_int(const struct shell *shell,
			   size_t argc, char **argv)
{
  10b8ee:	55                   	push   %rbp
  10b8ef:	48 89 e5             	mov    %rsp,%rbp
  10b8f2:	41 55                	push   %r13
  10b8f4:	49 89 d5             	mov    %rdx,%r13
  10b8f7:	41 54                	push   %r12
  10b8f9:	49 89 fc             	mov    %rdi,%r12
  10b8fc:	53                   	push   %rbx
  10b8fd:	48 83 ec 18          	sub    $0x18,%rsp
	if (!IS_ENABLED(CONFIG_IVSHMEM_DOORBELL)) {
		shell_error(shell, "CONFIG_IVSHMEM_DOORBELL is not enabled");
		return 0;
	}

	if (!get_ivshmem(shell)) {
  10b901:	e8 90 ff ff ff       	callq  10b896 <get_ivshmem>
		return 0;
  10b906:	45 31 c9             	xor    %r9d,%r9d
	if (!get_ivshmem(shell)) {
  10b909:	84 c0                	test   %al,%al
  10b90b:	74 7e                	je     10b98b <cmd_ivshmem_int+0x9d>
	}

	peer_id = strtol(argv[1], NULL, 10);
  10b90d:	49 8b 7d 08          	mov    0x8(%r13),%rdi
  10b911:	31 f6                	xor    %esi,%esi
  10b913:	ba 0a 00 00 00       	mov    $0xa,%edx
  10b918:	e8 14 e3 ff ff       	callq  109c31 <strtol>
	vector = strtol(argv[2], NULL, 10);
  10b91d:	49 8b 7d 10          	mov    0x10(%r13),%rdi
  10b921:	ba 0a 00 00 00       	mov    $0xa,%edx
  10b926:	31 f6                	xor    %esi,%esi
	peer_id = strtol(argv[1], NULL, 10);
  10b928:	48 89 c3             	mov    %rax,%rbx
	vector = strtol(argv[2], NULL, 10);
  10b92b:	e8 01 e3 ff ff       	callq  109c31 <strtol>

	ret = ivshmem_int_peer(ivshmem, (uint16_t)peer_id, (uint16_t)vector);
  10b930:	48 8b 3d 59 14 0b 00 	mov    0xb1459(%rip),%rdi        # 1bcd90 <ivshmem>
  10b937:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  10b93b:	0f b7 d0             	movzwl %ax,%edx
	return api->int_peer(dev, peer_id, vector);
  10b93e:	48 8b 47 10          	mov    0x10(%rdi),%rax
  10b942:	0f b7 f3             	movzwl %bx,%esi
  10b945:	ff 50 18             	callq  *0x18(%rax)
	if (ret != 0) {
  10b948:	4c 8b 45 d8          	mov    -0x28(%rbp),%r8
  10b94c:	85 c0                	test   %eax,%eax
  10b94e:	41 89 c1             	mov    %eax,%r9d
  10b951:	74 1e                	je     10b971 <cmd_ivshmem_int+0x83>
		shell_error(shell,
  10b953:	89 d9                	mov    %ebx,%ecx
  10b955:	ba 92 f0 11 00       	mov    $0x11f092,%edx
  10b95a:	be 02 00 00 00       	mov    $0x2,%esi
  10b95f:	4c 89 e7             	mov    %r12,%rdi
  10b962:	31 c0                	xor    %eax,%eax
  10b964:	e8 2a a2 ff ff       	callq  105b93 <shell_fprintf>
			    "Could not notify peer %u on %u. status %d",
			    peer_id, vector, ret);
		return -EIO;
  10b969:	41 b9 fb ff ff ff    	mov    $0xfffffffb,%r9d
  10b96f:	eb 1a                	jmp    10b98b <cmd_ivshmem_int+0x9d>
  10b971:	89 45 d8             	mov    %eax,-0x28(%rbp)
	}

	shell_fprintf(shell, SHELL_NORMAL,
  10b974:	89 d9                	mov    %ebx,%ecx
  10b976:	ba bd f0 11 00       	mov    $0x11f0bd,%edx
  10b97b:	31 f6                	xor    %esi,%esi
  10b97d:	4c 89 e7             	mov    %r12,%rdi
  10b980:	31 c0                	xor    %eax,%eax
  10b982:	e8 0c a2 ff ff       	callq  105b93 <shell_fprintf>
  10b987:	44 8b 4d d8          	mov    -0x28(%rbp),%r9d
		      "Notification sent to peer %u on vector %u\n",
		      peer_id, vector);

	return 0;
}
  10b98b:	48 83 c4 18          	add    $0x18,%rsp
  10b98f:	44 89 c8             	mov    %r9d,%eax
  10b992:	5b                   	pop    %rbx
  10b993:	41 5c                	pop    %r12
  10b995:	41 5d                	pop    %r13
  10b997:	5d                   	pop    %rbp
  10b998:	c3                   	retq   

000000000010b999 <cmd_ivshmem_dump>:
{
  10b999:	55                   	push   %rbp
  10b99a:	48 89 e5             	mov    %rsp,%rbp
  10b99d:	41 55                	push   %r13
  10b99f:	49 89 d5             	mov    %rdx,%r13
  10b9a2:	41 54                	push   %r12
  10b9a4:	49 89 fc             	mov    %rdi,%r12
  10b9a7:	53                   	push   %rbx
  10b9a8:	48 83 ec 18          	sub    $0x18,%rsp
	if (!get_ivshmem(shell)) {
  10b9ac:	e8 e5 fe ff ff       	callq  10b896 <get_ivshmem>
  10b9b1:	84 c0                	test   %al,%al
  10b9b3:	0f 84 81 00 00 00    	je     10ba3a <cmd_ivshmem_dump+0xa1>
	dump_pos = strtol(argv[1], NULL, 10);
  10b9b9:	49 8b 7d 08          	mov    0x8(%r13),%rdi
  10b9bd:	31 f6                	xor    %esi,%esi
  10b9bf:	ba 0a 00 00 00       	mov    $0xa,%edx
  10b9c4:	e8 68 e2 ff ff       	callq  109c31 <strtol>
	dump_size = strtol(argv[2], NULL, 10);
  10b9c9:	49 8b 7d 10          	mov    0x10(%r13),%rdi
  10b9cd:	ba 0a 00 00 00       	mov    $0xa,%edx
  10b9d2:	31 f6                	xor    %esi,%esi
	dump_pos = strtol(argv[1], NULL, 10);
  10b9d4:	48 89 c3             	mov    %rax,%rbx
	dump_size = strtol(argv[2], NULL, 10);
  10b9d7:	e8 55 e2 ff ff       	callq  109c31 <strtol>
	size = ivshmem_get_mem(ivshmem, &mem);
  10b9dc:	48 8b 3d ad 13 0b 00 	mov    0xb13ad(%rip),%rdi        # 1bcd90 <ivshmem>
	dump_size = strtol(argv[2], NULL, 10);
  10b9e3:	49 89 c5             	mov    %rax,%r13
	return api->get_mem(dev, memmap);
  10b9e6:	48 8b 47 10          	mov    0x10(%rdi),%rax
  10b9ea:	48 8d 75 d8          	lea    -0x28(%rbp),%rsi
  10b9ee:	ff 10                	callq  *(%rax)
		shell_error(shell, "Size is too big");
  10b9f0:	ba e8 f0 11 00       	mov    $0x11f0e8,%edx
	if (dump_size > size) {
  10b9f5:	49 39 c5             	cmp    %rax,%r13
  10b9f8:	77 24                	ja     10ba1e <cmd_ivshmem_dump+0x85>
		shell_error(shell, "Position is out of the shared memory");
  10b9fa:	ba f9 f0 11 00       	mov    $0x11f0f9,%edx
	} else if (dump_pos > size) {
  10b9ff:	48 39 c3             	cmp    %rax,%rbx
  10ba02:	77 1a                	ja     10ba1e <cmd_ivshmem_dump+0x85>
	} else if ((mem + dump_pos + dump_size) > (mem + size)) {
  10ba04:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  10ba08:	48 8d 34 13          	lea    (%rbx,%rdx,1),%rsi
  10ba0c:	48 01 d0             	add    %rdx,%rax
  10ba0f:	49 8d 4c 35 00       	lea    0x0(%r13,%rsi,1),%rcx
  10ba14:	48 39 c1             	cmp    %rax,%rcx
  10ba17:	76 16                	jbe    10ba2f <cmd_ivshmem_dump+0x96>
		shell_error(shell, "Position and size overflow");
  10ba19:	ba 1f f1 11 00       	mov    $0x11f11f,%edx
  10ba1e:	be 02 00 00 00       	mov    $0x2,%esi
  10ba23:	4c 89 e7             	mov    %r12,%rdi
  10ba26:	31 c0                	xor    %eax,%eax
  10ba28:	e8 66 a1 ff ff       	callq  105b93 <shell_fprintf>
  10ba2d:	eb 0b                	jmp    10ba3a <cmd_ivshmem_dump+0xa1>
		shell_hexdump(shell, (const uint8_t *)mem+dump_pos, dump_size);
  10ba2f:	4c 89 ea             	mov    %r13,%rdx
  10ba32:	4c 89 e7             	mov    %r12,%rdi
  10ba35:	e8 48 a3 ff ff       	callq  105d82 <shell_hexdump>
}
  10ba3a:	48 83 c4 18          	add    $0x18,%rsp
  10ba3e:	31 c0                	xor    %eax,%eax
  10ba40:	5b                   	pop    %rbx
  10ba41:	41 5c                	pop    %r12
  10ba43:	41 5d                	pop    %r13
  10ba45:	5d                   	pop    %rbp
  10ba46:	c3                   	retq   

000000000010ba47 <cmd_ivshmem_get_notified>:

static int cmd_ivshmem_get_notified(const struct shell *shell,
				    size_t argc, char **argv)
{
  10ba47:	55                   	push   %rbp
  10ba48:	48 89 e5             	mov    %rsp,%rbp
  10ba4b:	41 56                	push   %r14
  10ba4d:	41 55                	push   %r13
  10ba4f:	49 89 fd             	mov    %rdi,%r13
  10ba52:	41 54                	push   %r12
  10ba54:	49 89 d4             	mov    %rdx,%r12
  10ba57:	48 83 ec 18          	sub    $0x18,%rsp
#ifdef CONFIG_IVSHMEM_DOORBELL
	int vector;

	if (!get_ivshmem(shell)) {
  10ba5b:	e8 36 fe ff ff       	callq  10b896 <get_ivshmem>
  10ba60:	84 c0                	test   %al,%al
  10ba62:	75 08                	jne    10ba6c <cmd_ivshmem_get_notified+0x25>
		return 0;
  10ba64:	45 31 e4             	xor    %r12d,%r12d
  10ba67:	e9 da 00 00 00       	jmpq   10bb46 <cmd_ivshmem_get_notified+0xff>
	}

	vector = strtol(argv[1], NULL, 10);
  10ba6c:	49 8b 7c 24 08       	mov    0x8(%r12),%rdi
  10ba71:	ba 0a 00 00 00       	mov    $0xa,%edx
  10ba76:	31 f6                	xor    %esi,%esi
  10ba78:	e8 b4 e1 ff ff       	callq  109c31 <strtol>

	if (ivshmem_register_handler(ivshmem, &doorbell_sig,
  10ba7d:	48 8b 3d 0c 13 0b 00 	mov    0xb130c(%rip),%rdi        # 1bcd90 <ivshmem>
  10ba84:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  10ba88:	0f b7 d0             	movzwl %ax,%edx
	return api->register_handler(dev, signal, vector);
  10ba8b:	48 8b 47 10          	mov    0x10(%rdi),%rax
  10ba8f:	be 70 13 5e 00       	mov    $0x5e1370,%esi
  10ba94:	ff 50 20             	callq  *0x20(%rax)
  10ba97:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  10ba9b:	85 c0                	test   %eax,%eax
  10ba9d:	41 89 c4             	mov    %eax,%r12d
  10baa0:	74 1f                	je     10bac1 <cmd_ivshmem_get_notified+0x7a>
				     (uint16_t)vector)) {
		shell_error(shell, "Could not get notifications on vector %u",
  10baa2:	ba 3b f1 11 00       	mov    $0x11f13b,%edx
  10baa7:	be 02 00 00 00       	mov    $0x2,%esi
  10baac:	4c 89 ef             	mov    %r13,%rdi
  10baaf:	31 c0                	xor    %eax,%eax
  10bab1:	e8 dd a0 ff ff       	callq  105b93 <shell_fprintf>
			    vector);
		return -EIO;
  10bab6:	41 bc fb ff ff ff    	mov    $0xfffffffb,%r12d
  10babc:	e9 85 00 00 00       	jmpq   10bb46 <cmd_ivshmem_get_notified+0xff>
	}

	shell_fprintf(shell, SHELL_NORMAL,
  10bac1:	31 f6                	xor    %esi,%esi
  10bac3:	31 c0                	xor    %eax,%eax
  10bac5:	ba 65 f1 11 00       	mov    $0x11f165,%edx
  10baca:	4c 89 ef             	mov    %r13,%rdi
  10bacd:	e8 c1 a0 ff ff       	callq  105b93 <shell_fprintf>
		      "Notifications enabled for vector %u\n", vector);

	if (!doorbell_started) {
  10bad2:	80 3d 72 13 0b 00 00 	cmpb   $0x0,0xb1372(%rip)        # 1bce4b <doorbell_started>
  10bad9:	75 89                	jne    10ba64 <cmd_ivshmem_get_notified+0x1d>
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
  10badb:	6a 00                	pushq  $0x0
  10badd:	45 31 c9             	xor    %r9d,%r9d
  10bae0:	4d 89 e8             	mov    %r13,%r8
  10bae3:	b9 55 bb 10 00       	mov    $0x10bb55,%ecx
  10bae8:	6a 00                	pushq  $0x0
  10baea:	ba 00 02 00 00       	mov    $0x200,%edx
  10baef:	be 00 a0 5d 00       	mov    $0x5da000,%esi
  10baf4:	bf a0 7b 12 00       	mov    $0x127ba0,%edi
  10baf9:	6a f2                	pushq  $0xfffffffffffffff2
  10bafb:	6a 00                	pushq  $0x0
  10bafd:	e8 73 23 00 00       	callq  10de75 <z_impl_k_thread_create>
  10bb02:	48 83 c4 20          	add    $0x20,%rsp
  10bb06:	49 89 c6             	mov    %rax,%r14
			&doorbell_thread,
			doorbell_stack, STACK_SIZE,
			(k_thread_entry_t)doorbell_notification_thread,
			(void *)shell, NULL, NULL,
			K_PRIO_COOP(2), 0, K_NO_WAIT);
		if (!tid) {
  10bb09:	48 85 c0             	test   %rax,%rax
  10bb0c:	75 1c                	jne    10bb2a <cmd_ivshmem_get_notified+0xe3>
			shell_error(shell, "Cannot start notification thread");
  10bb0e:	ba 8a f1 11 00       	mov    $0x11f18a,%edx
  10bb13:	be 02 00 00 00       	mov    $0x2,%esi
  10bb18:	4c 89 ef             	mov    %r13,%rdi
  10bb1b:	31 c0                	xor    %eax,%eax
  10bb1d:	e8 71 a0 ff ff       	callq  105b93 <shell_fprintf>
			return -ENOEXEC;
  10bb22:	41 bc f8 ff ff ff    	mov    $0xfffffff8,%r12d
  10bb28:	eb 1c                	jmp    10bb46 <cmd_ivshmem_get_notified+0xff>
	return z_impl_k_thread_name_set(thread, str);
  10bb2a:	be ac f1 11 00       	mov    $0x11f1ac,%esi
  10bb2f:	48 89 c7             	mov    %rax,%rdi
  10bb32:	e8 ab 1a 00 00       	callq  10d5e2 <z_impl_k_thread_name_set>
	z_impl_k_thread_start(thread);
  10bb37:	4c 89 f7             	mov    %r14,%rdi
  10bb3a:	e8 a3 1c 00 00       	callq  10d7e2 <z_impl_k_thread_start>

		k_thread_name_set(tid, "notification_thread");

		k_thread_start(tid);

		doorbell_started = true;
  10bb3f:	c6 05 05 13 0b 00 01 	movb   $0x1,0xb1305(%rip)        # 1bce4b <doorbell_started>
	}
#else
	shell_error(shell, "CONFIG_IVSHMEM_DOORBELL is not enabled");
#endif
	return 0;
}
  10bb46:	48 8d 65 e8          	lea    -0x18(%rbp),%rsp
  10bb4a:	44 89 e0             	mov    %r12d,%eax
  10bb4d:	41 5c                	pop    %r12
  10bb4f:	41 5d                	pop    %r13
  10bb51:	41 5e                	pop    %r14
  10bb53:	5d                   	pop    %rbp
  10bb54:	c3                   	retq   

000000000010bb55 <doorbell_notification_thread>:
{
  10bb55:	55                   	push   %rbp
  10bb56:	48 89 e5             	mov    %rsp,%rbp
  10bb59:	53                   	push   %rbx
  10bb5a:	48 89 fb             	mov    %rdi,%rbx
  10bb5d:	48 83 ec 18          	sub    $0x18,%rsp
	return z_impl_k_poll(events, num_events, timeout);
  10bb61:	48 83 ca ff          	or     $0xffffffffffffffff,%rdx
  10bb65:	be 01 00 00 00       	mov    $0x1,%esi
  10bb6a:	bf e0 12 5e 00       	mov    $0x5e12e0,%edi
  10bb6f:	e8 b9 93 00 00       	callq  114f2d <z_impl_k_poll>
	z_impl_k_poll_signal_check(sig, signaled, result);
  10bb74:	bf 70 13 5e 00       	mov    $0x5e1370,%edi
  10bb79:	48 8d 55 ec          	lea    -0x14(%rbp),%rdx
  10bb7d:	48 8d 75 e8          	lea    -0x18(%rbp),%rsi
  10bb81:	e8 2c 9b 00 00       	callq  1156b2 <z_impl_k_poll_signal_check>
		if (signaled == 0) {
  10bb86:	83 7d e8 00          	cmpl   $0x0,-0x18(%rbp)
  10bb8a:	74 d5                	je     10bb61 <doorbell_notification_thread+0xc>
		shell_fprintf(shell, SHELL_NORMAL,
  10bb8c:	8b 4d ec             	mov    -0x14(%rbp),%ecx
  10bb8f:	ba c0 f1 11 00       	mov    $0x11f1c0,%edx
  10bb94:	31 f6                	xor    %esi,%esi
  10bb96:	48 89 df             	mov    %rbx,%rdi
  10bb99:	31 c0                	xor    %eax,%eax
  10bb9b:	e8 f3 9f ff ff       	callq  105b93 <shell_fprintf>
	z_impl_k_poll_signal_init(sig);
  10bba0:	bf 70 13 5e 00       	mov    $0x5e1370,%edi
  10bba5:	e8 69 9a 00 00       	callq  115613 <z_impl_k_poll_signal_init>
  10bbaa:	eb b5                	jmp    10bb61 <doorbell_notification_thread+0xc>

000000000010bbac <cmd_ivshmem_shmem>:
{
  10bbac:	55                   	push   %rbp
  10bbad:	48 89 e5             	mov    %rsp,%rbp
  10bbb0:	41 54                	push   %r12
  10bbb2:	49 89 fc             	mov    %rdi,%r12
  10bbb5:	48 83 ec 28          	sub    $0x28,%rsp
	if (!get_ivshmem(shell)) {
  10bbb9:	e8 d8 fc ff ff       	callq  10b896 <get_ivshmem>
  10bbbe:	84 c0                	test   %al,%al
  10bbc0:	74 58                	je     10bc1a <cmd_ivshmem_shmem+0x6e>
	size = ivshmem_get_mem(ivshmem, &mem);
  10bbc2:	48 8b 3d c7 11 0b 00 	mov    0xb11c7(%rip),%rdi        # 1bcd90 <ivshmem>
	return api->get_mem(dev, memmap);
  10bbc9:	48 8b 47 10          	mov    0x10(%rdi),%rax
  10bbcd:	48 8d 75 e8          	lea    -0x18(%rbp),%rsi
  10bbd1:	ff 10                	callq  *(%rax)
	id = ivshmem_get_id(ivshmem);
  10bbd3:	48 8b 3d b6 11 0b 00 	mov    0xb11b6(%rip),%rdi        # 1bcd90 <ivshmem>
  10bbda:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	return api->get_id(dev);
  10bbde:	48 8b 47 10          	mov    0x10(%rdi),%rax
  10bbe2:	ff 50 08             	callq  *0x8(%rax)
	vectors = ivshmem_get_vectors(ivshmem);
  10bbe5:	48 8b 3d a4 11 0b 00 	mov    0xb11a4(%rip),%rdi        # 1bcd90 <ivshmem>
  10bbec:	89 45 dc             	mov    %eax,-0x24(%rbp)
	return api->get_vectors(dev);
  10bbef:	48 8b 47 10          	mov    0x10(%rdi),%rax
  10bbf3:	ff 50 10             	callq  *0x10(%rax)
	shell_fprintf(shell, SHELL_NORMAL,
  10bbf6:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  10bbfa:	44 8b 4d dc          	mov    -0x24(%rbp),%r9d
  10bbfe:	31 f6                	xor    %esi,%esi
  10bc00:	0f b7 c0             	movzwl %ax,%eax
  10bc03:	52                   	push   %rdx
  10bc04:	4c 8b 45 d0          	mov    -0x30(%rbp),%r8
  10bc08:	ba e6 f1 11 00       	mov    $0x11f1e6,%edx
  10bc0d:	50                   	push   %rax
  10bc0e:	4c 89 e7             	mov    %r12,%rdi
  10bc11:	31 c0                	xor    %eax,%eax
  10bc13:	e8 7b 9f ff ff       	callq  105b93 <shell_fprintf>
  10bc18:	59                   	pop    %rcx
  10bc19:	5e                   	pop    %rsi
}
  10bc1a:	4c 8b 65 f8          	mov    -0x8(%rbp),%r12
  10bc1e:	31 c0                	xor    %eax,%eax
  10bc20:	c9                   	leaveq 
  10bc21:	c3                   	retq   

000000000010bc22 <z_obj_validation_check.constprop.0>:
 * @return 0 on success, nonzero on failure
 */
#define Z_SYSCALL_MEMORY_ARRAY_WRITE(ptr, nmemb, size) \
	Z_SYSCALL_MEMORY_ARRAY(ptr, nmemb, size, 1)

static inline int z_obj_validation_check(struct z_object *ko,
  10bc22:	55                   	push   %rbp
  10bc23:	48 89 e5             	mov    %rsp,%rbp
  10bc26:	41 57                	push   %r15
  10bc28:	49 89 f7             	mov    %rsi,%r15
  10bc2b:	41 56                	push   %r14
  10bc2d:	41 89 d6             	mov    %edx,%r14d
					 enum k_objects otype,
					 enum _obj_init_check init)
{
	int ret;

	ret = z_object_validate(ko, otype, init);
  10bc30:	31 d2                	xor    %edx,%edx
static inline int z_obj_validation_check(struct z_object *ko,
  10bc32:	41 55                	push   %r13
	ret = z_object_validate(ko, otype, init);
  10bc34:	44 89 f6             	mov    %r14d,%esi
static inline int z_obj_validation_check(struct z_object *ko,
  10bc37:	49 89 fd             	mov    %rdi,%r13
  10bc3a:	48 83 ec 18          	sub    $0x18,%rsp
	ret = z_object_validate(ko, otype, init);
  10bc3e:	e8 29 b3 00 00       	callq  116f6c <z_object_validate>

#ifdef CONFIG_LOG
	if (ret != 0) {
  10bc43:	85 c0                	test   %eax,%eax
  10bc45:	74 16                	je     10bc5d <z_obj_validation_check.constprop.0+0x3b>
		z_dump_object_error(ret, obj, ko, otype);
  10bc47:	89 c7                	mov    %eax,%edi
  10bc49:	44 89 f1             	mov    %r14d,%ecx
  10bc4c:	4c 89 ea             	mov    %r13,%rdx
  10bc4f:	4c 89 fe             	mov    %r15,%rsi
  10bc52:	89 45 dc             	mov    %eax,-0x24(%rbp)
  10bc55:	e8 c7 b1 00 00       	callq  116e21 <z_dump_object_error>
  10bc5a:	8b 45 dc             	mov    -0x24(%rbp),%eax
#else
	ARG_UNUSED(obj);
#endif

	return ret;
}
  10bc5d:	48 83 c4 18          	add    $0x18,%rsp
  10bc61:	41 5d                	pop    %r13
  10bc63:	41 5e                	pop    %r14
  10bc65:	41 5f                	pop    %r15
  10bc67:	5d                   	pop    %rbp
  10bc68:	c3                   	retq   

000000000010bc69 <z_mrsh_ivshmem_get_mem>:
#include <syscalls/ivshmem.h>

extern size_t z_vrfy_ivshmem_get_mem(const struct device * dev, uintptr_t * memmap);
uintptr_t z_mrsh_ivshmem_get_mem(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
  10bc69:	55                   	push   %rbp
	_current->syscall_frame = ssf;
  10bc6a:	48 8b 05 df ca 01 00 	mov    0x1cadf(%rip),%rax        # 128750 <_kernel+0x10>
{
  10bc71:	48 89 e5             	mov    %rsp,%rbp
  10bc74:	41 55                	push   %r13
  10bc76:	49 89 f5             	mov    %rsi,%r13
	_current->syscall_frame = ssf;
  10bc79:	48 8b 55 10          	mov    0x10(%rbp),%rdx
{
  10bc7d:	41 54                	push   %r12
  10bc7f:	49 89 fc             	mov    %rdi,%r12
	_current->syscall_frame = ssf;
  10bc82:	48 89 90 40 01 00 00 	mov    %rdx,0x140(%rax)
#include <syscall_handler.h>
#include <string.h>

static inline size_t z_vrfy_ivshmem_get_mem(const struct device *dev, uintptr_t *memmap)
{
	Z_OOPS(Z_SYSCALL_DRIVER_IVSHMEM(dev, get_mem));
  10bc89:	e8 46 ae 00 00       	callq  116ad4 <z_object_find>
  10bc8e:	ba 32 00 00 00       	mov    $0x32,%edx
  10bc93:	4c 89 e6             	mov    %r12,%rsi
  10bc96:	48 89 c7             	mov    %rax,%rdi
  10bc99:	e8 84 ff ff ff       	callq  10bc22 <z_obj_validation_check.constprop.0>
  10bc9e:	85 c0                	test   %eax,%eax
  10bca0:	74 18                	je     10bcba <z_mrsh_ivshmem_get_mem+0x51>
  10bca2:	ba 10 c0 11 00       	mov    $0x11c010,%edx
  10bca7:	be 45 00 00 00       	mov    $0x45,%esi
  10bcac:	bf 23 f3 11 00       	mov    $0x11f323,%edi
  10bcb1:	31 c0                	xor    %eax,%eax
  10bcb3:	e8 0e 74 ff ff       	callq  1030c6 <z_log_minimal_printk>
  10bcb8:	eb 26                	jmp    10bce0 <z_mrsh_ivshmem_get_mem+0x77>
  10bcba:	4d 8b 44 24 10       	mov    0x10(%r12),%r8
  10bcbf:	49 83 38 00          	cmpq   $0x0,(%r8)
  10bcc3:	75 2e                	jne    10bcf3 <z_mrsh_ivshmem_get_mem+0x8a>
  10bcc5:	b9 4f f3 11 00       	mov    $0x11f34f,%ecx
  10bcca:	ba 10 c0 11 00       	mov    $0x11c010,%edx
  10bccf:	be 45 00 00 00       	mov    $0x45,%esi
  10bcd4:	31 c0                	xor    %eax,%eax
  10bcd6:	bf 57 f3 11 00       	mov    $0x11f357,%edi
  10bcdb:	e8 e6 73 ff ff       	callq  1030c6 <z_log_minimal_printk>
	Z_OOPS(Z_SYSCALL_MEMORY_WRITE(memmap, sizeof(uintptr_t)));
  10bce0:	48 8b 05 69 ca 01 00 	mov    0x1ca69(%rip),%rax        # 128750 <_kernel+0x10>
  10bce7:	48 8b b8 40 01 00 00 	mov    0x140(%rax),%rdi
  10bcee:	e8 1a df ff ff       	callq  109c0d <arch_syscall_oops>
  10bcf3:	ba 01 00 00 00       	mov    $0x1,%edx
  10bcf8:	be 08 00 00 00       	mov    $0x8,%esi
  10bcfd:	4c 89 ef             	mov    %r13,%rdi
  10bd00:	e8 b7 d6 ff ff       	callq  1093bc <arch_buffer_validate>
  10bd05:	85 c0                	test   %eax,%eax
  10bd07:	74 27                	je     10bd30 <z_mrsh_ivshmem_get_mem+0xc7>
  10bd09:	41 b9 a4 d2 11 00    	mov    $0x11d2a4,%r9d
  10bd0f:	4c 89 e9             	mov    %r13,%rcx
  10bd12:	ba 10 c0 11 00       	mov    $0x11c010,%edx
  10bd17:	31 c0                	xor    %eax,%eax
  10bd19:	41 b8 08 00 00 00    	mov    $0x8,%r8d
  10bd1f:	be 45 00 00 00       	mov    $0x45,%esi
  10bd24:	bf 1e cf 11 00       	mov    $0x11cf1e,%edi
  10bd29:	e8 98 73 ff ff       	callq  1030c6 <z_log_minimal_printk>
  10bd2e:	eb b0                	jmp    10bce0 <z_mrsh_ivshmem_get_mem+0x77>
	return api->get_mem(dev, memmap);
  10bd30:	49 8b 44 24 10       	mov    0x10(%r12),%rax
  10bd35:	4c 89 ee             	mov    %r13,%rsi
  10bd38:	4c 89 e7             	mov    %r12,%rdi
  10bd3b:	ff 10                	callq  *(%rax)
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	size_t ret = z_vrfy_ivshmem_get_mem(*(const struct device **)&arg0, *(uintptr_t **)&arg1)
;
	_current->syscall_frame = NULL;
  10bd3d:	48 8b 15 0c ca 01 00 	mov    0x1ca0c(%rip),%rdx        # 128750 <_kernel+0x10>
  10bd44:	48 c7 82 40 01 00 00 	movq   $0x0,0x140(%rdx)
  10bd4b:	00 00 00 00 
	return (uintptr_t) ret;
}
  10bd4f:	41 5c                	pop    %r12
  10bd51:	41 5d                	pop    %r13
  10bd53:	5d                   	pop    %rbp
  10bd54:	c3                   	retq   

000000000010bd55 <z_mrsh_ivshmem_get_id>:
#include <syscalls/ivshmem.h>

extern uint32_t z_vrfy_ivshmem_get_id(const struct device * dev);
uintptr_t z_mrsh_ivshmem_get_id(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
  10bd55:	55                   	push   %rbp
  10bd56:	48 89 e5             	mov    %rsp,%rbp
  10bd59:	41 54                	push   %r12
  10bd5b:	49 89 fc             	mov    %rdi,%r12
  10bd5e:	51                   	push   %rcx
	_current->syscall_frame = ssf;
  10bd5f:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  10bd63:	48 8b 05 e6 c9 01 00 	mov    0x1c9e6(%rip),%rax        # 128750 <_kernel+0x10>
  10bd6a:	48 89 90 40 01 00 00 	mov    %rdx,0x140(%rax)
}
#include <syscalls/ivshmem_get_mem_mrsh.c>

static inline uint32_t z_vrfy_ivshmem_get_id(const struct device *dev)
{
	Z_OOPS(Z_SYSCALL_DRIVER_IVSHMEM(dev, get_id));
  10bd71:	e8 5e ad 00 00       	callq  116ad4 <z_object_find>
  10bd76:	ba 32 00 00 00       	mov    $0x32,%edx
  10bd7b:	4c 89 e6             	mov    %r12,%rsi
  10bd7e:	48 89 c7             	mov    %rax,%rdi
  10bd81:	e8 9c fe ff ff       	callq  10bc22 <z_obj_validation_check.constprop.0>
  10bd86:	85 c0                	test   %eax,%eax
  10bd88:	74 18                	je     10bda2 <z_mrsh_ivshmem_get_id+0x4d>
  10bd8a:	ba f0 bf 11 00       	mov    $0x11bff0,%edx
  10bd8f:	be 45 00 00 00       	mov    $0x45,%esi
  10bd94:	bf 23 f3 11 00       	mov    $0x11f323,%edi
  10bd99:	31 c0                	xor    %eax,%eax
  10bd9b:	e8 26 73 ff ff       	callq  1030c6 <z_log_minimal_printk>
  10bda0:	eb 29                	jmp    10bdcb <z_mrsh_ivshmem_get_id+0x76>
  10bda2:	4d 8b 44 24 10       	mov    0x10(%r12),%r8
  10bda7:	49 8b 40 08          	mov    0x8(%r8),%rax
  10bdab:	48 85 c0             	test   %rax,%rax
  10bdae:	75 2e                	jne    10bdde <z_mrsh_ivshmem_get_id+0x89>
  10bdb0:	b9 a5 f3 11 00       	mov    $0x11f3a5,%ecx
  10bdb5:	ba f0 bf 11 00       	mov    $0x11bff0,%edx
  10bdba:	be 45 00 00 00       	mov    $0x45,%esi
  10bdbf:	31 c0                	xor    %eax,%eax
  10bdc1:	bf 57 f3 11 00       	mov    $0x11f357,%edi
  10bdc6:	e8 fb 72 ff ff       	callq  1030c6 <z_log_minimal_printk>
  10bdcb:	48 8b 05 7e c9 01 00 	mov    0x1c97e(%rip),%rax        # 128750 <_kernel+0x10>
  10bdd2:	48 8b b8 40 01 00 00 	mov    0x140(%rax),%rdi
  10bdd9:	e8 2f de ff ff       	callq  109c0d <arch_syscall_oops>
	return api->get_id(dev);
  10bdde:	4c 89 e7             	mov    %r12,%rdi
  10bde1:	ff d0                	callq  *%rax
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	uint32_t ret = z_vrfy_ivshmem_get_id(*(const struct device **)&arg0)
;
	_current->syscall_frame = NULL;
  10bde3:	48 8b 15 66 c9 01 00 	mov    0x1c966(%rip),%rdx        # 128750 <_kernel+0x10>
	return (uintptr_t) ret;
  10bdea:	89 c0                	mov    %eax,%eax
	_current->syscall_frame = NULL;
  10bdec:	48 c7 82 40 01 00 00 	movq   $0x0,0x140(%rdx)
  10bdf3:	00 00 00 00 
}
  10bdf7:	5a                   	pop    %rdx
  10bdf8:	41 5c                	pop    %r12
  10bdfa:	5d                   	pop    %rbp
  10bdfb:	c3                   	retq   

000000000010bdfc <z_mrsh_ivshmem_get_vectors>:
#include <syscalls/ivshmem.h>

extern uint16_t z_vrfy_ivshmem_get_vectors(const struct device * dev);
uintptr_t z_mrsh_ivshmem_get_vectors(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
  10bdfc:	55                   	push   %rbp
  10bdfd:	48 89 e5             	mov    %rsp,%rbp
  10be00:	41 54                	push   %r12
  10be02:	49 89 fc             	mov    %rdi,%r12
  10be05:	51                   	push   %rcx
	_current->syscall_frame = ssf;
  10be06:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  10be0a:	48 8b 05 3f c9 01 00 	mov    0x1c93f(%rip),%rax        # 128750 <_kernel+0x10>
  10be11:	48 89 90 40 01 00 00 	mov    %rdx,0x140(%rax)
}
#include <syscalls/ivshmem_get_id_mrsh.c>

static inline uint16_t z_vrfy_ivshmem_get_vectors(const struct device *dev)
{
	Z_OOPS(Z_SYSCALL_DRIVER_IVSHMEM(dev, get_vectors));
  10be18:	e8 b7 ac 00 00       	callq  116ad4 <z_object_find>
  10be1d:	ba 32 00 00 00       	mov    $0x32,%edx
  10be22:	4c 89 e6             	mov    %r12,%rsi
  10be25:	48 89 c7             	mov    %rax,%rdi
  10be28:	e8 f5 fd ff ff       	callq  10bc22 <z_obj_validation_check.constprop.0>
  10be2d:	85 c0                	test   %eax,%eax
  10be2f:	74 18                	je     10be49 <z_mrsh_ivshmem_get_vectors+0x4d>
  10be31:	ba d0 bf 11 00       	mov    $0x11bfd0,%edx
  10be36:	be 45 00 00 00       	mov    $0x45,%esi
  10be3b:	bf 23 f3 11 00       	mov    $0x11f323,%edi
  10be40:	31 c0                	xor    %eax,%eax
  10be42:	e8 7f 72 ff ff       	callq  1030c6 <z_log_minimal_printk>
  10be47:	eb 29                	jmp    10be72 <z_mrsh_ivshmem_get_vectors+0x76>
  10be49:	4d 8b 44 24 10       	mov    0x10(%r12),%r8
  10be4e:	49 8b 40 10          	mov    0x10(%r8),%rax
  10be52:	48 85 c0             	test   %rax,%rax
  10be55:	75 2e                	jne    10be85 <z_mrsh_ivshmem_get_vectors+0x89>
  10be57:	b9 ac f3 11 00       	mov    $0x11f3ac,%ecx
  10be5c:	ba d0 bf 11 00       	mov    $0x11bfd0,%edx
  10be61:	be 45 00 00 00       	mov    $0x45,%esi
  10be66:	31 c0                	xor    %eax,%eax
  10be68:	bf 57 f3 11 00       	mov    $0x11f357,%edi
  10be6d:	e8 54 72 ff ff       	callq  1030c6 <z_log_minimal_printk>
  10be72:	48 8b 05 d7 c8 01 00 	mov    0x1c8d7(%rip),%rax        # 128750 <_kernel+0x10>
  10be79:	48 8b b8 40 01 00 00 	mov    0x140(%rax),%rdi
  10be80:	e8 88 dd ff ff       	callq  109c0d <arch_syscall_oops>
	return api->get_vectors(dev);
  10be85:	4c 89 e7             	mov    %r12,%rdi
  10be88:	ff d0                	callq  *%rax
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	uint16_t ret = z_vrfy_ivshmem_get_vectors(*(const struct device **)&arg0)
;
	_current->syscall_frame = NULL;
  10be8a:	48 8b 15 bf c8 01 00 	mov    0x1c8bf(%rip),%rdx        # 128750 <_kernel+0x10>
	return (uintptr_t) ret;
  10be91:	0f b7 c0             	movzwl %ax,%eax
	_current->syscall_frame = NULL;
  10be94:	48 c7 82 40 01 00 00 	movq   $0x0,0x140(%rdx)
  10be9b:	00 00 00 00 
}
  10be9f:	5a                   	pop    %rdx
  10bea0:	41 5c                	pop    %r12
  10bea2:	5d                   	pop    %rbp
  10bea3:	c3                   	retq   

000000000010bea4 <z_mrsh_ivshmem_int_peer>:
#include <syscalls/ivshmem.h>

extern int z_vrfy_ivshmem_int_peer(const struct device * dev, uint32_t peer_id, uint16_t vector);
uintptr_t z_mrsh_ivshmem_int_peer(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
  10bea4:	55                   	push   %rbp
  10bea5:	48 89 e5             	mov    %rsp,%rbp
  10bea8:	41 55                	push   %r13
	_current->syscall_frame = ssf;
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	int ret = z_vrfy_ivshmem_int_peer(*(const struct device **)&arg0, *(uint32_t*)&arg1, *(uint16_t*)&arg2)
  10beaa:	44 0f b7 ea          	movzwl %dx,%r13d
{
  10beae:	41 54                	push   %r12
  10beb0:	49 89 fc             	mov    %rdi,%r12
  10beb3:	53                   	push   %rbx
  10beb4:	48 89 f3             	mov    %rsi,%rbx
  10beb7:	51                   	push   %rcx
	_current->syscall_frame = ssf;
  10beb8:	48 8b 4d 10          	mov    0x10(%rbp),%rcx
  10bebc:	48 8b 05 8d c8 01 00 	mov    0x1c88d(%rip),%rax        # 128750 <_kernel+0x10>
  10bec3:	48 89 88 40 01 00 00 	mov    %rcx,0x140(%rax)
#include <syscalls/ivshmem_get_vectors_mrsh.c>

static inline int z_vrfy_ivshmem_int_peer(const struct device *dev, uint32_t peer_id,
					  uint16_t vector)
{
	Z_OOPS(Z_SYSCALL_DRIVER_IVSHMEM(dev, int_peer));
  10beca:	e8 05 ac 00 00       	callq  116ad4 <z_object_find>
  10becf:	ba 32 00 00 00       	mov    $0x32,%edx
  10bed4:	4c 89 e6             	mov    %r12,%rsi
  10bed7:	48 89 c7             	mov    %rax,%rdi
  10beda:	e8 43 fd ff ff       	callq  10bc22 <z_obj_validation_check.constprop.0>
  10bedf:	85 c0                	test   %eax,%eax
  10bee1:	74 18                	je     10befb <z_mrsh_ivshmem_int_peer+0x57>
  10bee3:	ba b0 bf 11 00       	mov    $0x11bfb0,%edx
  10bee8:	be 45 00 00 00       	mov    $0x45,%esi
  10beed:	bf 23 f3 11 00       	mov    $0x11f323,%edi
  10bef2:	31 c0                	xor    %eax,%eax
  10bef4:	e8 cd 71 ff ff       	callq  1030c6 <z_log_minimal_printk>
  10bef9:	eb 29                	jmp    10bf24 <z_mrsh_ivshmem_int_peer+0x80>
  10befb:	4d 8b 44 24 10       	mov    0x10(%r12),%r8
  10bf00:	49 8b 40 18          	mov    0x18(%r8),%rax
  10bf04:	48 85 c0             	test   %rax,%rax
  10bf07:	75 2e                	jne    10bf37 <z_mrsh_ivshmem_int_peer+0x93>
  10bf09:	b9 00 f3 11 00       	mov    $0x11f300,%ecx
  10bf0e:	ba b0 bf 11 00       	mov    $0x11bfb0,%edx
  10bf13:	be 45 00 00 00       	mov    $0x45,%esi
  10bf18:	31 c0                	xor    %eax,%eax
  10bf1a:	bf 57 f3 11 00       	mov    $0x11f357,%edi
  10bf1f:	e8 a2 71 ff ff       	callq  1030c6 <z_log_minimal_printk>
  10bf24:	48 8b 05 25 c8 01 00 	mov    0x1c825(%rip),%rax        # 128750 <_kernel+0x10>
  10bf2b:	48 8b b8 40 01 00 00 	mov    0x140(%rax),%rdi
  10bf32:	e8 d6 dc ff ff       	callq  109c0d <arch_syscall_oops>
	return api->int_peer(dev, peer_id, vector);
  10bf37:	44 89 ea             	mov    %r13d,%edx
  10bf3a:	89 de                	mov    %ebx,%esi
  10bf3c:	4c 89 e7             	mov    %r12,%rdi
  10bf3f:	ff d0                	callq  *%rax
;
	_current->syscall_frame = NULL;
  10bf41:	48 8b 15 08 c8 01 00 	mov    0x1c808(%rip),%rdx        # 128750 <_kernel+0x10>
	return (uintptr_t) ret;
  10bf48:	48 98                	cltq   
	_current->syscall_frame = NULL;
  10bf4a:	48 c7 82 40 01 00 00 	movq   $0x0,0x140(%rdx)
  10bf51:	00 00 00 00 
}
  10bf55:	5a                   	pop    %rdx
  10bf56:	5b                   	pop    %rbx
  10bf57:	41 5c                	pop    %r12
  10bf59:	41 5d                	pop    %r13
  10bf5b:	5d                   	pop    %rbp
  10bf5c:	c3                   	retq   

000000000010bf5d <z_mrsh_ivshmem_register_handler>:
#include <syscalls/ivshmem.h>

extern int z_vrfy_ivshmem_register_handler(const struct device * dev, struct k_poll_signal * signal, uint16_t vector);
uintptr_t z_mrsh_ivshmem_register_handler(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
  10bf5d:	55                   	push   %rbp
  10bf5e:	48 89 e5             	mov    %rsp,%rbp
  10bf61:	41 56                	push   %r14
	_current->syscall_frame = ssf;
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	int ret = z_vrfy_ivshmem_register_handler(*(const struct device **)&arg0, *(struct k_poll_signal **)&arg1, *(uint16_t*)&arg2)
  10bf63:	44 0f b7 f2          	movzwl %dx,%r14d
{
  10bf67:	41 55                	push   %r13
  10bf69:	49 89 f5             	mov    %rsi,%r13
  10bf6c:	41 54                	push   %r12
  10bf6e:	49 89 fc             	mov    %rdi,%r12
  10bf71:	51                   	push   %rcx
	_current->syscall_frame = ssf;
  10bf72:	48 8b 4d 10          	mov    0x10(%rbp),%rcx
  10bf76:	48 8b 05 d3 c7 01 00 	mov    0x1c7d3(%rip),%rax        # 128750 <_kernel+0x10>
  10bf7d:	48 89 88 40 01 00 00 	mov    %rcx,0x140(%rax)
#include <syscalls/ivshmem_int_peer_mrsh.c>

static inline int z_vrfy_ivshmem_register_handler(const struct device *dev,
						  struct k_poll_signal *signal, uint16_t vector)
{
	Z_OOPS(Z_SYSCALL_DRIVER_IVSHMEM(dev, register_handler));
  10bf84:	e8 4b ab 00 00       	callq  116ad4 <z_object_find>
  10bf89:	ba 32 00 00 00       	mov    $0x32,%edx
  10bf8e:	4c 89 e6             	mov    %r12,%rsi
  10bf91:	48 89 c7             	mov    %rax,%rdi
  10bf94:	e8 89 fc ff ff       	callq  10bc22 <z_obj_validation_check.constprop.0>
  10bf99:	85 c0                	test   %eax,%eax
  10bf9b:	74 29                	je     10bfc6 <z_mrsh_ivshmem_register_handler+0x69>
	Z_OOPS(Z_SYSCALL_OBJ(signal, K_OBJ_POLL_SIGNAL));
  10bf9d:	ba 60 b0 11 00       	mov    $0x11b060,%edx
  10bfa2:	be 45 00 00 00       	mov    $0x45,%esi
  10bfa7:	bf 23 f3 11 00       	mov    $0x11f323,%edi
  10bfac:	31 c0                	xor    %eax,%eax
  10bfae:	e8 13 71 ff ff       	callq  1030c6 <z_log_minimal_printk>
  10bfb3:	48 8b 05 96 c7 01 00 	mov    0x1c796(%rip),%rax        # 128750 <_kernel+0x10>
  10bfba:	48 8b b8 40 01 00 00 	mov    0x140(%rax),%rdi
  10bfc1:	e8 47 dc ff ff       	callq  109c0d <arch_syscall_oops>
	Z_OOPS(Z_SYSCALL_DRIVER_IVSHMEM(dev, register_handler));
  10bfc6:	4d 8b 44 24 10       	mov    0x10(%r12),%r8
  10bfcb:	49 83 78 20 00       	cmpq   $0x0,0x20(%r8)
  10bfd0:	75 1d                	jne    10bfef <z_mrsh_ivshmem_register_handler+0x92>
  10bfd2:	b9 b8 f3 11 00       	mov    $0x11f3b8,%ecx
  10bfd7:	ba 60 b0 11 00       	mov    $0x11b060,%edx
  10bfdc:	be 45 00 00 00       	mov    $0x45,%esi
  10bfe1:	31 c0                	xor    %eax,%eax
  10bfe3:	bf 57 f3 11 00       	mov    $0x11f357,%edi
  10bfe8:	e8 d9 70 ff ff       	callq  1030c6 <z_log_minimal_printk>
  10bfed:	eb c4                	jmp    10bfb3 <z_mrsh_ivshmem_register_handler+0x56>
	Z_OOPS(Z_SYSCALL_OBJ(signal, K_OBJ_POLL_SIGNAL));
  10bfef:	4c 89 ef             	mov    %r13,%rdi
  10bff2:	e8 dd aa 00 00       	callq  116ad4 <z_object_find>
  10bff7:	ba 06 00 00 00       	mov    $0x6,%edx
  10bffc:	4c 89 ee             	mov    %r13,%rsi
  10bfff:	48 89 c7             	mov    %rax,%rdi
  10c002:	e8 1b fc ff ff       	callq  10bc22 <z_obj_validation_check.constprop.0>
  10c007:	85 c0                	test   %eax,%eax
  10c009:	75 92                	jne    10bf9d <z_mrsh_ivshmem_register_handler+0x40>
	return api->register_handler(dev, signal, vector);
  10c00b:	49 8b 44 24 10       	mov    0x10(%r12),%rax
  10c010:	44 89 f2             	mov    %r14d,%edx
  10c013:	4c 89 ee             	mov    %r13,%rsi
  10c016:	4c 89 e7             	mov    %r12,%rdi
  10c019:	ff 50 20             	callq  *0x20(%rax)
;
	_current->syscall_frame = NULL;
  10c01c:	48 8b 15 2d c7 01 00 	mov    0x1c72d(%rip),%rdx        # 128750 <_kernel+0x10>
	return (uintptr_t) ret;
  10c023:	48 98                	cltq   
	_current->syscall_frame = NULL;
  10c025:	48 c7 82 40 01 00 00 	movq   $0x0,0x140(%rdx)
  10c02c:	00 00 00 00 
}
  10c030:	5a                   	pop    %rdx
  10c031:	41 5c                	pop    %r12
  10c033:	41 5d                	pop    %r13
  10c035:	41 5e                	pop    %r14
  10c037:	5d                   	pop    %rbp
  10c038:	c3                   	retq   

000000000010c039 <z_mrsh_ivshmem_get_semaphore>:
#include <syscalls/ivshmem.h>

extern int z_vrfy_ivshmem_get_semaphore(const struct device * dev);
uintptr_t z_mrsh_ivshmem_get_semaphore(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
  10c039:	55                   	push   %rbp
  10c03a:	48 89 e5             	mov    %rsp,%rbp
  10c03d:	41 54                	push   %r12
  10c03f:	49 89 fc             	mov    %rdi,%r12
  10c042:	51                   	push   %rcx
	_current->syscall_frame = ssf;
  10c043:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  10c047:	48 8b 05 02 c7 01 00 	mov    0x1c702(%rip),%rax        # 128750 <_kernel+0x10>
  10c04e:	48 89 90 40 01 00 00 	mov    %rdx,0x140(%rax)
#include <syscalls/ivshmem_register_handler_mrsh.c>

// eigenbau
static inline int z_vrfy_ivshmem_get_semaphore(const struct device *dev)
{
	Z_OOPS(Z_SYSCALL_DRIVER_IVSHMEM(dev, get_semaphore));
  10c055:	e8 7a aa 00 00       	callq  116ad4 <z_object_find>
  10c05a:	ba 32 00 00 00       	mov    $0x32,%edx
  10c05f:	4c 89 e6             	mov    %r12,%rsi
  10c062:	48 89 c7             	mov    %rax,%rdi
  10c065:	e8 b8 fb ff ff       	callq  10bc22 <z_obj_validation_check.constprop.0>
  10c06a:	85 c0                	test   %eax,%eax
  10c06c:	74 18                	je     10c086 <z_mrsh_ivshmem_get_semaphore+0x4d>
  10c06e:	ba 90 bf 11 00       	mov    $0x11bf90,%edx
  10c073:	be 45 00 00 00       	mov    $0x45,%esi
  10c078:	bf 23 f3 11 00       	mov    $0x11f323,%edi
  10c07d:	31 c0                	xor    %eax,%eax
  10c07f:	e8 42 70 ff ff       	callq  1030c6 <z_log_minimal_printk>
  10c084:	eb 29                	jmp    10c0af <z_mrsh_ivshmem_get_semaphore+0x76>
  10c086:	4d 8b 44 24 10       	mov    0x10(%r12),%r8
  10c08b:	49 8b 40 28          	mov    0x28(%r8),%rax
  10c08f:	48 85 c0             	test   %rax,%rax
  10c092:	75 2e                	jne    10c0c2 <z_mrsh_ivshmem_get_semaphore+0x89>
  10c094:	b9 c9 f3 11 00       	mov    $0x11f3c9,%ecx
  10c099:	ba 90 bf 11 00       	mov    $0x11bf90,%edx
  10c09e:	be 45 00 00 00       	mov    $0x45,%esi
  10c0a3:	31 c0                	xor    %eax,%eax
  10c0a5:	bf 57 f3 11 00       	mov    $0x11f357,%edi
  10c0aa:	e8 17 70 ff ff       	callq  1030c6 <z_log_minimal_printk>
  10c0af:	48 8b 05 9a c6 01 00 	mov    0x1c69a(%rip),%rax        # 128750 <_kernel+0x10>
  10c0b6:	48 8b b8 40 01 00 00 	mov    0x140(%rax),%rdi
  10c0bd:	e8 4b db ff ff       	callq  109c0d <arch_syscall_oops>
	return api->get_semaphore(dev);
  10c0c2:	4c 89 e7             	mov    %r12,%rdi
  10c0c5:	ff d0                	callq  *%rax
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	int ret = z_vrfy_ivshmem_get_semaphore(*(const struct device **)&arg0)
;
	_current->syscall_frame = NULL;
  10c0c7:	48 8b 15 82 c6 01 00 	mov    0x1c682(%rip),%rdx        # 128750 <_kernel+0x10>
	return (uintptr_t) ret;
  10c0ce:	48 98                	cltq   
	_current->syscall_frame = NULL;
  10c0d0:	48 c7 82 40 01 00 00 	movq   $0x0,0x140(%rdx)
  10c0d7:	00 00 00 00 
}
  10c0db:	5a                   	pop    %rdx
  10c0dc:	41 5c                	pop    %r12
  10c0de:	5d                   	pop    %rbp
  10c0df:	c3                   	retq   

000000000010c0e0 <uart_ns16550_config_get>:

#ifdef CONFIG_UART_USE_RUNTIME_CONFIGURE
static int uart_ns16550_config_get(const struct device *dev,
				   struct uart_config *cfg)
{
	struct uart_ns16550_dev_data *data = DEV_DATA(dev);
  10c0e0:	48 8b 47 20          	mov    0x20(%rdi),%rax

	cfg->baudrate = data->uart_config.baudrate;
  10c0e4:	8b 10                	mov    (%rax),%edx
  10c0e6:	89 16                	mov    %edx,(%rsi)
	cfg->parity = data->uart_config.parity;
  10c0e8:	8a 50 04             	mov    0x4(%rax),%dl
  10c0eb:	88 56 04             	mov    %dl,0x4(%rsi)
	cfg->stop_bits = data->uart_config.stop_bits;
  10c0ee:	8a 50 05             	mov    0x5(%rax),%dl
  10c0f1:	88 56 05             	mov    %dl,0x5(%rsi)
	cfg->data_bits = data->uart_config.data_bits;
  10c0f4:	8a 50 06             	mov    0x6(%rax),%dl
  10c0f7:	88 56 06             	mov    %dl,0x6(%rsi)
	cfg->flow_ctrl = data->uart_config.flow_ctrl;
  10c0fa:	8a 40 07             	mov    0x7(%rax),%al
  10c0fd:	88 46 07             	mov    %al,0x7(%rsi)

	return 0;
}
  10c100:	31 c0                	xor    %eax,%eax
  10c102:	c3                   	retq   

000000000010c103 <uart_ns16550_configure>:
{
  10c103:	55                   	push   %rbp
  10c104:	48 89 e5             	mov    %rsp,%rbp
  10c107:	41 57                	push   %r15
  10c109:	41 56                	push   %r14
  10c10b:	49 89 fe             	mov    %rdi,%r14
  10c10e:	41 55                	push   %r13
  10c110:	41 54                	push   %r12
  10c112:	53                   	push   %rbx
  10c113:	48 89 f3             	mov    %rsi,%rbx
  10c116:	51                   	push   %rcx
	struct uart_ns16550_dev_data * const dev_data = DEV_DATA(dev);
  10c117:	4c 8b 7f 20          	mov    0x20(%rdi),%r15
	k_spinlock_key_t key = k_spin_lock(&dev_data->lock);
  10c11b:	4d 8d 67 08          	lea    0x8(%r15),%r12
  10c11f:	9c                   	pushfq 
  10c120:	fa                   	cli    
  10c121:	41 5d                	pop    %r13
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  10c123:	4c 89 e7             	mov    %r12,%rdi
  10c126:	e8 4e 17 00 00       	callq  10d879 <z_spin_lock_valid>
  10c12b:	84 c0                	test   %al,%al
  10c12d:	75 37                	jne    10c166 <uart_ns16550_configure+0x63>
  10c12f:	b9 8e 00 00 00       	mov    $0x8e,%ecx
  10c134:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  10c139:	be fd d1 11 00       	mov    $0x11d1fd,%esi
  10c13e:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  10c143:	e8 b0 44 ff ff       	callq  1005f8 <printk>
  10c148:	4c 89 e6             	mov    %r12,%rsi
  10c14b:	bf 12 d2 11 00       	mov    $0x11d212,%edi
  10c150:	31 c0                	xor    %eax,%eax
  10c152:	e8 a1 44 ff ff       	callq  1005f8 <printk>
  10c157:	be 8e 00 00 00       	mov    $0x8e,%esi
  10c15c:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  10c161:	e8 32 6a ff ff       	callq  102b98 <assert_post_action>
	z_spin_lock_set_owner(l);
  10c166:	4c 89 e7             	mov    %r12,%rdi
  10c169:	e8 4f 17 00 00       	callq  10d8bd <z_spin_lock_set_owner>
	set_baud_rate(dev, cfg->baudrate);
  10c16e:	8b 3b                	mov    (%rbx),%edi
	const struct uart_ns16550_device_config * const dev_cfg = DEV_CFG(dev);
  10c170:	49 8b 76 08          	mov    0x8(%r14),%rsi
	if ((baud_rate != 0U) && (dev_cfg->sys_clk_freq != 0U)) {
  10c174:	85 ff                	test   %edi,%edi
  10c176:	74 42                	je     10c1ba <uart_ns16550_configure+0xb7>
  10c178:	8b 46 04             	mov    0x4(%rsi),%eax
  10c17b:	85 c0                	test   %eax,%eax
  10c17d:	74 3b                	je     10c1ba <uart_ns16550_configure+0xb7>
		divisor = ((dev_cfg->sys_clk_freq + (baud_rate << 3))
  10c17f:	8d 04 f8             	lea    (%rax,%rdi,8),%eax
					/ baud_rate) >> 4;
  10c182:	31 d2                	xor    %edx,%edx
	return DEV_CFG(dev)->port;
  10c184:	44 8b 16             	mov    (%rsi),%r10d
					/ baud_rate) >> 4;
  10c187:	f7 f7                	div    %edi
		lcr_cache = INBYTE(LCR(dev));
  10c189:	45 8d 42 03          	lea    0x3(%r10),%r8d
	__asm__ volatile("inb %w1, %b0" : "=a"(ret) : "Nd"(port));
  10c18d:	44 89 c2             	mov    %r8d,%edx
					/ baud_rate) >> 4;
  10c190:	89 c1                	mov    %eax,%ecx
  10c192:	ec                   	in     (%dx),%al
  10c193:	41 89 c1             	mov    %eax,%r9d
		OUTBYTE(LCR(dev), LCR_DLAB | lcr_cache);
  10c196:	83 c8 80             	or     $0xffffff80,%eax
	__asm__ volatile("outb %b0, %w1" :: "a"(data), "Nd"(port));
  10c199:	ee                   	out    %al,(%dx)
		divisor = ((dev_cfg->sys_clk_freq + (baud_rate << 3))
  10c19a:	89 c8                	mov    %ecx,%eax
  10c19c:	44 89 d2             	mov    %r10d,%edx
  10c19f:	c1 e8 04             	shr    $0x4,%eax
  10c1a2:	ee                   	out    %al,(%dx)
		OUTBYTE(BRDH(dev), (unsigned char)((divisor >> 8) & 0xff));
  10c1a3:	89 c8                	mov    %ecx,%eax
  10c1a5:	41 8d 52 01          	lea    0x1(%r10),%edx
  10c1a9:	c1 e8 0c             	shr    $0xc,%eax
  10c1ac:	ee                   	out    %al,(%dx)
  10c1ad:	44 89 c8             	mov    %r9d,%eax
  10c1b0:	44 89 c2             	mov    %r8d,%edx
  10c1b3:	ee                   	out    %al,(%dx)
		dev_data->uart_config.baudrate = baud_rate;
  10c1b4:	49 8b 46 20          	mov    0x20(%r14),%rax
  10c1b8:	89 38                	mov    %edi,(%rax)
	switch (cfg->data_bits) {
  10c1ba:	8a 53 06             	mov    0x6(%rbx),%dl
		ret = -ENOTSUP;
  10c1bd:	41 be 7a ff ff ff    	mov    $0xffffff7a,%r14d
  10c1c3:	80 fa 03             	cmp    $0x3,%dl
  10c1c6:	77 4d                	ja     10c215 <uart_ns16550_configure+0x112>
	switch (cfg->stop_bits) {
  10c1c8:	8a 43 05             	mov    0x5(%rbx),%al
  10c1cb:	3c 01                	cmp    $0x1,%al
  10c1cd:	74 09                	je     10c1d8 <uart_ns16550_configure+0xd5>
  10c1cf:	40 b7 04             	mov    $0x4,%dil
  10c1d2:	3c 03                	cmp    $0x3,%al
  10c1d4:	74 04                	je     10c1da <uart_ns16550_configure+0xd7>
  10c1d6:	eb 3d                	jmp    10c215 <uart_ns16550_configure+0x112>
		uart_cfg.stop_bits = LCR_1_STB;
  10c1d8:	31 ff                	xor    %edi,%edi
	switch (cfg->parity) {
  10c1da:	8a 43 04             	mov    0x4(%rbx),%al
  10c1dd:	84 c0                	test   %al,%al
  10c1df:	74 0c                	je     10c1ed <uart_ns16550_configure+0xea>
  10c1e1:	41 be 7a ff ff ff    	mov    $0xffffff7a,%r14d
  10c1e7:	3c 02                	cmp    $0x2,%al
  10c1e9:	75 2a                	jne    10c215 <uart_ns16550_configure+0x112>
  10c1eb:	b0 10                	mov    $0x10,%al
	dev_data->uart_config = *cfg;
  10c1ed:	48 8b 0b             	mov    (%rbx),%rcx
	OUTBYTE(LCR(dev),
  10c1f0:	09 fa                	or     %edi,%edx
  10c1f2:	09 d0                	or     %edx,%eax
	dev_data->uart_config = *cfg;
  10c1f4:	49 89 0f             	mov    %rcx,(%r15)
	return DEV_CFG(dev)->port;
  10c1f7:	8b 0e                	mov    (%rsi),%ecx
	OUTBYTE(LCR(dev),
  10c1f9:	8d 51 03             	lea    0x3(%rcx),%edx
  10c1fc:	ee                   	out    %al,(%dx)
  10c1fd:	b0 0b                	mov    $0xb,%al
	OUTBYTE(MDC(dev), mdc);
  10c1ff:	8d 51 04             	lea    0x4(%rcx),%edx
  10c202:	ee                   	out    %al,(%dx)
  10c203:	b0 87                	mov    $0x87,%al
	OUTBYTE(FCR(dev),
  10c205:	8d 51 02             	lea    0x2(%rcx),%edx
  10c208:	ee                   	out    %al,(%dx)
	__asm__ volatile("inb %w1, %b0" : "=a"(ret) : "Nd"(port));
  10c209:	89 ca                	mov    %ecx,%edx
  10c20b:	ec                   	in     (%dx),%al
	__asm__ volatile("outb %b0, %w1" :: "a"(data), "Nd"(port));
  10c20c:	31 c0                	xor    %eax,%eax
	OUTBYTE(IER(dev), 0x00);
  10c20e:	8d 51 01             	lea    0x1(%rcx),%edx
  10c211:	ee                   	out    %al,(%dx)
	int ret = 0;
  10c212:	45 31 f6             	xor    %r14d,%r14d
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  10c215:	4c 89 e7             	mov    %r12,%rdi
  10c218:	e8 7c 16 00 00       	callq  10d899 <z_spin_unlock_valid>
  10c21d:	84 c0                	test   %al,%al
  10c21f:	75 37                	jne    10c258 <uart_ns16550_configure+0x155>
  10c221:	b9 b9 00 00 00       	mov    $0xb9,%ecx
  10c226:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  10c22b:	be 41 d2 11 00       	mov    $0x11d241,%esi
  10c230:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  10c235:	e8 be 43 ff ff       	callq  1005f8 <printk>
  10c23a:	4c 89 e6             	mov    %r12,%rsi
  10c23d:	bf 58 d2 11 00       	mov    $0x11d258,%edi
  10c242:	31 c0                	xor    %eax,%eax
  10c244:	e8 af 43 ff ff       	callq  1005f8 <printk>
  10c249:	be b9 00 00 00       	mov    $0xb9,%esi
  10c24e:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  10c253:	e8 40 69 ff ff       	callq  102b98 <assert_post_action>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  10c258:	41 0f ba e5 09       	bt     $0x9,%r13d
  10c25d:	73 01                	jae    10c260 <uart_ns16550_configure+0x15d>
		__asm__ volatile ("sti" ::: "memory");
  10c25f:	fb                   	sti    
};
  10c260:	5a                   	pop    %rdx
  10c261:	44 89 f0             	mov    %r14d,%eax
  10c264:	5b                   	pop    %rbx
  10c265:	41 5c                	pop    %r12
  10c267:	41 5d                	pop    %r13
  10c269:	41 5e                	pop    %r14
  10c26b:	41 5f                	pop    %r15
  10c26d:	5d                   	pop    %rbp
  10c26e:	c3                   	retq   

000000000010c26f <uart_ns16550_init>:
 */
static int uart_ns16550_init(const struct device *dev)
{
	int ret;

	ret = uart_ns16550_configure(dev, &DEV_DATA(dev)->uart_config);
  10c26f:	48 8b 77 20          	mov    0x20(%rdi),%rsi
  10c273:	e9 8b fe ff ff       	jmpq   10c103 <uart_ns16550_configure>

000000000010c278 <uart_ns16550_poll_in>:
 * @param c Pointer to character
 *
 * @return 0 if a character arrived, -1 if the input buffer if empty.
 */
static int uart_ns16550_poll_in(const struct device *dev, unsigned char *c)
{
  10c278:	55                   	push   %rbp
  10c279:	48 89 e5             	mov    %rsp,%rbp
  10c27c:	41 57                	push   %r15
  10c27e:	49 89 f7             	mov    %rsi,%r15
  10c281:	41 56                	push   %r14
  10c283:	41 55                	push   %r13
  10c285:	41 54                	push   %r12
  10c287:	53                   	push   %rbx
  10c288:	48 89 fb             	mov    %rdi,%rbx
  10c28b:	51                   	push   %rcx
	int ret = -1;
	k_spinlock_key_t key = k_spin_lock(&DEV_DATA(dev)->lock);
  10c28c:	48 8b 47 20          	mov    0x20(%rdi),%rax
  10c290:	4c 8d 60 08          	lea    0x8(%rax),%r12
  10c294:	9c                   	pushfq 
  10c295:	fa                   	cli    
  10c296:	41 5d                	pop    %r13
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  10c298:	4c 89 e7             	mov    %r12,%rdi
  10c29b:	e8 d9 15 00 00       	callq  10d879 <z_spin_lock_valid>
  10c2a0:	84 c0                	test   %al,%al
  10c2a2:	75 37                	jne    10c2db <uart_ns16550_poll_in+0x63>
  10c2a4:	b9 8e 00 00 00       	mov    $0x8e,%ecx
  10c2a9:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  10c2ae:	be fd d1 11 00       	mov    $0x11d1fd,%esi
  10c2b3:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  10c2b8:	e8 3b 43 ff ff       	callq  1005f8 <printk>
  10c2bd:	4c 89 e6             	mov    %r12,%rsi
  10c2c0:	bf 12 d2 11 00       	mov    $0x11d212,%edi
  10c2c5:	31 c0                	xor    %eax,%eax
  10c2c7:	e8 2c 43 ff ff       	callq  1005f8 <printk>
  10c2cc:	be 8e 00 00 00       	mov    $0x8e,%esi
  10c2d1:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  10c2d6:	e8 bd 68 ff ff       	callq  102b98 <assert_post_action>
	z_spin_lock_set_owner(l);
  10c2db:	4c 89 e7             	mov    %r12,%rdi
  10c2de:	e8 da 15 00 00       	callq  10d8bd <z_spin_lock_set_owner>
	return DEV_CFG(dev)->port;
  10c2e3:	48 8b 43 08          	mov    0x8(%rbx),%rax
  10c2e7:	8b 08                	mov    (%rax),%ecx

	if ((INBYTE(LSR(dev)) & LSR_RXRDY) != 0) {
  10c2e9:	8d 51 05             	lea    0x5(%rcx),%edx
	__asm__ volatile("inb %w1, %b0" : "=a"(ret) : "Nd"(port));
  10c2ec:	ec                   	in     (%dx),%al
	int ret = -1;
  10c2ed:	41 83 ce ff          	or     $0xffffffff,%r14d
	if ((INBYTE(LSR(dev)) & LSR_RXRDY) != 0) {
  10c2f1:	a8 01                	test   $0x1,%al
  10c2f3:	74 09                	je     10c2fe <uart_ns16550_poll_in+0x86>
  10c2f5:	89 ca                	mov    %ecx,%edx
  10c2f7:	ec                   	in     (%dx),%al
		/* got a character */
		*c = INBYTE(RDR(dev));
  10c2f8:	41 88 07             	mov    %al,(%r15)
		ret = 0;
  10c2fb:	45 31 f6             	xor    %r14d,%r14d
	}

	k_spin_unlock(&DEV_DATA(dev)->lock, key);
  10c2fe:	4c 8b 63 20          	mov    0x20(%rbx),%r12
  10c302:	49 83 c4 08          	add    $0x8,%r12
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  10c306:	4c 89 e7             	mov    %r12,%rdi
  10c309:	e8 8b 15 00 00       	callq  10d899 <z_spin_unlock_valid>
  10c30e:	84 c0                	test   %al,%al
  10c310:	75 37                	jne    10c349 <uart_ns16550_poll_in+0xd1>
  10c312:	b9 b9 00 00 00       	mov    $0xb9,%ecx
  10c317:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  10c31c:	be 41 d2 11 00       	mov    $0x11d241,%esi
  10c321:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  10c326:	e8 cd 42 ff ff       	callq  1005f8 <printk>
  10c32b:	4c 89 e6             	mov    %r12,%rsi
  10c32e:	bf 58 d2 11 00       	mov    $0x11d258,%edi
  10c333:	31 c0                	xor    %eax,%eax
  10c335:	e8 be 42 ff ff       	callq  1005f8 <printk>
  10c33a:	be b9 00 00 00       	mov    $0xb9,%esi
  10c33f:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  10c344:	e8 4f 68 ff ff       	callq  102b98 <assert_post_action>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  10c349:	41 0f ba e5 09       	bt     $0x9,%r13d
  10c34e:	73 01                	jae    10c351 <uart_ns16550_poll_in+0xd9>
		__asm__ volatile ("sti" ::: "memory");
  10c350:	fb                   	sti    

	return ret;
}
  10c351:	5a                   	pop    %rdx
  10c352:	44 89 f0             	mov    %r14d,%eax
  10c355:	5b                   	pop    %rbx
  10c356:	41 5c                	pop    %r12
  10c358:	41 5d                	pop    %r13
  10c35a:	41 5e                	pop    %r14
  10c35c:	41 5f                	pop    %r15
  10c35e:	5d                   	pop    %rbp
  10c35f:	c3                   	retq   

000000000010c360 <uart_ns16550_poll_out>:
 * @param dev UART device struct
 * @param c Character to send
 */
static void uart_ns16550_poll_out(const struct device *dev,
					   unsigned char c)
{
  10c360:	55                   	push   %rbp
  10c361:	48 89 e5             	mov    %rsp,%rbp
  10c364:	41 56                	push   %r14
  10c366:	41 89 f6             	mov    %esi,%r14d
  10c369:	41 55                	push   %r13
  10c36b:	41 54                	push   %r12
  10c36d:	53                   	push   %rbx
	k_spinlock_key_t key = k_spin_lock(&DEV_DATA(dev)->lock);
  10c36e:	48 8b 47 20          	mov    0x20(%rdi),%rax
{
  10c372:	48 89 fb             	mov    %rdi,%rbx
	k_spinlock_key_t key = k_spin_lock(&DEV_DATA(dev)->lock);
  10c375:	4c 8d 60 08          	lea    0x8(%rax),%r12
  10c379:	9c                   	pushfq 
  10c37a:	fa                   	cli    
  10c37b:	41 5d                	pop    %r13
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  10c37d:	4c 89 e7             	mov    %r12,%rdi
  10c380:	e8 f4 14 00 00       	callq  10d879 <z_spin_lock_valid>
  10c385:	84 c0                	test   %al,%al
  10c387:	75 37                	jne    10c3c0 <uart_ns16550_poll_out+0x60>
  10c389:	b9 8e 00 00 00       	mov    $0x8e,%ecx
  10c38e:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  10c393:	be fd d1 11 00       	mov    $0x11d1fd,%esi
  10c398:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  10c39d:	e8 56 42 ff ff       	callq  1005f8 <printk>
  10c3a2:	4c 89 e6             	mov    %r12,%rsi
  10c3a5:	bf 12 d2 11 00       	mov    $0x11d212,%edi
  10c3aa:	31 c0                	xor    %eax,%eax
  10c3ac:	e8 47 42 ff ff       	callq  1005f8 <printk>
  10c3b1:	be 8e 00 00 00       	mov    $0x8e,%esi
  10c3b6:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  10c3bb:	e8 d8 67 ff ff       	callq  102b98 <assert_post_action>
	z_spin_lock_set_owner(l);
  10c3c0:	4c 89 e7             	mov    %r12,%rdi
  10c3c3:	e8 f5 14 00 00       	callq  10d8bd <z_spin_lock_set_owner>
	return DEV_CFG(dev)->port;
  10c3c8:	48 8b 43 08          	mov    0x8(%rbx),%rax
  10c3cc:	8b 08                	mov    (%rax),%ecx

	while ((INBYTE(LSR(dev)) & LSR_THRE) == 0) {
  10c3ce:	8d 51 05             	lea    0x5(%rcx),%edx
	__asm__ volatile("inb %w1, %b0" : "=a"(ret) : "Nd"(port));
  10c3d1:	ec                   	in     (%dx),%al
  10c3d2:	a8 20                	test   $0x20,%al
  10c3d4:	74 fb                	je     10c3d1 <uart_ns16550_poll_out+0x71>
	__asm__ volatile("outb %b0, %w1" :: "a"(data), "Nd"(port));
  10c3d6:	44 89 f0             	mov    %r14d,%eax
  10c3d9:	89 ca                	mov    %ecx,%edx
  10c3db:	ee                   	out    %al,(%dx)
	}

	OUTBYTE(THR(dev), c);

	k_spin_unlock(&DEV_DATA(dev)->lock, key);
  10c3dc:	4c 8b 63 20          	mov    0x20(%rbx),%r12
  10c3e0:	49 83 c4 08          	add    $0x8,%r12
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  10c3e4:	4c 89 e7             	mov    %r12,%rdi
  10c3e7:	e8 ad 14 00 00       	callq  10d899 <z_spin_unlock_valid>
  10c3ec:	84 c0                	test   %al,%al
  10c3ee:	75 37                	jne    10c427 <uart_ns16550_poll_out+0xc7>
  10c3f0:	b9 b9 00 00 00       	mov    $0xb9,%ecx
  10c3f5:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  10c3fa:	be 41 d2 11 00       	mov    $0x11d241,%esi
  10c3ff:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  10c404:	e8 ef 41 ff ff       	callq  1005f8 <printk>
  10c409:	4c 89 e6             	mov    %r12,%rsi
  10c40c:	bf 58 d2 11 00       	mov    $0x11d258,%edi
  10c411:	31 c0                	xor    %eax,%eax
  10c413:	e8 e0 41 ff ff       	callq  1005f8 <printk>
  10c418:	be b9 00 00 00       	mov    $0xb9,%esi
  10c41d:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  10c422:	e8 71 67 ff ff       	callq  102b98 <assert_post_action>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  10c427:	41 0f ba e5 09       	bt     $0x9,%r13d
  10c42c:	73 01                	jae    10c42f <uart_ns16550_poll_out+0xcf>
		__asm__ volatile ("sti" ::: "memory");
  10c42e:	fb                   	sti    
}
  10c42f:	5b                   	pop    %rbx
  10c430:	41 5c                	pop    %r12
  10c432:	41 5d                	pop    %r13
  10c434:	41 5e                	pop    %r14
  10c436:	5d                   	pop    %rbp
  10c437:	c3                   	retq   

000000000010c438 <uart_ns16550_err_check>:
 *
 * @return one of UART_ERROR_OVERRUN, UART_ERROR_PARITY, UART_ERROR_FRAMING,
 * UART_BREAK if an error was detected, 0 otherwise.
 */
static int uart_ns16550_err_check(const struct device *dev)
{
  10c438:	55                   	push   %rbp
  10c439:	48 89 e5             	mov    %rsp,%rbp
  10c43c:	41 56                	push   %r14
  10c43e:	41 55                	push   %r13
  10c440:	41 54                	push   %r12
  10c442:	49 89 fc             	mov    %rdi,%r12
  10c445:	53                   	push   %rbx
	k_spinlock_key_t key = k_spin_lock(&DEV_DATA(dev)->lock);
  10c446:	48 8b 47 20          	mov    0x20(%rdi),%rax
  10c44a:	4c 8d 68 08          	lea    0x8(%rax),%r13
  10c44e:	9c                   	pushfq 
  10c44f:	fa                   	cli    
  10c450:	41 5e                	pop    %r14
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  10c452:	4c 89 ef             	mov    %r13,%rdi
  10c455:	e8 1f 14 00 00       	callq  10d879 <z_spin_lock_valid>
  10c45a:	84 c0                	test   %al,%al
  10c45c:	75 37                	jne    10c495 <uart_ns16550_err_check+0x5d>
  10c45e:	b9 8e 00 00 00       	mov    $0x8e,%ecx
  10c463:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  10c468:	be fd d1 11 00       	mov    $0x11d1fd,%esi
  10c46d:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  10c472:	e8 81 41 ff ff       	callq  1005f8 <printk>
  10c477:	4c 89 ee             	mov    %r13,%rsi
  10c47a:	bf 12 d2 11 00       	mov    $0x11d212,%edi
  10c47f:	31 c0                	xor    %eax,%eax
  10c481:	e8 72 41 ff ff       	callq  1005f8 <printk>
  10c486:	be 8e 00 00 00       	mov    $0x8e,%esi
  10c48b:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  10c490:	e8 03 67 ff ff       	callq  102b98 <assert_post_action>
	z_spin_lock_set_owner(l);
  10c495:	4c 89 ef             	mov    %r13,%rdi
  10c498:	e8 20 14 00 00       	callq  10d8bd <z_spin_lock_set_owner>
	return DEV_CFG(dev)->port;
  10c49d:	49 8b 44 24 08       	mov    0x8(%r12),%rax
	int check = (INBYTE(LSR(dev)) & LSR_EOB_MASK);
  10c4a2:	8b 10                	mov    (%rax),%edx
  10c4a4:	83 c2 05             	add    $0x5,%edx
	__asm__ volatile("inb %w1, %b0" : "=a"(ret) : "Nd"(port));
  10c4a7:	ec                   	in     (%dx),%al

	k_spin_unlock(&DEV_DATA(dev)->lock, key);
  10c4a8:	4d 8b 64 24 20       	mov    0x20(%r12),%r12
	int check = (INBYTE(LSR(dev)) & LSR_EOB_MASK);
  10c4ad:	89 c3                	mov    %eax,%ebx
  10c4af:	83 e3 1e             	and    $0x1e,%ebx
	k_spin_unlock(&DEV_DATA(dev)->lock, key);
  10c4b2:	49 83 c4 08          	add    $0x8,%r12
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  10c4b6:	4c 89 e7             	mov    %r12,%rdi
  10c4b9:	e8 db 13 00 00       	callq  10d899 <z_spin_unlock_valid>
  10c4be:	84 c0                	test   %al,%al
  10c4c0:	75 37                	jne    10c4f9 <uart_ns16550_err_check+0xc1>
  10c4c2:	b9 b9 00 00 00       	mov    $0xb9,%ecx
  10c4c7:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  10c4cc:	be 41 d2 11 00       	mov    $0x11d241,%esi
  10c4d1:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  10c4d6:	e8 1d 41 ff ff       	callq  1005f8 <printk>
  10c4db:	4c 89 e6             	mov    %r12,%rsi
  10c4de:	bf 58 d2 11 00       	mov    $0x11d258,%edi
  10c4e3:	31 c0                	xor    %eax,%eax
  10c4e5:	e8 0e 41 ff ff       	callq  1005f8 <printk>
  10c4ea:	be b9 00 00 00       	mov    $0xb9,%esi
  10c4ef:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  10c4f4:	e8 9f 66 ff ff       	callq  102b98 <assert_post_action>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  10c4f9:	41 0f ba e6 09       	bt     $0x9,%r14d
  10c4fe:	73 01                	jae    10c501 <uart_ns16550_err_check+0xc9>
		__asm__ volatile ("sti" ::: "memory");
  10c500:	fb                   	sti    

	return check >> 1;
  10c501:	89 d8                	mov    %ebx,%eax
}
  10c503:	5b                   	pop    %rbx
  10c504:	41 5c                	pop    %r12
	return check >> 1;
  10c506:	d1 f8                	sar    %eax
}
  10c508:	41 5d                	pop    %r13
  10c50a:	41 5e                	pop    %r14
  10c50c:	5d                   	pop    %rbp
  10c50d:	c3                   	retq   

000000000010c50e <z_obj_validation_check.constprop.0>:
static inline int z_obj_validation_check(struct z_object *ko,
  10c50e:	55                   	push   %rbp
	ret = z_object_validate(ko, otype, init);
  10c50f:	31 d2                	xor    %edx,%edx
static inline int z_obj_validation_check(struct z_object *ko,
  10c511:	48 89 e5             	mov    %rsp,%rbp
  10c514:	41 56                	push   %r14
  10c516:	49 89 f6             	mov    %rsi,%r14
	ret = z_object_validate(ko, otype, init);
  10c519:	be 2f 00 00 00       	mov    $0x2f,%esi
static inline int z_obj_validation_check(struct z_object *ko,
  10c51e:	41 55                	push   %r13
  10c520:	49 89 fd             	mov    %rdi,%r13
  10c523:	48 83 ec 10          	sub    $0x10,%rsp
	ret = z_object_validate(ko, otype, init);
  10c527:	e8 40 aa 00 00       	callq  116f6c <z_object_validate>
	if (ret != 0) {
  10c52c:	85 c0                	test   %eax,%eax
  10c52e:	74 18                	je     10c548 <z_obj_validation_check.constprop.0+0x3a>
		z_dump_object_error(ret, obj, ko, otype);
  10c530:	89 c7                	mov    %eax,%edi
  10c532:	b9 2f 00 00 00       	mov    $0x2f,%ecx
  10c537:	4c 89 ea             	mov    %r13,%rdx
  10c53a:	4c 89 f6             	mov    %r14,%rsi
  10c53d:	89 45 ec             	mov    %eax,-0x14(%rbp)
  10c540:	e8 dc a8 00 00       	callq  116e21 <z_dump_object_error>
  10c545:	8b 45 ec             	mov    -0x14(%rbp),%eax
}
  10c548:	5a                   	pop    %rdx
  10c549:	59                   	pop    %rcx
  10c54a:	41 5d                	pop    %r13
  10c54c:	41 5e                	pop    %r14
  10c54e:	5d                   	pop    %rbp
  10c54f:	c3                   	retq   

000000000010c550 <z_mrsh_uart_err_check>:
#include <syscalls/uart.h>

extern int z_vrfy_uart_err_check(const struct device * dev);
uintptr_t z_mrsh_uart_err_check(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
  10c550:	55                   	push   %rbp
  10c551:	48 89 e5             	mov    %rsp,%rbp
  10c554:	41 54                	push   %r12
  10c556:	49 89 fc             	mov    %rdi,%r12
  10c559:	51                   	push   %rcx
	_current->syscall_frame = ssf;
  10c55a:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  10c55e:	48 8b 05 eb c1 01 00 	mov    0x1c1eb(%rip),%rax        # 128750 <_kernel+0x10>
  10c565:	48 89 90 40 01 00 00 	mov    %rdx,0x140(%rax)
	{							 \
		Z_OOPS(Z_SYSCALL_DRIVER_UART(dev, op_)); \
		z_impl_uart_ ## op_(dev); \
	}

UART_SIMPLE(err_check)
  10c56c:	e8 63 a5 00 00       	callq  116ad4 <z_object_find>
  10c571:	4c 89 e6             	mov    %r12,%rsi
  10c574:	48 89 c7             	mov    %rax,%rdi
  10c577:	e8 92 ff ff ff       	callq  10c50e <z_obj_validation_check.constprop.0>
  10c57c:	85 c0                	test   %eax,%eax
  10c57e:	74 18                	je     10c598 <z_mrsh_uart_err_check+0x48>
  10c580:	ba b0 c0 11 00       	mov    $0x11c0b0,%edx
  10c585:	be 45 00 00 00       	mov    $0x45,%esi
  10c58a:	bf 23 f3 11 00       	mov    $0x11f323,%edi
  10c58f:	31 c0                	xor    %eax,%eax
  10c591:	e8 30 6b ff ff       	callq  1030c6 <z_log_minimal_printk>
  10c596:	eb 29                	jmp    10c5c1 <z_mrsh_uart_err_check+0x71>
  10c598:	4d 8b 44 24 10       	mov    0x10(%r12),%r8
  10c59d:	49 8b 40 10          	mov    0x10(%r8),%rax
  10c5a1:	48 85 c0             	test   %rax,%rax
  10c5a4:	75 2e                	jne    10c5d4 <z_mrsh_uart_err_check+0x84>
  10c5a6:	b9 ed f3 11 00       	mov    $0x11f3ed,%ecx
  10c5ab:	ba b0 c0 11 00       	mov    $0x11c0b0,%edx
  10c5b0:	be 45 00 00 00       	mov    $0x45,%esi
  10c5b5:	31 c0                	xor    %eax,%eax
  10c5b7:	bf 57 f3 11 00       	mov    $0x11f357,%edi
  10c5bc:	e8 05 6b ff ff       	callq  1030c6 <z_log_minimal_printk>
  10c5c1:	48 8b 05 88 c1 01 00 	mov    0x1c188(%rip),%rax        # 128750 <_kernel+0x10>
  10c5c8:	48 8b b8 40 01 00 00 	mov    0x140(%rax),%rdi
  10c5cf:	e8 39 d6 ff ff       	callq  109c0d <arch_syscall_oops>
	return api->err_check(dev);
  10c5d4:	4c 89 e7             	mov    %r12,%rdi
  10c5d7:	ff d0                	callq  *%rax
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	int ret = z_vrfy_uart_err_check(*(const struct device **)&arg0)
;
	_current->syscall_frame = NULL;
  10c5d9:	48 8b 15 70 c1 01 00 	mov    0x1c170(%rip),%rdx        # 128750 <_kernel+0x10>
	return (uintptr_t) ret;
  10c5e0:	48 98                	cltq   
	_current->syscall_frame = NULL;
  10c5e2:	48 c7 82 40 01 00 00 	movq   $0x0,0x140(%rdx)
  10c5e9:	00 00 00 00 
}
  10c5ed:	5a                   	pop    %rdx
  10c5ee:	41 5c                	pop    %r12
  10c5f0:	5d                   	pop    %rbp
  10c5f1:	c3                   	retq   

000000000010c5f2 <z_mrsh_uart_poll_in>:
#include <syscalls/uart.h>

extern int z_vrfy_uart_poll_in(const struct device * dev, unsigned char * p_char);
uintptr_t z_mrsh_uart_poll_in(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
  10c5f2:	55                   	push   %rbp
	_current->syscall_frame = ssf;
  10c5f3:	48 8b 05 56 c1 01 00 	mov    0x1c156(%rip),%rax        # 128750 <_kernel+0x10>
{
  10c5fa:	48 89 e5             	mov    %rsp,%rbp
  10c5fd:	41 55                	push   %r13
  10c5ff:	49 89 f5             	mov    %rsi,%r13
	_current->syscall_frame = ssf;
  10c602:	48 8b 55 10          	mov    0x10(%rbp),%rdx
{
  10c606:	41 54                	push   %r12
  10c608:	49 89 fc             	mov    %rdi,%r12
	_current->syscall_frame = ssf;
  10c60b:	48 89 90 40 01 00 00 	mov    %rdx,0x140(%rax)
#include <syscalls/uart_err_check_mrsh.c>

static inline int z_vrfy_uart_poll_in(const struct device *dev,
				      unsigned char *p_char)
{
	Z_OOPS(Z_SYSCALL_DRIVER_UART(dev, poll_in));
  10c612:	e8 bd a4 00 00       	callq  116ad4 <z_object_find>
  10c617:	4c 89 e6             	mov    %r12,%rsi
  10c61a:	48 89 c7             	mov    %rax,%rdi
  10c61d:	e8 ec fe ff ff       	callq  10c50e <z_obj_validation_check.constprop.0>
  10c622:	85 c0                	test   %eax,%eax
  10c624:	74 18                	je     10c63e <z_mrsh_uart_poll_in+0x4c>
  10c626:	ba 90 c0 11 00       	mov    $0x11c090,%edx
  10c62b:	be 45 00 00 00       	mov    $0x45,%esi
  10c630:	bf 23 f3 11 00       	mov    $0x11f323,%edi
  10c635:	31 c0                	xor    %eax,%eax
  10c637:	e8 8a 6a ff ff       	callq  1030c6 <z_log_minimal_printk>
  10c63c:	eb 26                	jmp    10c664 <z_mrsh_uart_poll_in+0x72>
  10c63e:	4d 8b 44 24 10       	mov    0x10(%r12),%r8
  10c643:	49 83 38 00          	cmpq   $0x0,(%r8)
  10c647:	75 2e                	jne    10c677 <z_mrsh_uart_poll_in+0x85>
  10c649:	b9 f7 f3 11 00       	mov    $0x11f3f7,%ecx
  10c64e:	ba 90 c0 11 00       	mov    $0x11c090,%edx
  10c653:	be 45 00 00 00       	mov    $0x45,%esi
  10c658:	31 c0                	xor    %eax,%eax
  10c65a:	bf 57 f3 11 00       	mov    $0x11f357,%edi
  10c65f:	e8 62 6a ff ff       	callq  1030c6 <z_log_minimal_printk>
	Z_OOPS(Z_SYSCALL_MEMORY_WRITE(p_char, sizeof(unsigned char)));
  10c664:	48 8b 05 e5 c0 01 00 	mov    0x1c0e5(%rip),%rax        # 128750 <_kernel+0x10>
  10c66b:	48 8b b8 40 01 00 00 	mov    0x140(%rax),%rdi
  10c672:	e8 96 d5 ff ff       	callq  109c0d <arch_syscall_oops>
  10c677:	ba 01 00 00 00       	mov    $0x1,%edx
  10c67c:	be 01 00 00 00       	mov    $0x1,%esi
  10c681:	4c 89 ef             	mov    %r13,%rdi
  10c684:	e8 33 cd ff ff       	callq  1093bc <arch_buffer_validate>
  10c689:	85 c0                	test   %eax,%eax
  10c68b:	74 27                	je     10c6b4 <z_mrsh_uart_poll_in+0xc2>
  10c68d:	41 b9 a4 d2 11 00    	mov    $0x11d2a4,%r9d
  10c693:	4c 89 e9             	mov    %r13,%rcx
  10c696:	ba 90 c0 11 00       	mov    $0x11c090,%edx
  10c69b:	31 c0                	xor    %eax,%eax
  10c69d:	41 b8 01 00 00 00    	mov    $0x1,%r8d
  10c6a3:	be 45 00 00 00       	mov    $0x45,%esi
  10c6a8:	bf 1e cf 11 00       	mov    $0x11cf1e,%edi
  10c6ad:	e8 14 6a ff ff       	callq  1030c6 <z_log_minimal_printk>
  10c6b2:	eb b0                	jmp    10c664 <z_mrsh_uart_poll_in+0x72>
	if (api->poll_in == NULL) {
  10c6b4:	49 8b 44 24 10       	mov    0x10(%r12),%rax
  10c6b9:	48 8b 10             	mov    (%rax),%rdx
		return -ENOSYS;
  10c6bc:	b8 a8 ff ff ff       	mov    $0xffffffa8,%eax
	if (api->poll_in == NULL) {
  10c6c1:	48 85 d2             	test   %rdx,%rdx
  10c6c4:	74 08                	je     10c6ce <z_mrsh_uart_poll_in+0xdc>
	return api->poll_in(dev, p_char);
  10c6c6:	4c 89 ee             	mov    %r13,%rsi
  10c6c9:	4c 89 e7             	mov    %r12,%rdi
  10c6cc:	ff d2                	callq  *%rdx
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	int ret = z_vrfy_uart_poll_in(*(const struct device **)&arg0, *(unsigned char **)&arg1)
;
	_current->syscall_frame = NULL;
  10c6ce:	48 8b 15 7b c0 01 00 	mov    0x1c07b(%rip),%rdx        # 128750 <_kernel+0x10>
	return (uintptr_t) ret;
  10c6d5:	48 98                	cltq   
	_current->syscall_frame = NULL;
  10c6d7:	48 c7 82 40 01 00 00 	movq   $0x0,0x140(%rdx)
  10c6de:	00 00 00 00 
}
  10c6e2:	41 5c                	pop    %r12
  10c6e4:	41 5d                	pop    %r13
  10c6e6:	5d                   	pop    %rbp
  10c6e7:	c3                   	retq   

000000000010c6e8 <z_mrsh_uart_poll_out>:
#include <syscalls/uart.h>

extern void z_vrfy_uart_poll_out(const struct device * dev, unsigned char out_char);
uintptr_t z_mrsh_uart_poll_out(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
  10c6e8:	55                   	push   %rbp
	_current->syscall_frame = ssf;
  10c6e9:	48 8b 05 60 c0 01 00 	mov    0x1c060(%rip),%rax        # 128750 <_kernel+0x10>
{
  10c6f0:	48 89 e5             	mov    %rsp,%rbp
  10c6f3:	41 55                	push   %r13
	(void) arg2;	/* unused */
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	z_vrfy_uart_poll_out(*(const struct device **)&arg0, *(unsigned char*)&arg1)
  10c6f5:	44 0f b6 ee          	movzbl %sil,%r13d
	_current->syscall_frame = ssf;
  10c6f9:	48 8b 55 10          	mov    0x10(%rbp),%rdx
{
  10c6fd:	41 54                	push   %r12
  10c6ff:	49 89 fc             	mov    %rdi,%r12
	_current->syscall_frame = ssf;
  10c702:	48 89 90 40 01 00 00 	mov    %rdx,0x140(%rax)
#include <syscalls/uart_poll_in_mrsh.c>

static inline void z_vrfy_uart_poll_out(const struct device *dev,
					unsigned char out_char)
{
	Z_OOPS(Z_SYSCALL_DRIVER_UART(dev, poll_out));
  10c709:	e8 c6 a3 00 00       	callq  116ad4 <z_object_find>
  10c70e:	4c 89 e6             	mov    %r12,%rsi
  10c711:	48 89 c7             	mov    %rax,%rdi
  10c714:	e8 f5 fd ff ff       	callq  10c50e <z_obj_validation_check.constprop.0>
  10c719:	85 c0                	test   %eax,%eax
  10c71b:	74 18                	je     10c735 <z_mrsh_uart_poll_out+0x4d>
  10c71d:	ba 70 c0 11 00       	mov    $0x11c070,%edx
  10c722:	be 45 00 00 00       	mov    $0x45,%esi
  10c727:	bf 23 f3 11 00       	mov    $0x11f323,%edi
  10c72c:	31 c0                	xor    %eax,%eax
  10c72e:	e8 93 69 ff ff       	callq  1030c6 <z_log_minimal_printk>
  10c733:	eb 29                	jmp    10c75e <z_mrsh_uart_poll_out+0x76>
  10c735:	4d 8b 44 24 10       	mov    0x10(%r12),%r8
  10c73a:	49 8b 40 08          	mov    0x8(%r8),%rax
  10c73e:	48 85 c0             	test   %rax,%rax
  10c741:	75 2e                	jne    10c771 <z_mrsh_uart_poll_out+0x89>
  10c743:	b9 ff f3 11 00       	mov    $0x11f3ff,%ecx
  10c748:	ba 70 c0 11 00       	mov    $0x11c070,%edx
  10c74d:	be 45 00 00 00       	mov    $0x45,%esi
  10c752:	31 c0                	xor    %eax,%eax
  10c754:	bf 57 f3 11 00       	mov    $0x11f357,%edi
  10c759:	e8 68 69 ff ff       	callq  1030c6 <z_log_minimal_printk>
  10c75e:	48 8b 05 eb bf 01 00 	mov    0x1bfeb(%rip),%rax        # 128750 <_kernel+0x10>
  10c765:	48 8b b8 40 01 00 00 	mov    0x140(%rax),%rdi
  10c76c:	e8 9c d4 ff ff       	callq  109c0d <arch_syscall_oops>
	api->poll_out(dev, out_char);
  10c771:	44 89 ee             	mov    %r13d,%esi
  10c774:	4c 89 e7             	mov    %r12,%rdi
  10c777:	ff d0                	callq  *%rax
;
	_current->syscall_frame = NULL;
  10c779:	48 8b 05 d0 bf 01 00 	mov    0x1bfd0(%rip),%rax        # 128750 <_kernel+0x10>
  10c780:	48 c7 80 40 01 00 00 	movq   $0x0,0x140(%rax)
  10c787:	00 00 00 00 
	return 0;
}
  10c78b:	31 c0                	xor    %eax,%eax
  10c78d:	41 5c                	pop    %r12
  10c78f:	41 5d                	pop    %r13
  10c791:	5d                   	pop    %rbp
  10c792:	c3                   	retq   

000000000010c793 <z_mrsh_uart_config_get>:
#include <syscalls/uart.h>

extern int z_vrfy_uart_config_get(const struct device * dev, struct uart_config * cfg);
uintptr_t z_mrsh_uart_config_get(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
  10c793:	55                   	push   %rbp
	_current->syscall_frame = ssf;
  10c794:	48 8b 05 b5 bf 01 00 	mov    0x1bfb5(%rip),%rax        # 128750 <_kernel+0x10>
{
  10c79b:	48 89 e5             	mov    %rsp,%rbp
  10c79e:	41 55                	push   %r13
  10c7a0:	49 89 f5             	mov    %rsi,%r13
	_current->syscall_frame = ssf;
  10c7a3:	48 8b 55 10          	mov    0x10(%rbp),%rdx
{
  10c7a7:	41 54                	push   %r12
  10c7a9:	49 89 fc             	mov    %rdi,%r12
	_current->syscall_frame = ssf;
  10c7ac:	48 89 90 40 01 00 00 	mov    %rdx,0x140(%rax)
#include <syscalls/uart_poll_out_mrsh.c>

static inline int z_vrfy_uart_config_get(const struct device *dev,
					 struct uart_config *cfg)
{
	Z_OOPS(Z_SYSCALL_DRIVER_UART(dev, config_get));
  10c7b3:	e8 1c a3 00 00       	callq  116ad4 <z_object_find>
  10c7b8:	4c 89 e6             	mov    %r12,%rsi
  10c7bb:	48 89 c7             	mov    %rax,%rdi
  10c7be:	e8 4b fd ff ff       	callq  10c50e <z_obj_validation_check.constprop.0>
  10c7c3:	85 c0                	test   %eax,%eax
  10c7c5:	74 18                	je     10c7df <z_mrsh_uart_config_get+0x4c>
  10c7c7:	ba 50 c0 11 00       	mov    $0x11c050,%edx
  10c7cc:	be 45 00 00 00       	mov    $0x45,%esi
  10c7d1:	bf 23 f3 11 00       	mov    $0x11f323,%edi
  10c7d6:	31 c0                	xor    %eax,%eax
  10c7d8:	e8 e9 68 ff ff       	callq  1030c6 <z_log_minimal_printk>
  10c7dd:	eb 27                	jmp    10c806 <z_mrsh_uart_config_get+0x73>
  10c7df:	4d 8b 44 24 10       	mov    0x10(%r12),%r8
  10c7e4:	49 83 78 20 00       	cmpq   $0x0,0x20(%r8)
  10c7e9:	75 2e                	jne    10c819 <z_mrsh_uart_config_get+0x86>
  10c7eb:	b9 08 f4 11 00       	mov    $0x11f408,%ecx
  10c7f0:	ba 50 c0 11 00       	mov    $0x11c050,%edx
  10c7f5:	be 45 00 00 00       	mov    $0x45,%esi
  10c7fa:	31 c0                	xor    %eax,%eax
  10c7fc:	bf 57 f3 11 00       	mov    $0x11f357,%edi
  10c801:	e8 c0 68 ff ff       	callq  1030c6 <z_log_minimal_printk>
	Z_OOPS(Z_SYSCALL_MEMORY_WRITE(cfg, sizeof(struct uart_config)));
  10c806:	48 8b 05 43 bf 01 00 	mov    0x1bf43(%rip),%rax        # 128750 <_kernel+0x10>
  10c80d:	48 8b b8 40 01 00 00 	mov    0x140(%rax),%rdi
  10c814:	e8 f4 d3 ff ff       	callq  109c0d <arch_syscall_oops>
  10c819:	ba 01 00 00 00       	mov    $0x1,%edx
  10c81e:	be 08 00 00 00       	mov    $0x8,%esi
  10c823:	4c 89 ef             	mov    %r13,%rdi
  10c826:	e8 91 cb ff ff       	callq  1093bc <arch_buffer_validate>
  10c82b:	85 c0                	test   %eax,%eax
  10c82d:	74 27                	je     10c856 <z_mrsh_uart_config_get+0xc3>
  10c82f:	41 b9 a4 d2 11 00    	mov    $0x11d2a4,%r9d
  10c835:	4c 89 e9             	mov    %r13,%rcx
  10c838:	ba 50 c0 11 00       	mov    $0x11c050,%edx
  10c83d:	31 c0                	xor    %eax,%eax
  10c83f:	41 b8 08 00 00 00    	mov    $0x8,%r8d
  10c845:	be 45 00 00 00       	mov    $0x45,%esi
  10c84a:	bf 1e cf 11 00       	mov    $0x11cf1e,%edi
  10c84f:	e8 72 68 ff ff       	callq  1030c6 <z_log_minimal_printk>
  10c854:	eb b0                	jmp    10c806 <z_mrsh_uart_config_get+0x73>
					 struct uart_config *cfg)
{
	const struct uart_driver_api *api =
				(const struct uart_driver_api *)dev->api;

	if (api->config_get == NULL) {
  10c856:	49 8b 44 24 10       	mov    0x10(%r12),%rax
  10c85b:	48 8b 50 20          	mov    0x20(%rax),%rdx
		return -ENOSYS;
  10c85f:	b8 a8 ff ff ff       	mov    $0xffffffa8,%eax
	if (api->config_get == NULL) {
  10c864:	48 85 d2             	test   %rdx,%rdx
  10c867:	74 08                	je     10c871 <z_mrsh_uart_config_get+0xde>
	}

	return api->config_get(dev, cfg);
  10c869:	4c 89 ee             	mov    %r13,%rsi
  10c86c:	4c 89 e7             	mov    %r12,%rdi
  10c86f:	ff d2                	callq  *%rdx
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	int ret = z_vrfy_uart_config_get(*(const struct device **)&arg0, *(struct uart_config **)&arg1)
;
	_current->syscall_frame = NULL;
  10c871:	48 8b 15 d8 be 01 00 	mov    0x1bed8(%rip),%rdx        # 128750 <_kernel+0x10>
	return (uintptr_t) ret;
  10c878:	48 98                	cltq   
	_current->syscall_frame = NULL;
  10c87a:	48 c7 82 40 01 00 00 	movq   $0x0,0x140(%rdx)
  10c881:	00 00 00 00 
}
  10c885:	41 5c                	pop    %r12
  10c887:	41 5d                	pop    %r13
  10c889:	5d                   	pop    %rbp
  10c88a:	c3                   	retq   

000000000010c88b <z_mrsh_uart_configure>:
#include <syscalls/uart.h>

extern int z_vrfy_uart_configure(const struct device * dev, const struct uart_config * cfg);
uintptr_t z_mrsh_uart_configure(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
  10c88b:	55                   	push   %rbp
	_current->syscall_frame = ssf;
  10c88c:	48 8b 05 bd be 01 00 	mov    0x1bebd(%rip),%rax        # 128750 <_kernel+0x10>
{
  10c893:	48 89 e5             	mov    %rsp,%rbp
  10c896:	41 55                	push   %r13
  10c898:	49 89 f5             	mov    %rsi,%r13
	_current->syscall_frame = ssf;
  10c89b:	48 8b 55 10          	mov    0x10(%rbp),%rdx
{
  10c89f:	41 54                	push   %r12
  10c8a1:	49 89 fc             	mov    %rdi,%r12
	_current->syscall_frame = ssf;
  10c8a4:	48 89 90 40 01 00 00 	mov    %rdx,0x140(%rax)
#include <syscalls/uart_config_get_mrsh.c>

static inline int z_vrfy_uart_configure(const struct device *dev,
					const struct uart_config *cfg)
{
	Z_OOPS(Z_SYSCALL_DRIVER_UART(dev, config_get));
  10c8ab:	e8 24 a2 00 00       	callq  116ad4 <z_object_find>
  10c8b0:	4c 89 e6             	mov    %r12,%rsi
  10c8b3:	48 89 c7             	mov    %rax,%rdi
  10c8b6:	e8 53 fc ff ff       	callq  10c50e <z_obj_validation_check.constprop.0>
  10c8bb:	85 c0                	test   %eax,%eax
  10c8bd:	74 18                	je     10c8d7 <z_mrsh_uart_configure+0x4c>
  10c8bf:	ba 30 c0 11 00       	mov    $0x11c030,%edx
  10c8c4:	be 45 00 00 00       	mov    $0x45,%esi
  10c8c9:	bf 23 f3 11 00       	mov    $0x11f323,%edi
  10c8ce:	31 c0                	xor    %eax,%eax
  10c8d0:	e8 f1 67 ff ff       	callq  1030c6 <z_log_minimal_printk>
  10c8d5:	eb 27                	jmp    10c8fe <z_mrsh_uart_configure+0x73>
  10c8d7:	4d 8b 44 24 10       	mov    0x10(%r12),%r8
  10c8dc:	49 83 78 20 00       	cmpq   $0x0,0x20(%r8)
  10c8e1:	75 2e                	jne    10c911 <z_mrsh_uart_configure+0x86>
  10c8e3:	b9 08 f4 11 00       	mov    $0x11f408,%ecx
  10c8e8:	ba 30 c0 11 00       	mov    $0x11c030,%edx
  10c8ed:	be 45 00 00 00       	mov    $0x45,%esi
  10c8f2:	31 c0                	xor    %eax,%eax
  10c8f4:	bf 57 f3 11 00       	mov    $0x11f357,%edi
  10c8f9:	e8 c8 67 ff ff       	callq  1030c6 <z_log_minimal_printk>
	Z_OOPS(Z_SYSCALL_MEMORY_READ(cfg, sizeof(struct uart_config)));
  10c8fe:	48 8b 05 4b be 01 00 	mov    0x1be4b(%rip),%rax        # 128750 <_kernel+0x10>
  10c905:	48 8b b8 40 01 00 00 	mov    0x140(%rax),%rdi
  10c90c:	e8 fc d2 ff ff       	callq  109c0d <arch_syscall_oops>
  10c911:	31 d2                	xor    %edx,%edx
  10c913:	be 08 00 00 00       	mov    $0x8,%esi
  10c918:	4c 89 ef             	mov    %r13,%rdi
  10c91b:	e8 9c ca ff ff       	callq  1093bc <arch_buffer_validate>
  10c920:	85 c0                	test   %eax,%eax
  10c922:	74 27                	je     10c94b <z_mrsh_uart_configure+0xc0>
  10c924:	41 b9 de 0d 12 00    	mov    $0x120dde,%r9d
  10c92a:	4c 89 e9             	mov    %r13,%rcx
  10c92d:	ba 30 c0 11 00       	mov    $0x11c030,%edx
  10c932:	31 c0                	xor    %eax,%eax
  10c934:	41 b8 08 00 00 00    	mov    $0x8,%r8d
  10c93a:	be 45 00 00 00       	mov    $0x45,%esi
  10c93f:	bf 1e cf 11 00       	mov    $0x11cf1e,%edi
  10c944:	e8 7d 67 ff ff       	callq  1030c6 <z_log_minimal_printk>
  10c949:	eb b3                	jmp    10c8fe <z_mrsh_uart_configure+0x73>
	if (api->configure == NULL) {
  10c94b:	49 8b 44 24 10       	mov    0x10(%r12),%rax
  10c950:	48 8b 50 18          	mov    0x18(%rax),%rdx
		return -ENOSYS;
  10c954:	b8 a8 ff ff ff       	mov    $0xffffffa8,%eax
	if (api->configure == NULL) {
  10c959:	48 85 d2             	test   %rdx,%rdx
  10c95c:	74 08                	je     10c966 <z_mrsh_uart_configure+0xdb>
	return api->configure(dev, cfg);
  10c95e:	4c 89 ee             	mov    %r13,%rsi
  10c961:	4c 89 e7             	mov    %r12,%rdi
  10c964:	ff d2                	callq  *%rdx
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	int ret = z_vrfy_uart_configure(*(const struct device **)&arg0, *(const struct uart_config **)&arg1)
;
	_current->syscall_frame = NULL;
  10c966:	48 8b 15 e3 bd 01 00 	mov    0x1bde3(%rip),%rdx        # 128750 <_kernel+0x10>
	return (uintptr_t) ret;
  10c96d:	48 98                	cltq   
	_current->syscall_frame = NULL;
  10c96f:	48 c7 82 40 01 00 00 	movq   $0x0,0x140(%rdx)
  10c976:	00 00 00 00 
}
  10c97a:	41 5c                	pop    %r12
  10c97c:	41 5d                	pop    %r13
  10c97e:	5d                   	pop    %rbp
  10c97f:	c3                   	retq   

000000000010c980 <isr>:
	__asm__ volatile("rdtsc" : "=d"(hi), "=a"(lo));
	return lo + (((uint64_t)hi) << 32);
}

static void isr(const void *arg)
{
  10c980:	55                   	push   %rbp
  10c981:	48 89 e5             	mov    %rsp,%rbp
  10c984:	41 54                	push   %r12
  10c986:	53                   	push   %rbx
  10c987:	9c                   	pushfq 
  10c988:	fa                   	cli    
  10c989:	41 5c                	pop    %r12
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  10c98b:	bf a0 cd 1b 00       	mov    $0x1bcda0,%edi
  10c990:	e8 e4 0e 00 00       	callq  10d879 <z_spin_lock_valid>
  10c995:	84 c0                	test   %al,%al
  10c997:	75 39                	jne    10c9d2 <isr+0x52>
  10c999:	b9 8e 00 00 00       	mov    $0x8e,%ecx
  10c99e:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  10c9a3:	be fd d1 11 00       	mov    $0x11d1fd,%esi
  10c9a8:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  10c9ad:	e8 46 3c ff ff       	callq  1005f8 <printk>
  10c9b2:	be a0 cd 1b 00       	mov    $0x1bcda0,%esi
  10c9b7:	bf 12 d2 11 00       	mov    $0x11d212,%edi
  10c9bc:	31 c0                	xor    %eax,%eax
  10c9be:	e8 35 3c ff ff       	callq  1005f8 <printk>
  10c9c3:	be 8e 00 00 00       	mov    $0x8e,%esi
  10c9c8:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  10c9cd:	e8 c6 61 ff ff       	callq  102b98 <assert_post_action>
	z_spin_lock_set_owner(l);
  10c9d2:	bf a0 cd 1b 00       	mov    $0x1bcda0,%edi
  10c9d7:	e8 e1 0e 00 00       	callq  10d8bd <z_spin_lock_set_owner>
	__asm__ volatile("rdtsc" : "=d"(hi), "=a"(lo));
  10c9dc:	0f 31                	rdtsc  
	return lo + (((uint64_t)hi) << 32);
  10c9de:	89 c0                	mov    %eax,%eax
  10c9e0:	48 c1 e2 20          	shl    $0x20,%rdx
	ARG_UNUSED(arg);
	k_spinlock_key_t key = k_spin_lock(&lock);
	uint32_t ticks = (rdtsc() - last_announce) / CYC_PER_TICK;
  10c9e4:	be 30 e6 02 00       	mov    $0x2e630,%esi
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  10c9e9:	bf a0 cd 1b 00       	mov    $0x1bcda0,%edi
  10c9ee:	48 8b 0d a3 03 0b 00 	mov    0xb03a3(%rip),%rcx        # 1bcd98 <last_announce>
  10c9f5:	48 29 c8             	sub    %rcx,%rax
  10c9f8:	48 01 d0             	add    %rdx,%rax
  10c9fb:	31 d2                	xor    %edx,%edx
  10c9fd:	48 f7 f6             	div    %rsi
  10ca00:	48 89 c3             	mov    %rax,%rbx

	last_announce += ticks * CYC_PER_TICK;
  10ca03:	89 c0                	mov    %eax,%eax
  10ca05:	48 69 c0 30 e6 02 00 	imul   $0x2e630,%rax,%rax
  10ca0c:	48 01 c8             	add    %rcx,%rax
  10ca0f:	48 89 05 82 03 0b 00 	mov    %rax,0xb0382(%rip)        # 1bcd98 <last_announce>
  10ca16:	e8 7e 0e 00 00       	callq  10d899 <z_spin_unlock_valid>
  10ca1b:	84 c0                	test   %al,%al
  10ca1d:	75 39                	jne    10ca58 <isr+0xd8>
  10ca1f:	b9 b9 00 00 00       	mov    $0xb9,%ecx
  10ca24:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  10ca29:	be 41 d2 11 00       	mov    $0x11d241,%esi
  10ca2e:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  10ca33:	e8 c0 3b ff ff       	callq  1005f8 <printk>
  10ca38:	be a0 cd 1b 00       	mov    $0x1bcda0,%esi
  10ca3d:	bf 58 d2 11 00       	mov    $0x11d258,%edi
  10ca42:	31 c0                	xor    %eax,%eax
  10ca44:	e8 af 3b ff ff       	callq  1005f8 <printk>
  10ca49:	be b9 00 00 00       	mov    $0xb9,%esi
  10ca4e:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  10ca53:	e8 40 61 ff ff       	callq  102b98 <assert_post_action>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  10ca58:	41 0f ba e4 09       	bt     $0x9,%r12d
  10ca5d:	73 01                	jae    10ca60 <isr+0xe0>
		__asm__ volatile ("sti" ::: "memory");
  10ca5f:	fb                   	sti    
	k_spin_unlock(&lock, key);
	sys_clock_announce(ticks);
  10ca60:	89 df                	mov    %ebx,%edi

	if (!IS_ENABLED(CONFIG_TICKLESS_KERNEL)) {
		sys_clock_set_timeout(1, false);
	}
}
  10ca62:	5b                   	pop    %rbx
  10ca63:	41 5c                	pop    %r12
  10ca65:	5d                   	pop    %rbp
	sys_clock_announce(ticks);
  10ca66:	e9 ac 68 00 00       	jmpq   113317 <sys_clock_announce>

000000000010ca6b <sys_clock_set_timeout>:

	__asm__ volatile("wrmsr" :: "d"(hi), "a"(lo), "c"(msr));
}

void sys_clock_set_timeout(int32_t ticks, bool idle)
{
  10ca6b:	55                   	push   %rbp
  10ca6c:	48 89 e5             	mov    %rsp,%rbp
  10ca6f:	41 56                	push   %r14
  10ca71:	41 55                	push   %r13
  10ca73:	41 54                	push   %r12
  10ca75:	53                   	push   %rbx
  10ca76:	89 fb                	mov    %edi,%ebx
	__asm__ volatile("rdtsc" : "=d"(hi), "=a"(lo));
  10ca78:	0f 31                	rdtsc  
	return lo + (((uint64_t)hi) << 32);
  10ca7a:	49 89 d5             	mov    %rdx,%r13
  10ca7d:	41 89 c6             	mov    %eax,%r14d
  10ca80:	49 c1 e5 20          	shl    $0x20,%r13
  10ca84:	9c                   	pushfq 
  10ca85:	fa                   	cli    
  10ca86:	41 5c                	pop    %r12
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  10ca88:	bf a0 cd 1b 00       	mov    $0x1bcda0,%edi
  10ca8d:	e8 e7 0d 00 00       	callq  10d879 <z_spin_lock_valid>
  10ca92:	84 c0                	test   %al,%al
  10ca94:	75 39                	jne    10cacf <sys_clock_set_timeout+0x64>
  10ca96:	b9 8e 00 00 00       	mov    $0x8e,%ecx
  10ca9b:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  10caa0:	be fd d1 11 00       	mov    $0x11d1fd,%esi
  10caa5:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  10caaa:	e8 49 3b ff ff       	callq  1005f8 <printk>
  10caaf:	be a0 cd 1b 00       	mov    $0x1bcda0,%esi
  10cab4:	bf 12 d2 11 00       	mov    $0x11d212,%edi
  10cab9:	31 c0                	xor    %eax,%eax
  10cabb:	e8 38 3b ff ff       	callq  1005f8 <printk>
  10cac0:	be 8e 00 00 00       	mov    $0x8e,%esi
  10cac5:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  10caca:	e8 c9 60 ff ff       	callq  102b98 <assert_post_action>
	z_spin_lock_set_owner(l);
  10cacf:	bf a0 cd 1b 00       	mov    $0x1bcda0,%edi
  10cad4:	e8 e4 0d 00 00       	callq  10d8bd <z_spin_lock_set_owner>
	ARG_UNUSED(idle);

	uint64_t now = rdtsc();
	k_spinlock_key_t key = k_spin_lock(&lock);
	uint64_t expires = now + MAX(ticks - 1, 0) * CYC_PER_TICK;
  10cad9:	89 d8                	mov    %ebx,%eax
  10cadb:	ba 00 00 00 00       	mov    $0x0,%edx

	expires = last_announce + (((expires - last_announce + CYC_PER_TICK - 1)
  10cae0:	48 8b 0d b1 02 0b 00 	mov    0xb02b1(%rip),%rcx        # 1bcd98 <last_announce>
	uint64_t expires = now + MAX(ticks - 1, 0) * CYC_PER_TICK;
  10cae7:	ff c8                	dec    %eax
				    / CYC_PER_TICK) * CYC_PER_TICK);
  10cae9:	be 30 e6 02 00       	mov    $0x2e630,%esi
	uint64_t expires = now + MAX(ticks - 1, 0) * CYC_PER_TICK;
  10caee:	0f 48 c2             	cmovs  %edx,%eax
				    / CYC_PER_TICK) * CYC_PER_TICK);
  10caf1:	31 d2                	xor    %edx,%edx
	uint64_t expires = now + MAX(ticks - 1, 0) * CYC_PER_TICK;
  10caf3:	48 98                	cltq   
  10caf5:	48 69 c0 30 e6 02 00 	imul   $0x2e630,%rax,%rax
	expires = last_announce + (((expires - last_announce + CYC_PER_TICK - 1)
  10cafc:	48 29 c8             	sub    %rcx,%rax
  10caff:	49 8d 84 06 2f e6 02 	lea    0x2e62f(%r14,%rax,1),%rax
  10cb06:	00 
  10cb07:	4c 01 e8             	add    %r13,%rax
				    / CYC_PER_TICK) * CYC_PER_TICK);
  10cb0a:	48 f7 f6             	div    %rsi
  10cb0d:	48 69 c0 30 e6 02 00 	imul   $0x2e630,%rax,%rax
	 * interrupt if we try to set an expiration across the 64 bit
	 * rollover.  Unfortunately there's no way to test that as on
	 * real hardware it requires more than a century of uptime,
	 * but this is cheap and safe.
	 */
	if (ticks == K_TICKS_FOREVER || expires < last_announce) {
  10cb14:	48 01 c8             	add    %rcx,%rax
  10cb17:	72 04                	jb     10cb1d <sys_clock_set_timeout+0xb2>
  10cb19:	ff c3                	inc    %ebx
  10cb1b:	75 04                	jne    10cb21 <sys_clock_set_timeout+0xb6>
		expires = UINT64_MAX;
  10cb1d:	48 83 c8 ff          	or     $0xffffffffffffffff,%rax
	uint32_t hi = (uint32_t) (val >> 32);
  10cb21:	48 89 c2             	mov    %rax,%rdx
	__asm__ volatile("wrmsr" :: "d"(hi), "a"(lo), "c"(msr));
  10cb24:	b9 e0 06 00 00       	mov    $0x6e0,%ecx
	uint32_t hi = (uint32_t) (val >> 32);
  10cb29:	48 c1 ea 20          	shr    $0x20,%rdx
	__asm__ volatile("wrmsr" :: "d"(hi), "a"(lo), "c"(msr));
  10cb2d:	0f 30                	wrmsr  
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  10cb2f:	bf a0 cd 1b 00       	mov    $0x1bcda0,%edi
  10cb34:	e8 60 0d 00 00       	callq  10d899 <z_spin_unlock_valid>
  10cb39:	84 c0                	test   %al,%al
  10cb3b:	75 39                	jne    10cb76 <sys_clock_set_timeout+0x10b>
  10cb3d:	b9 b9 00 00 00       	mov    $0xb9,%ecx
  10cb42:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  10cb47:	be 41 d2 11 00       	mov    $0x11d241,%esi
  10cb4c:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  10cb51:	e8 a2 3a ff ff       	callq  1005f8 <printk>
  10cb56:	be a0 cd 1b 00       	mov    $0x1bcda0,%esi
  10cb5b:	bf 58 d2 11 00       	mov    $0x11d258,%edi
  10cb60:	31 c0                	xor    %eax,%eax
  10cb62:	e8 91 3a ff ff       	callq  1005f8 <printk>
  10cb67:	be b9 00 00 00       	mov    $0xb9,%esi
  10cb6c:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  10cb71:	e8 22 60 ff ff       	callq  102b98 <assert_post_action>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  10cb76:	41 0f ba e4 09       	bt     $0x9,%r12d
  10cb7b:	73 01                	jae    10cb7e <sys_clock_set_timeout+0x113>
		__asm__ volatile ("sti" ::: "memory");
  10cb7d:	fb                   	sti    
	}

	wrmsr(IA32_TSC_DEADLINE_MSR, expires);
	k_spin_unlock(&lock, key);
}
  10cb7e:	5b                   	pop    %rbx
  10cb7f:	41 5c                	pop    %r12
  10cb81:	41 5d                	pop    %r13
  10cb83:	41 5e                	pop    %r14
  10cb85:	5d                   	pop    %rbp
  10cb86:	c3                   	retq   

000000000010cb87 <sys_clock_elapsed>:

uint32_t sys_clock_elapsed(void)
{
  10cb87:	55                   	push   %rbp
  10cb88:	48 89 e5             	mov    %rsp,%rbp
  10cb8b:	41 54                	push   %r12
  10cb8d:	53                   	push   %rbx
  10cb8e:	9c                   	pushfq 
  10cb8f:	fa                   	cli    
  10cb90:	41 5c                	pop    %r12
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  10cb92:	bf a0 cd 1b 00       	mov    $0x1bcda0,%edi
  10cb97:	e8 dd 0c 00 00       	callq  10d879 <z_spin_lock_valid>
  10cb9c:	84 c0                	test   %al,%al
  10cb9e:	75 39                	jne    10cbd9 <sys_clock_elapsed+0x52>
  10cba0:	b9 8e 00 00 00       	mov    $0x8e,%ecx
  10cba5:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  10cbaa:	be fd d1 11 00       	mov    $0x11d1fd,%esi
  10cbaf:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  10cbb4:	e8 3f 3a ff ff       	callq  1005f8 <printk>
  10cbb9:	be a0 cd 1b 00       	mov    $0x1bcda0,%esi
  10cbbe:	bf 12 d2 11 00       	mov    $0x11d212,%edi
  10cbc3:	31 c0                	xor    %eax,%eax
  10cbc5:	e8 2e 3a ff ff       	callq  1005f8 <printk>
  10cbca:	be 8e 00 00 00       	mov    $0x8e,%esi
  10cbcf:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  10cbd4:	e8 bf 5f ff ff       	callq  102b98 <assert_post_action>
	z_spin_lock_set_owner(l);
  10cbd9:	bf a0 cd 1b 00       	mov    $0x1bcda0,%edi
  10cbde:	e8 da 0c 00 00       	callq  10d8bd <z_spin_lock_set_owner>
	__asm__ volatile("rdtsc" : "=d"(hi), "=a"(lo));
  10cbe3:	0f 31                	rdtsc  
	return lo + (((uint64_t)hi) << 32);
  10cbe5:	48 c1 e2 20          	shl    $0x20,%rdx
  10cbe9:	89 c0                	mov    %eax,%eax
	k_spinlock_key_t key = k_spin_lock(&lock);
	uint32_t ret = (rdtsc() - last_announce) / CYC_PER_TICK;
  10cbeb:	b9 30 e6 02 00       	mov    $0x2e630,%ecx
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  10cbf0:	bf a0 cd 1b 00       	mov    $0x1bcda0,%edi
  10cbf5:	48 2b 05 9c 01 0b 00 	sub    0xb019c(%rip),%rax        # 1bcd98 <last_announce>
  10cbfc:	48 01 d0             	add    %rdx,%rax
  10cbff:	31 d2                	xor    %edx,%edx
  10cc01:	48 f7 f1             	div    %rcx
  10cc04:	48 89 c3             	mov    %rax,%rbx
  10cc07:	e8 8d 0c 00 00       	callq  10d899 <z_spin_unlock_valid>
  10cc0c:	84 c0                	test   %al,%al
  10cc0e:	75 39                	jne    10cc49 <sys_clock_elapsed+0xc2>
  10cc10:	b9 b9 00 00 00       	mov    $0xb9,%ecx
  10cc15:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  10cc1a:	be 41 d2 11 00       	mov    $0x11d241,%esi
  10cc1f:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  10cc24:	e8 cf 39 ff ff       	callq  1005f8 <printk>
  10cc29:	be a0 cd 1b 00       	mov    $0x1bcda0,%esi
  10cc2e:	bf 58 d2 11 00       	mov    $0x11d258,%edi
  10cc33:	31 c0                	xor    %eax,%eax
  10cc35:	e8 be 39 ff ff       	callq  1005f8 <printk>
  10cc3a:	be b9 00 00 00       	mov    $0xb9,%esi
  10cc3f:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  10cc44:	e8 4f 5f ff ff       	callq  102b98 <assert_post_action>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  10cc49:	41 0f ba e4 09       	bt     $0x9,%r12d
  10cc4e:	73 01                	jae    10cc51 <sys_clock_elapsed+0xca>
		__asm__ volatile ("sti" ::: "memory");
  10cc50:	fb                   	sti    

	k_spin_unlock(&lock, key);
	return ret;
}
  10cc51:	89 d8                	mov    %ebx,%eax
  10cc53:	5b                   	pop    %rbx
  10cc54:	41 5c                	pop    %r12
  10cc56:	5d                   	pop    %rbp
  10cc57:	c3                   	retq   

000000000010cc58 <sys_clock_cycle_get_32>:
	__asm__ volatile("rdtsc" : "=d"(hi), "=a"(lo));
  10cc58:	0f 31                	rdtsc  
	return lo + (((uint64_t)hi) << 32);
  10cc5a:	48 c1 e2 20          	shl    $0x20,%rdx
  10cc5e:	89 c0                	mov    %eax,%eax
  10cc60:	48 01 d0             	add    %rdx,%rax

uint32_t sys_clock_cycle_get_32(void)
{
	return (uint32_t) rdtsc();
}
  10cc63:	c3                   	retq   

000000000010cc64 <sys_clock_driver_init>:
			 : "=b"(*ebx), "=c"(*ecx), "=d"(*edx)
			 : "a"(*eax), "c"(*ecx));
}

int sys_clock_driver_init(const struct device *dev)
{
  10cc64:	55                   	push   %rbp
	__asm__ volatile("cpuid"
  10cc65:	b8 01 00 00 00       	mov    $0x1,%eax
{
  10cc6a:	48 89 e5             	mov    %rsp,%rbp
  10cc6d:	53                   	push   %rbx
  10cc6e:	51                   	push   %rcx
	__asm__ volatile("cpuid"
  10cc6f:	31 c9                	xor    %ecx,%ecx
  10cc71:	0f a2                	cpuid  
#ifdef CONFIG_ASSERT
	uint32_t eax, ebx, ecx, edx;

	eax = 1; ecx = 0;
	cpuid(&eax, &ebx, &ecx, &edx);
	__ASSERT((ecx & BIT(24)) != 0, "No TSC Deadline support");
  10cc73:	0f ba e1 18          	bt     $0x18,%ecx
  10cc77:	72 36                	jb     10ccaf <sys_clock_driver_init+0x4b>
  10cc79:	be 49 f4 11 00       	mov    $0x11f449,%esi
  10cc7e:	b9 9f 00 00 00       	mov    $0x9f,%ecx
  10cc83:	ba 1d f4 11 00       	mov    $0x11f41d,%edx
  10cc88:	31 c0                	xor    %eax,%eax
  10cc8a:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  10cc8f:	e8 64 39 ff ff       	callq  1005f8 <printk>
  10cc94:	bf 64 f4 11 00       	mov    $0x11f464,%edi
  10cc99:	31 c0                	xor    %eax,%eax
  10cc9b:	e8 58 39 ff ff       	callq  1005f8 <printk>
  10cca0:	be 9f 00 00 00       	mov    $0x9f,%esi
  10cca5:	bf 1d f4 11 00       	mov    $0x11f41d,%edi
  10ccaa:	e8 e9 5e ff ff       	callq  102b98 <assert_post_action>
	__asm__ volatile("cpuid"
  10ccaf:	b8 07 00 00 80       	mov    $0x80000007,%eax
  10ccb4:	31 c9                	xor    %ecx,%ecx
  10ccb6:	0f a2                	cpuid  

	eax = 0x80000007; ecx = 0;
	cpuid(&eax, &ebx, &ecx, &edx);
	__ASSERT((edx & BIT(8)) != 0, "No Invariant TSC support");
  10ccb8:	0f ba e2 08          	bt     $0x8,%edx
  10ccbc:	72 36                	jb     10ccf4 <sys_clock_driver_init+0x90>
  10ccbe:	be 7e f4 11 00       	mov    $0x11f47e,%esi
  10ccc3:	b9 a3 00 00 00       	mov    $0xa3,%ecx
  10ccc8:	ba 1d f4 11 00       	mov    $0x11f41d,%edx
  10cccd:	31 c0                	xor    %eax,%eax
  10cccf:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  10ccd4:	e8 1f 39 ff ff       	callq  1005f8 <printk>
  10ccd9:	bf 98 f4 11 00       	mov    $0x11f498,%edi
  10ccde:	31 c0                	xor    %eax,%eax
  10cce0:	e8 13 39 ff ff       	callq  1005f8 <printk>
  10cce5:	be a3 00 00 00       	mov    $0xa3,%esi
  10ccea:	bf 1d f4 11 00       	mov    $0x11f41d,%edi
  10ccef:	e8 a4 5e ff ff       	callq  102b98 <assert_post_action>
	__asm__ volatile("cpuid"
  10ccf4:	b8 07 00 00 00       	mov    $0x7,%eax
  10ccf9:	31 c9                	xor    %ecx,%ecx
  10ccfb:	0f a2                	cpuid  

	eax = 7; ecx = 0;
	cpuid(&eax, &ebx, &ecx, &edx);
	__ASSERT((ebx & BIT(1)) != 0, "No TSC_ADJUST MSR support");
  10ccfd:	80 e3 02             	and    $0x2,%bl
  10cd00:	75 36                	jne    10cd38 <sys_clock_driver_init+0xd4>
  10cd02:	be b3 f4 11 00       	mov    $0x11f4b3,%esi
  10cd07:	b9 a7 00 00 00       	mov    $0xa7,%ecx
  10cd0c:	ba 1d f4 11 00       	mov    $0x11f41d,%edx
  10cd11:	31 c0                	xor    %eax,%eax
  10cd13:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  10cd18:	e8 db 38 ff ff       	callq  1005f8 <printk>
  10cd1d:	bf cd f4 11 00       	mov    $0x11f4cd,%edi
  10cd22:	31 c0                	xor    %eax,%eax
  10cd24:	e8 cf 38 ff ff       	callq  1005f8 <printk>
  10cd29:	be a7 00 00 00       	mov    $0xa7,%esi
  10cd2e:	bf 1d f4 11 00       	mov    $0x11f41d,%edi
  10cd33:	e8 60 5e ff ff       	callq  102b98 <assert_post_action>
	return z_loapic_irq_base();
  10cd38:	e8 b6 dc ff ff       	callq  10a9f3 <z_loapic_irq_base>
static inline int
irq_connect_dynamic(unsigned int irq, unsigned int priority,
		    void (*routine)(const void *parameter),
		    const void *parameter, uint32_t flags)
{
	return arch_irq_connect_dynamic(irq, priority, routine, parameter,
  10cd3d:	31 c9                	xor    %ecx,%ecx
  10cd3f:	45 31 c0             	xor    %r8d,%r8d
  10cd42:	ba 80 c9 10 00       	mov    $0x10c980,%edx
  10cd47:	89 c7                	mov    %eax,%edi
  10cd49:	be 04 00 00 00       	mov    $0x4,%esi
  10cd4e:	e8 12 cd ff ff       	callq  109a65 <arch_irq_connect_dynamic>
	__asm__ volatile ("rdmsr" : "=a" (rv.lo), "=d" (rv.hi) : "c" (msr));
  10cd53:	b9 32 08 00 00       	mov    $0x832,%ecx
  10cd58:	0f 32                	rdmsr  
	return x86_read_x2apic(reg);
  10cd5a:	89 05 d4 00 0b 00    	mov    %eax,0xb00d4(%rip)        # 1bce34 <lvt_reg>
	 */
	irq_connect_dynamic(timer_irq(), CONFIG_APIC_TIMER_IRQ_PRIORITY, isr, 0, 0);

	lvt_reg.val = x86_read_loapic(LOAPIC_TIMER);
	lvt_reg.lvt.mode = TSC_DEADLINE;
	lvt_reg.lvt.masked = 0;
  10cd60:	8a 05 d0 00 0b 00    	mov    0xb00d0(%rip),%al        # 1bce36 <lvt_reg+0x2>
	__asm__ volatile ("wrmsr" : : "c"(msr), "a"(low), "d"(high));
  10cd66:	31 d2                	xor    %edx,%edx
  10cd68:	83 e0 f8             	and    $0xfffffff8,%eax
  10cd6b:	83 c8 04             	or     $0x4,%eax
  10cd6e:	88 05 c2 00 0b 00    	mov    %al,0xb00c2(%rip)        # 1bce36 <lvt_reg+0x2>
  10cd74:	8b 05 ba 00 0b 00    	mov    0xb00ba(%rip),%eax        # 1bce34 <lvt_reg>
  10cd7a:	0f 30                	wrmsr  
	/* Per the SDM, the TSC_DEADLINE MSR is not serializing, so
	 * this fence is needed to be sure that an upcoming MSR write
	 * (i.e. a timeout we're about to set) cannot possibly reorder
	 * around the initialization we just did.
	 */
	__asm__ volatile("mfence" ::: "memory");
  10cd7c:	0f ae f0             	mfence 
	__asm__ volatile("rdtsc" : "=d"(hi), "=a"(lo));
  10cd7f:	0f 31                	rdtsc  
	return lo + (((uint64_t)hi) << 32);
  10cd81:	89 c0                	mov    %eax,%eax
  10cd83:	48 c1 e2 20          	shl    $0x20,%rdx
  10cd87:	48 01 c2             	add    %rax,%rdx
  10cd8a:	48 89 15 07 00 0b 00 	mov    %rdx,0xb0007(%rip)        # 1bcd98 <last_announce>
	return z_loapic_irq_base();
  10cd91:	e8 5d dc ff ff       	callq  10a9f3 <z_loapic_irq_base>
  10cd96:	89 c7                	mov    %eax,%edi

	last_announce = rdtsc();
	irq_enable(timer_irq());
  10cd98:	e8 3a dd ff ff       	callq  10aad7 <arch_irq_enable>
	if (!IS_ENABLED(CONFIG_TICKLESS_KERNEL)) {
		sys_clock_set_timeout(1, false);
	}

	return 0;
}
  10cd9d:	5a                   	pop    %rdx
  10cd9e:	31 c0                	xor    %eax,%eax
  10cda0:	5b                   	pop    %rbx
  10cda1:	5d                   	pop    %rbp
  10cda2:	c3                   	retq   

000000000010cda3 <z_device_state_init>:
 *
 * The state object is always zero-initialized, but this may not be
 * sufficient.
 */
void z_device_state_init(void)
{
  10cda3:	55                   	push   %rbp
  10cda4:	48 89 e5             	mov    %rsp,%rbp
  10cda7:	53                   	push   %rbx
	const struct device *dev = __device_start;
  10cda8:	bb 20 a1 11 00       	mov    $0x11a120,%ebx
{
  10cdad:	52                   	push   %rdx

	while (dev < __device_end) {
  10cdae:	48 81 fb 70 a2 11 00 	cmp    $0x11a270,%rbx
  10cdb5:	73 0e                	jae    10cdc5 <z_device_state_init+0x22>
		z_object_init(dev);
  10cdb7:	48 89 df             	mov    %rbx,%rdi
		++dev;
  10cdba:	48 83 c3 30          	add    $0x30,%rbx
		z_object_init(dev);
  10cdbe:	e8 2e a2 00 00       	callq  116ff1 <z_object_init>
		++dev;
  10cdc3:	eb e9                	jmp    10cdae <z_device_state_init+0xb>
	}
}
  10cdc5:	58                   	pop    %rax
  10cdc6:	5b                   	pop    %rbx
  10cdc7:	5d                   	pop    %rbp
  10cdc8:	c3                   	retq   

000000000010cdc9 <z_sys_init_run_level>:
 * off and the next one begins.
 *
 * @param level init level to run.
 */
void z_sys_init_run_level(int32_t level)
{
  10cdc9:	55                   	push   %rbp
		/* End marker */
		__init_end,
	};
	const struct init_entry *entry;

	for (entry = levels[level]; entry < levels[level+1]; entry++) {
  10cdca:	48 63 c7             	movslq %edi,%rax
  10cdcd:	ff c7                	inc    %edi
{
  10cdcf:	48 89 e5             	mov    %rsp,%rbp
  10cdd2:	41 55                	push   %r13
  10cdd4:	41 54                	push   %r12
  10cdd6:	53                   	push   %rbx
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
  10cdd7:	48 63 df             	movslq %edi,%rbx
{
  10cdda:	52                   	push   %rdx
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
  10cddb:	4c 8b 24 c5 c0 b0 11 	mov    0x11b0c0(,%rax,8),%r12
  10cde2:	00 
  10cde3:	4c 39 24 dd c0 b0 11 	cmp    %r12,0x11b0c0(,%rbx,8)
  10cdea:	00 
  10cdeb:	76 3b                	jbe    10ce28 <z_sys_init_run_level+0x5f>
		const struct device *dev = entry->dev;
  10cded:	4d 8b 6c 24 08       	mov    0x8(%r12),%r13
		int rc = entry->init(dev);
  10cdf2:	4c 89 ef             	mov    %r13,%rdi
  10cdf5:	41 ff 14 24          	callq  *(%r12)

		if (dev != NULL) {
  10cdf9:	4d 85 ed             	test   %r13,%r13
  10cdfc:	74 24                	je     10ce22 <z_sys_init_run_level+0x59>
					rc = -rc;
				}
				if (rc > UINT8_MAX) {
					rc = UINT8_MAX;
				}
				dev->state->init_res = rc;
  10cdfe:	49 8b 55 18          	mov    0x18(%r13),%rdx
			if (rc != 0) {
  10ce02:	85 c0                	test   %eax,%eax
  10ce04:	74 18                	je     10ce1e <z_sys_init_run_level+0x55>
				if (rc < 0) {
  10ce06:	89 c1                	mov    %eax,%ecx
  10ce08:	c1 f9 1f             	sar    $0x1f,%ecx
  10ce0b:	31 c8                	xor    %ecx,%eax
  10ce0d:	29 c8                	sub    %ecx,%eax
				dev->state->init_res = rc;
  10ce0f:	b9 ff 00 00 00       	mov    $0xff,%ecx
  10ce14:	3d ff 00 00 00       	cmp    $0xff,%eax
  10ce19:	0f 4f c1             	cmovg  %ecx,%eax
  10ce1c:	88 02                	mov    %al,(%rdx)
			}
			dev->state->initialized = true;
  10ce1e:	80 4a 01 01          	orb    $0x1,0x1(%rdx)
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
  10ce22:	49 83 c4 10          	add    $0x10,%r12
  10ce26:	eb bb                	jmp    10cde3 <z_sys_init_run_level+0x1a>
		}
	}
}
  10ce28:	58                   	pop    %rax
  10ce29:	5b                   	pop    %rbx
  10ce2a:	41 5c                	pop    %r12
  10ce2c:	41 5d                	pop    %r13
  10ce2e:	5d                   	pop    %rbp
  10ce2f:	c3                   	retq   

000000000010ce30 <z_device_get_all_static>:
#endif /* CONFIG_USERSPACE */

size_t z_device_get_all_static(struct device const **devices)
{
	*devices = __device_start;
	return __device_end - __device_start;
  10ce30:	b8 70 a2 11 00       	mov    $0x11a270,%eax
	*devices = __device_start;
  10ce35:	48 c7 07 20 a1 11 00 	movq   $0x11a120,(%rdi)
	return __device_end - __device_start;
  10ce3c:	48 ba ab aa aa aa aa 	movabs $0xaaaaaaaaaaaaaaab,%rdx
  10ce43:	aa aa aa 
  10ce46:	48 2d 20 a1 11 00    	sub    $0x11a120,%rax
  10ce4c:	48 c1 f8 04          	sar    $0x4,%rax
  10ce50:	48 0f af c2          	imul   %rdx,%rax
}
  10ce54:	c3                   	retq   

000000000010ce55 <z_device_ready>:
	/*
	 * if an invalid device pointer is passed as argument, this call
	 * reports the `device` as not ready for usage.
	 */
	if (dev == NULL) {
		return false;
  10ce55:	31 c0                	xor    %eax,%eax
	if (dev == NULL) {
  10ce57:	48 85 ff             	test   %rdi,%rdi
  10ce5a:	74 11                	je     10ce6d <z_device_ready+0x18>
	}

	return dev->state->initialized && (dev->state->init_res == 0U);
  10ce5c:	48 8b 47 18          	mov    0x18(%rdi),%rax
  10ce60:	8b 00                	mov    (%rax),%eax
  10ce62:	66 25 ff 01          	and    $0x1ff,%ax
  10ce66:	66 3d 00 01          	cmp    $0x100,%ax
  10ce6a:	0f 94 c0             	sete   %al
}
  10ce6d:	c3                   	retq   

000000000010ce6e <z_impl_device_get_binding>:
{
  10ce6e:	55                   	push   %rbp
  10ce6f:	48 89 e5             	mov    %rsp,%rbp
  10ce72:	41 54                	push   %r12
  10ce74:	53                   	push   %rbx
	if ((name == NULL) || (name[0] == '\0')) {
  10ce75:	48 85 ff             	test   %rdi,%rdi
  10ce78:	75 05                	jne    10ce7f <z_impl_device_get_binding+0x11>
		return NULL;
  10ce7a:	45 31 e4             	xor    %r12d,%r12d
  10ce7d:	eb 60                	jmp    10cedf <z_impl_device_get_binding+0x71>
	if ((name == NULL) || (name[0] == '\0')) {
  10ce7f:	80 3f 00             	cmpb   $0x0,(%rdi)
  10ce82:	48 89 fb             	mov    %rdi,%rbx
	for (dev = __device_start; dev != __device_end; dev++) {
  10ce85:	41 bc 20 a1 11 00    	mov    $0x11a120,%r12d
	if ((name == NULL) || (name[0] == '\0')) {
  10ce8b:	74 ed                	je     10ce7a <z_impl_device_get_binding+0xc>
	for (dev = __device_start; dev != __device_end; dev++) {
  10ce8d:	49 81 fc 70 a2 11 00 	cmp    $0x11a270,%r12
  10ce94:	74 18                	je     10ceae <z_impl_device_get_binding+0x40>
		if (z_device_ready(dev) && (dev->name == name)) {
  10ce96:	4c 89 e7             	mov    %r12,%rdi
  10ce99:	e8 b7 ff ff ff       	callq  10ce55 <z_device_ready>
  10ce9e:	84 c0                	test   %al,%al
  10cea0:	74 06                	je     10cea8 <z_impl_device_get_binding+0x3a>
  10cea2:	49 39 1c 24          	cmp    %rbx,(%r12)
  10cea6:	74 37                	je     10cedf <z_impl_device_get_binding+0x71>
	for (dev = __device_start; dev != __device_end; dev++) {
  10cea8:	49 83 c4 30          	add    $0x30,%r12
  10ceac:	eb df                	jmp    10ce8d <z_impl_device_get_binding+0x1f>
	for (dev = __device_start; dev != __device_end; dev++) {
  10ceae:	41 bc 20 a1 11 00    	mov    $0x11a120,%r12d
  10ceb4:	49 81 fc 70 a2 11 00 	cmp    $0x11a270,%r12
  10cebb:	74 bd                	je     10ce7a <z_impl_device_get_binding+0xc>
		if (z_device_ready(dev) && (strcmp(name, dev->name) == 0)) {
  10cebd:	4c 89 e7             	mov    %r12,%rdi
  10cec0:	e8 90 ff ff ff       	callq  10ce55 <z_device_ready>
  10cec5:	84 c0                	test   %al,%al
  10cec7:	75 06                	jne    10cecf <z_impl_device_get_binding+0x61>
	for (dev = __device_start; dev != __device_end; dev++) {
  10cec9:	49 83 c4 30          	add    $0x30,%r12
  10cecd:	eb e5                	jmp    10ceb4 <z_impl_device_get_binding+0x46>
		if (z_device_ready(dev) && (strcmp(name, dev->name) == 0)) {
  10cecf:	49 8b 34 24          	mov    (%r12),%rsi
  10ced3:	48 89 df             	mov    %rbx,%rdi
  10ced6:	e8 22 d1 ff ff       	callq  109ffd <strcmp>
  10cedb:	85 c0                	test   %eax,%eax
  10cedd:	75 ea                	jne    10cec9 <z_impl_device_get_binding+0x5b>
}
  10cedf:	4c 89 e0             	mov    %r12,%rax
  10cee2:	5b                   	pop    %rbx
  10cee3:	41 5c                	pop    %r12
  10cee5:	5d                   	pop    %rbp
  10cee6:	c3                   	retq   

000000000010cee7 <z_mrsh_device_get_binding>:
#include <syscalls/device.h>

extern const struct device * z_vrfy_device_get_binding(const char * name);
uintptr_t z_mrsh_device_get_binding(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
  10cee7:	55                   	push   %rbp
  10cee8:	48 89 fe             	mov    %rdi,%rsi
  10ceeb:	48 89 e5             	mov    %rsp,%rbp
  10ceee:	48 83 ec 30          	sub    $0x30,%rsp
	_current->syscall_frame = ssf;
  10cef2:	48 8b 05 57 b8 01 00 	mov    0x1b857(%rip),%rax        # 128750 <_kernel+0x10>
  10cef9:	48 8b 55 10          	mov    0x10(%rbp),%rdx
	if (z_user_string_copy(name_copy, (char *)name, sizeof(name_copy))
  10cefd:	48 8d 7d d0          	lea    -0x30(%rbp),%rdi
  10cf01:	48 89 90 40 01 00 00 	mov    %rdx,0x140(%rax)
  10cf08:	ba 30 00 00 00       	mov    $0x30,%edx
  10cf0d:	e8 18 a1 00 00       	callq  11702a <z_user_string_copy>
  10cf12:	41 89 c0             	mov    %eax,%r8d
  10cf15:	31 c0                	xor    %eax,%eax
  10cf17:	45 85 c0             	test   %r8d,%r8d
  10cf1a:	75 09                	jne    10cf25 <z_mrsh_device_get_binding+0x3e>
	return z_impl_device_get_binding(name_copy);
  10cf1c:	48 8d 7d d0          	lea    -0x30(%rbp),%rdi
  10cf20:	e8 49 ff ff ff       	callq  10ce6e <z_impl_device_get_binding>
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	const struct device * ret = z_vrfy_device_get_binding(*(const char **)&arg0)
;
	_current->syscall_frame = NULL;
  10cf25:	48 8b 15 24 b8 01 00 	mov    0x1b824(%rip),%rdx        # 128750 <_kernel+0x10>
  10cf2c:	48 c7 82 40 01 00 00 	movq   $0x0,0x140(%rdx)
  10cf33:	00 00 00 00 
	return (uintptr_t) ret;
}
  10cf37:	c9                   	leaveq 
  10cf38:	c3                   	retq   

000000000010cf39 <z_mrsh_device_usable_check>:
#include <syscalls/device.h>

extern int z_vrfy_device_usable_check(const struct device * dev);
uintptr_t z_mrsh_device_usable_check(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
  10cf39:	55                   	push   %rbp
	_current->syscall_frame = ssf;
  10cf3a:	48 8b 05 0f b8 01 00 	mov    0x1b80f(%rip),%rax        # 128750 <_kernel+0x10>
{
  10cf41:	48 89 e5             	mov    %rsp,%rbp
  10cf44:	41 54                	push   %r12
	_current->syscall_frame = ssf;
  10cf46:	48 8b 55 10          	mov    0x10(%rbp),%rdx
{
  10cf4a:	53                   	push   %rbx
  10cf4b:	48 89 fb             	mov    %rdi,%rbx
	_current->syscall_frame = ssf;
  10cf4e:	48 89 90 40 01 00 00 	mov    %rdx,0x140(%rax)
	Z_OOPS(Z_SYSCALL_OBJ_INIT(dev, K_OBJ_ANY));
  10cf55:	e8 7a 9b 00 00       	callq  116ad4 <z_object_find>
	ret = z_object_validate(ko, otype, init);
  10cf5a:	ba 01 00 00 00       	mov    $0x1,%edx
  10cf5f:	31 f6                	xor    %esi,%esi
  10cf61:	48 89 c7             	mov    %rax,%rdi
  10cf64:	49 89 c4             	mov    %rax,%r12
  10cf67:	e8 00 a0 00 00       	callq  116f6c <z_object_validate>
  10cf6c:	41 89 c0             	mov    %eax,%r8d
	if (ret != 0) {
  10cf6f:	85 c0                	test   %eax,%eax
  10cf71:	74 38                	je     10cfab <z_mrsh_device_usable_check+0x72>
		z_dump_object_error(ret, obj, ko, otype);
  10cf73:	89 c7                	mov    %eax,%edi
  10cf75:	31 c9                	xor    %ecx,%ecx
  10cf77:	4c 89 e2             	mov    %r12,%rdx
  10cf7a:	48 89 de             	mov    %rbx,%rsi
  10cf7d:	e8 9f 9e 00 00       	callq  116e21 <z_dump_object_error>
  10cf82:	bf 23 f3 11 00       	mov    $0x11f323,%edi
  10cf87:	31 c0                	xor    %eax,%eax
  10cf89:	ba d0 c0 11 00       	mov    $0x11c0d0,%edx
  10cf8e:	be 45 00 00 00       	mov    $0x45,%esi
  10cf93:	e8 2e 61 ff ff       	callq  1030c6 <z_log_minimal_printk>
  10cf98:	48 8b 05 b1 b7 01 00 	mov    0x1b7b1(%rip),%rax        # 128750 <_kernel+0x10>
  10cf9f:	48 8b b8 40 01 00 00 	mov    0x140(%rax),%rdi
  10cfa6:	e8 62 cc ff ff       	callq  109c0d <arch_syscall_oops>
  10cfab:	48 89 df             	mov    %rbx,%rdi
  10cfae:	e8 a2 fe ff ff       	callq  10ce55 <z_device_ready>
  10cfb3:	84 c0                	test   %al,%al
  10cfb5:	b8 ed ff ff ff       	mov    $0xffffffed,%eax
  10cfba:	44 0f 44 c0          	cmove  %eax,%r8d
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	int ret = z_vrfy_device_usable_check(*(const struct device **)&arg0)
;
	_current->syscall_frame = NULL;
  10cfbe:	48 8b 05 8b b7 01 00 	mov    0x1b78b(%rip),%rax        # 128750 <_kernel+0x10>
  10cfc5:	48 c7 80 40 01 00 00 	movq   $0x0,0x140(%rax)
  10cfcc:	00 00 00 00 
	return (uintptr_t) ret;
  10cfd0:	49 63 c0             	movslq %r8d,%rax
}
  10cfd3:	5b                   	pop    %rbx
  10cfd4:	41 5c                	pop    %r12
  10cfd6:	5d                   	pop    %rbp
  10cfd7:	c3                   	retq   

000000000010cfd8 <device_required_foreach>:

int device_required_foreach(const struct device *dev,
			  device_visitor_callback_t visitor_cb,
			  void *context)
{
  10cfd8:	55                   	push   %rbp
  10cfd9:	48 89 e5             	mov    %rsp,%rbp
  10cfdc:	41 57                	push   %r15
  10cfde:	41 56                	push   %r14
  10cfe0:	49 89 f6             	mov    %rsi,%r14
  10cfe3:	41 55                	push   %r13
  10cfe5:	41 54                	push   %r12
		size_t i = 0;
  10cfe7:	45 31 e4             	xor    %r12d,%r12d
  10cfea:	53                   	push   %rbx
  10cfeb:	48 83 ec 18          	sub    $0x18,%rsp
  10cfef:	4c 8b 7f 28          	mov    0x28(%rdi),%r15
	if (rv != NULL) {
  10cff3:	4d 85 ff             	test   %r15,%r15
  10cff6:	74 78                	je     10d070 <device_required_foreach+0x98>
		       && (rv[i] != DEVICE_HANDLE_SEP)) {
  10cff8:	66 43 8b 04 67       	mov    (%r15,%r12,2),%ax
  10cffd:	66 05 ff 7f          	add    $0x7fff,%ax
		while ((rv[i] != DEVICE_HANDLE_ENDS)
  10d001:	66 83 f8 fd          	cmp    $0xfffd,%ax
  10d005:	77 05                	ja     10d00c <device_required_foreach+0x34>
			++i;
  10d007:	49 ff c4             	inc    %r12
  10d00a:	eb ec                	jmp    10cff8 <device_required_foreach+0x20>
	size_t numdev = __device_end - __device_start;
  10d00c:	bb 70 a2 11 00       	mov    $0x11a270,%ebx
	size_t handle_count = 0;
	const device_handle_t *handles =
		device_required_handles_get(dev, &handle_count);

	/* Iterate over fixed devices */
	for (size_t i = 0; i < handle_count; ++i) {
  10d011:	45 31 ed             	xor    %r13d,%r13d
  10d014:	48 b8 ab aa aa aa aa 	movabs $0xaaaaaaaaaaaaaaab,%rax
  10d01b:	aa aa aa 
  10d01e:	48 81 eb 20 a1 11 00 	sub    $0x11a120,%rbx
  10d025:	48 c1 fb 04          	sar    $0x4,%rbx
  10d029:	48 0f af d8          	imul   %rax,%rbx
  10d02d:	4d 39 e5             	cmp    %r12,%r13
  10d030:	74 3e                	je     10d070 <device_required_foreach+0x98>
		device_handle_t dh = handles[i];
  10d032:	66 43 8b 04 6f       	mov    (%r15,%r13,2),%ax
	const struct device *dev = NULL;
  10d037:	31 ff                	xor    %edi,%edi
	if ((dev_handle > 0) && ((size_t)dev_handle <= numdev)) {
  10d039:	66 85 c0             	test   %ax,%ax
  10d03c:	7e 1b                	jle    10d059 <device_required_foreach+0x81>
  10d03e:	48 0f bf c8          	movswq %ax,%rcx
  10d042:	48 39 cb             	cmp    %rcx,%rbx
  10d045:	72 12                	jb     10d059 <device_required_foreach+0x81>
		dev = &__device_start[dev_handle - 1];
  10d047:	8d 78 ff             	lea    -0x1(%rax),%edi
  10d04a:	48 0f bf ff          	movswq %di,%rdi
  10d04e:	48 6b ff 30          	imul   $0x30,%rdi,%rdi
  10d052:	48 81 c7 20 a1 11 00 	add    $0x11a120,%rdi
		const struct device *rdev = device_from_handle(dh);
		int rc = visitor_cb(rdev, context);
  10d059:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  10d05d:	48 89 d6             	mov    %rdx,%rsi
  10d060:	41 ff d6             	callq  *%r14

		if (rc < 0) {
  10d063:	85 c0                	test   %eax,%eax
  10d065:	78 0c                	js     10d073 <device_required_foreach+0x9b>
	for (size_t i = 0; i < handle_count; ++i) {
  10d067:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  10d06b:	49 ff c5             	inc    %r13
  10d06e:	eb bd                	jmp    10d02d <device_required_foreach+0x55>
			return rc;
		}
	}

	return handle_count;
  10d070:	44 89 e0             	mov    %r12d,%eax
}
  10d073:	48 83 c4 18          	add    $0x18,%rsp
  10d077:	5b                   	pop    %rbx
  10d078:	41 5c                	pop    %r12
  10d07a:	41 5d                	pop    %r13
  10d07c:	41 5e                	pop    %r14
  10d07e:	41 5f                	pop    %r15
  10d080:	5d                   	pop    %rbp
  10d081:	c3                   	retq   

000000000010d082 <z_impl_z_errno>:
int *z_impl_z_errno(void)
{
	/* Initialized to the lowest address in the stack so the thread can
	 * directly read/write it
	 */
	return &_current->userspace_local_data->errno_var;
  10d082:	48 8b 05 c7 b6 01 00 	mov    0x1b6c7(%rip),%rax        # 128750 <_kernel+0x10>
  10d089:	48 8b 80 00 01 00 00 	mov    0x100(%rax),%rax
}
  10d090:	c3                   	retq   

000000000010d091 <z_mrsh_z_errno>:

extern int * z_vrfy_z_errno();
uintptr_t z_mrsh_z_errno(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
	_current->syscall_frame = ssf;
  10d091:	48 8b 15 b8 b6 01 00 	mov    0x1b6b8(%rip),%rdx        # 128750 <_kernel+0x10>
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	int * ret = z_vrfy_z_errno()
;
	_current->syscall_frame = NULL;
  10d098:	48 c7 82 40 01 00 00 	movq   $0x0,0x140(%rdx)
  10d09f:	00 00 00 00 
	return &_current->userspace_local_data->errno_var;
  10d0a3:	48 8b 82 00 01 00 00 	mov    0x100(%rdx),%rax
	return (uintptr_t) ret;
}
  10d0aa:	c3                   	retq   

000000000010d0ab <arch_system_halt>:
  10d0ab:	9c                   	pushfq 
  10d0ac:	fa                   	cli    
  10d0ad:	58                   	pop    %rax
	/* TODO: What's the best way to totally halt the system if SMP
	 * is enabled?
	 */

	(void)arch_irq_lock();
	for (;;) {
  10d0ae:	eb fe                	jmp    10d0ae <arch_system_halt+0x3>

000000000010d0b0 <k_sys_fatal_error_handler>:
/* LCOV_EXCL_STOP */

/* LCOV_EXCL_START */
__weak void k_sys_fatal_error_handler(unsigned int reason,
				      const z_arch_esf_t *esf)
{
  10d0b0:	55                   	push   %rbp
	ARG_UNUSED(esf);

	LOG_PANIC();
	LOG_ERR("Halting system");
  10d0b1:	be 45 00 00 00       	mov    $0x45,%esi
{
  10d0b6:	48 89 e5             	mov    %rsp,%rbp
  10d0b9:	41 54                	push   %r12
  10d0bb:	41 89 fc             	mov    %edi,%r12d
	LOG_ERR("Halting system");
  10d0be:	bf e9 f4 11 00       	mov    $0x11f4e9,%edi
{
  10d0c3:	50                   	push   %rax
	LOG_ERR("Halting system");
  10d0c4:	31 c0                	xor    %eax,%eax
  10d0c6:	e8 fb 5f ff ff       	callq  1030c6 <z_log_minimal_printk>
	arch_system_halt(reason);
  10d0cb:	44 89 e7             	mov    %r12d,%edi
  10d0ce:	e8 d8 ff ff ff       	callq  10d0ab <arch_system_halt>

000000000010d0d3 <z_fatal_error>:
	return 0;
#endif
}

void z_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
  10d0d3:	55                   	push   %rbp
  10d0d4:	48 89 e5             	mov    %rsp,%rbp
  10d0d7:	41 56                	push   %r14
  10d0d9:	49 89 f6             	mov    %rsi,%r14
  10d0dc:	41 55                	push   %r13
  10d0de:	41 89 fd             	mov    %edi,%r13d
  10d0e1:	41 54                	push   %r12
  10d0e3:	53                   	push   %rbx
  10d0e4:	9c                   	pushfq 
  10d0e5:	fa                   	cli    
  10d0e6:	5b                   	pop    %rbx
	return z_impl_z_current_get();
  10d0e7:	e8 62 56 00 00       	callq  11274e <z_impl_z_current_get>
  10d0ec:	b9 fd f4 11 00       	mov    $0x11f4fd,%ecx
  10d0f1:	49 89 c4             	mov    %rax,%r12
	switch (reason) {
  10d0f4:	41 83 fd 04          	cmp    $0x4,%r13d
  10d0f8:	77 0b                	ja     10d105 <z_fatal_error+0x32>
  10d0fa:	44 89 e8             	mov    %r13d,%eax
  10d0fd:	48 8b 0c c5 00 b1 11 	mov    0x11b100(,%rax,8),%rcx
  10d104:	00 
			k_current_get() : NULL;

	/* twister looks for the "ZEPHYR FATAL ERROR" string, don't
	 * change it without also updating twister
	 */
	LOG_ERR(">>> ZEPHYR FATAL ERROR %d: %s on CPU %d", reason,
  10d105:	45 31 c0             	xor    %r8d,%r8d
  10d108:	31 c0                	xor    %eax,%eax
  10d10a:	44 89 ea             	mov    %r13d,%edx
  10d10d:	be 45 00 00 00       	mov    $0x45,%esi
  10d112:	bf 13 f5 11 00       	mov    $0x11f513,%edi
  10d117:	e8 aa 5f ff ff       	callq  1030c6 <z_log_minimal_printk>
	const char *thread_name = (thread != NULL) ? k_thread_name_get(thread) : NULL;
  10d11c:	4d 85 e4             	test   %r12,%r12
  10d11f:	74 15                	je     10d136 <z_fatal_error+0x63>
  10d121:	4c 89 e7             	mov    %r12,%rdi
  10d124:	e8 95 05 00 00       	callq  10d6be <k_thread_name_get>
  10d129:	48 89 c1             	mov    %rax,%rcx
	if ((thread_name == NULL) || (thread_name[0] == '\0')) {
  10d12c:	48 85 c0             	test   %rax,%rax
  10d12f:	74 05                	je     10d136 <z_fatal_error+0x63>
  10d131:	80 38 00             	cmpb   $0x0,(%rax)
  10d134:	75 05                	jne    10d13b <z_fatal_error+0x68>
		thread_name = "unknown";
  10d136:	b9 0b f5 11 00       	mov    $0x11f50b,%ecx
	if ((esf != NULL) && arch_is_in_nested_exception(esf)) {
		LOG_ERR("Fault during interrupt handling\n");
	}
#endif

	LOG_ERR("Current thread: %p (%s)", thread,
  10d13b:	31 c0                	xor    %eax,%eax
  10d13d:	4c 89 e2             	mov    %r12,%rdx
  10d140:	be 45 00 00 00       	mov    $0x45,%esi
  10d145:	bf 40 f5 11 00       	mov    $0x11f540,%edi
  10d14a:	e8 77 5f ff ff       	callq  1030c6 <z_log_minimal_printk>
		log_strdup(thread_name_get(thread)));

	coredump(reason, esf, thread);

	k_sys_fatal_error_handler(reason, esf);
  10d14f:	4c 89 f6             	mov    %r14,%rsi
  10d152:	44 89 ef             	mov    %r13d,%edi
  10d155:	e8 56 ff ff ff       	callq  10d0b0 <k_sys_fatal_error_handler>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  10d15a:	0f ba e3 09          	bt     $0x9,%ebx
  10d15e:	73 01                	jae    10d161 <z_fatal_error+0x8e>
		__asm__ volatile ("sti" ::: "memory");
  10d160:	fb                   	sti    
	arch_irq_unlock(key);

	if (IS_ENABLED(CONFIG_MULTITHREADING)) {
		k_thread_abort(thread);
	}
}
  10d161:	5b                   	pop    %rbx
	z_impl_k_thread_abort(thread);
  10d162:	4c 89 e7             	mov    %r12,%rdi
  10d165:	41 5c                	pop    %r12
  10d167:	41 5d                	pop    %r13
  10d169:	41 5e                	pop    %r14
  10d16b:	5d                   	pop    %rbp
  10d16c:	e9 0c 58 00 00       	jmpq   11297d <z_impl_k_thread_abort>

000000000010d171 <init_idle_thread>:
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */

#if defined(CONFIG_MULTITHREADING)
__boot_func
static void init_idle_thread(int i)
{
  10d171:	55                   	push   %rbp
	k_thread_stack_t *stack = z_idle_stacks[i];

#ifdef CONFIG_THREAD_NAME
	char tname[8];

	snprintk(tname, 8, "idle %02d", i);
  10d172:	ba a7 f5 11 00       	mov    $0x11f5a7,%edx
  10d177:	be 08 00 00 00       	mov    $0x8,%esi
  10d17c:	31 c0                	xor    %eax,%eax
{
  10d17e:	48 89 e5             	mov    %rsp,%rbp
  10d181:	41 54                	push   %r12
  10d183:	53                   	push   %rbx
	snprintk(tname, 8, "idle %02d", i);
  10d184:	4c 8d 65 e8          	lea    -0x18(%rbp),%r12
{
  10d188:	48 63 df             	movslq %edi,%rbx
  10d18b:	48 89 d9             	mov    %rbx,%rcx
	snprintk(tname, 8, "idle %02d", i);
  10d18e:	4c 89 e7             	mov    %r12,%rdi
{
  10d191:	48 83 ec 10          	sub    $0x10,%rsp
	snprintk(tname, 8, "idle %02d", i);
  10d195:	e8 29 35 ff ff       	callq  1006c3 <snprintk>
#else
	char *tname = NULL;
#endif /* CONFIG_THREAD_NAME */

	z_setup_new_thread(thread, stack,
			  CONFIG_IDLE_STACK_SIZE, idle, &_kernel.cpus[i],
  10d19a:	48 6b c3 28          	imul   $0x28,%rbx,%rax
	k_thread_stack_t *stack = z_idle_stacks[i];
  10d19e:	48 89 de             	mov    %rbx,%rsi
	z_setup_new_thread(thread, stack,
  10d1a1:	41 54                	push   %r12
	struct k_thread *thread = &z_idle_threads[i];
  10d1a3:	48 69 db e0 03 00 00 	imul   $0x3e0,%rbx,%rbx
	z_setup_new_thread(thread, stack,
  10d1aa:	6a 01                	pushq  $0x1
	k_thread_stack_t *stack = z_idle_stacks[i];
  10d1ac:	48 c1 e6 0d          	shl    $0xd,%rsi
	z_setup_new_thread(thread, stack,
  10d1b0:	45 31 c9             	xor    %r9d,%r9d
  10d1b3:	6a 0f                	pushq  $0xf
  10d1b5:	b9 3b e6 10 00       	mov    $0x10e63b,%ecx
  10d1ba:	ba 00 10 00 00       	mov    $0x1000,%edx
	k_thread_stack_t *stack = z_idle_stacks[i];
  10d1bf:	48 81 c6 00 00 5d 00 	add    $0x5d0000,%rsi
	z_setup_new_thread(thread, stack,
  10d1c6:	6a 00                	pushq  $0x0
  10d1c8:	4c 8d 80 40 87 12 00 	lea    0x128740(%rax),%r8
	struct k_thread *thread = &z_idle_threads[i];
  10d1cf:	48 81 c3 80 7f 12 00 	add    $0x127f80,%rbx
	z_setup_new_thread(thread, stack,
  10d1d6:	48 89 df             	mov    %rbx,%rdi
  10d1d9:	e8 fb 08 00 00       	callq  10dad9 <z_setup_new_thread>
	SYS_PORT_TRACING_FUNC(k_thread, sched_resume, thread);
}

static inline void z_mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
  10d1de:	80 63 19 fb          	andb   $0xfb,0x19(%rbx)
  10d1e2:	48 83 c4 20          	add    $0x20,%rsp
	z_mark_thread_as_started(thread);

#ifdef CONFIG_SMP
	thread->base.is_idle = 1U;
#endif
}
  10d1e6:	48 8d 65 f0          	lea    -0x10(%rbp),%rsp
  10d1ea:	5b                   	pop    %rbx
  10d1eb:	41 5c                	pop    %r12
  10d1ed:	5d                   	pop    %rbp
  10d1ee:	c3                   	retq   

000000000010d1ef <bg_thread_main>:
{
  10d1ef:	55                   	push   %rbp
  10d1f0:	48 89 e5             	mov    %rsp,%rbp
	z_mem_manage_init();
  10d1f3:	e8 3d 73 00 00       	callq  114535 <z_mem_manage_init>
	z_sys_init_run_level(_SYS_INIT_LEVEL_POST_KERNEL);
  10d1f8:	bf 02 00 00 00       	mov    $0x2,%edi
	z_sys_post_kernel = true;
  10d1fd:	c6 05 48 fc 0a 00 01 	movb   $0x1,0xafc48(%rip)        # 1bce4c <z_sys_post_kernel>
	z_sys_init_run_level(_SYS_INIT_LEVEL_POST_KERNEL);
  10d204:	e8 c0 fb ff ff       	callq  10cdc9 <z_sys_init_run_level>
	boot_banner();
  10d209:	e8 aa 9e 00 00       	callq  1170b8 <boot_banner>
	z_sys_init_run_level(_SYS_INIT_LEVEL_APPLICATION);
  10d20e:	bf 03 00 00 00       	mov    $0x3,%edi
  10d213:	e8 b1 fb ff ff       	callq  10cdc9 <z_sys_init_run_level>
	z_init_static_threads();
  10d218:	e8 96 0f 00 00       	callq  10e1b3 <z_init_static_threads>
	z_mem_manage_boot_finish();
  10d21d:	e8 3e 74 00 00       	callq  114660 <z_mem_manage_boot_finish>
	main();
  10d222:	e8 45 30 ff ff       	callq  10026c <main>
	z_main_thread.base.user_options &= ~K_ESSENTIAL;
  10d227:	80 25 4a b1 01 00 fe 	andb   $0xfe,0x1b14a(%rip)        # 128378 <z_main_thread+0x18>
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */
  10d22e:	5d                   	pop    %rbp
  10d22f:	c3                   	retq   

000000000010d230 <z_bss_zero>:
	(void)memset(__bss_start, 0, __bss_end - __bss_start);
  10d230:	ba 50 ce 1b 00       	mov    $0x1bce50,%edx
  10d235:	31 f6                	xor    %esi,%esi
  10d237:	bf 00 60 12 00       	mov    $0x126000,%edi
  10d23c:	48 81 ea 00 60 12 00 	sub    $0x126000,%rdx
  10d243:	e9 6a ce ff ff       	jmpq   10a0b2 <memset>

000000000010d248 <z_cstart>:
 *
 * @return Does not return
 */
__boot_func
FUNC_NORETURN void z_cstart(void)
{
  10d248:	55                   	push   %rbp
  10d249:	48 89 e5             	mov    %rsp,%rbp
  10d24c:	41 54                	push   %r12
  10d24e:	53                   	push   %rbx
#endif
#ifdef CONFIG_USERSPACE
	dummy_thread->mem_domain_info.mem_domain = &k_mem_domain_default;
#endif

	_current_cpu->current = dummy_thread;
  10d24f:	48 8d 85 10 fc ff ff 	lea    -0x3f0(%rbp),%rax
  10d256:	48 81 ec e0 03 00 00 	sub    $0x3e0,%rsp
  10d25d:	48 89 05 ec b4 01 00 	mov    %rax,0x1b4ec(%rip)        # 128750 <_kernel+0x10>
	dummy_thread->base.user_options = K_ESSENTIAL;
  10d264:	66 c7 85 28 fc ff ff 	movw   $0x101,-0x3d8(%rbp)
  10d26b:	01 01 
	dummy_thread->stack_info.start = 0U;
  10d26d:	48 c7 85 18 fd ff ff 	movq   $0x0,-0x2e8(%rbp)
  10d274:	00 00 00 00 
	dummy_thread->stack_info.size = 0U;
  10d278:	48 c7 85 20 fd ff ff 	movq   $0x0,-0x2e0(%rbp)
  10d27f:	00 00 00 00 
	dummy_thread->mem_domain_info.mem_domain = &k_mem_domain_default;
  10d283:	48 c7 85 40 fd ff ff 	movq   $0x1bc7a0,-0x2c0(%rbp)
  10d28a:	a0 c7 1b 00 
	struct k_thread dummy_thread;

	z_dummy_thread_init(&dummy_thread);
#endif
	/* do any necessary initialization of static devices */
	z_device_state_init();
  10d28e:	e8 10 fb ff ff       	callq  10cda3 <z_device_state_init>

	/* perform basic hardware initialization */
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
  10d293:	31 ff                	xor    %edi,%edi
  10d295:	e8 2f fb ff ff       	callq  10cdc9 <z_sys_init_run_level>
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_2);
  10d29a:	bf 01 00 00 00       	mov    $0x1,%edi
  10d29f:	e8 25 fb ff ff       	callq  10cdc9 <z_sys_init_run_level>
	z_sched_init();
  10d2a4:	e8 bf 4d 00 00       	callq  112068 <z_sched_init>
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
  10d2a9:	68 b1 f5 11 00       	pushq  $0x11f5b1
  10d2ae:	45 31 c9             	xor    %r9d,%r9d
  10d2b1:	45 31 c0             	xor    %r8d,%r8d
  10d2b4:	6a 01                	pushq  $0x1
  10d2b6:	b9 ef d1 10 00       	mov    $0x10d1ef,%ecx
  10d2bb:	ba 00 20 00 00       	mov    $0x2000,%edx
  10d2c0:	be 00 d0 5d 00       	mov    $0x5dd000,%esi
  10d2c5:	6a 00                	pushq  $0x0
  10d2c7:	bf 60 83 12 00       	mov    $0x128360,%edi
  10d2cc:	6a 00                	pushq  $0x0
	_kernel.ready_q.cache = &z_main_thread;
  10d2ce:	48 c7 05 8f b4 01 00 	movq   $0x128360,0x1b48f(%rip)        # 128768 <_kernel+0x28>
  10d2d5:	60 83 12 00 
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
  10d2d9:	e8 fb 07 00 00       	callq  10dad9 <z_setup_new_thread>
  10d2de:	48 83 c4 20          	add    $0x20,%rsp
	z_ready_thread(&z_main_thread);
  10d2e2:	bf 60 83 12 00       	mov    $0x128360,%edi
  10d2e7:	80 25 8b b0 01 00 fb 	andb   $0xfb,0x1b08b(%rip)        # 128379 <z_main_thread+0x19>
  10d2ee:	e8 57 41 00 00       	callq  11144a <z_ready_thread>
		init_idle_thread(i);
  10d2f3:	31 ff                	xor    %edi,%edi
  10d2f5:	e8 77 fe ff ff       	callq  10d171 <init_idle_thread>
		_kernel.cpus[i].id = i;
  10d2fa:	c6 05 63 b4 01 00 00 	movb   $0x0,0x1b463(%rip)        # 128764 <_kernel+0x24>
		_kernel.cpus[i].idle_thread = &z_idle_threads[i];
  10d301:	48 c7 05 4c b4 01 00 	movq   $0x127f80,0x1b44c(%rip)        # 128758 <_kernel+0x18>
  10d308:	80 7f 12 00 
		_kernel.cpus[i].irq_stack =
  10d30c:	48 c7 05 31 b4 01 00 	movq   $0x5d0000,0x1b431(%rip)        # 128748 <_kernel+0x8>
  10d313:	00 00 5d 00 
  10d317:	9c                   	pushfq 
  10d318:	fa                   	cli    
  10d319:	58                   	pop    %rax
	__ASSERT(arch_irq_unlocked(key) ||
  10d31a:	0f ba e0 09          	bt     $0x9,%eax
  10d31e:	72 43                	jb     10d363 <z_cstart+0x11b>
  10d320:	48 8b 05 29 b4 01 00 	mov    0x1b429(%rip),%rax        # 128750 <_kernel+0x10>
  10d327:	f6 40 19 09          	testb  $0x9,0x19(%rax)
  10d32b:	75 36                	jne    10d363 <z_cstart+0x11b>
  10d32d:	be e0 f5 11 00       	mov    $0x11f5e0,%esi
  10d332:	b9 53 00 00 00       	mov    $0x53,%ecx
  10d337:	ba b6 f5 11 00       	mov    $0x11f5b6,%edx
  10d33c:	31 c0                	xor    %eax,%eax
  10d33e:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  10d343:	e8 b0 32 ff ff       	callq  1005f8 <printk>
  10d348:	bf 49 f6 11 00       	mov    $0x11f649,%edi
  10d34d:	31 c0                	xor    %eax,%eax
  10d34f:	e8 a4 32 ff ff       	callq  1005f8 <printk>
  10d354:	be 53 00 00 00       	mov    $0x53,%esi
  10d359:	bf b6 f5 11 00       	mov    $0x11f5b6,%edi
  10d35e:	e8 35 58 ff ff       	callq  102b98 <assert_post_action>
	old_thread = _current;
  10d363:	48 8b 1d e6 b3 01 00 	mov    0x1b3e6(%rip),%rbx        # 128750 <_kernel+0x10>
	old_thread->swap_retval = -EAGAIN;
  10d36a:	c7 83 48 01 00 00 f5 	movl   $0xfffffff5,0x148(%rbx)
  10d371:	ff ff ff 
  10d374:	9c                   	pushfq 
  10d375:	fa                   	cli    
  10d376:	58                   	pop    %rax
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  10d377:	bf c8 cd 1b 00       	mov    $0x1bcdc8,%edi
  10d37c:	e8 f8 04 00 00       	callq  10d879 <z_spin_lock_valid>
  10d381:	84 c0                	test   %al,%al
  10d383:	75 39                	jne    10d3be <z_cstart+0x176>
  10d385:	b9 8e 00 00 00       	mov    $0x8e,%ecx
  10d38a:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  10d38f:	be fd d1 11 00       	mov    $0x11d1fd,%esi
  10d394:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  10d399:	e8 5a 32 ff ff       	callq  1005f8 <printk>
  10d39e:	be c8 cd 1b 00       	mov    $0x1bcdc8,%esi
  10d3a3:	bf 12 d2 11 00       	mov    $0x11d212,%edi
  10d3a8:	31 c0                	xor    %eax,%eax
  10d3aa:	e8 49 32 ff ff       	callq  1005f8 <printk>
  10d3af:	be 8e 00 00 00       	mov    $0x8e,%esi
  10d3b4:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  10d3b9:	e8 da 57 ff ff       	callq  102b98 <assert_post_action>
	z_spin_lock_set_owner(l);
  10d3be:	bf c8 cd 1b 00       	mov    $0x1bcdc8,%edi
  10d3c3:	e8 f5 04 00 00       	callq  10d8bd <z_spin_lock_set_owner>
	new_thread = z_swap_next_thread();
  10d3c8:	e8 70 3b 00 00       	callq  110f3d <z_swap_next_thread>
  10d3cd:	49 89 c4             	mov    %rax,%r12
	if (new_thread != old_thread) {
  10d3d0:	48 39 c3             	cmp    %rax,%rbx
  10d3d3:	74 7b                	je     10d450 <z_cstart+0x208>
		z_reset_time_slice();
  10d3d5:	e8 16 34 00 00       	callq  1107f0 <z_reset_time_slice>
		z_thread_mark_switched_out();
  10d3da:	e8 c1 11 00 00       	callq  10e5a0 <z_thread_mark_switched_out>
		z_spin_lock_set_owner(&sched_spinlock);
  10d3df:	bf c8 cd 1b 00       	mov    $0x1bcdc8,%edi
		_current_cpu->current = new_thread;
  10d3e4:	4c 89 25 65 b3 01 00 	mov    %r12,0x1b365(%rip)        # 128750 <_kernel+0x10>
		z_spin_lock_set_owner(&sched_spinlock);
  10d3eb:	e8 cd 04 00 00       	callq  10d8bd <z_spin_lock_set_owner>
 */
static ALWAYS_INLINE void k_spin_release(struct k_spinlock *l)
{
	ARG_UNUSED(l);
#ifdef CONFIG_SPIN_VALIDATE
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  10d3f0:	bf c8 cd 1b 00       	mov    $0x1bcdc8,%edi
		void *newsh = new_thread->switch_handle;
  10d3f5:	4d 8b a4 24 50 01 00 	mov    0x150(%r12),%r12
  10d3fc:	00 
  10d3fd:	e8 97 04 00 00       	callq  10d899 <z_spin_unlock_valid>
  10d402:	84 c0                	test   %al,%al
  10d404:	75 39                	jne    10d43f <z_cstart+0x1f7>
  10d406:	b9 d0 00 00 00       	mov    $0xd0,%ecx
  10d40b:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  10d410:	be 41 d2 11 00       	mov    $0x11d241,%esi
  10d415:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  10d41a:	e8 d9 31 ff ff       	callq  1005f8 <printk>
  10d41f:	be c8 cd 1b 00       	mov    $0x1bcdc8,%esi
  10d424:	bf 58 d2 11 00       	mov    $0x11d258,%edi
  10d429:	31 c0                	xor    %eax,%eax
  10d42b:	e8 c8 31 ff ff       	callq  1005f8 <printk>
  10d430:	be d0 00 00 00       	mov    $0xd0,%esi
  10d435:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  10d43a:	e8 59 57 ff ff       	callq  102b98 <assert_post_action>
		arch_switch(newsh, &old_thread->switch_handle);
  10d43f:	48 8d b3 50 01 00 00 	lea    0x150(%rbx),%rsi

extern void z_x86_switch(void *switch_to, void **switched_from);

static inline void arch_switch(void *switch_to, void **switched_from)
{
	z_x86_switch(switch_to, switched_from);
  10d446:	4c 89 e7             	mov    %r12,%rdi
  10d449:	e8 35 3d ef ff       	callq  1183 <z_x86_switch>
}
  10d44e:	eb 47                	jmp    10d497 <z_cstart+0x24f>
  10d450:	bf c8 cd 1b 00       	mov    $0x1bcdc8,%edi
  10d455:	e8 3f 04 00 00       	callq  10d899 <z_spin_unlock_valid>
  10d45a:	84 c0                	test   %al,%al
  10d45c:	75 39                	jne    10d497 <z_cstart+0x24f>
  10d45e:	b9 d0 00 00 00       	mov    $0xd0,%ecx
  10d463:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  10d468:	be 41 d2 11 00       	mov    $0x11d241,%esi
  10d46d:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  10d472:	e8 81 31 ff ff       	callq  1005f8 <printk>
  10d477:	be c8 cd 1b 00       	mov    $0x1bcdc8,%esi
  10d47c:	bf 58 d2 11 00       	mov    $0x11d258,%edi
  10d481:	31 c0                	xor    %eax,%eax
  10d483:	e8 70 31 ff ff       	callq  1005f8 <printk>
  10d488:	be d0 00 00 00       	mov    $0xd0,%esi
  10d48d:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  10d492:	e8 01 57 ff ff       	callq  102b98 <assert_post_action>
  10d497:	fb                   	sti    

000000000010d498 <init_mem_slab_module>:
 * Perform any initialization that wasn't done at build time.
 *
 * @return N/A
 */
static int init_mem_slab_module(const struct device *dev)
{
  10d498:	55                   	push   %rbp
  10d499:	48 89 e5             	mov    %rsp,%rbp
  10d49c:	53                   	push   %rbx
	int rc = 0;
	ARG_UNUSED(dev);

	STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
  10d49d:	bb 6c 14 5e 00       	mov    $0x5e146c,%ebx
{
  10d4a2:	51                   	push   %rcx
	STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
  10d4a3:	48 81 fb 6c 14 5e 00 	cmp    $0x5e146c,%rbx
  10d4aa:	76 36                	jbe    10d4e2 <init_mem_slab_module+0x4a>
  10d4ac:	be 99 f6 11 00       	mov    $0x11f699,%esi
  10d4b1:	b9 3c 00 00 00       	mov    $0x3c,%ecx
  10d4b6:	ba 74 f6 11 00       	mov    $0x11f674,%edx
  10d4bb:	31 c0                	xor    %eax,%eax
  10d4bd:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  10d4c2:	e8 31 31 ff ff       	callq  1005f8 <printk>
  10d4c7:	bf b6 f6 11 00       	mov    $0x11f6b6,%edi
  10d4cc:	31 c0                	xor    %eax,%eax
  10d4ce:	e8 25 31 ff ff       	callq  1005f8 <printk>
  10d4d3:	be 3c 00 00 00       	mov    $0x3c,%esi
  10d4d8:	bf 74 f6 11 00       	mov    $0x11f674,%edi
  10d4dd:	e8 b6 56 ff ff       	callq  102b98 <assert_post_action>
  10d4e2:	48 81 fb 6c 14 5e 00 	cmp    $0x5e146c,%rbx
  10d4e9:	73 47                	jae    10d532 <init_mem_slab_module+0x9a>
	CHECKIF(((slab->block_size | (uintptr_t)slab->buffer) &
  10d4eb:	48 8b 43 28          	mov    0x28(%rbx),%rax
  10d4ef:	48 8b 4b 20          	mov    0x20(%rbx),%rcx
  10d4f3:	48 89 c2             	mov    %rax,%rdx
  10d4f6:	48 09 ca             	or     %rcx,%rdx
  10d4f9:	80 e2 07             	and    $0x7,%dl
  10d4fc:	75 38                	jne    10d536 <init_mem_slab_module+0x9e>
	slab->free_list = NULL;
  10d4fe:	48 c7 43 30 00 00 00 	movq   $0x0,0x30(%rbx)
  10d505:	00 
	for (j = 0U; j < slab->num_blocks; j++) {
  10d506:	8b 73 18             	mov    0x18(%rbx),%esi
  10d509:	31 d2                	xor    %edx,%edx
  10d50b:	39 f2                	cmp    %esi,%edx
  10d50d:	74 12                	je     10d521 <init_mem_slab_module+0x89>
		*(char **)p = slab->free_list;
  10d50f:	48 8b 7b 30          	mov    0x30(%rbx),%rdi
	for (j = 0U; j < slab->num_blocks; j++) {
  10d513:	ff c2                	inc    %edx
		*(char **)p = slab->free_list;
  10d515:	48 89 38             	mov    %rdi,(%rax)
		slab->free_list = p;
  10d518:	48 89 43 30          	mov    %rax,0x30(%rbx)
		p += slab->block_size;
  10d51c:	48 01 c8             	add    %rcx,%rax
	for (j = 0U; j < slab->num_blocks; j++) {
  10d51f:	eb ea                	jmp    10d50b <init_mem_slab_module+0x73>
		rc = create_free_list(slab);
		if (rc < 0) {
			goto out;
		}
		z_object_init(slab);
  10d521:	48 89 df             	mov    %rbx,%rdi
	STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
  10d524:	48 83 c3 40          	add    $0x40,%rbx
		z_object_init(slab);
  10d528:	e8 c4 9a 00 00       	callq  116ff1 <z_object_init>
	STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
  10d52d:	e9 71 ff ff ff       	jmpq   10d4a3 <init_mem_slab_module+0xb>
	}

out:
  10d532:	31 c0                	xor    %eax,%eax
  10d534:	eb 05                	jmp    10d53b <init_mem_slab_module+0xa3>
  10d536:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
	return rc;
}
  10d53b:	5a                   	pop    %rdx
  10d53c:	5b                   	pop    %rbx
  10d53d:	5d                   	pop    %rbp
  10d53e:	c3                   	retq   

000000000010d53f <z_obj_validation_check>:
{
  10d53f:	55                   	push   %rbp
  10d540:	48 89 e5             	mov    %rsp,%rbp
  10d543:	41 57                	push   %r15
  10d545:	49 89 f7             	mov    %rsi,%r15
  10d548:	41 56                	push   %r14
  10d54a:	41 89 d6             	mov    %edx,%r14d
  10d54d:	89 ca                	mov    %ecx,%edx
  10d54f:	41 55                	push   %r13
	ret = z_object_validate(ko, otype, init);
  10d551:	44 89 f6             	mov    %r14d,%esi
{
  10d554:	49 89 fd             	mov    %rdi,%r13
  10d557:	48 83 ec 18          	sub    $0x18,%rsp
	ret = z_object_validate(ko, otype, init);
  10d55b:	e8 0c 9a 00 00       	callq  116f6c <z_object_validate>
	if (ret != 0) {
  10d560:	85 c0                	test   %eax,%eax
  10d562:	74 16                	je     10d57a <z_obj_validation_check+0x3b>
		z_dump_object_error(ret, obj, ko, otype);
  10d564:	89 c7                	mov    %eax,%edi
  10d566:	44 89 f1             	mov    %r14d,%ecx
  10d569:	4c 89 ea             	mov    %r13,%rdx
  10d56c:	4c 89 fe             	mov    %r15,%rsi
  10d56f:	89 45 dc             	mov    %eax,-0x24(%rbp)
  10d572:	e8 aa 98 00 00       	callq  116e21 <z_dump_object_error>
  10d577:	8b 45 dc             	mov    -0x24(%rbp),%eax
}
  10d57a:	48 83 c4 18          	add    $0x18,%rsp
  10d57e:	41 5d                	pop    %r13
  10d580:	41 5e                	pop    %r14
  10d582:	41 5f                	pop    %r15
  10d584:	5d                   	pop    %rbp
  10d585:	c3                   	retq   

000000000010d586 <schedule_new_thread>:
#endif
#endif

#ifdef CONFIG_MULTITHREADING
static void schedule_new_thread(struct k_thread *thread, k_timeout_t delay)
{
  10d586:	48 89 f2             	mov    %rsi,%rdx
#ifdef CONFIG_SYS_CLOCK_EXISTS
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
  10d589:	48 85 f6             	test   %rsi,%rsi
  10d58c:	75 05                	jne    10d593 <schedule_new_thread+0xd>
	z_sched_start(thread);
  10d58e:	e9 70 3f 00 00       	jmpq   111503 <z_sched_start>

extern void z_thread_timeout(struct _timeout *timeout);

static inline void z_add_thread_timeout(struct k_thread *thread, k_timeout_t ticks)
{
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
  10d593:	48 83 c7 28          	add    $0x28,%rdi
  10d597:	be 35 17 11 00       	mov    $0x111735,%esi
  10d59c:	e9 64 58 00 00       	jmpq   112e05 <z_add_timeout>

000000000010d5a1 <k_is_in_isr>:
	__asm__ volatile ("pushf; cli");
	ret = arch_curr_cpu()->nested != 0;
	__asm__ volatile ("popf");
	return ret;
#else
	return _kernel.cpus[0].nested != 0U;
  10d5a1:	83 3d 98 b1 01 00 00 	cmpl   $0x0,0x1b198(%rip)        # 128740 <_kernel>
  10d5a8:	0f 95 c0             	setne  %al
}
  10d5ab:	c3                   	retq   

000000000010d5ac <z_mrsh_k_thread_custom_data_set>:

extern void z_vrfy_k_thread_custom_data_set(void * value);
uintptr_t z_mrsh_k_thread_custom_data_set(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
	_current->syscall_frame = ssf;
  10d5ac:	48 8b 05 9d b1 01 00 	mov    0x1b19d(%rip),%rax        # 128750 <_kernel+0x10>
	_current->custom_data = value;
  10d5b3:	48 89 b8 f8 00 00 00 	mov    %rdi,0xf8(%rax)
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	z_vrfy_k_thread_custom_data_set(*(void **)&arg0)
;
	_current->syscall_frame = NULL;
  10d5ba:	48 c7 80 40 01 00 00 	movq   $0x0,0x140(%rax)
  10d5c1:	00 00 00 00 
	return 0;
}
  10d5c5:	31 c0                	xor    %eax,%eax
  10d5c7:	c3                   	retq   

000000000010d5c8 <z_mrsh_k_thread_custom_data_get>:

extern void * z_vrfy_k_thread_custom_data_get();
uintptr_t z_mrsh_k_thread_custom_data_get(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
	_current->syscall_frame = ssf;
  10d5c8:	48 8b 15 81 b1 01 00 	mov    0x1b181(%rip),%rdx        # 128750 <_kernel+0x10>
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	void * ret = z_vrfy_k_thread_custom_data_get()
;
	_current->syscall_frame = NULL;
  10d5cf:	48 c7 82 40 01 00 00 	movq   $0x0,0x140(%rdx)
  10d5d6:	00 00 00 00 
	return _current->custom_data;
  10d5da:	48 8b 82 f8 00 00 00 	mov    0xf8(%rdx),%rax
	return (uintptr_t) ret;
}
  10d5e1:	c3                   	retq   

000000000010d5e2 <z_impl_k_thread_name_set>:
{
  10d5e2:	55                   	push   %rbp
  10d5e3:	48 89 e5             	mov    %rsp,%rbp
  10d5e6:	53                   	push   %rbx
  10d5e7:	51                   	push   %rcx
		thread = _current;
  10d5e8:	48 8b 1d 61 b1 01 00 	mov    0x1b161(%rip),%rbx        # 128750 <_kernel+0x10>
	if (thread == NULL) {
  10d5ef:	48 85 ff             	test   %rdi,%rdi
  10d5f2:	74 03                	je     10d5f7 <z_impl_k_thread_name_set+0x15>
  10d5f4:	48 89 fb             	mov    %rdi,%rbx
	strncpy(thread->name, value, CONFIG_THREAD_MAX_NAME_LEN);
  10d5f7:	48 8d bb d8 00 00 00 	lea    0xd8(%rbx),%rdi
  10d5fe:	ba 20 00 00 00       	mov    $0x20,%edx
  10d603:	e8 7c c9 ff ff       	callq  109f84 <strncpy>
	thread->name[CONFIG_THREAD_MAX_NAME_LEN - 1] = '\0';
  10d608:	c6 83 f7 00 00 00 00 	movb   $0x0,0xf7(%rbx)
}
  10d60f:	31 c0                	xor    %eax,%eax
  10d611:	5a                   	pop    %rdx
  10d612:	5b                   	pop    %rbx
  10d613:	5d                   	pop    %rbp
  10d614:	c3                   	retq   

000000000010d615 <z_mrsh_k_thread_name_set>:
#include <syscalls/kernel.h>

extern int z_vrfy_k_thread_name_set(k_tid_t thread, const char * str);
uintptr_t z_mrsh_k_thread_name_set(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
  10d615:	55                   	push   %rbp
  10d616:	48 89 e5             	mov    %rsp,%rbp
  10d619:	41 55                	push   %r13
  10d61b:	49 89 f5             	mov    %rsi,%r13
  10d61e:	41 54                	push   %r12
  10d620:	49 89 fc             	mov    %rdi,%r12
  10d623:	48 83 ec 20          	sub    $0x20,%rsp
	_current->syscall_frame = ssf;
  10d627:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  10d62b:	48 8b 05 1e b1 01 00 	mov    0x1b11e(%rip),%rax        # 128750 <_kernel+0x10>
  10d632:	48 89 90 40 01 00 00 	mov    %rdx,0x140(%rax)
	if (thread != NULL) {
  10d639:	48 85 ff             	test   %rdi,%rdi
  10d63c:	74 38                	je     10d676 <z_mrsh_k_thread_name_set+0x61>
		if (Z_SYSCALL_OBJ(thread, K_OBJ_THREAD) != 0) {
  10d63e:	e8 91 94 00 00       	callq  116ad4 <z_object_find>
  10d643:	31 c9                	xor    %ecx,%ecx
  10d645:	ba 09 00 00 00       	mov    $0x9,%edx
  10d64a:	4c 89 e6             	mov    %r12,%rsi
  10d64d:	48 89 c7             	mov    %rax,%rdi
  10d650:	e8 ea fe ff ff       	callq  10d53f <z_obj_validation_check>
  10d655:	85 c0                	test   %eax,%eax
  10d657:	74 1d                	je     10d676 <z_mrsh_k_thread_name_set+0x61>
  10d659:	31 c0                	xor    %eax,%eax
  10d65b:	ba 90 c1 11 00       	mov    $0x11c190,%edx
  10d660:	be 45 00 00 00       	mov    $0x45,%esi
  10d665:	bf 23 f3 11 00       	mov    $0x11f323,%edi
  10d66a:	e8 57 5a ff ff       	callq  1030c6 <z_log_minimal_printk>
			return -EINVAL;
  10d66f:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
  10d674:	eb 2a                	jmp    10d6a0 <z_mrsh_k_thread_name_set+0x8b>
	if (z_user_string_copy(name, (char *)str, sizeof(name)) != 0) {
  10d676:	ba 20 00 00 00       	mov    $0x20,%edx
  10d67b:	4c 89 ee             	mov    %r13,%rsi
  10d67e:	48 8d 7d d0          	lea    -0x30(%rbp),%rdi
  10d682:	e8 a3 99 00 00       	callq  11702a <z_user_string_copy>
  10d687:	41 89 c0             	mov    %eax,%r8d
		return -EFAULT;
  10d68a:	b8 f2 ff ff ff       	mov    $0xfffffff2,%eax
	if (z_user_string_copy(name, (char *)str, sizeof(name)) != 0) {
  10d68f:	45 85 c0             	test   %r8d,%r8d
  10d692:	75 0c                	jne    10d6a0 <z_mrsh_k_thread_name_set+0x8b>
	return z_impl_k_thread_name_set(thread, name);
  10d694:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  10d698:	4c 89 e7             	mov    %r12,%rdi
  10d69b:	e8 42 ff ff ff       	callq  10d5e2 <z_impl_k_thread_name_set>
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	int ret = z_vrfy_k_thread_name_set(*(k_tid_t*)&arg0, *(const char **)&arg1)
;
	_current->syscall_frame = NULL;
  10d6a0:	48 8b 15 a9 b0 01 00 	mov    0x1b0a9(%rip),%rdx        # 128750 <_kernel+0x10>
	return (uintptr_t) ret;
  10d6a7:	48 98                	cltq   
	_current->syscall_frame = NULL;
  10d6a9:	48 c7 82 40 01 00 00 	movq   $0x0,0x140(%rdx)
  10d6b0:	00 00 00 00 
}
  10d6b4:	48 83 c4 20          	add    $0x20,%rsp
  10d6b8:	41 5c                	pop    %r12
  10d6ba:	41 5d                	pop    %r13
  10d6bc:	5d                   	pop    %rbp
  10d6bd:	c3                   	retq   

000000000010d6be <k_thread_name_get>:
	return (const char *)thread->name;
  10d6be:	48 8d 87 d8 00 00 00 	lea    0xd8(%rdi),%rax
}
  10d6c5:	c3                   	retq   

000000000010d6c6 <k_thread_state_str>:
	switch (thread_id->base.thread_state) {
  10d6c6:	0f b6 57 19          	movzbl 0x19(%rdi),%edx
  10d6ca:	80 fa 10             	cmp    $0x10,%dl
  10d6cd:	77 0d                	ja     10d6dc <k_thread_state_str+0x16>
  10d6cf:	ff 24 d5 f8 cc 11 00 	jmpq   *0x11ccf8(,%rdx,8)
  10d6d6:	b8 f5 f6 11 00       	mov    $0x11f6f5,%eax
  10d6db:	c3                   	retq   
		return "aborting";
  10d6dc:	b8 fb f6 11 00       	mov    $0x11f6fb,%eax
	switch (thread_id->base.thread_state) {
  10d6e1:	80 fa 20             	cmp    $0x20,%dl
  10d6e4:	74 35                	je     10d71b <k_thread_state_str+0x55>
		return "queued";
  10d6e6:	80 fa 80             	cmp    $0x80,%dl
  10d6e9:	b8 0b f5 11 00       	mov    $0x11f50b,%eax
  10d6ee:	ba 04 f7 11 00       	mov    $0x11f704,%edx
  10d6f3:	48 0f 44 c2          	cmove  %rdx,%rax
  10d6f7:	c3                   	retq   
		return "pending";
  10d6f8:	b8 d5 f6 11 00       	mov    $0x11f6d5,%eax
  10d6fd:	c3                   	retq   
		return "prestart";
  10d6fe:	b8 dd f6 11 00       	mov    $0x11f6dd,%eax
  10d703:	c3                   	retq   
		return "dead";
  10d704:	b8 e6 f6 11 00       	mov    $0x11f6e6,%eax
  10d709:	c3                   	retq   
		return "suspended";
  10d70a:	b8 eb f6 11 00       	mov    $0x11f6eb,%eax
  10d70f:	c3                   	retq   
	return "unknown";
  10d710:	b8 0b f5 11 00       	mov    $0x11f50b,%eax
  10d715:	c3                   	retq   
		return "";
  10d716:	b8 24 fc 11 00       	mov    $0x11fc24,%eax
}
  10d71b:	c3                   	retq   

000000000010d71c <z_mrsh_k_thread_name_copy>:
#include <syscalls/kernel.h>

extern int z_vrfy_k_thread_name_copy(k_tid_t thread, char * buf, size_t size);
uintptr_t z_mrsh_k_thread_name_copy(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
  10d71c:	55                   	push   %rbp
  10d71d:	48 89 e5             	mov    %rsp,%rbp
  10d720:	41 56                	push   %r14
  10d722:	49 89 f6             	mov    %rsi,%r14
  10d725:	41 55                	push   %r13
  10d727:	49 89 d5             	mov    %rdx,%r13
  10d72a:	41 54                	push   %r12
  10d72c:	49 89 fc             	mov    %rdi,%r12
  10d72f:	51                   	push   %rcx
	_current->syscall_frame = ssf;
  10d730:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  10d734:	48 8b 05 15 b0 01 00 	mov    0x1b015(%rip),%rax        # 128750 <_kernel+0x10>
  10d73b:	48 89 90 40 01 00 00 	mov    %rdx,0x140(%rax)
	struct z_object *ko = z_object_find(thread);
  10d742:	e8 8d 93 00 00       	callq  116ad4 <z_object_find>
  10d747:	48 89 c2             	mov    %rax,%rdx
		return -EINVAL;
  10d74a:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
	if (thread == NULL || ko->type != K_OBJ_THREAD ||
  10d74f:	4d 85 e4             	test   %r12,%r12
  10d752:	74 71                	je     10d7c5 <z_mrsh_k_thread_name_copy+0xa9>
  10d754:	80 7a 0c 09          	cmpb   $0x9,0xc(%rdx)
  10d758:	75 6b                	jne    10d7c5 <z_mrsh_k_thread_name_copy+0xa9>
  10d75a:	f6 42 0d 01          	testb  $0x1,0xd(%rdx)
  10d75e:	74 65                	je     10d7c5 <z_mrsh_k_thread_name_copy+0xa9>
	if (Z_SYSCALL_MEMORY_WRITE(buf, size) != 0) {
  10d760:	ba 01 00 00 00       	mov    $0x1,%edx
  10d765:	4c 89 ee             	mov    %r13,%rsi
  10d768:	4c 89 f7             	mov    %r14,%rdi
  10d76b:	e8 4c bc ff ff       	callq  1093bc <arch_buffer_validate>
  10d770:	85 c0                	test   %eax,%eax
  10d772:	74 29                	je     10d79d <z_mrsh_k_thread_name_copy+0x81>
  10d774:	31 c0                	xor    %eax,%eax
  10d776:	41 b9 a4 d2 11 00    	mov    $0x11d2a4,%r9d
  10d77c:	4d 89 e8             	mov    %r13,%r8
  10d77f:	4c 89 f1             	mov    %r14,%rcx
  10d782:	ba 70 c1 11 00       	mov    $0x11c170,%edx
  10d787:	be 45 00 00 00       	mov    $0x45,%esi
  10d78c:	bf 1e cf 11 00       	mov    $0x11cf1e,%edi
  10d791:	e8 30 59 ff ff       	callq  1030c6 <z_log_minimal_printk>
		return -EFAULT;
  10d796:	b8 f2 ff ff ff       	mov    $0xfffffff2,%eax
  10d79b:	eb 28                	jmp    10d7c5 <z_mrsh_k_thread_name_copy+0xa9>
	len = strlen(thread->name);
  10d79d:	49 81 c4 d8 00 00 00 	add    $0xd8,%r12
  10d7a4:	4c 89 e7             	mov    %r12,%rdi
  10d7a7:	e8 30 c8 ff ff       	callq  109fdc <strlen>
	if (len + 1 > size) {
  10d7ac:	48 8d 50 01          	lea    0x1(%rax),%rdx
		return -ENOSPC;
  10d7b0:	b8 e4 ff ff ff       	mov    $0xffffffe4,%eax
	if (len + 1 > size) {
  10d7b5:	49 39 d5             	cmp    %rdx,%r13
  10d7b8:	72 0b                	jb     10d7c5 <z_mrsh_k_thread_name_copy+0xa9>
	return z_user_to_copy((void *)buf, thread->name, len + 1);
  10d7ba:	4c 89 e6             	mov    %r12,%rsi
  10d7bd:	4c 89 f7             	mov    %r14,%rdi
  10d7c0:	e8 5b 98 00 00       	callq  117020 <z_user_to_copy>
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	int ret = z_vrfy_k_thread_name_copy(*(k_tid_t*)&arg0, *(char **)&arg1, *(size_t*)&arg2)
;
	_current->syscall_frame = NULL;
  10d7c5:	48 8b 15 84 af 01 00 	mov    0x1af84(%rip),%rdx        # 128750 <_kernel+0x10>
	return (uintptr_t) ret;
  10d7cc:	48 98                	cltq   
	_current->syscall_frame = NULL;
  10d7ce:	48 c7 82 40 01 00 00 	movq   $0x0,0x140(%rdx)
  10d7d5:	00 00 00 00 
}
  10d7d9:	5a                   	pop    %rdx
  10d7da:	41 5c                	pop    %r12
  10d7dc:	41 5d                	pop    %r13
  10d7de:	41 5e                	pop    %r14
  10d7e0:	5d                   	pop    %rbp
  10d7e1:	c3                   	retq   

000000000010d7e2 <z_impl_k_thread_start>:
	z_sched_start(thread);
  10d7e2:	e9 1c 3d 00 00       	jmpq   111503 <z_sched_start>

000000000010d7e7 <z_mrsh_k_thread_start>:
#include <syscalls/kernel.h>

extern void z_vrfy_k_thread_start(k_tid_t thread);
uintptr_t z_mrsh_k_thread_start(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
  10d7e7:	55                   	push   %rbp
  10d7e8:	48 89 e5             	mov    %rsp,%rbp
  10d7eb:	41 54                	push   %r12
  10d7ed:	49 89 fc             	mov    %rdi,%r12
  10d7f0:	51                   	push   %rcx
	_current->syscall_frame = ssf;
  10d7f1:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  10d7f5:	48 8b 05 54 af 01 00 	mov    0x1af54(%rip),%rax        # 128750 <_kernel+0x10>
  10d7fc:	48 89 90 40 01 00 00 	mov    %rdx,0x140(%rax)
	Z_OOPS(Z_SYSCALL_OBJ(thread, K_OBJ_THREAD));
  10d803:	e8 cc 92 00 00       	callq  116ad4 <z_object_find>
  10d808:	31 c9                	xor    %ecx,%ecx
  10d80a:	ba 09 00 00 00       	mov    $0x9,%edx
  10d80f:	4c 89 e6             	mov    %r12,%rsi
  10d812:	48 89 c7             	mov    %rax,%rdi
  10d815:	e8 25 fd ff ff       	callq  10d53f <z_obj_validation_check>
  10d81a:	85 c0                	test   %eax,%eax
  10d81c:	74 29                	je     10d847 <z_mrsh_k_thread_start+0x60>
  10d81e:	bf 23 f3 11 00       	mov    $0x11f323,%edi
  10d823:	31 c0                	xor    %eax,%eax
  10d825:	ba 50 c1 11 00       	mov    $0x11c150,%edx
  10d82a:	be 45 00 00 00       	mov    $0x45,%esi
  10d82f:	e8 92 58 ff ff       	callq  1030c6 <z_log_minimal_printk>
  10d834:	48 8b 05 15 af 01 00 	mov    0x1af15(%rip),%rax        # 128750 <_kernel+0x10>
  10d83b:	48 8b b8 40 01 00 00 	mov    0x140(%rax),%rdi
  10d842:	e8 c6 c3 ff ff       	callq  109c0d <arch_syscall_oops>
	z_sched_start(thread);
  10d847:	4c 89 e7             	mov    %r12,%rdi
  10d84a:	e8 b4 3c 00 00       	callq  111503 <z_sched_start>
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	z_vrfy_k_thread_start(*(k_tid_t*)&arg0)
;
	_current->syscall_frame = NULL;
  10d84f:	48 8b 05 fa ae 01 00 	mov    0x1aefa(%rip),%rax        # 128750 <_kernel+0x10>
  10d856:	48 c7 80 40 01 00 00 	movq   $0x0,0x140(%rax)
  10d85d:	00 00 00 00 
	return 0;
}
  10d861:	31 c0                	xor    %eax,%eax
  10d863:	5a                   	pop    %rdx
  10d864:	41 5c                	pop    %r12
  10d866:	5d                   	pop    %rbp
  10d867:	c3                   	retq   

000000000010d868 <z_stack_is_user_capable>:
}


#ifdef CONFIG_USERSPACE
bool z_stack_is_user_capable(k_thread_stack_t *stack)
{
  10d868:	55                   	push   %rbp
  10d869:	48 89 e5             	mov    %rsp,%rbp
	return z_object_find(stack) != NULL;
  10d86c:	e8 63 92 00 00       	callq  116ad4 <z_object_find>
}
  10d871:	5d                   	pop    %rbp
	return z_object_find(stack) != NULL;
  10d872:	48 85 c0             	test   %rax,%rax
  10d875:	0f 95 c0             	setne  %al
}
  10d878:	c3                   	retq   

000000000010d879 <z_spin_lock_valid>:
 * them in spinlock.h is a giant header ordering headache.
 */
#ifdef CONFIG_SPIN_VALIDATE
bool z_spin_lock_valid(struct k_spinlock *l)
{
	uintptr_t thread_cpu = l->thread_cpu;
  10d879:	48 8b 07             	mov    (%rdi),%rax
	if (thread_cpu != 0U) {
		if ((thread_cpu & 3U) == _current_cpu->id) {
			return false;
		}
	}
	return true;
  10d87c:	41 b0 01             	mov    $0x1,%r8b
	if (thread_cpu != 0U) {
  10d87f:	48 85 c0             	test   %rax,%rax
  10d882:	74 11                	je     10d895 <z_spin_lock_valid+0x1c>
		if ((thread_cpu & 3U) == _current_cpu->id) {
  10d884:	0f b6 15 d9 ae 01 00 	movzbl 0x1aed9(%rip),%edx        # 128764 <_kernel+0x24>
  10d88b:	83 e0 03             	and    $0x3,%eax
  10d88e:	48 39 d0             	cmp    %rdx,%rax
  10d891:	41 0f 95 c0          	setne  %r8b
}
  10d895:	44 89 c0             	mov    %r8d,%eax
  10d898:	c3                   	retq   

000000000010d899 <z_spin_unlock_valid>:

bool z_spin_unlock_valid(struct k_spinlock *l)
{
	if (l->thread_cpu != (_current_cpu->id | (uintptr_t)_current)) {
  10d899:	0f b6 05 c4 ae 01 00 	movzbl 0x1aec4(%rip),%eax        # 128764 <_kernel+0x24>
		return false;
  10d8a0:	45 31 c0             	xor    %r8d,%r8d
	if (l->thread_cpu != (_current_cpu->id | (uintptr_t)_current)) {
  10d8a3:	48 0b 05 a6 ae 01 00 	or     0x1aea6(%rip),%rax        # 128750 <_kernel+0x10>
  10d8aa:	48 39 07             	cmp    %rax,(%rdi)
  10d8ad:	75 0a                	jne    10d8b9 <z_spin_unlock_valid+0x20>
	}
	l->thread_cpu = 0;
  10d8af:	48 c7 07 00 00 00 00 	movq   $0x0,(%rdi)
	return true;
  10d8b6:	41 b0 01             	mov    $0x1,%r8b
}
  10d8b9:	44 89 c0             	mov    %r8d,%eax
  10d8bc:	c3                   	retq   

000000000010d8bd <z_spin_lock_set_owner>:

void z_spin_lock_set_owner(struct k_spinlock *l)
{
	l->thread_cpu = _current_cpu->id | (uintptr_t)_current;
  10d8bd:	0f b6 05 a0 ae 01 00 	movzbl 0x1aea0(%rip),%eax        # 128764 <_kernel+0x24>
  10d8c4:	48 0b 05 85 ae 01 00 	or     0x1ae85(%rip),%rax        # 128750 <_kernel+0x10>
  10d8cb:	48 89 07             	mov    %rax,(%rdi)
}
  10d8ce:	c3                   	retq   

000000000010d8cf <k_thread_foreach>:
{
  10d8cf:	55                   	push   %rbp
  10d8d0:	48 89 e5             	mov    %rsp,%rbp
  10d8d3:	41 56                	push   %r14
  10d8d5:	41 55                	push   %r13
  10d8d7:	49 89 f5             	mov    %rsi,%r13
  10d8da:	41 54                	push   %r12
  10d8dc:	49 89 fc             	mov    %rdi,%r12
  10d8df:	53                   	push   %rbx
	__ASSERT(user_cb != NULL, "user_cb can not be NULL");
  10d8e0:	48 85 ff             	test   %rdi,%rdi
  10d8e3:	75 36                	jne    10d91b <k_thread_foreach+0x4c>
  10d8e5:	be a0 f7 11 00       	mov    $0x11f7a0,%esi
  10d8ea:	b9 37 00 00 00       	mov    $0x37,%ecx
  10d8ef:	ba 0b f7 11 00       	mov    $0x11f70b,%edx
  10d8f4:	31 c0                	xor    %eax,%eax
  10d8f6:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  10d8fb:	e8 f8 2c ff ff       	callq  1005f8 <printk>
  10d900:	bf b7 f7 11 00       	mov    $0x11f7b7,%edi
  10d905:	31 c0                	xor    %eax,%eax
  10d907:	e8 ec 2c ff ff       	callq  1005f8 <printk>
  10d90c:	be 37 00 00 00       	mov    $0x37,%esi
  10d911:	bf 0b f7 11 00       	mov    $0x11f70b,%edi
  10d916:	e8 7d 52 ff ff       	callq  102b98 <assert_post_action>
  10d91b:	9c                   	pushfq 
  10d91c:	fa                   	cli    
  10d91d:	41 5e                	pop    %r14
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  10d91f:	bf a8 cd 1b 00       	mov    $0x1bcda8,%edi
  10d924:	e8 50 ff ff ff       	callq  10d879 <z_spin_lock_valid>
  10d929:	84 c0                	test   %al,%al
  10d92b:	75 39                	jne    10d966 <k_thread_foreach+0x97>
  10d92d:	b9 8e 00 00 00       	mov    $0x8e,%ecx
  10d932:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  10d937:	be fd d1 11 00       	mov    $0x11d1fd,%esi
  10d93c:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  10d941:	e8 b2 2c ff ff       	callq  1005f8 <printk>
  10d946:	be a8 cd 1b 00       	mov    $0x1bcda8,%esi
  10d94b:	bf 12 d2 11 00       	mov    $0x11d212,%edi
  10d950:	31 c0                	xor    %eax,%eax
  10d952:	e8 a1 2c ff ff       	callq  1005f8 <printk>
  10d957:	be 8e 00 00 00       	mov    $0x8e,%esi
  10d95c:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  10d961:	e8 32 52 ff ff       	callq  102b98 <assert_post_action>
	z_spin_lock_set_owner(l);
  10d966:	bf a8 cd 1b 00       	mov    $0x1bcda8,%edi
  10d96b:	e8 4d ff ff ff       	callq  10d8bd <z_spin_lock_set_owner>
	for (thread = _kernel.threads; thread; thread = thread->next_thread) {
  10d970:	48 8b 1d 09 ae 01 00 	mov    0x1ae09(%rip),%rbx        # 128780 <_kernel+0x40>
  10d977:	48 85 db             	test   %rbx,%rbx
  10d97a:	74 12                	je     10d98e <k_thread_foreach+0xbf>
		user_cb(thread, user_data);
  10d97c:	48 89 df             	mov    %rbx,%rdi
  10d97f:	4c 89 ee             	mov    %r13,%rsi
  10d982:	41 ff d4             	callq  *%r12
	for (thread = _kernel.threads; thread; thread = thread->next_thread) {
  10d985:	48 8b 9b d0 00 00 00 	mov    0xd0(%rbx),%rbx
  10d98c:	eb e9                	jmp    10d977 <k_thread_foreach+0xa8>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  10d98e:	bf a8 cd 1b 00       	mov    $0x1bcda8,%edi
  10d993:	e8 01 ff ff ff       	callq  10d899 <z_spin_unlock_valid>
  10d998:	84 c0                	test   %al,%al
  10d99a:	75 39                	jne    10d9d5 <k_thread_foreach+0x106>
  10d99c:	b9 b9 00 00 00       	mov    $0xb9,%ecx
  10d9a1:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  10d9a6:	be 41 d2 11 00       	mov    $0x11d241,%esi
  10d9ab:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  10d9b0:	e8 43 2c ff ff       	callq  1005f8 <printk>
  10d9b5:	be a8 cd 1b 00       	mov    $0x1bcda8,%esi
  10d9ba:	bf 58 d2 11 00       	mov    $0x11d258,%edi
  10d9bf:	31 c0                	xor    %eax,%eax
  10d9c1:	e8 32 2c ff ff       	callq  1005f8 <printk>
  10d9c6:	be b9 00 00 00       	mov    $0xb9,%esi
  10d9cb:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  10d9d0:	e8 c3 51 ff ff       	callq  102b98 <assert_post_action>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  10d9d5:	41 0f ba e6 09       	bt     $0x9,%r14d
  10d9da:	73 01                	jae    10d9dd <k_thread_foreach+0x10e>
		__asm__ volatile ("sti" ::: "memory");
  10d9dc:	fb                   	sti    
}
  10d9dd:	5b                   	pop    %rbx
  10d9de:	41 5c                	pop    %r12
  10d9e0:	41 5d                	pop    %r13
  10d9e2:	41 5e                	pop    %r14
  10d9e4:	5d                   	pop    %rbp
  10d9e5:	c3                   	retq   

000000000010d9e6 <z_thread_monitor_exit>:
{
  10d9e6:	55                   	push   %rbp
  10d9e7:	48 89 e5             	mov    %rsp,%rbp
  10d9ea:	41 54                	push   %r12
  10d9ec:	53                   	push   %rbx
  10d9ed:	48 89 fb             	mov    %rdi,%rbx
  10d9f0:	9c                   	pushfq 
  10d9f1:	fa                   	cli    
  10d9f2:	41 5c                	pop    %r12
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  10d9f4:	bf a8 cd 1b 00       	mov    $0x1bcda8,%edi
  10d9f9:	e8 7b fe ff ff       	callq  10d879 <z_spin_lock_valid>
  10d9fe:	84 c0                	test   %al,%al
  10da00:	75 39                	jne    10da3b <z_thread_monitor_exit+0x55>
  10da02:	b9 8e 00 00 00       	mov    $0x8e,%ecx
  10da07:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  10da0c:	be fd d1 11 00       	mov    $0x11d1fd,%esi
  10da11:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  10da16:	e8 dd 2b ff ff       	callq  1005f8 <printk>
  10da1b:	be a8 cd 1b 00       	mov    $0x1bcda8,%esi
  10da20:	bf 12 d2 11 00       	mov    $0x11d212,%edi
  10da25:	31 c0                	xor    %eax,%eax
  10da27:	e8 cc 2b ff ff       	callq  1005f8 <printk>
  10da2c:	be 8e 00 00 00       	mov    $0x8e,%esi
  10da31:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  10da36:	e8 5d 51 ff ff       	callq  102b98 <assert_post_action>
	z_spin_lock_set_owner(l);
  10da3b:	bf a8 cd 1b 00       	mov    $0x1bcda8,%edi
  10da40:	e8 78 fe ff ff       	callq  10d8bd <z_spin_lock_set_owner>
	if (thread == _kernel.threads) {
  10da45:	48 8b 05 34 ad 01 00 	mov    0x1ad34(%rip),%rax        # 128780 <_kernel+0x40>
  10da4c:	48 39 d8             	cmp    %rbx,%rax
  10da4f:	75 1f                	jne    10da70 <z_thread_monitor_exit+0x8a>
		_kernel.threads = _kernel.threads->next_thread;
  10da51:	48 8b 83 d0 00 00 00 	mov    0xd0(%rbx),%rax
  10da58:	48 89 05 21 ad 01 00 	mov    %rax,0x1ad21(%rip)        # 128780 <_kernel+0x40>
  10da5f:	eb 24                	jmp    10da85 <z_thread_monitor_exit+0x9f>
			(thread != prev_thread->next_thread)) {
  10da61:	48 8b 90 d0 00 00 00 	mov    0xd0(%rax),%rdx
		while ((prev_thread != NULL) &&
  10da68:	48 39 da             	cmp    %rbx,%rdx
  10da6b:	74 0a                	je     10da77 <z_thread_monitor_exit+0x91>
  10da6d:	48 89 d0             	mov    %rdx,%rax
  10da70:	48 85 c0             	test   %rax,%rax
  10da73:	75 ec                	jne    10da61 <z_thread_monitor_exit+0x7b>
  10da75:	eb 0e                	jmp    10da85 <z_thread_monitor_exit+0x9f>
			prev_thread->next_thread = thread->next_thread;
  10da77:	48 8b 93 d0 00 00 00 	mov    0xd0(%rbx),%rdx
  10da7e:	48 89 90 d0 00 00 00 	mov    %rdx,0xd0(%rax)
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  10da85:	bf a8 cd 1b 00       	mov    $0x1bcda8,%edi
  10da8a:	e8 0a fe ff ff       	callq  10d899 <z_spin_unlock_valid>
  10da8f:	84 c0                	test   %al,%al
  10da91:	75 39                	jne    10dacc <z_thread_monitor_exit+0xe6>
  10da93:	b9 b9 00 00 00       	mov    $0xb9,%ecx
  10da98:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  10da9d:	be 41 d2 11 00       	mov    $0x11d241,%esi
  10daa2:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  10daa7:	e8 4c 2b ff ff       	callq  1005f8 <printk>
  10daac:	be a8 cd 1b 00       	mov    $0x1bcda8,%esi
  10dab1:	bf 58 d2 11 00       	mov    $0x11d258,%edi
  10dab6:	31 c0                	xor    %eax,%eax
  10dab8:	e8 3b 2b ff ff       	callq  1005f8 <printk>
  10dabd:	be b9 00 00 00       	mov    $0xb9,%esi
  10dac2:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  10dac7:	e8 cc 50 ff ff       	callq  102b98 <assert_post_action>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  10dacc:	41 0f ba e4 09       	bt     $0x9,%r12d
  10dad1:	73 01                	jae    10dad4 <z_thread_monitor_exit+0xee>
		__asm__ volatile ("sti" ::: "memory");
  10dad3:	fb                   	sti    
}
  10dad4:	5b                   	pop    %rbx
  10dad5:	41 5c                	pop    %r12
  10dad7:	5d                   	pop    %rbp
  10dad8:	c3                   	retq   

000000000010dad9 <z_setup_new_thread>:
{
  10dad9:	55                   	push   %rbp
  10dada:	48 89 e5             	mov    %rsp,%rbp
  10dadd:	41 57                	push   %r15
  10dadf:	41 56                	push   %r14
  10dae1:	4d 89 c6             	mov    %r8,%r14
  10dae4:	41 55                	push   %r13
  10dae6:	49 89 fd             	mov    %rdi,%r13
  10dae9:	41 54                	push   %r12
  10daeb:	49 89 f4             	mov    %rsi,%r12
  10daee:	53                   	push   %rbx
  10daef:	48 89 cb             	mov    %rcx,%rbx
  10daf2:	48 83 ec 28          	sub    $0x28,%rsp
  10daf6:	44 8b 7d 18          	mov    0x18(%rbp),%r15d
  10dafa:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  10dafe:	4c 89 4d c0          	mov    %r9,-0x40(%rbp)
	Z_ASSERT_VALID_PRIO(prio, entry);
  10db02:	41 83 ff 0f          	cmp    $0xf,%r15d
  10db06:	75 09                	jne    10db11 <z_setup_new_thread+0x38>
  10db08:	48 81 f9 3b e6 10 00 	cmp    $0x10e63b,%rcx
  10db0f:	74 4c                	je     10db5d <z_setup_new_thread+0x84>
  10db11:	41 8d 47 10          	lea    0x10(%r15),%eax
  10db15:	83 f8 1e             	cmp    $0x1e,%eax
  10db18:	76 43                	jbe    10db5d <z_setup_new_thread+0x84>
  10db1a:	b9 05 02 00 00       	mov    $0x205,%ecx
  10db1f:	ba 0b f7 11 00       	mov    $0x11f70b,%edx
  10db24:	be d1 f7 11 00       	mov    $0x11f7d1,%esi
  10db29:	31 c0                	xor    %eax,%eax
  10db2b:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  10db30:	e8 c3 2a ff ff       	callq  1005f8 <printk>
  10db35:	44 89 fe             	mov    %r15d,%esi
  10db38:	bf 51 f8 11 00       	mov    $0x11f851,%edi
  10db3d:	31 c0                	xor    %eax,%eax
  10db3f:	b9 f0 ff ff ff       	mov    $0xfffffff0,%ecx
  10db44:	ba 0e 00 00 00       	mov    $0xe,%edx
  10db49:	e8 aa 2a ff ff       	callq  1005f8 <printk>
  10db4e:	be 05 02 00 00       	mov    $0x205,%esi
  10db53:	bf 0b f7 11 00       	mov    $0x11f70b,%edi
  10db58:	e8 3b 50 ff ff       	callq  102b98 <assert_post_action>
	__ASSERT((options & K_USER) == 0U || z_stack_is_user_capable(stack),
  10db5d:	f6 45 20 04          	testb  $0x4,0x20(%rbp)
  10db61:	74 46                	je     10dba9 <z_setup_new_thread+0xd0>
  10db63:	4c 89 e7             	mov    %r12,%rdi
  10db66:	e8 fd fc ff ff       	callq  10d868 <z_stack_is_user_capable>
  10db6b:	84 c0                	test   %al,%al
  10db6d:	75 3a                	jne    10dba9 <z_setup_new_thread+0xd0>
  10db6f:	b9 08 02 00 00       	mov    $0x208,%ecx
  10db74:	ba 0b f7 11 00       	mov    $0x11f70b,%edx
  10db79:	be 82 f8 11 00       	mov    $0x11f882,%esi
  10db7e:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  10db83:	e8 70 2a ff ff       	callq  1005f8 <printk>
  10db88:	4c 89 ee             	mov    %r13,%rsi
  10db8b:	bf c5 f8 11 00       	mov    $0x11f8c5,%edi
  10db90:	4c 89 e2             	mov    %r12,%rdx
  10db93:	31 c0                	xor    %eax,%eax
  10db95:	e8 5e 2a ff ff       	callq  1005f8 <printk>
  10db9a:	be 08 02 00 00       	mov    $0x208,%esi
  10db9f:	bf 0b f7 11 00       	mov    $0x11f70b,%edi
  10dba4:	e8 ef 4f ff ff       	callq  102b98 <assert_post_action>
	z_object_init(new_thread);
  10dba9:	4c 89 ef             	mov    %r13,%rdi
  10dbac:	e8 40 94 00 00       	callq  116ff1 <z_object_init>
	z_object_init(stack);
  10dbb1:	4c 89 e7             	mov    %r12,%rdi
  10dbb4:	e8 38 94 00 00       	callq  116ff1 <z_object_init>
	new_thread->stack_obj = stack;
  10dbb9:	4d 89 a5 38 01 00 00 	mov    %r12,0x138(%r13)
	new_thread->syscall_frame = NULL;
  10dbc0:	49 c7 85 40 01 00 00 	movq   $0x0,0x140(%r13)
  10dbc7:	00 00 00 00 
  10dbcb:	4c 89 ee             	mov    %r13,%rsi
  10dbce:	4c 89 ef             	mov    %r13,%rdi
  10dbd1:	e8 71 93 00 00       	callq  116f47 <z_impl_k_object_access_grant>
	SYS_DLIST_FOR_EACH_CONTAINER(&((wq)->waitq), thread_ptr, \
				     base.qnode_dlist)

static inline void z_waitq_init(_wait_q_t *w)
{
	sys_dlist_init(&w->waitq);
  10dbd6:	49 8d 85 98 00 00 00 	lea    0x98(%r13),%rax
	thread_base->prio = priority;
  10dbdd:	45 88 7d 1a          	mov    %r15b,0x1a(%r13)
	if (z_stack_is_user_capable(stack)) {
  10dbe1:	4c 89 e7             	mov    %r12,%rdi
	list->head = (sys_dnode_t *)list;
  10dbe4:	49 89 85 98 00 00 00 	mov    %rax,0x98(%r13)
	list->tail = (sys_dnode_t *)list;
  10dbeb:	49 89 85 a0 00 00 00 	mov    %rax,0xa0(%r13)
	thread_base->user_options = (uint8_t)options;
  10dbf2:	8a 45 20             	mov    0x20(%rbp),%al
	thread_base->pended_on = NULL;
  10dbf5:	49 c7 45 10 00 00 00 	movq   $0x0,0x10(%r13)
  10dbfc:	00 
	thread_base->user_options = (uint8_t)options;
  10dbfd:	41 88 45 18          	mov    %al,0x18(%r13)
	thread_base->thread_state = (uint8_t)initial_state;
  10dc01:	41 c6 45 19 04       	movb   $0x4,0x19(%r13)
	thread_base->sched_locked = 0U;
  10dc06:	41 c6 45 1b 00       	movb   $0x0,0x1b(%r13)
	node->next = NULL;
  10dc0b:	49 c7 45 28 00 00 00 	movq   $0x0,0x28(%r13)
  10dc12:	00 
	node->prev = NULL;
  10dc13:	49 c7 45 30 00 00 00 	movq   $0x0,0x30(%r13)
  10dc1a:	00 
	if (z_stack_is_user_capable(stack)) {
  10dc1b:	e8 48 fc ff ff       	callq  10d868 <z_stack_is_user_capable>
		stack_obj_size = Z_THREAD_STACK_SIZE_ADJUST(stack_size);
  10dc20:	4c 8b 7d c8          	mov    -0x38(%rbp),%r15
	if (z_stack_is_user_capable(stack)) {
  10dc24:	84 c0                	test   %al,%al
  10dc26:	74 1f                	je     10dc47 <z_setup_new_thread+0x16e>
		stack_obj_size = Z_THREAD_STACK_SIZE_ADJUST(stack_size);
  10dc28:	49 81 c7 ff 0f 00 00 	add    $0xfff,%r15
 * @param sym Declared stack symbol name
 * @return The buffer itself, a char *
 */
static inline char *Z_THREAD_STACK_BUFFER(k_thread_stack_t *sym)
{
	return (char *)sym + K_THREAD_STACK_RESERVED;
  10dc2f:	49 8d bc 24 00 20 00 	lea    0x2000(%r12),%rdi
  10dc36:	00 
  10dc37:	49 81 e7 00 f0 ff ff 	and    $0xfffffffffffff000,%r15
  10dc3e:	49 8d 8f 00 20 00 00 	lea    0x2000(%r15),%rcx
		stack_buf_size = stack_obj_size - K_THREAD_STACK_RESERVED;
  10dc45:	eb 17                	jmp    10dc5e <z_setup_new_thread+0x185>
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
  10dc47:	49 83 c7 0f          	add    $0xf,%r15
	return (char *)sym + K_KERNEL_STACK_RESERVED;
  10dc4b:	49 8d bc 24 00 10 00 	lea    0x1000(%r12),%rdi
  10dc52:	00 
  10dc53:	49 83 e7 f0          	and    $0xfffffffffffffff0,%r15
  10dc57:	49 8d 8f 00 10 00 00 	lea    0x1000(%r15),%rcx
	stack_ptr = (char *)stack + stack_obj_size;
  10dc5e:	4c 01 e1             	add    %r12,%rcx
	memset(stack_buf_start, 0xaa, stack_buf_size);
  10dc61:	4c 89 fa             	mov    %r15,%rdx
  10dc64:	be aa 00 00 00       	mov    $0xaa,%esi
  10dc69:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
	stack_ptr = (char *)stack + stack_obj_size;
  10dc6d:	48 89 4d b8          	mov    %rcx,-0x48(%rbp)
	memset(stack_buf_start, 0xaa, stack_buf_size);
  10dc71:	e8 3c c4 ff ff       	callq  10a0b2 <memset>
		(struct _thread_userspace_local_data *)(stack_ptr - delta);
  10dc76:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
	new_thread->stack_info.start = (uintptr_t)stack_buf_start;
  10dc7a:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
  10dc7e:	4d 89 f0             	mov    %r14,%r8
	new_thread->stack_info.size = stack_buf_size;
  10dc81:	4d 89 bd 10 01 00 00 	mov    %r15,0x110(%r13)
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
  10dc88:	4c 8b 4d c0          	mov    -0x40(%rbp),%r9
  10dc8c:	4c 89 e6             	mov    %r12,%rsi
		(struct _thread_userspace_local_data *)(stack_ptr - delta);
  10dc8f:	48 8d 41 fc          	lea    -0x4(%rcx),%rax
	new_thread->stack_info.start = (uintptr_t)stack_buf_start;
  10dc93:	49 89 bd 08 01 00 00 	mov    %rdi,0x108(%r13)
	stack_ptr -= delta;
  10dc9a:	4c 8d 79 f0          	lea    -0x10(%rcx),%r15
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
  10dc9e:	4c 89 ef             	mov    %r13,%rdi
		(struct _thread_userspace_local_data *)(stack_ptr - delta);
  10dca1:	49 89 85 00 01 00 00 	mov    %rax,0x100(%r13)
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
  10dca8:	48 89 d9             	mov    %rbx,%rcx
  10dcab:	4c 89 fa             	mov    %r15,%rdx
  10dcae:	50                   	push   %rax
	new_thread->stack_info.delta = delta;
  10dcaf:	49 c7 85 18 01 00 00 	movq   $0x10,0x118(%r13)
  10dcb6:	10 00 00 00 
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
  10dcba:	ff 75 10             	pushq  0x10(%rbp)
  10dcbd:	e8 48 be ff ff       	callq  109b0a <arch_new_thread>
	__ASSERT(new_thread->switch_handle != NULL,
  10dcc2:	49 83 bd 50 01 00 00 	cmpq   $0x0,0x150(%r13)
  10dcc9:	00 
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
  10dcca:	5a                   	pop    %rdx
	new_thread->init_data = NULL;
  10dccb:	49 c7 85 90 00 00 00 	movq   $0x0,0x90(%r13)
  10dcd2:	00 00 00 00 
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
  10dcd6:	59                   	pop    %rcx
	__ASSERT(new_thread->switch_handle != NULL,
  10dcd7:	75 36                	jne    10dd0f <z_setup_new_thread+0x236>
  10dcd9:	be f0 f8 11 00       	mov    $0x11f8f0,%esi
  10dcde:	b9 2b 02 00 00       	mov    $0x22b,%ecx
  10dce3:	ba 0b f7 11 00       	mov    $0x11f70b,%edx
  10dce8:	31 c0                	xor    %eax,%eax
  10dcea:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  10dcef:	e8 04 29 ff ff       	callq  1005f8 <printk>
  10dcf4:	bf 19 f9 11 00       	mov    $0x11f919,%edi
  10dcf9:	31 c0                	xor    %eax,%eax
  10dcfb:	e8 f8 28 ff ff       	callq  1005f8 <printk>
  10dd00:	be 2b 02 00 00       	mov    $0x22b,%esi
  10dd05:	bf 0b f7 11 00       	mov    $0x11f70b,%edi
  10dd0a:	e8 89 4e ff ff       	callq  102b98 <assert_post_action>
	new_thread->entry.parameter2 = p2;
  10dd0f:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
	new_thread->entry.pEntry = entry;
  10dd13:	49 89 9d b0 00 00 00 	mov    %rbx,0xb0(%r13)
	new_thread->custom_data = NULL;
  10dd1a:	49 c7 85 f8 00 00 00 	movq   $0x0,0xf8(%r13)
  10dd21:	00 00 00 00 
	new_thread->entry.parameter2 = p2;
  10dd25:	49 89 85 c0 00 00 00 	mov    %rax,0xc0(%r13)
	new_thread->entry.parameter3 = p3;
  10dd2c:	48 8b 45 10          	mov    0x10(%rbp),%rax
	new_thread->entry.parameter1 = p1;
  10dd30:	4d 89 b5 b8 00 00 00 	mov    %r14,0xb8(%r13)
	new_thread->entry.parameter3 = p3;
  10dd37:	49 89 85 c8 00 00 00 	mov    %rax,0xc8(%r13)
  10dd3e:	9c                   	pushfq 
  10dd3f:	fa                   	cli    
  10dd40:	5b                   	pop    %rbx
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  10dd41:	bf a8 cd 1b 00       	mov    $0x1bcda8,%edi
  10dd46:	e8 2e fb ff ff       	callq  10d879 <z_spin_lock_valid>
  10dd4b:	84 c0                	test   %al,%al
  10dd4d:	75 39                	jne    10dd88 <z_setup_new_thread+0x2af>
  10dd4f:	b9 8e 00 00 00       	mov    $0x8e,%ecx
  10dd54:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  10dd59:	be fd d1 11 00       	mov    $0x11d1fd,%esi
  10dd5e:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  10dd63:	e8 90 28 ff ff       	callq  1005f8 <printk>
  10dd68:	be a8 cd 1b 00       	mov    $0x1bcda8,%esi
  10dd6d:	bf 12 d2 11 00       	mov    $0x11d212,%edi
  10dd72:	31 c0                	xor    %eax,%eax
  10dd74:	e8 7f 28 ff ff       	callq  1005f8 <printk>
  10dd79:	be 8e 00 00 00       	mov    $0x8e,%esi
  10dd7e:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  10dd83:	e8 10 4e ff ff       	callq  102b98 <assert_post_action>
	z_spin_lock_set_owner(l);
  10dd88:	bf a8 cd 1b 00       	mov    $0x1bcda8,%edi
  10dd8d:	e8 2b fb ff ff       	callq  10d8bd <z_spin_lock_set_owner>
	new_thread->next_thread = _kernel.threads;
  10dd92:	48 8b 05 e7 a9 01 00 	mov    0x1a9e7(%rip),%rax        # 128780 <_kernel+0x40>
	_kernel.threads = new_thread;
  10dd99:	4c 89 2d e0 a9 01 00 	mov    %r13,0x1a9e0(%rip)        # 128780 <_kernel+0x40>
	new_thread->next_thread = _kernel.threads;
  10dda0:	49 89 85 d0 00 00 00 	mov    %rax,0xd0(%r13)
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  10dda7:	e8 ed fa ff ff       	callq  10d899 <z_spin_unlock_valid>
  10ddac:	84 c0                	test   %al,%al
  10ddae:	75 39                	jne    10dde9 <z_setup_new_thread+0x310>
  10ddb0:	b9 b9 00 00 00       	mov    $0xb9,%ecx
  10ddb5:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  10ddba:	be 41 d2 11 00       	mov    $0x11d241,%esi
  10ddbf:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  10ddc4:	e8 2f 28 ff ff       	callq  1005f8 <printk>
  10ddc9:	be a8 cd 1b 00       	mov    $0x1bcda8,%esi
  10ddce:	bf 58 d2 11 00       	mov    $0x11d258,%edi
  10ddd3:	31 c0                	xor    %eax,%eax
  10ddd5:	e8 1e 28 ff ff       	callq  1005f8 <printk>
  10ddda:	be b9 00 00 00       	mov    $0xb9,%esi
  10dddf:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  10dde4:	e8 af 4d ff ff       	callq  102b98 <assert_post_action>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  10dde9:	0f ba e3 09          	bt     $0x9,%ebx
  10dded:	73 01                	jae    10ddf0 <z_setup_new_thread+0x317>
		__asm__ volatile ("sti" ::: "memory");
  10ddef:	fb                   	sti    
	if (name != NULL) {
  10ddf0:	48 83 7d 28 00       	cmpq   $0x0,0x28(%rbp)
  10ddf5:	74 1f                	je     10de16 <z_setup_new_thread+0x33d>
		strncpy(new_thread->name, name,
  10ddf7:	48 8b 75 28          	mov    0x28(%rbp),%rsi
  10ddfb:	49 8d bd d8 00 00 00 	lea    0xd8(%r13),%rdi
  10de02:	ba 1f 00 00 00       	mov    $0x1f,%edx
  10de07:	e8 78 c1 ff ff       	callq  109f84 <strncpy>
		new_thread->name[CONFIG_THREAD_MAX_NAME_LEN - 1] = '\0';
  10de0c:	41 c6 85 f7 00 00 00 	movb   $0x0,0xf7(%r13)
  10de13:	00 
  10de14:	eb 08                	jmp    10de1e <z_setup_new_thread+0x345>
		new_thread->name[0] = '\0';
  10de16:	41 c6 85 d8 00 00 00 	movb   $0x0,0xd8(%r13)
  10de1d:	00 
	z_mem_domain_init_thread(new_thread);
  10de1e:	4c 89 ef             	mov    %r13,%rdi
  10de21:	e8 cd 85 00 00       	callq  1163f3 <z_mem_domain_init_thread>
	if ((options & K_INHERIT_PERMS) != 0U) {
  10de26:	f6 45 20 08          	testb  $0x8,0x20(%rbp)
  10de2a:	74 0f                	je     10de3b <z_setup_new_thread+0x362>
		z_thread_perms_inherit(_current, new_thread);
  10de2c:	48 8b 3d 1d a9 01 00 	mov    0x1a91d(%rip),%rdi        # 128750 <_kernel+0x10>
  10de33:	4c 89 ee             	mov    %r13,%rsi
  10de36:	e8 0b 8e 00 00       	callq  116c46 <z_thread_perms_inherit>
	new_thread->resource_pool = _current->resource_pool;
  10de3b:	48 8b 05 0e a9 01 00 	mov    0x1a90e(%rip),%rax        # 128750 <_kernel+0x10>
	memset(&new_thread->rt_stats, 0, sizeof(new_thread->rt_stats));
  10de42:	49 8d bd 60 01 00 00 	lea    0x160(%r13),%rdi
  10de49:	ba 10 00 00 00       	mov    $0x10,%edx
  10de4e:	31 f6                	xor    %esi,%esi
	new_thread->resource_pool = _current->resource_pool;
  10de50:	48 8b 80 58 01 00 00 	mov    0x158(%rax),%rax
  10de57:	49 89 85 58 01 00 00 	mov    %rax,0x158(%r13)
	memset(&new_thread->rt_stats, 0, sizeof(new_thread->rt_stats));
  10de5e:	e8 4f c2 ff ff       	callq  10a0b2 <memset>
}
  10de63:	48 8d 65 d8          	lea    -0x28(%rbp),%rsp
  10de67:	4c 89 f8             	mov    %r15,%rax
  10de6a:	5b                   	pop    %rbx
  10de6b:	41 5c                	pop    %r12
  10de6d:	41 5d                	pop    %r13
  10de6f:	41 5e                	pop    %r14
  10de71:	41 5f                	pop    %r15
  10de73:	5d                   	pop    %rbp
  10de74:	c3                   	retq   

000000000010de75 <z_impl_k_thread_create>:
{
  10de75:	55                   	push   %rbp
  10de76:	48 89 e5             	mov    %rsp,%rbp
  10de79:	41 57                	push   %r15
  10de7b:	49 89 cf             	mov    %rcx,%r15
  10de7e:	41 56                	push   %r14
  10de80:	49 89 d6             	mov    %rdx,%r14
  10de83:	41 55                	push   %r13
  10de85:	49 89 f5             	mov    %rsi,%r13
  10de88:	41 54                	push   %r12
  10de8a:	49 89 fc             	mov    %rdi,%r12
  10de8d:	48 83 ec 10          	sub    $0x10,%rsp
	__ASSERT(!arch_is_in_isr(), "Threads may not be created in ISRs");
  10de91:	83 3d a8 a8 01 00 00 	cmpl   $0x0,0x1a8a8(%rip)        # 128740 <_kernel>
  10de98:	74 46                	je     10dee0 <z_impl_k_thread_create+0x6b>
  10de9a:	b9 6e 02 00 00       	mov    $0x26e,%ecx
  10de9f:	ba 0b f7 11 00       	mov    $0x11f70b,%edx
  10dea4:	31 c0                	xor    %eax,%eax
  10dea6:	4c 89 4d d0          	mov    %r9,-0x30(%rbp)
  10deaa:	be 49 f9 11 00       	mov    $0x11f949,%esi
  10deaf:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  10deb4:	4c 89 45 d8          	mov    %r8,-0x28(%rbp)
  10deb8:	e8 3b 27 ff ff       	callq  1005f8 <printk>
  10debd:	bf 5b f9 11 00       	mov    $0x11f95b,%edi
  10dec2:	31 c0                	xor    %eax,%eax
  10dec4:	e8 2f 27 ff ff       	callq  1005f8 <printk>
  10dec9:	be 6e 02 00 00       	mov    $0x26e,%esi
  10dece:	bf 0b f7 11 00       	mov    $0x11f70b,%edi
  10ded3:	e8 c0 4c ff ff       	callq  102b98 <assert_post_action>
  10ded8:	4c 8b 4d d0          	mov    -0x30(%rbp),%r9
  10dedc:	4c 8b 45 d8          	mov    -0x28(%rbp),%r8
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
  10dee0:	8b 45 20             	mov    0x20(%rbp),%eax
  10dee3:	6a 00                	pushq  $0x0
  10dee5:	4c 89 f9             	mov    %r15,%rcx
  10dee8:	4c 89 f2             	mov    %r14,%rdx
  10deeb:	4c 89 ee             	mov    %r13,%rsi
  10deee:	4c 89 e7             	mov    %r12,%rdi
  10def1:	50                   	push   %rax
  10def2:	8b 45 18             	mov    0x18(%rbp),%eax
  10def5:	50                   	push   %rax
  10def6:	ff 75 10             	pushq  0x10(%rbp)
  10def9:	e8 db fb ff ff       	callq  10dad9 <z_setup_new_thread>
  10defe:	48 83 c4 20          	add    $0x20,%rsp
	if (!K_TIMEOUT_EQ(delay, K_FOREVER)) {
  10df02:	48 83 7d 28 ff       	cmpq   $0xffffffffffffffff,0x28(%rbp)
  10df07:	74 0c                	je     10df15 <z_impl_k_thread_create+0xa0>
		schedule_new_thread(new_thread, delay);
  10df09:	48 8b 75 28          	mov    0x28(%rbp),%rsi
  10df0d:	4c 89 e7             	mov    %r12,%rdi
  10df10:	e8 71 f6 ff ff       	callq  10d586 <schedule_new_thread>
}
  10df15:	48 8d 65 e0          	lea    -0x20(%rbp),%rsp
  10df19:	4c 89 e0             	mov    %r12,%rax
  10df1c:	41 5c                	pop    %r12
  10df1e:	41 5d                	pop    %r13
  10df20:	41 5e                	pop    %r14
  10df22:	41 5f                	pop    %r15
  10df24:	5d                   	pop    %rbp
  10df25:	c3                   	retq   

000000000010df26 <z_vrfy_k_thread_create>:
{
  10df26:	55                   	push   %rbp
  10df27:	48 89 e5             	mov    %rsp,%rbp
  10df2a:	41 57                	push   %r15
  10df2c:	49 89 cf             	mov    %rcx,%r15
  10df2f:	41 56                	push   %r14
  10df31:	49 89 f6             	mov    %rsi,%r14
  10df34:	41 55                	push   %r13
  10df36:	49 89 d5             	mov    %rdx,%r13
  10df39:	41 54                	push   %r12
  10df3b:	49 89 fc             	mov    %rdi,%r12
  10df3e:	53                   	push   %rbx
  10df3f:	48 83 ec 18          	sub    $0x18,%rsp
  10df43:	4c 89 4d c0          	mov    %r9,-0x40(%rbp)
  10df47:	4c 89 45 c8          	mov    %r8,-0x38(%rbp)
	Z_OOPS(Z_SYSCALL_OBJ_NEVER_INIT(new_thread, K_OBJ_THREAD));
  10df4b:	e8 84 8b 00 00       	callq  116ad4 <z_object_find>
  10df50:	83 c9 ff             	or     $0xffffffff,%ecx
  10df53:	ba 09 00 00 00       	mov    $0x9,%edx
  10df58:	4c 89 e6             	mov    %r12,%rsi
  10df5b:	48 89 c7             	mov    %rax,%rdi
  10df5e:	e8 dc f5 ff ff       	callq  10d53f <z_obj_validation_check>
  10df63:	4c 8b 4d c0          	mov    -0x40(%rbp),%r9
  10df67:	85 c0                	test   %eax,%eax
  10df69:	74 11                	je     10df7c <z_vrfy_k_thread_create+0x56>
  10df6b:	ba 30 c1 11 00       	mov    $0x11c130,%edx
  10df70:	be 45 00 00 00       	mov    $0x45,%esi
  10df75:	bf 23 f3 11 00       	mov    $0x11f323,%edi
  10df7a:	eb 39                	jmp    10dfb5 <z_vrfy_k_thread_create+0x8f>
	stack_object = z_object_find(stack);
  10df7c:	4c 89 f7             	mov    %r14,%rdi
  10df7f:	4c 89 4d c0          	mov    %r9,-0x40(%rbp)
  10df83:	e8 4c 8b 00 00       	callq  116ad4 <z_object_find>
	Z_OOPS(Z_SYSCALL_VERIFY_MSG(z_obj_validation_check(stack_object, stack,
  10df88:	83 c9 ff             	or     $0xffffffff,%ecx
  10df8b:	ba 0b 00 00 00       	mov    $0xb,%edx
  10df90:	4c 89 f6             	mov    %r14,%rsi
  10df93:	48 89 c7             	mov    %rax,%rdi
	stack_object = z_object_find(stack);
  10df96:	48 89 c3             	mov    %rax,%rbx
	Z_OOPS(Z_SYSCALL_VERIFY_MSG(z_obj_validation_check(stack_object, stack,
  10df99:	e8 a1 f5 ff ff       	callq  10d53f <z_obj_validation_check>
  10df9e:	4c 8b 4d c0          	mov    -0x40(%rbp),%r9
  10dfa2:	85 c0                	test   %eax,%eax
  10dfa4:	74 29                	je     10dfcf <z_vrfy_k_thread_create+0xa9>
  10dfa6:	ba 30 c1 11 00       	mov    $0x11c130,%edx
  10dfab:	be 45 00 00 00       	mov    $0x45,%esi
  10dfb0:	bf 80 f9 11 00       	mov    $0x11f980,%edi
  10dfb5:	31 c0                	xor    %eax,%eax
  10dfb7:	e8 0a 51 ff ff       	callq  1030c6 <z_log_minimal_printk>
  10dfbc:	48 8b 05 8d a7 01 00 	mov    0x1a78d(%rip),%rax        # 128750 <_kernel+0x10>
  10dfc3:	48 8b b8 40 01 00 00 	mov    0x140(%rax),%rdi
  10dfca:	e8 3e bc ff ff       	callq  109c0d <arch_syscall_oops>
	return __builtin_add_overflow(a, b, result);
  10dfcf:	4c 89 e9             	mov    %r13,%rcx
  10dfd2:	48 81 c1 00 20 00 00 	add    $0x2000,%rcx
  10dfd9:	0f 82 c9 00 00 00    	jb     10e0a8 <z_vrfy_k_thread_create+0x182>
	stack_obj_size = stack_object->data.stack_size;
  10dfdf:	4c 8b 43 0e          	mov    0xe(%rbx),%r8
	Z_OOPS(Z_SYSCALL_VERIFY_MSG(total_size <= stack_obj_size,
  10dfe3:	4c 39 c1             	cmp    %r8,%rcx
  10dfe6:	76 14                	jbe    10dffc <z_vrfy_k_thread_create+0xd6>
  10dfe8:	ba 30 c1 11 00       	mov    $0x11c130,%edx
  10dfed:	be 45 00 00 00       	mov    $0x45,%esi
  10dff2:	bf eb f9 11 00       	mov    $0x11f9eb,%edi
  10dff7:	e9 c4 00 00 00       	jmpq   10e0c0 <z_vrfy_k_thread_create+0x19a>
	Z_OOPS(Z_SYSCALL_VERIFY(options & K_USER));
  10dffc:	f6 45 20 04          	testb  $0x4,0x20(%rbp)
  10e000:	75 11                	jne    10e013 <z_vrfy_k_thread_create+0xed>
  10e002:	ba 30 c1 11 00       	mov    $0x11c130,%edx
  10e007:	be 45 00 00 00       	mov    $0x45,%esi
  10e00c:	bf 2f fa 11 00       	mov    $0x11fa2f,%edi
  10e011:	eb a2                	jmp    10dfb5 <z_vrfy_k_thread_create+0x8f>
	Z_OOPS(Z_SYSCALL_VERIFY(!(options & K_ESSENTIAL)));
  10e013:	f6 45 20 01          	testb  $0x1,0x20(%rbp)
  10e017:	74 11                	je     10e02a <z_vrfy_k_thread_create+0x104>
  10e019:	ba 30 c1 11 00       	mov    $0x11c130,%edx
  10e01e:	be 45 00 00 00       	mov    $0x45,%esi
  10e023:	bf 5e fa 11 00       	mov    $0x11fa5e,%edi
  10e028:	eb 8b                	jmp    10dfb5 <z_vrfy_k_thread_create+0x8f>
	if (!z_is_prio_higher_or_equal(prio,
				       K_LOWEST_APPLICATION_THREAD_PRIO)) {
		return false;
	}

	if (!z_is_prio_lower_or_equal(prio,
  10e02a:	8b 45 18             	mov    0x18(%rbp),%eax
  10e02d:	83 c0 10             	add    $0x10,%eax
	Z_OOPS(Z_SYSCALL_VERIFY(_is_valid_prio(prio, NULL)));
  10e030:	83 f8 1e             	cmp    $0x1e,%eax
  10e033:	76 14                	jbe    10e049 <z_vrfy_k_thread_create+0x123>
  10e035:	ba 30 c1 11 00       	mov    $0x11c130,%edx
  10e03a:	be 45 00 00 00       	mov    $0x45,%esi
  10e03f:	bf 95 fa 11 00       	mov    $0x11fa95,%edi
  10e044:	e9 6c ff ff ff       	jmpq   10dfb5 <z_vrfy_k_thread_create+0x8f>
	Z_OOPS(Z_SYSCALL_VERIFY(z_is_prio_lower_or_equal(prio,
  10e049:	48 8b 05 00 a7 01 00 	mov    0x1a700(%rip),%rax        # 128750 <_kernel+0x10>
  10e050:	0f be 40 1a          	movsbl 0x1a(%rax),%eax
  10e054:	3b 45 18             	cmp    0x18(%rbp),%eax
  10e057:	7e 14                	jle    10e06d <z_vrfy_k_thread_create+0x147>
  10e059:	ba 30 c1 11 00       	mov    $0x11c130,%edx
  10e05e:	be 45 00 00 00       	mov    $0x45,%esi
  10e063:	bf ce fa 11 00       	mov    $0x11face,%edi
  10e068:	e9 48 ff ff ff       	jmpq   10dfb5 <z_vrfy_k_thread_create+0x8f>
	z_setup_new_thread(new_thread, stack, stack_size,
  10e06d:	8b 45 20             	mov    0x20(%rbp),%eax
  10e070:	6a 00                	pushq  $0x0
  10e072:	4c 89 f9             	mov    %r15,%rcx
  10e075:	4c 89 ea             	mov    %r13,%rdx
  10e078:	4c 8b 45 c8          	mov    -0x38(%rbp),%r8
  10e07c:	4c 89 f6             	mov    %r14,%rsi
  10e07f:	4c 89 e7             	mov    %r12,%rdi
  10e082:	50                   	push   %rax
  10e083:	8b 45 18             	mov    0x18(%rbp),%eax
  10e086:	50                   	push   %rax
  10e087:	ff 75 10             	pushq  0x10(%rbp)
  10e08a:	e8 4a fa ff ff       	callq  10dad9 <z_setup_new_thread>
  10e08f:	48 83 c4 20          	add    $0x20,%rsp
	if (!K_TIMEOUT_EQ(delay, K_FOREVER)) {
  10e093:	48 83 7d 28 ff       	cmpq   $0xffffffffffffffff,0x28(%rbp)
  10e098:	74 32                	je     10e0cc <z_vrfy_k_thread_create+0x1a6>
		schedule_new_thread(new_thread, delay);
  10e09a:	48 8b 75 28          	mov    0x28(%rbp),%rsi
  10e09e:	4c 89 e7             	mov    %r12,%rdi
  10e0a1:	e8 e0 f4 ff ff       	callq  10d586 <schedule_new_thread>
	return new_thread;
  10e0a6:	eb 24                	jmp    10e0cc <z_vrfy_k_thread_create+0x1a6>
	Z_OOPS(Z_SYSCALL_VERIFY_MSG(!size_add_overflow(K_THREAD_STACK_RESERVED,
  10e0a8:	41 b8 00 20 00 00    	mov    $0x2000,%r8d
  10e0ae:	4c 89 e9             	mov    %r13,%rcx
  10e0b1:	ba 30 c1 11 00       	mov    $0x11c130,%edx
  10e0b6:	be 45 00 00 00       	mov    $0x45,%esi
  10e0bb:	bf af f9 11 00       	mov    $0x11f9af,%edi
  10e0c0:	31 c0                	xor    %eax,%eax
  10e0c2:	e8 ff 4f ff ff       	callq  1030c6 <z_log_minimal_printk>
  10e0c7:	e9 f0 fe ff ff       	jmpq   10dfbc <z_vrfy_k_thread_create+0x96>
}
  10e0cc:	48 8d 65 d8          	lea    -0x28(%rbp),%rsp
  10e0d0:	4c 89 e0             	mov    %r12,%rax
  10e0d3:	5b                   	pop    %rbx
  10e0d4:	41 5c                	pop    %r12
  10e0d6:	41 5d                	pop    %r13
  10e0d8:	41 5e                	pop    %r14
  10e0da:	41 5f                	pop    %r15
  10e0dc:	5d                   	pop    %rbp
  10e0dd:	c3                   	retq   

000000000010e0de <z_mrsh_k_thread_create>:
#include <syscalls/kernel.h>

extern k_tid_t z_vrfy_k_thread_create(struct k_thread * new_thread, k_thread_stack_t * stack, size_t stack_size, k_thread_entry_t entry, void * p1, void * p2, void * p3, int prio, uint32_t options, k_timeout_t delay);
uintptr_t z_mrsh_k_thread_create(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, void *more, void *ssf)
{
  10e0de:	55                   	push   %rbp
  10e0df:	48 89 e5             	mov    %rsp,%rbp
  10e0e2:	41 57                	push   %r15
  10e0e4:	49 89 d7             	mov    %rdx,%r15
  10e0e7:	41 56                	push   %r14
  10e0e9:	49 89 f6             	mov    %rsi,%r14
	_current->syscall_frame = ssf;
	Z_OOPS(Z_SYSCALL_MEMORY_READ(more, 4 * sizeof(uintptr_t)));
  10e0ec:	be 20 00 00 00       	mov    $0x20,%esi
{
  10e0f1:	41 55                	push   %r13
  10e0f3:	49 89 fd             	mov    %rdi,%r13
	Z_OOPS(Z_SYSCALL_MEMORY_READ(more, 4 * sizeof(uintptr_t)));
  10e0f6:	4c 89 cf             	mov    %r9,%rdi
{
  10e0f9:	41 54                	push   %r12
  10e0fb:	4d 89 cc             	mov    %r9,%r12
  10e0fe:	48 83 ec 10          	sub    $0x10,%rsp
	_current->syscall_frame = ssf;
  10e102:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  10e106:	48 8b 05 43 a6 01 00 	mov    0x1a643(%rip),%rax        # 128750 <_kernel+0x10>
{
  10e10d:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
  10e111:	4c 89 45 d8          	mov    %r8,-0x28(%rbp)
	_current->syscall_frame = ssf;
  10e115:	48 89 90 40 01 00 00 	mov    %rdx,0x140(%rax)
	Z_OOPS(Z_SYSCALL_MEMORY_READ(more, 4 * sizeof(uintptr_t)));
  10e11c:	31 d2                	xor    %edx,%edx
  10e11e:	e8 99 b2 ff ff       	callq  1093bc <arch_buffer_validate>
  10e123:	4c 8b 45 d8          	mov    -0x28(%rbp),%r8
  10e127:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
  10e12b:	85 c0                	test   %eax,%eax
  10e12d:	74 38                	je     10e167 <z_mrsh_k_thread_create+0x89>
  10e12f:	bf 1e cf 11 00       	mov    $0x11cf1e,%edi
  10e134:	31 c0                	xor    %eax,%eax
  10e136:	41 b9 de 0d 12 00    	mov    $0x120dde,%r9d
  10e13c:	4c 89 e1             	mov    %r12,%rcx
  10e13f:	41 b8 20 00 00 00    	mov    $0x20,%r8d
  10e145:	ba 10 c1 11 00       	mov    $0x11c110,%edx
  10e14a:	be 45 00 00 00       	mov    $0x45,%esi
  10e14f:	e8 72 4f ff ff       	callq  1030c6 <z_log_minimal_printk>
  10e154:	48 8b 05 f5 a5 01 00 	mov    0x1a5f5(%rip),%rax        # 128750 <_kernel+0x10>
  10e15b:	48 8b b8 40 01 00 00 	mov    0x140(%rax),%rdi
  10e162:	e8 a6 ba ff ff       	callq  109c0d <arch_syscall_oops>
	k_tid_t ret = z_vrfy_k_thread_create(*(struct k_thread **)&arg0, *(k_thread_stack_t **)&arg1, *(size_t*)&arg2, *(k_thread_entry_t*)&arg3, *(void **)&arg4, *(void **)&(((uintptr_t *)more)[0]), *(void **)&(((uintptr_t *)more)[1]), *(int*)&(((uintptr_t *)more)[2]), *(uint32_t*)&(((uintptr_t *)more)[3]), *(k_timeout_t*)&(((uintptr_t *)more)[4]))
  10e167:	41 8b 44 24 18       	mov    0x18(%r12),%eax
  10e16c:	41 ff 74 24 20       	pushq  0x20(%r12)
  10e171:	4c 89 fa             	mov    %r15,%rdx
  10e174:	4c 89 f6             	mov    %r14,%rsi
  10e177:	4d 8b 0c 24          	mov    (%r12),%r9
  10e17b:	4c 89 ef             	mov    %r13,%rdi
  10e17e:	50                   	push   %rax
  10e17f:	41 8b 44 24 10       	mov    0x10(%r12),%eax
  10e184:	50                   	push   %rax
  10e185:	41 ff 74 24 08       	pushq  0x8(%r12)
  10e18a:	e8 97 fd ff ff       	callq  10df26 <z_vrfy_k_thread_create>
;
	_current->syscall_frame = NULL;
  10e18f:	48 8b 15 ba a5 01 00 	mov    0x1a5ba(%rip),%rdx        # 128750 <_kernel+0x10>
	k_tid_t ret = z_vrfy_k_thread_create(*(struct k_thread **)&arg0, *(k_thread_stack_t **)&arg1, *(size_t*)&arg2, *(k_thread_entry_t*)&arg3, *(void **)&arg4, *(void **)&(((uintptr_t *)more)[0]), *(void **)&(((uintptr_t *)more)[1]), *(int*)&(((uintptr_t *)more)[2]), *(uint32_t*)&(((uintptr_t *)more)[3]), *(k_timeout_t*)&(((uintptr_t *)more)[4]))
  10e196:	48 83 c4 20          	add    $0x20,%rsp
	_current->syscall_frame = NULL;
  10e19a:	48 c7 82 40 01 00 00 	movq   $0x0,0x140(%rdx)
  10e1a1:	00 00 00 00 
	return (uintptr_t) ret;
}
  10e1a5:	48 8d 65 e0          	lea    -0x20(%rbp),%rsp
  10e1a9:	41 5c                	pop    %r12
  10e1ab:	41 5d                	pop    %r13
  10e1ad:	41 5e                	pop    %r14
  10e1af:	41 5f                	pop    %r15
  10e1b1:	5d                   	pop    %rbp
  10e1b2:	c3                   	retq   

000000000010e1b3 <z_init_static_threads>:
{
  10e1b3:	55                   	push   %rbp
  10e1b4:	48 89 e5             	mov    %rsp,%rbp
  10e1b7:	41 54                	push   %r12
  10e1b9:	53                   	push   %rbx
	_FOREACH_STATIC_THREAD(thread_data) {
  10e1ba:	bb 6c 14 5e 00       	mov    $0x5e146c,%ebx
  10e1bf:	48 81 fb 6c 14 5e 00 	cmp    $0x5e146c,%rbx
  10e1c6:	76 36                	jbe    10e1fe <z_init_static_threads+0x4b>
  10e1c8:	be 20 fb 11 00       	mov    $0x11fb20,%esi
  10e1cd:	b9 d5 02 00 00       	mov    $0x2d5,%ecx
  10e1d2:	ba 0b f7 11 00       	mov    $0x11f70b,%edx
  10e1d7:	31 c0                	xor    %eax,%eax
  10e1d9:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  10e1de:	e8 15 24 ff ff       	callq  1005f8 <printk>
  10e1e3:	bf b6 f6 11 00       	mov    $0x11f6b6,%edi
  10e1e8:	31 c0                	xor    %eax,%eax
  10e1ea:	e8 09 24 ff ff       	callq  1005f8 <printk>
  10e1ef:	be d5 02 00 00       	mov    $0x2d5,%esi
  10e1f4:	bf 0b f7 11 00       	mov    $0x11f70b,%edi
  10e1f9:	e8 9a 49 ff ff       	callq  102b98 <assert_post_action>
  10e1fe:	48 81 fb 6c 14 5e 00 	cmp    $0x5e146c,%rbx
  10e205:	73 40                	jae    10e247 <z_init_static_threads+0x94>
		z_setup_new_thread(
  10e207:	48 8b 4b 18          	mov    0x18(%rbx),%rcx
  10e20b:	8b 53 10             	mov    0x10(%rbx),%edx
  10e20e:	48 8b 73 08          	mov    0x8(%rbx),%rsi
  10e212:	ff 73 50             	pushq  0x50(%rbx)
  10e215:	8b 43 3c             	mov    0x3c(%rbx),%eax
  10e218:	50                   	push   %rax
  10e219:	8b 43 38             	mov    0x38(%rbx),%eax
  10e21c:	50                   	push   %rax
  10e21d:	ff 73 30             	pushq  0x30(%rbx)
  10e220:	4c 8b 4b 28          	mov    0x28(%rbx),%r9
  10e224:	4c 8b 43 20          	mov    0x20(%rbx),%r8
  10e228:	48 8b 3b             	mov    (%rbx),%rdi
  10e22b:	e8 a9 f8 ff ff       	callq  10dad9 <z_setup_new_thread>
		thread_data->init_thread->init_data = thread_data;
  10e230:	48 8b 03             	mov    (%rbx),%rax
		z_setup_new_thread(
  10e233:	48 83 c4 20          	add    $0x20,%rsp
		thread_data->init_thread->init_data = thread_data;
  10e237:	48 89 98 90 00 00 00 	mov    %rbx,0x90(%rax)
	_FOREACH_STATIC_THREAD(thread_data) {
  10e23e:	48 83 c3 58          	add    $0x58,%rbx
  10e242:	e9 78 ff ff ff       	jmpq   10e1bf <z_init_static_threads+0xc>
	STRUCT_SECTION_FOREACH(z_object_assignment, pos) {
  10e247:	bb 70 a2 11 00       	mov    $0x11a270,%ebx
  10e24c:	48 81 fb 70 a2 11 00 	cmp    $0x11a270,%rbx
  10e253:	76 36                	jbe    10e28b <z_init_static_threads+0xd8>
  10e255:	be 4d fb 11 00       	mov    $0x11fb4d,%esi
  10e25a:	b9 ca 02 00 00       	mov    $0x2ca,%ecx
  10e25f:	ba 0b f7 11 00       	mov    $0x11f70b,%edx
  10e264:	31 c0                	xor    %eax,%eax
  10e266:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  10e26b:	e8 88 23 ff ff       	callq  1005f8 <printk>
  10e270:	bf b6 f6 11 00       	mov    $0x11f6b6,%edi
  10e275:	31 c0                	xor    %eax,%eax
  10e277:	e8 7c 23 ff ff       	callq  1005f8 <printk>
  10e27c:	be ca 02 00 00       	mov    $0x2ca,%esi
  10e281:	bf 0b f7 11 00       	mov    $0x11f70b,%edi
  10e286:	e8 0d 49 ff ff       	callq  102b98 <assert_post_action>
  10e28b:	48 81 fb 70 a2 11 00 	cmp    $0x11a270,%rbx
  10e292:	73 26                	jae    10e2ba <z_init_static_threads+0x107>
		for (int i = 0; pos->objects[i] != NULL; i++) {
  10e294:	45 31 e4             	xor    %r12d,%r12d
  10e297:	48 8b 53 08          	mov    0x8(%rbx),%rdx
  10e29b:	49 63 c4             	movslq %r12d,%rax
  10e29e:	48 8b 3c c2          	mov    (%rdx,%rax,8),%rdi
  10e2a2:	48 85 ff             	test   %rdi,%rdi
  10e2a5:	74 0d                	je     10e2b4 <z_init_static_threads+0x101>
			k_object_access_grant(pos->objects[i],
  10e2a7:	48 8b 33             	mov    (%rbx),%rsi
  10e2aa:	e8 98 8c 00 00       	callq  116f47 <z_impl_k_object_access_grant>
		for (int i = 0; pos->objects[i] != NULL; i++) {
  10e2af:	41 ff c4             	inc    %r12d
  10e2b2:	eb e3                	jmp    10e297 <z_init_static_threads+0xe4>
	STRUCT_SECTION_FOREACH(z_object_assignment, pos) {
  10e2b4:	48 83 c3 10          	add    $0x10,%rbx
  10e2b8:	eb 92                	jmp    10e24c <z_init_static_threads+0x99>
	k_sched_lock();
  10e2ba:	e8 46 2b 00 00       	callq  110e05 <k_sched_lock>
	_FOREACH_STATIC_THREAD(thread_data) {
  10e2bf:	41 bc 6c 14 5e 00    	mov    $0x5e146c,%r12d
					    K_MSEC(thread_data->init_delay));
  10e2c5:	31 db                	xor    %ebx,%ebx
	_FOREACH_STATIC_THREAD(thread_data) {
  10e2c7:	49 81 fc 6c 14 5e 00 	cmp    $0x5e146c,%r12
  10e2ce:	76 36                	jbe    10e306 <z_init_static_threads+0x153>
  10e2d0:	be 20 fb 11 00       	mov    $0x11fb20,%esi
  10e2d5:	b9 f4 02 00 00       	mov    $0x2f4,%ecx
  10e2da:	ba 0b f7 11 00       	mov    $0x11f70b,%edx
  10e2df:	31 c0                	xor    %eax,%eax
  10e2e1:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  10e2e6:	e8 0d 23 ff ff       	callq  1005f8 <printk>
  10e2eb:	bf b6 f6 11 00       	mov    $0x11f6b6,%edi
  10e2f0:	31 c0                	xor    %eax,%eax
  10e2f2:	e8 01 23 ff ff       	callq  1005f8 <printk>
  10e2f7:	be f4 02 00 00       	mov    $0x2f4,%esi
  10e2fc:	bf 0b f7 11 00       	mov    $0x11f70b,%edi
  10e301:	e8 92 48 ff ff       	callq  102b98 <assert_post_action>
  10e306:	49 81 fc 6c 14 5e 00 	cmp    $0x5e146c,%r12
  10e30d:	73 23                	jae    10e332 <z_init_static_threads+0x17f>
		if (thread_data->init_delay != K_TICKS_FOREVER) {
  10e30f:	49 63 74 24 40       	movslq 0x40(%r12),%rsi
  10e314:	83 fe ff             	cmp    $0xffffffff,%esi
  10e317:	74 13                	je     10e32c <z_init_static_threads+0x179>
					    K_MSEC(thread_data->init_delay));
  10e319:	85 f6                	test   %esi,%esi
			schedule_new_thread(thread_data->init_thread,
  10e31b:	49 8b 3c 24          	mov    (%r12),%rdi
					    K_MSEC(thread_data->init_delay));
  10e31f:	48 0f 48 f3          	cmovs  %rbx,%rsi
  10e323:	48 6b f6 0a          	imul   $0xa,%rsi,%rsi
			schedule_new_thread(thread_data->init_thread,
  10e327:	e8 5a f2 ff ff       	callq  10d586 <schedule_new_thread>
	_FOREACH_STATIC_THREAD(thread_data) {
  10e32c:	49 83 c4 58          	add    $0x58,%r12
  10e330:	eb 95                	jmp    10e2c7 <z_init_static_threads+0x114>
}
  10e332:	48 8d 65 f0          	lea    -0x10(%rbp),%rsp
  10e336:	5b                   	pop    %rbx
  10e337:	41 5c                	pop    %r12
  10e339:	5d                   	pop    %rbp
	k_sched_unlock();
  10e33a:	e9 0f 3a 00 00       	jmpq   111d4e <k_sched_unlock>

000000000010e33f <z_mrsh_k_float_disable>:
#include <syscalls/kernel.h>

extern int z_vrfy_k_float_disable(struct k_thread * thread);
uintptr_t z_mrsh_k_float_disable(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
  10e33f:	55                   	push   %rbp
  10e340:	48 89 e5             	mov    %rsp,%rbp
  10e343:	41 54                	push   %r12
  10e345:	49 89 fc             	mov    %rdi,%r12
  10e348:	51                   	push   %rcx
	_current->syscall_frame = ssf;
  10e349:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  10e34d:	48 8b 05 fc a3 01 00 	mov    0x1a3fc(%rip),%rax        # 128750 <_kernel+0x10>
  10e354:	48 89 90 40 01 00 00 	mov    %rdx,0x140(%rax)
}

#ifdef CONFIG_USERSPACE
static inline int z_vrfy_k_float_disable(struct k_thread *thread)
{
	Z_OOPS(Z_SYSCALL_OBJ(thread, K_OBJ_THREAD));
  10e35b:	e8 74 87 00 00       	callq  116ad4 <z_object_find>
  10e360:	31 c9                	xor    %ecx,%ecx
  10e362:	ba 09 00 00 00       	mov    $0x9,%edx
  10e367:	4c 89 e6             	mov    %r12,%rsi
  10e36a:	48 89 c7             	mov    %rax,%rdi
  10e36d:	e8 cd f1 ff ff       	callq  10d53f <z_obj_validation_check>
  10e372:	85 c0                	test   %eax,%eax
  10e374:	74 29                	je     10e39f <z_mrsh_k_float_disable+0x60>
  10e376:	bf 23 f3 11 00       	mov    $0x11f323,%edi
  10e37b:	31 c0                	xor    %eax,%eax
  10e37d:	ba f0 c0 11 00       	mov    $0x11c0f0,%edx
  10e382:	be 45 00 00 00       	mov    $0x45,%esi
  10e387:	e8 3a 4d ff ff       	callq  1030c6 <z_log_minimal_printk>
  10e38c:	48 8b 05 bd a3 01 00 	mov    0x1a3bd(%rip),%rax        # 128750 <_kernel+0x10>
  10e393:	48 8b b8 40 01 00 00 	mov    0x140(%rax),%rdi
  10e39a:	e8 6e b8 ff ff       	callq  109c0d <arch_syscall_oops>
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	int ret = z_vrfy_k_float_disable(*(struct k_thread **)&arg0)
;
	_current->syscall_frame = NULL;
  10e39f:	48 8b 05 aa a3 01 00 	mov    0x1a3aa(%rip),%rax        # 128750 <_kernel+0x10>
  10e3a6:	48 c7 80 40 01 00 00 	movq   $0x0,0x140(%rax)
  10e3ad:	00 00 00 00 
	return (uintptr_t) ret;
}
  10e3b1:	5a                   	pop    %rdx
  10e3b2:	48 c7 c0 7a ff ff ff 	mov    $0xffffffffffffff7a,%rax
  10e3b9:	41 5c                	pop    %r12
  10e3bb:	5d                   	pop    %rbp
  10e3bc:	c3                   	retq   

000000000010e3bd <z_impl_k_thread_stack_space_get>:
#endif

int z_impl_k_thread_stack_space_get(const struct k_thread *thread,
				    size_t *unused_ptr)
{
	const uint8_t *start = (uint8_t *)thread->stack_info.start;
  10e3bd:	48 8b 8f 08 01 00 00 	mov    0x108(%rdi),%rcx
	size_t size = thread->stack_info.size;
  10e3c4:	48 8b 97 10 01 00 00 	mov    0x110(%rdi),%rdx
	size_t unused = 0;
  10e3cb:	31 c0                	xor    %eax,%eax
		 */
		checked_stack += 4;
		size -= 4;
	}

	for (size_t i = 0; i < size; i++) {
  10e3cd:	48 39 d0             	cmp    %rdx,%rax
  10e3d0:	74 0b                	je     10e3dd <z_impl_k_thread_stack_space_get+0x20>
		if ((checked_stack[i]) == 0xaaU) {
  10e3d2:	80 3c 01 aa          	cmpb   $0xaa,(%rcx,%rax,1)
  10e3d6:	75 05                	jne    10e3dd <z_impl_k_thread_stack_space_get+0x20>
			unused++;
  10e3d8:	48 ff c0             	inc    %rax
	for (size_t i = 0; i < size; i++) {
  10e3db:	eb f0                	jmp    10e3cd <z_impl_k_thread_stack_space_get+0x10>
		} else {
			break;
		}
	}

	*unused_ptr = unused;
  10e3dd:	48 89 06             	mov    %rax,(%rsi)

	return 0;
}
  10e3e0:	31 c0                	xor    %eax,%eax
  10e3e2:	c3                   	retq   

000000000010e3e3 <z_vrfy_k_thread_stack_space_get>:

#ifdef CONFIG_USERSPACE
int z_vrfy_k_thread_stack_space_get(const struct k_thread *thread,
				    size_t *unused_ptr)
{
  10e3e3:	55                   	push   %rbp
  10e3e4:	48 89 e5             	mov    %rsp,%rbp
  10e3e7:	41 55                	push   %r13
  10e3e9:	49 89 f5             	mov    %rsi,%r13
  10e3ec:	41 54                	push   %r12
  10e3ee:	49 89 fc             	mov    %rdi,%r12
  10e3f1:	48 83 ec 10          	sub    $0x10,%rsp
	size_t unused;
	int ret;

	ret = Z_SYSCALL_OBJ(thread, K_OBJ_THREAD);
  10e3f5:	e8 da 86 00 00       	callq  116ad4 <z_object_find>
  10e3fa:	31 c9                	xor    %ecx,%ecx
  10e3fc:	ba 09 00 00 00       	mov    $0x9,%edx
  10e401:	4c 89 e6             	mov    %r12,%rsi
  10e404:	48 89 c7             	mov    %rax,%rdi
  10e407:	e8 33 f1 ff ff       	callq  10d53f <z_obj_validation_check>
  10e40c:	85 c0                	test   %eax,%eax
  10e40e:	74 1d                	je     10e42d <z_vrfy_k_thread_stack_space_get+0x4a>
  10e410:	31 c0                	xor    %eax,%eax
  10e412:	ba c0 b1 11 00       	mov    $0x11b1c0,%edx
  10e417:	be 45 00 00 00       	mov    $0x45,%esi
  10e41c:	bf 23 f3 11 00       	mov    $0x11f323,%edi
  10e421:	e8 a0 4c ff ff       	callq  1030c6 <z_log_minimal_printk>
	CHECKIF(ret != 0) {
		return ret;
  10e426:	b8 01 00 00 00       	mov    $0x1,%eax
  10e42b:	eb 21                	jmp    10e44e <z_vrfy_k_thread_stack_space_get+0x6b>
	}

	ret = z_impl_k_thread_stack_space_get(thread, &unused);
  10e42d:	48 8d 75 e8          	lea    -0x18(%rbp),%rsi
  10e431:	4c 89 e7             	mov    %r12,%rdi
  10e434:	e8 84 ff ff ff       	callq  10e3bd <z_impl_k_thread_stack_space_get>
	CHECKIF(ret != 0) {
  10e439:	85 c0                	test   %eax,%eax
  10e43b:	75 11                	jne    10e44e <z_vrfy_k_thread_stack_space_get+0x6b>
		return ret;
	}

	ret = z_user_to_copy(unused_ptr, &unused, sizeof(size_t));
  10e43d:	ba 08 00 00 00       	mov    $0x8,%edx
  10e442:	48 8d 75 e8          	lea    -0x18(%rbp),%rsi
  10e446:	4c 89 ef             	mov    %r13,%rdi
  10e449:	e8 d2 8b 00 00       	callq  117020 <z_user_to_copy>
	CHECKIF(ret != 0) {
		return ret;
	}

	return 0;
}
  10e44e:	5a                   	pop    %rdx
  10e44f:	59                   	pop    %rcx
  10e450:	41 5c                	pop    %r12
  10e452:	41 5d                	pop    %r13
  10e454:	5d                   	pop    %rbp
  10e455:	c3                   	retq   

000000000010e456 <z_mrsh_k_thread_stack_space_get>:
#include <syscalls/kernel.h>

extern int z_vrfy_k_thread_stack_space_get(const struct k_thread * thread, size_t * unused_ptr);
uintptr_t z_mrsh_k_thread_stack_space_get(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
  10e456:	55                   	push   %rbp
	_current->syscall_frame = ssf;
  10e457:	48 8b 05 f2 a2 01 00 	mov    0x1a2f2(%rip),%rax        # 128750 <_kernel+0x10>
{
  10e45e:	48 89 e5             	mov    %rsp,%rbp
	_current->syscall_frame = ssf;
  10e461:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  10e465:	48 89 90 40 01 00 00 	mov    %rdx,0x140(%rax)
	(void) arg2;	/* unused */
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	int ret = z_vrfy_k_thread_stack_space_get(*(const struct k_thread **)&arg0, *(size_t **)&arg1)
  10e46c:	e8 72 ff ff ff       	callq  10e3e3 <z_vrfy_k_thread_stack_space_get>
;
	_current->syscall_frame = NULL;
  10e471:	48 8b 15 d8 a2 01 00 	mov    0x1a2d8(%rip),%rdx        # 128750 <_kernel+0x10>
	return (uintptr_t) ret;
  10e478:	48 98                	cltq   
	_current->syscall_frame = NULL;
  10e47a:	48 c7 82 40 01 00 00 	movq   $0x0,0x140(%rdx)
  10e481:	00 00 00 00 
}
  10e485:	5d                   	pop    %rbp
  10e486:	c3                   	retq   

000000000010e487 <z_mrsh_k_thread_timeout_remaining_ticks>:
#include <syscalls/kernel.h>

extern k_ticks_t z_vrfy_k_thread_timeout_remaining_ticks(const struct k_thread * t);
uintptr_t z_mrsh_k_thread_timeout_remaining_ticks(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
  10e487:	55                   	push   %rbp
  10e488:	48 89 e5             	mov    %rsp,%rbp
  10e48b:	53                   	push   %rbx
  10e48c:	48 89 fb             	mov    %rdi,%rbx
  10e48f:	51                   	push   %rcx
	_current->syscall_frame = ssf;
  10e490:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  10e494:	48 8b 05 b5 a2 01 00 	mov    0x1a2b5(%rip),%rax        # 128750 <_kernel+0x10>
  10e49b:	48 89 90 40 01 00 00 	mov    %rdx,0x140(%rax)

#ifdef CONFIG_USERSPACE
static inline k_ticks_t z_vrfy_k_thread_timeout_remaining_ticks(
						    const struct k_thread *t)
{
	Z_OOPS(Z_SYSCALL_OBJ(t, K_OBJ_THREAD));
  10e4a2:	e8 2d 86 00 00       	callq  116ad4 <z_object_find>
  10e4a7:	31 c9                	xor    %ecx,%ecx
  10e4a9:	ba 09 00 00 00       	mov    $0x9,%edx
  10e4ae:	48 89 de             	mov    %rbx,%rsi
  10e4b1:	48 89 c7             	mov    %rax,%rdi
  10e4b4:	e8 86 f0 ff ff       	callq  10d53f <z_obj_validation_check>
  10e4b9:	85 c0                	test   %eax,%eax
  10e4bb:	74 29                	je     10e4e6 <z_mrsh_k_thread_timeout_remaining_ticks+0x5f>
  10e4bd:	bf 23 f3 11 00       	mov    $0x11f323,%edi
  10e4c2:	31 c0                	xor    %eax,%eax
  10e4c4:	ba 80 b1 11 00       	mov    $0x11b180,%edx
  10e4c9:	be 45 00 00 00       	mov    $0x45,%esi
  10e4ce:	e8 f3 4b ff ff       	callq  1030c6 <z_log_minimal_printk>
  10e4d3:	48 8b 05 76 a2 01 00 	mov    0x1a276(%rip),%rax        # 128750 <_kernel+0x10>
  10e4da:	48 8b b8 40 01 00 00 	mov    0x140(%rax),%rdi
  10e4e1:	e8 27 b7 ff ff       	callq  109c0d <arch_syscall_oops>
	return z_timeout_remaining(&t->base.timeout);
  10e4e6:	48 8d 7b 28          	lea    0x28(%rbx),%rdi
  10e4ea:	e8 bd 4b 00 00       	callq  1130ac <z_timeout_remaining>
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	k_ticks_t ret = z_vrfy_k_thread_timeout_remaining_ticks(*(const struct k_thread **)&arg0)
;
	_current->syscall_frame = NULL;
  10e4ef:	48 8b 15 5a a2 01 00 	mov    0x1a25a(%rip),%rdx        # 128750 <_kernel+0x10>
  10e4f6:	48 c7 82 40 01 00 00 	movq   $0x0,0x140(%rdx)
  10e4fd:	00 00 00 00 
	return (uintptr_t) ret;
}
  10e501:	5a                   	pop    %rdx
  10e502:	5b                   	pop    %rbx
  10e503:	5d                   	pop    %rbp
  10e504:	c3                   	retq   

000000000010e505 <z_mrsh_k_thread_timeout_expires_ticks>:
#include <syscalls/kernel.h>

extern k_ticks_t z_vrfy_k_thread_timeout_expires_ticks(const struct k_thread * t);
uintptr_t z_mrsh_k_thread_timeout_expires_ticks(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
  10e505:	55                   	push   %rbp
  10e506:	48 89 e5             	mov    %rsp,%rbp
  10e509:	53                   	push   %rbx
  10e50a:	48 89 fb             	mov    %rdi,%rbx
  10e50d:	51                   	push   %rcx
	_current->syscall_frame = ssf;
  10e50e:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  10e512:	48 8b 05 37 a2 01 00 	mov    0x1a237(%rip),%rax        # 128750 <_kernel+0x10>
  10e519:	48 89 90 40 01 00 00 	mov    %rdx,0x140(%rax)
#include <syscalls/k_thread_timeout_remaining_ticks_mrsh.c>

static inline k_ticks_t z_vrfy_k_thread_timeout_expires_ticks(
						  const struct k_thread *t)
{
	Z_OOPS(Z_SYSCALL_OBJ(t, K_OBJ_THREAD));
  10e520:	e8 af 85 00 00       	callq  116ad4 <z_object_find>
  10e525:	31 c9                	xor    %ecx,%ecx
  10e527:	ba 09 00 00 00       	mov    $0x9,%edx
  10e52c:	48 89 de             	mov    %rbx,%rsi
  10e52f:	48 89 c7             	mov    %rax,%rdi
  10e532:	e8 08 f0 ff ff       	callq  10d53f <z_obj_validation_check>
  10e537:	85 c0                	test   %eax,%eax
  10e539:	74 29                	je     10e564 <z_mrsh_k_thread_timeout_expires_ticks+0x5f>
  10e53b:	bf 23 f3 11 00       	mov    $0x11f323,%edi
  10e540:	31 c0                	xor    %eax,%eax
  10e542:	ba 40 b1 11 00       	mov    $0x11b140,%edx
  10e547:	be 45 00 00 00       	mov    $0x45,%esi
  10e54c:	e8 75 4b ff ff       	callq  1030c6 <z_log_minimal_printk>
  10e551:	48 8b 05 f8 a1 01 00 	mov    0x1a1f8(%rip),%rax        # 128750 <_kernel+0x10>
  10e558:	48 8b b8 40 01 00 00 	mov    0x140(%rax),%rdi
  10e55f:	e8 a9 b6 ff ff       	callq  109c0d <arch_syscall_oops>
	return z_timeout_expires(&t->base.timeout);
  10e564:	48 8d 7b 28          	lea    0x28(%rbx),%rdi
  10e568:	e8 fe 4b 00 00       	callq  11316b <z_timeout_expires>
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	k_ticks_t ret = z_vrfy_k_thread_timeout_expires_ticks(*(const struct k_thread **)&arg0)
;
	_current->syscall_frame = NULL;
  10e56d:	48 8b 15 dc a1 01 00 	mov    0x1a1dc(%rip),%rdx        # 128750 <_kernel+0x10>
  10e574:	48 c7 82 40 01 00 00 	movq   $0x0,0x140(%rdx)
  10e57b:	00 00 00 00 
	return (uintptr_t) ret;
}
  10e57f:	5a                   	pop    %rdx
  10e580:	5b                   	pop    %rbx
  10e581:	5d                   	pop    %rbp
  10e582:	c3                   	retq   

000000000010e583 <z_thread_mark_switched_in>:
#include <syscalls/k_thread_timeout_expires_ticks_mrsh.c>
#endif

#ifdef CONFIG_INSTRUMENT_THREAD_SWITCHING
void z_thread_mark_switched_in(void)
{
  10e583:	55                   	push   %rbp
  10e584:	48 89 e5             	mov    %rsp,%rbp
  10e587:	53                   	push   %rbx
  10e588:	50                   	push   %rax
	return z_impl_z_current_get();
  10e589:	e8 c0 41 00 00       	callq  11274e <z_impl_z_current_get>
  10e58e:	48 89 c3             	mov    %rax,%rbx
	return sys_clock_cycle_get_32();
  10e591:	e8 c2 e6 ff ff       	callq  10cc58 <sys_clock_cycle_get_32>

	thread = k_current_get();
#ifdef CONFIG_THREAD_RUNTIME_STATS_USE_TIMING_FUNCTIONS
	thread->rt_stats.last_switched_in = timing_counter_get();
#else
	thread->rt_stats.last_switched_in = k_cycle_get_32();
  10e596:	89 83 60 01 00 00    	mov    %eax,0x160(%rbx)
#endif /* CONFIG_THREAD_RUNTIME_STATS_USE_TIMING_FUNCTIONS */

#endif /* CONFIG_THREAD_RUNTIME_STATS */
}
  10e59c:	5a                   	pop    %rdx
  10e59d:	5b                   	pop    %rbx
  10e59e:	5d                   	pop    %rbp
  10e59f:	c3                   	retq   

000000000010e5a0 <z_thread_mark_switched_out>:

void z_thread_mark_switched_out(void)
{
  10e5a0:	55                   	push   %rbp
  10e5a1:	48 89 e5             	mov    %rsp,%rbp
  10e5a4:	53                   	push   %rbx
  10e5a5:	52                   	push   %rdx
  10e5a6:	e8 a3 41 00 00       	callq  11274e <z_impl_z_current_get>
	uint64_t diff;
	struct k_thread *thread;

	thread = k_current_get();

	if (unlikely(thread->rt_stats.last_switched_in == 0)) {
  10e5ab:	83 b8 60 01 00 00 00 	cmpl   $0x0,0x160(%rax)
  10e5b2:	74 2c                	je     10e5e0 <z_thread_mark_switched_out+0x40>
		/* Has not run before */
		return;
	}

	if (unlikely(thread->base.thread_state == _THREAD_DUMMY)) {
  10e5b4:	80 78 19 01          	cmpb   $0x1,0x19(%rax)
  10e5b8:	48 89 c3             	mov    %rax,%rbx
  10e5bb:	74 23                	je     10e5e0 <z_thread_mark_switched_out+0x40>
  10e5bd:	e8 96 e6 ff ff       	callq  10cc58 <sys_clock_cycle_get_32>
#ifdef CONFIG_THREAD_RUNTIME_STATS_USE_TIMING_FUNCTIONS
	now = timing_counter_get();
	diff = timing_cycles_get(&thread->rt_stats.last_switched_in, &now);
#else
	now = k_cycle_get_32();
	diff = (uint64_t)(now - thread->rt_stats.last_switched_in);
  10e5c2:	2b 83 60 01 00 00    	sub    0x160(%rbx),%eax
	thread->rt_stats.last_switched_in = 0;
#endif /* CONFIG_THREAD_RUNTIME_STATS_USE_TIMING_FUNCTIONS */

	thread->rt_stats.stats.execution_cycles += diff;
  10e5c8:	48 01 83 68 01 00 00 	add    %rax,0x168(%rbx)

	threads_runtime_stats.execution_cycles += diff;
  10e5cf:	48 01 05 da e7 0a 00 	add    %rax,0xae7da(%rip)        # 1bcdb0 <threads_runtime_stats>
	thread->rt_stats.last_switched_in = 0;
  10e5d6:	c7 83 60 01 00 00 00 	movl   $0x0,0x160(%rbx)
  10e5dd:	00 00 00 
#endif /* CONFIG_THREAD_RUNTIME_STATS */

#ifdef CONFIG_TRACING
	SYS_PORT_TRACING_FUNC(k_thread, switched_out);
#endif
}
  10e5e0:	58                   	pop    %rax
  10e5e1:	5b                   	pop    %rbx
  10e5e2:	5d                   	pop    %rbp
  10e5e3:	c3                   	retq   

000000000010e5e4 <k_thread_runtime_stats_get>:

#ifdef CONFIG_THREAD_RUNTIME_STATS
int k_thread_runtime_stats_get(k_tid_t thread,
			       k_thread_runtime_stats_t *stats)
{
	if ((thread == NULL) || (stats == NULL)) {
  10e5e4:	48 85 ff             	test   %rdi,%rdi
  10e5e7:	74 24                	je     10e60d <k_thread_runtime_stats_get+0x29>
  10e5e9:	49 89 f0             	mov    %rsi,%r8
  10e5ec:	48 85 f6             	test   %rsi,%rsi
  10e5ef:	74 1c                	je     10e60d <k_thread_runtime_stats_get+0x29>
{
  10e5f1:	55                   	push   %rbp
		return -EINVAL;
	}

	(void)memcpy(stats, &thread->rt_stats.stats,
  10e5f2:	48 8d b7 68 01 00 00 	lea    0x168(%rdi),%rsi
  10e5f9:	ba 08 00 00 00       	mov    $0x8,%edx
  10e5fe:	4c 89 c7             	mov    %r8,%rdi
{
  10e601:	48 89 e5             	mov    %rsp,%rbp
	(void)memcpy(stats, &thread->rt_stats.stats,
  10e604:	e8 8f ba ff ff       	callq  10a098 <memcpy>
		     sizeof(thread->rt_stats.stats));

	return 0;
  10e609:	31 c0                	xor    %eax,%eax
}
  10e60b:	5d                   	pop    %rbp
  10e60c:	c3                   	retq   
		return -EINVAL;
  10e60d:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
}
  10e612:	c3                   	retq   

000000000010e613 <k_thread_runtime_stats_all_get>:

int k_thread_runtime_stats_all_get(k_thread_runtime_stats_t *stats)
{
	if (stats == NULL) {
  10e613:	48 85 ff             	test   %rdi,%rdi
  10e616:	74 17                	je     10e62f <k_thread_runtime_stats_all_get+0x1c>
{
  10e618:	55                   	push   %rbp
		return -EINVAL;
	}

	(void)memcpy(stats, &threads_runtime_stats,
  10e619:	ba 08 00 00 00       	mov    $0x8,%edx
  10e61e:	be b0 cd 1b 00       	mov    $0x1bcdb0,%esi
{
  10e623:	48 89 e5             	mov    %rsp,%rbp
	(void)memcpy(stats, &threads_runtime_stats,
  10e626:	e8 6d ba ff ff       	callq  10a098 <memcpy>
		     sizeof(threads_runtime_stats));

	return 0;
  10e62b:	31 c0                	xor    %eax,%eax
}
  10e62d:	5d                   	pop    %rbp
  10e62e:	c3                   	retq   
  10e62f:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
  10e634:	c3                   	retq   

000000000010e635 <sys_kernel_version_get>:
 * @return kernel version
 */
uint32_t sys_kernel_version_get(void)
{
	return KERNELVERSION;
}
  10e635:	b8 00 01 07 02       	mov    $0x2070100,%eax
  10e63a:	c3                   	retq   

000000000010e63b <idle>:
#endif	/* CONFIG_PM */
	sys_clock_idle_exit();
}

void idle(void *unused1, void *unused2, void *unused3)
{
  10e63b:	55                   	push   %rbp
	ARG_UNUSED(unused1);
	ARG_UNUSED(unused2);
	ARG_UNUSED(unused3);

	__ASSERT_NO_MSG(_current->base.prio >= 0);
  10e63c:	48 8b 05 0d a1 01 00 	mov    0x1a10d(%rip),%rax        # 128750 <_kernel+0x10>
  10e643:	80 78 1a 00          	cmpb   $0x0,0x1a(%rax)
{
  10e647:	48 89 e5             	mov    %rsp,%rbp
	__ASSERT_NO_MSG(_current->base.prio >= 0);
  10e64a:	79 2a                	jns    10e676 <idle+0x3b>
  10e64c:	be 93 fb 11 00       	mov    $0x11fb93,%esi
  10e651:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  10e656:	b9 46 00 00 00       	mov    $0x46,%ecx
  10e65b:	31 c0                	xor    %eax,%eax
  10e65d:	ba 72 fb 11 00       	mov    $0x11fb72,%edx
  10e662:	e8 91 1f ff ff       	callq  1005f8 <printk>
  10e667:	be 46 00 00 00       	mov    $0x46,%esi
  10e66c:	bf 72 fb 11 00       	mov    $0x11fb72,%edi
  10e671:	e8 22 45 ff ff       	callq  102b98 <assert_post_action>
  10e676:	9c                   	pushfq 
  10e677:	fa                   	cli    
  10e678:	58                   	pop    %rax
 *
 * @return N/A
 */
static inline void k_cpu_idle(void)
{
	arch_cpu_idle();
  10e679:	e8 ef 9a ff ff       	callq  10816d <arch_cpu_idle>
  10e67e:	eb f6                	jmp    10e676 <idle+0x3b>

000000000010e680 <z_obj_validation_check.constprop.0>:
static inline int z_obj_validation_check(struct z_object *ko,
  10e680:	55                   	push   %rbp
  10e681:	48 89 e5             	mov    %rsp,%rbp
  10e684:	41 56                	push   %r14
  10e686:	49 89 f6             	mov    %rsi,%r14
	ret = z_object_validate(ko, otype, init);
  10e689:	be 02 00 00 00       	mov    $0x2,%esi
static inline int z_obj_validation_check(struct z_object *ko,
  10e68e:	41 55                	push   %r13
  10e690:	49 89 fd             	mov    %rdi,%r13
  10e693:	48 83 ec 10          	sub    $0x10,%rsp
	ret = z_object_validate(ko, otype, init);
  10e697:	e8 d0 88 00 00       	callq  116f6c <z_object_validate>
	if (ret != 0) {
  10e69c:	85 c0                	test   %eax,%eax
  10e69e:	74 18                	je     10e6b8 <z_obj_validation_check.constprop.0+0x38>
		z_dump_object_error(ret, obj, ko, otype);
  10e6a0:	89 c7                	mov    %eax,%edi
  10e6a2:	b9 02 00 00 00       	mov    $0x2,%ecx
  10e6a7:	4c 89 ea             	mov    %r13,%rdx
  10e6aa:	4c 89 f6             	mov    %r14,%rsi
  10e6ad:	89 45 ec             	mov    %eax,-0x14(%rbp)
  10e6b0:	e8 6c 87 00 00       	callq  116e21 <z_dump_object_error>
  10e6b5:	8b 45 ec             	mov    -0x14(%rbp),%eax
}
  10e6b8:	5a                   	pop    %rdx
  10e6b9:	59                   	pop    %rcx
  10e6ba:	41 5d                	pop    %r13
  10e6bc:	41 5e                	pop    %r14
  10e6be:	5d                   	pop    %rbp
  10e6bf:	c3                   	retq   

000000000010e6c0 <k_msgq_init>:

void k_msgq_init(struct k_msgq *msgq, char *buffer, size_t msg_size,
		 uint32_t max_msgs)
{
	msgq->msg_size = msg_size;
	msgq->max_msgs = max_msgs;
  10e6c0:	89 4f 20             	mov    %ecx,0x20(%rdi)
	msgq->buffer_start = buffer;
	msgq->buffer_end = buffer + (max_msgs * msg_size);
  10e6c3:	89 c9                	mov    %ecx,%ecx
	msgq->used_msgs = 0;
	msgq->flags = 0;
	z_waitq_init(&msgq->wait_q);
	msgq->lock = (struct k_spinlock) {};
#ifdef CONFIG_POLL
	sys_dlist_init(&msgq->poll_events);
  10e6c5:	48 8d 47 50          	lea    0x50(%rdi),%rax
	msgq->buffer_end = buffer + (max_msgs * msg_size);
  10e6c9:	48 0f af ca          	imul   %rdx,%rcx
	msgq->msg_size = msg_size;
  10e6cd:	48 89 57 18          	mov    %rdx,0x18(%rdi)
	msgq->buffer_start = buffer;
  10e6d1:	48 89 77 28          	mov    %rsi,0x28(%rdi)
	msgq->read_ptr = buffer;
  10e6d5:	48 89 77 38          	mov    %rsi,0x38(%rdi)
	msgq->buffer_end = buffer + (max_msgs * msg_size);
  10e6d9:	48 01 f1             	add    %rsi,%rcx
	msgq->write_ptr = buffer;
  10e6dc:	48 89 77 40          	mov    %rsi,0x40(%rdi)
	msgq->buffer_end = buffer + (max_msgs * msg_size);
  10e6e0:	48 89 4f 30          	mov    %rcx,0x30(%rdi)
	msgq->used_msgs = 0;
  10e6e4:	c7 47 48 00 00 00 00 	movl   $0x0,0x48(%rdi)
	msgq->flags = 0;
  10e6eb:	c6 47 60 00          	movb   $0x0,0x60(%rdi)
	list->head = (sys_dnode_t *)list;
  10e6ef:	48 89 3f             	mov    %rdi,(%rdi)
	list->tail = (sys_dnode_t *)list;
  10e6f2:	48 89 7f 08          	mov    %rdi,0x8(%rdi)
	msgq->lock = (struct k_spinlock) {};
  10e6f6:	48 c7 47 10 00 00 00 	movq   $0x0,0x10(%rdi)
  10e6fd:	00 
	list->head = (sys_dnode_t *)list;
  10e6fe:	48 89 47 50          	mov    %rax,0x50(%rdi)
	list->tail = (sys_dnode_t *)list;
  10e702:	48 89 47 58          	mov    %rax,0x58(%rdi)
#endif	/* CONFIG_POLL */

	SYS_PORT_TRACING_OBJ_INIT(k_msgq, msgq);

	z_object_init(msgq);
  10e706:	e9 e6 88 00 00       	jmpq   116ff1 <z_object_init>

000000000010e70b <z_impl_k_msgq_alloc_init>:
}

int z_impl_k_msgq_alloc_init(struct k_msgq *msgq, size_t msg_size,
			    uint32_t max_msgs)
{
  10e70b:	55                   	push   %rbp
	size_t total_size;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_msgq, alloc_init, msgq);

	if (size_mul_overflow(msg_size, max_msgs, &total_size)) {
		ret = -EINVAL;
  10e70c:	41 b8 ea ff ff ff    	mov    $0xffffffea,%r8d
{
  10e712:	48 89 e5             	mov    %rsp,%rbp
  10e715:	41 55                	push   %r13
  10e717:	41 54                	push   %r12
  10e719:	49 89 f4             	mov    %rsi,%r12
  10e71c:	89 d6                	mov    %edx,%esi
	return __builtin_mul_overflow(a, b, result);
  10e71e:	48 89 f0             	mov    %rsi,%rax
  10e721:	53                   	push   %rbx
  10e722:	49 f7 e4             	mul    %r12
  10e725:	51                   	push   %rcx
  10e726:	70 33                	jo     10e75b <z_impl_k_msgq_alloc_init+0x50>
  10e728:	48 89 fb             	mov    %rdi,%rbx
  10e72b:	49 89 f5             	mov    %rsi,%r13
 * @return A pointer to the allocated memory, or NULL if there is insufficient
 * RAM in the pool or there is no pool to draw memory from
 */
static inline void *z_thread_malloc(size_t size)
{
	return z_thread_aligned_alloc(0, size);
  10e72e:	31 ff                	xor    %edi,%edi
  10e730:	48 89 c6             	mov    %rax,%rsi
  10e733:	e8 38 73 00 00       	callq  115a70 <z_thread_aligned_alloc>
		if (buffer != NULL) {
			k_msgq_init(msgq, buffer, msg_size, max_msgs);
			msgq->flags = K_MSGQ_FLAG_ALLOC;
			ret = 0;
		} else {
			ret = -ENOMEM;
  10e738:	41 b8 f4 ff ff ff    	mov    $0xfffffff4,%r8d
  10e73e:	48 89 c6             	mov    %rax,%rsi
		if (buffer != NULL) {
  10e741:	48 85 c0             	test   %rax,%rax
  10e744:	74 15                	je     10e75b <z_impl_k_msgq_alloc_init+0x50>
			k_msgq_init(msgq, buffer, msg_size, max_msgs);
  10e746:	44 89 e9             	mov    %r13d,%ecx
  10e749:	4c 89 e2             	mov    %r12,%rdx
  10e74c:	48 89 df             	mov    %rbx,%rdi
  10e74f:	e8 6c ff ff ff       	callq  10e6c0 <k_msgq_init>
			msgq->flags = K_MSGQ_FLAG_ALLOC;
  10e754:	c6 43 60 01          	movb   $0x1,0x60(%rbx)
			ret = 0;
  10e758:	45 31 c0             	xor    %r8d,%r8d
	}

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_msgq, alloc_init, msgq, ret);

	return ret;
}
  10e75b:	5a                   	pop    %rdx
  10e75c:	44 89 c0             	mov    %r8d,%eax
  10e75f:	5b                   	pop    %rbx
  10e760:	41 5c                	pop    %r12
  10e762:	41 5d                	pop    %r13
  10e764:	5d                   	pop    %rbp
  10e765:	c3                   	retq   

000000000010e766 <z_vrfy_k_msgq_alloc_init>:

#ifdef CONFIG_USERSPACE
int z_vrfy_k_msgq_alloc_init(struct k_msgq *msgq, size_t msg_size,
			    uint32_t max_msgs)
{
  10e766:	55                   	push   %rbp
  10e767:	48 89 e5             	mov    %rsp,%rbp
  10e76a:	41 56                	push   %r14
  10e76c:	41 89 d6             	mov    %edx,%r14d
  10e76f:	41 55                	push   %r13
  10e771:	49 89 f5             	mov    %rsi,%r13
  10e774:	41 54                	push   %r12
  10e776:	49 89 fc             	mov    %rdi,%r12
  10e779:	51                   	push   %rcx
	Z_OOPS(Z_SYSCALL_OBJ_NEVER_INIT(msgq, K_OBJ_MSGQ));
  10e77a:	e8 55 83 00 00       	callq  116ad4 <z_object_find>
  10e77f:	83 ca ff             	or     $0xffffffff,%edx
  10e782:	4c 89 e6             	mov    %r12,%rsi
  10e785:	48 89 c7             	mov    %rax,%rdi
  10e788:	e8 f3 fe ff ff       	callq  10e680 <z_obj_validation_check.constprop.0>
  10e78d:	85 c0                	test   %eax,%eax
  10e78f:	74 29                	je     10e7ba <z_vrfy_k_msgq_alloc_init+0x54>
  10e791:	bf 23 f3 11 00       	mov    $0x11f323,%edi
  10e796:	31 c0                	xor    %eax,%eax
  10e798:	ba 90 c2 11 00       	mov    $0x11c290,%edx
  10e79d:	be 45 00 00 00       	mov    $0x45,%esi
  10e7a2:	e8 1f 49 ff ff       	callq  1030c6 <z_log_minimal_printk>
  10e7a7:	48 8b 05 a2 9f 01 00 	mov    0x19fa2(%rip),%rax        # 128750 <_kernel+0x10>
  10e7ae:	48 8b b8 40 01 00 00 	mov    0x140(%rax),%rdi
  10e7b5:	e8 53 b4 ff ff       	callq  109c0d <arch_syscall_oops>

	return z_impl_k_msgq_alloc_init(msgq, msg_size, max_msgs);
}
  10e7ba:	58                   	pop    %rax
	return z_impl_k_msgq_alloc_init(msgq, msg_size, max_msgs);
  10e7bb:	44 89 f2             	mov    %r14d,%edx
  10e7be:	4c 89 ee             	mov    %r13,%rsi
  10e7c1:	4c 89 e7             	mov    %r12,%rdi
}
  10e7c4:	41 5c                	pop    %r12
  10e7c6:	41 5d                	pop    %r13
  10e7c8:	41 5e                	pop    %r14
  10e7ca:	5d                   	pop    %rbp
	return z_impl_k_msgq_alloc_init(msgq, msg_size, max_msgs);
  10e7cb:	e9 3b ff ff ff       	jmpq   10e70b <z_impl_k_msgq_alloc_init>

000000000010e7d0 <z_mrsh_k_msgq_alloc_init>:
#include <syscalls/kernel.h>

extern int z_vrfy_k_msgq_alloc_init(struct k_msgq * msgq, size_t msg_size, uint32_t max_msgs);
uintptr_t z_mrsh_k_msgq_alloc_init(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
  10e7d0:	55                   	push   %rbp
	_current->syscall_frame = ssf;
  10e7d1:	48 8b 05 78 9f 01 00 	mov    0x19f78(%rip),%rax        # 128750 <_kernel+0x10>
{
  10e7d8:	48 89 e5             	mov    %rsp,%rbp
	_current->syscall_frame = ssf;
  10e7db:	48 8b 4d 10          	mov    0x10(%rbp),%rcx
  10e7df:	48 89 88 40 01 00 00 	mov    %rcx,0x140(%rax)
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	int ret = z_vrfy_k_msgq_alloc_init(*(struct k_msgq **)&arg0, *(size_t*)&arg1, *(uint32_t*)&arg2)
  10e7e6:	e8 7b ff ff ff       	callq  10e766 <z_vrfy_k_msgq_alloc_init>
;
	_current->syscall_frame = NULL;
  10e7eb:	48 8b 15 5e 9f 01 00 	mov    0x19f5e(%rip),%rdx        # 128750 <_kernel+0x10>
	return (uintptr_t) ret;
  10e7f2:	48 98                	cltq   
	_current->syscall_frame = NULL;
  10e7f4:	48 c7 82 40 01 00 00 	movq   $0x0,0x140(%rdx)
  10e7fb:	00 00 00 00 
}
  10e7ff:	5d                   	pop    %rbp
  10e800:	c3                   	retq   

000000000010e801 <k_msgq_cleanup>:
#include <syscalls/k_msgq_alloc_init_mrsh.c>
#endif

int k_msgq_cleanup(struct k_msgq *msgq)
{
  10e801:	55                   	push   %rbp
  10e802:	48 89 e5             	mov    %rsp,%rbp
  10e805:	41 54                	push   %r12
  10e807:	53                   	push   %rbx
	return list->head == list;
  10e808:	48 8b 07             	mov    (%rdi),%rax
  10e80b:	48 89 fb             	mov    %rdi,%rbx
	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_msgq, cleanup, msgq);

	CHECKIF(z_waitq_head(&msgq->wait_q) != NULL) {
  10e80e:	48 39 c7             	cmp    %rax,%rdi
  10e811:	74 0b                	je     10e81e <k_msgq_cleanup+0x1d>
		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_msgq, cleanup, msgq, -EBUSY);

		return -EBUSY;
  10e813:	41 bc f0 ff ff ff    	mov    $0xfffffff0,%r12d
	CHECKIF(z_waitq_head(&msgq->wait_q) != NULL) {
  10e819:	48 85 c0             	test   %rax,%rax
  10e81c:	75 16                	jne    10e834 <k_msgq_cleanup+0x33>
		msgq->flags &= ~K_MSGQ_FLAG_ALLOC;
	}

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_msgq, cleanup, msgq, 0);

	return 0;
  10e81e:	45 31 e4             	xor    %r12d,%r12d
	if ((msgq->flags & K_MSGQ_FLAG_ALLOC) != 0U) {
  10e821:	f6 43 60 01          	testb  $0x1,0x60(%rbx)
  10e825:	74 0d                	je     10e834 <k_msgq_cleanup+0x33>
		k_free(msgq->buffer_start);
  10e827:	48 8b 7b 28          	mov    0x28(%rbx),%rdi
  10e82b:	e8 2d 72 00 00       	callq  115a5d <k_free>
		msgq->flags &= ~K_MSGQ_FLAG_ALLOC;
  10e830:	80 63 60 fe          	andb   $0xfe,0x60(%rbx)
}
  10e834:	44 89 e0             	mov    %r12d,%eax
  10e837:	5b                   	pop    %rbx
  10e838:	41 5c                	pop    %r12
  10e83a:	5d                   	pop    %rbp
  10e83b:	c3                   	retq   

000000000010e83c <z_impl_k_msgq_put>:


int z_impl_k_msgq_put(struct k_msgq *msgq, const void *data, k_timeout_t timeout)
{
  10e83c:	55                   	push   %rbp
  10e83d:	48 89 e5             	mov    %rsp,%rbp
  10e840:	41 57                	push   %r15
  10e842:	49 89 f7             	mov    %rsi,%r15
  10e845:	41 56                	push   %r14
  10e847:	49 89 d6             	mov    %rdx,%r14
  10e84a:	41 55                	push   %r13
  10e84c:	41 54                	push   %r12
  10e84e:	49 89 fc             	mov    %rdi,%r12
  10e851:	53                   	push   %rbx
  10e852:	48 83 ec 18          	sub    $0x18,%rsp
	__ASSERT(!arch_is_in_isr() || K_TIMEOUT_EQ(timeout, K_NO_WAIT), "");
  10e856:	83 3d e3 9e 01 00 00 	cmpl   $0x0,0x19ee3(%rip)        # 128740 <_kernel>
  10e85d:	74 3b                	je     10e89a <z_impl_k_msgq_put+0x5e>
  10e85f:	48 85 d2             	test   %rdx,%rdx
  10e862:	74 36                	je     10e89a <z_impl_k_msgq_put+0x5e>
  10e864:	be dd fb 11 00       	mov    $0x11fbdd,%esi
  10e869:	b9 76 00 00 00       	mov    $0x76,%ecx
  10e86e:	ba bb fb 11 00       	mov    $0x11fbbb,%edx
  10e873:	31 c0                	xor    %eax,%eax
  10e875:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  10e87a:	e8 79 1d ff ff       	callq  1005f8 <printk>
  10e87f:	bf 22 fc 11 00       	mov    $0x11fc22,%edi
  10e884:	31 c0                	xor    %eax,%eax
  10e886:	e8 6d 1d ff ff       	callq  1005f8 <printk>
  10e88b:	be 76 00 00 00       	mov    $0x76,%esi
  10e890:	bf bb fb 11 00       	mov    $0x11fbbb,%edi
  10e895:	e8 fe 42 ff ff       	callq  102b98 <assert_post_action>

	struct k_thread *pending_thread;
	k_spinlock_key_t key;
	int result;

	key = k_spin_lock(&msgq->lock);
  10e89a:	4d 8d 6c 24 10       	lea    0x10(%r12),%r13
  10e89f:	9c                   	pushfq 
  10e8a0:	fa                   	cli    
  10e8a1:	8f 45 c8             	popq   -0x38(%rbp)
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  10e8a4:	4c 89 ef             	mov    %r13,%rdi
  10e8a7:	e8 cd ef ff ff       	callq  10d879 <z_spin_lock_valid>
  10e8ac:	84 c0                	test   %al,%al
  10e8ae:	75 37                	jne    10e8e7 <z_impl_k_msgq_put+0xab>
  10e8b0:	b9 8e 00 00 00       	mov    $0x8e,%ecx
  10e8b5:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  10e8ba:	be fd d1 11 00       	mov    $0x11d1fd,%esi
  10e8bf:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  10e8c4:	e8 2f 1d ff ff       	callq  1005f8 <printk>
  10e8c9:	4c 89 ee             	mov    %r13,%rsi
  10e8cc:	bf 12 d2 11 00       	mov    $0x11d212,%edi
  10e8d1:	31 c0                	xor    %eax,%eax
  10e8d3:	e8 20 1d ff ff       	callq  1005f8 <printk>
  10e8d8:	be 8e 00 00 00       	mov    $0x8e,%esi
  10e8dd:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  10e8e2:	e8 b1 42 ff ff       	callq  102b98 <assert_post_action>
	z_spin_lock_set_owner(l);
  10e8e7:	4c 89 ef             	mov    %r13,%rdi
  10e8ea:	e8 ce ef ff ff       	callq  10d8bd <z_spin_lock_set_owner>

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_msgq, put, msgq, timeout);

	if (msgq->used_msgs < msgq->max_msgs) {
  10e8ef:	41 8b 44 24 20       	mov    0x20(%r12),%eax
  10e8f4:	41 39 44 24 48       	cmp    %eax,0x48(%r12)
  10e8f9:	0f 83 8b 00 00 00    	jae    10e98a <z_impl_k_msgq_put+0x14e>
		/* message queue isn't full */
		pending_thread = z_unpend_first_thread(&msgq->wait_q);
  10e8ff:	4c 89 e7             	mov    %r12,%rdi
  10e902:	e8 56 36 00 00       	callq  111f5d <z_unpend_first_thread>
  10e907:	49 8b 54 24 18       	mov    0x18(%r12),%rdx
		if (pending_thread != NULL) {
  10e90c:	48 85 c0             	test   %rax,%rax
		pending_thread = z_unpend_first_thread(&msgq->wait_q);
  10e90f:	49 89 c6             	mov    %rax,%r14
		if (pending_thread != NULL) {
  10e912:	74 31                	je     10e945 <z_impl_k_msgq_put+0x109>
			SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_msgq, put, msgq, timeout, 0);

			/* give message to waiting thread */
			(void)memcpy(pending_thread->base.swap_data, data,
  10e914:	48 8b 78 20          	mov    0x20(%rax),%rdi
  10e918:	4c 89 fe             	mov    %r15,%rsi
			       msgq->msg_size);
			/* wake up waiting thread */
			arch_thread_return_value_set(pending_thread, 0);
			z_ready_thread(pending_thread);
			z_reschedule(&msgq->lock, key);
			return 0;
  10e91b:	31 db                	xor    %ebx,%ebx
			(void)memcpy(pending_thread->base.swap_data, data,
  10e91d:	e8 76 b7 ff ff       	callq  10a098 <memcpy>
			z_ready_thread(pending_thread);
  10e922:	4c 89 f7             	mov    %r14,%rdi
 * z_swap() is in use it's a simple inline provided by the kernel.
 */
static ALWAYS_INLINE void
arch_thread_return_value_set(struct k_thread *thread, unsigned int value)
{
	thread->swap_retval = value;
  10e925:	41 c7 86 48 01 00 00 	movl   $0x0,0x148(%r14)
  10e92c:	00 00 00 00 
  10e930:	e8 15 2b 00 00       	callq  11144a <z_ready_thread>
			z_reschedule(&msgq->lock, key);
  10e935:	8b 75 c8             	mov    -0x38(%rbp),%esi
  10e938:	4c 89 ef             	mov    %r13,%rdi
  10e93b:	e8 21 24 00 00       	callq  110d61 <z_reschedule>
			return 0;
  10e940:	e9 c4 00 00 00       	jmpq   10ea09 <z_impl_k_msgq_put+0x1cd>
		} else {
			/* put message in queue */
			(void)memcpy(msgq->write_ptr, data, msgq->msg_size);
  10e945:	49 8b 7c 24 40       	mov    0x40(%r12),%rdi
  10e94a:	4c 89 fe             	mov    %r15,%rsi
  10e94d:	e8 46 b7 ff ff       	callq  10a098 <memcpy>
			msgq->write_ptr += msgq->msg_size;
  10e952:	49 8b 44 24 18       	mov    0x18(%r12),%rax
  10e957:	49 03 44 24 40       	add    0x40(%r12),%rax
  10e95c:	49 89 44 24 40       	mov    %rax,0x40(%r12)
			if (msgq->write_ptr == msgq->buffer_end) {
  10e961:	49 3b 44 24 30       	cmp    0x30(%r12),%rax
  10e966:	75 0a                	jne    10e972 <z_impl_k_msgq_put+0x136>
				msgq->write_ptr = msgq->buffer_start;
  10e968:	49 8b 44 24 28       	mov    0x28(%r12),%rax
  10e96d:	49 89 44 24 40       	mov    %rax,0x40(%r12)
			}
			msgq->used_msgs++;
  10e972:	41 ff 44 24 48       	incl   0x48(%r12)
	z_handle_obj_poll_events(&msgq->poll_events, state);
  10e977:	49 8d 7c 24 50       	lea    0x50(%r12),%rdi
  10e97c:	be 10 00 00 00       	mov    $0x10,%esi
#ifdef CONFIG_POLL
			handle_poll_events(msgq, K_POLL_STATE_MSGQ_DATA_AVAILABLE);
#endif /* CONFIG_POLL */
		}
		result = 0;
  10e981:	31 db                	xor    %ebx,%ebx
	z_handle_obj_poll_events(&msgq->poll_events, state);
  10e983:	e8 5d 6c 00 00       	callq  1155e5 <z_handle_obj_poll_events>
		result = 0;
  10e988:	eb 34                	jmp    10e9be <z_impl_k_msgq_put+0x182>
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
		/* don't wait for message space to become available */
		result = -ENOMSG;
  10e98a:	bb dd ff ff ff       	mov    $0xffffffdd,%ebx
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
  10e98f:	4d 85 f6             	test   %r14,%r14
  10e992:	74 2a                	je     10e9be <z_impl_k_msgq_put+0x182>
	} else {
		SYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_msgq, put, msgq, timeout);

		/* wait for put message success, failure, or timeout */
		_current->base.swap_data = (void *) data;
  10e994:	48 8b 05 b5 9d 01 00 	mov    0x19db5(%rip),%rax        # 128750 <_kernel+0x10>

		result = z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
  10e99b:	8b 75 c8             	mov    -0x38(%rbp),%esi
  10e99e:	4c 89 f1             	mov    %r14,%rcx
  10e9a1:	4c 89 e2             	mov    %r12,%rdx
  10e9a4:	4c 89 ef             	mov    %r13,%rdi
		_current->base.swap_data = (void *) data;
  10e9a7:	4c 89 78 20          	mov    %r15,0x20(%rax)
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_msgq, put, msgq, timeout, result);

	k_spin_unlock(&msgq->lock, key);

	return result;
}
  10e9ab:	48 83 c4 18          	add    $0x18,%rsp
  10e9af:	5b                   	pop    %rbx
  10e9b0:	41 5c                	pop    %r12
  10e9b2:	41 5d                	pop    %r13
  10e9b4:	41 5e                	pop    %r14
  10e9b6:	41 5f                	pop    %r15
  10e9b8:	5d                   	pop    %rbp
		result = z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
  10e9b9:	e9 2a 30 00 00       	jmpq   1119e8 <z_pend_curr>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  10e9be:	4c 89 ef             	mov    %r13,%rdi
  10e9c1:	e8 d3 ee ff ff       	callq  10d899 <z_spin_unlock_valid>
  10e9c6:	84 c0                	test   %al,%al
  10e9c8:	75 37                	jne    10ea01 <z_impl_k_msgq_put+0x1c5>
  10e9ca:	b9 b9 00 00 00       	mov    $0xb9,%ecx
  10e9cf:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  10e9d4:	be 41 d2 11 00       	mov    $0x11d241,%esi
  10e9d9:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  10e9de:	e8 15 1c ff ff       	callq  1005f8 <printk>
  10e9e3:	4c 89 ee             	mov    %r13,%rsi
  10e9e6:	bf 58 d2 11 00       	mov    $0x11d258,%edi
  10e9eb:	31 c0                	xor    %eax,%eax
  10e9ed:	e8 06 1c ff ff       	callq  1005f8 <printk>
  10e9f2:	be b9 00 00 00       	mov    $0xb9,%esi
  10e9f7:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  10e9fc:	e8 97 41 ff ff       	callq  102b98 <assert_post_action>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  10ea01:	0f ba 65 c8 09       	btl    $0x9,-0x38(%rbp)
  10ea06:	73 01                	jae    10ea09 <z_impl_k_msgq_put+0x1cd>
		__asm__ volatile ("sti" ::: "memory");
  10ea08:	fb                   	sti    
}
  10ea09:	48 83 c4 18          	add    $0x18,%rsp
  10ea0d:	89 d8                	mov    %ebx,%eax
  10ea0f:	5b                   	pop    %rbx
  10ea10:	41 5c                	pop    %r12
  10ea12:	41 5d                	pop    %r13
  10ea14:	41 5e                	pop    %r14
  10ea16:	41 5f                	pop    %r15
  10ea18:	5d                   	pop    %rbp
  10ea19:	c3                   	retq   

000000000010ea1a <z_mrsh_k_msgq_put>:
#include <syscalls/kernel.h>

extern int z_vrfy_k_msgq_put(struct k_msgq * msgq, const void * data, k_timeout_t timeout);
uintptr_t z_mrsh_k_msgq_put(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
  10ea1a:	55                   	push   %rbp
  10ea1b:	48 89 e5             	mov    %rsp,%rbp
  10ea1e:	41 56                	push   %r14
  10ea20:	49 89 d6             	mov    %rdx,%r14
  10ea23:	41 55                	push   %r13
  10ea25:	49 89 f5             	mov    %rsi,%r13
  10ea28:	41 54                	push   %r12
  10ea2a:	49 89 fc             	mov    %rdi,%r12
  10ea2d:	48 83 ec 18          	sub    $0x18,%rsp
  10ea31:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	_current->syscall_frame = ssf;
  10ea35:	48 8b 05 14 9d 01 00 	mov    0x19d14(%rip),%rax        # 128750 <_kernel+0x10>
  10ea3c:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  10ea40:	48 89 90 40 01 00 00 	mov    %rdx,0x140(%rax)

#ifdef CONFIG_USERSPACE
static inline int z_vrfy_k_msgq_put(struct k_msgq *msgq, const void *data,
				    k_timeout_t timeout)
{
	Z_OOPS(Z_SYSCALL_OBJ(msgq, K_OBJ_MSGQ));
  10ea47:	e8 88 80 00 00       	callq  116ad4 <z_object_find>
  10ea4c:	31 d2                	xor    %edx,%edx
  10ea4e:	4c 89 e6             	mov    %r12,%rsi
  10ea51:	48 89 c7             	mov    %rax,%rdi
  10ea54:	e8 27 fc ff ff       	callq  10e680 <z_obj_validation_check.constprop.0>
  10ea59:	85 c0                	test   %eax,%eax
  10ea5b:	74 18                	je     10ea75 <z_mrsh_k_msgq_put+0x5b>
  10ea5d:	ba 70 c2 11 00       	mov    $0x11c270,%edx
  10ea62:	be 45 00 00 00       	mov    $0x45,%esi
  10ea67:	bf 23 f3 11 00       	mov    $0x11f323,%edi
  10ea6c:	31 c0                	xor    %eax,%eax
  10ea6e:	e8 53 46 ff ff       	callq  1030c6 <z_log_minimal_printk>
  10ea73:	eb 37                	jmp    10eaac <z_mrsh_k_msgq_put+0x92>
	Z_OOPS(Z_SYSCALL_MEMORY_READ(data, msgq->msg_size));
  10ea75:	49 8b 74 24 18       	mov    0x18(%r12),%rsi
  10ea7a:	31 d2                	xor    %edx,%edx
  10ea7c:	4c 89 ef             	mov    %r13,%rdi
  10ea7f:	e8 38 a9 ff ff       	callq  1093bc <arch_buffer_validate>
  10ea84:	85 c0                	test   %eax,%eax
  10ea86:	74 37                	je     10eabf <z_mrsh_k_msgq_put+0xa5>
  10ea88:	4d 8b 44 24 18       	mov    0x18(%r12),%r8
  10ea8d:	41 b9 de 0d 12 00    	mov    $0x120dde,%r9d
  10ea93:	4c 89 e9             	mov    %r13,%rcx
  10ea96:	31 c0                	xor    %eax,%eax
  10ea98:	ba 70 c2 11 00       	mov    $0x11c270,%edx
  10ea9d:	be 45 00 00 00       	mov    $0x45,%esi
  10eaa2:	bf 1e cf 11 00       	mov    $0x11cf1e,%edi
  10eaa7:	e8 1a 46 ff ff       	callq  1030c6 <z_log_minimal_printk>
  10eaac:	48 8b 05 9d 9c 01 00 	mov    0x19c9d(%rip),%rax        # 128750 <_kernel+0x10>
  10eab3:	48 8b b8 40 01 00 00 	mov    0x140(%rax),%rdi
  10eaba:	e8 4e b1 ff ff       	callq  109c0d <arch_syscall_oops>

	return z_impl_k_msgq_put(msgq, data, timeout);
  10eabf:	4c 89 f2             	mov    %r14,%rdx
  10eac2:	4c 89 ee             	mov    %r13,%rsi
  10eac5:	4c 89 e7             	mov    %r12,%rdi
  10eac8:	e8 6f fd ff ff       	callq  10e83c <z_impl_k_msgq_put>
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	int ret = z_vrfy_k_msgq_put(*(struct k_msgq **)&arg0, *(const void **)&arg1, *(k_timeout_t*)&arg2)
;
	_current->syscall_frame = NULL;
  10eacd:	48 8b 15 7c 9c 01 00 	mov    0x19c7c(%rip),%rdx        # 128750 <_kernel+0x10>
	return (uintptr_t) ret;
  10ead4:	48 98                	cltq   
	_current->syscall_frame = NULL;
  10ead6:	48 c7 82 40 01 00 00 	movq   $0x0,0x140(%rdx)
  10eadd:	00 00 00 00 
}
  10eae1:	48 83 c4 18          	add    $0x18,%rsp
  10eae5:	41 5c                	pop    %r12
  10eae7:	41 5d                	pop    %r13
  10eae9:	41 5e                	pop    %r14
  10eaeb:	5d                   	pop    %rbp
  10eaec:	c3                   	retq   

000000000010eaed <z_mrsh_k_msgq_get_attrs>:
#include <syscalls/kernel.h>

extern void z_vrfy_k_msgq_get_attrs(struct k_msgq * msgq, struct k_msgq_attrs * attrs);
uintptr_t z_mrsh_k_msgq_get_attrs(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
  10eaed:	55                   	push   %rbp
	_current->syscall_frame = ssf;
  10eaee:	48 8b 05 5b 9c 01 00 	mov    0x19c5b(%rip),%rax        # 128750 <_kernel+0x10>
{
  10eaf5:	48 89 e5             	mov    %rsp,%rbp
  10eaf8:	41 54                	push   %r12
  10eafa:	49 89 f4             	mov    %rsi,%r12
	_current->syscall_frame = ssf;
  10eafd:	48 8b 55 10          	mov    0x10(%rbp),%rdx
{
  10eb01:	53                   	push   %rbx
  10eb02:	48 89 fb             	mov    %rdi,%rbx
	_current->syscall_frame = ssf;
  10eb05:	48 89 90 40 01 00 00 	mov    %rdx,0x140(%rax)

#ifdef CONFIG_USERSPACE
static inline void z_vrfy_k_msgq_get_attrs(struct k_msgq *msgq,
					   struct k_msgq_attrs *attrs)
{
	Z_OOPS(Z_SYSCALL_OBJ(msgq, K_OBJ_MSGQ));
  10eb0c:	e8 c3 7f 00 00       	callq  116ad4 <z_object_find>
  10eb11:	31 d2                	xor    %edx,%edx
  10eb13:	48 89 de             	mov    %rbx,%rsi
  10eb16:	48 89 c7             	mov    %rax,%rdi
  10eb19:	e8 62 fb ff ff       	callq  10e680 <z_obj_validation_check.constprop.0>
  10eb1e:	85 c0                	test   %eax,%eax
  10eb20:	74 18                	je     10eb3a <z_mrsh_k_msgq_get_attrs+0x4d>
  10eb22:	ba 50 c2 11 00       	mov    $0x11c250,%edx
  10eb27:	be 45 00 00 00       	mov    $0x45,%esi
  10eb2c:	bf 23 f3 11 00       	mov    $0x11f323,%edi
  10eb31:	31 c0                	xor    %eax,%eax
  10eb33:	e8 8e 45 ff ff       	callq  1030c6 <z_log_minimal_printk>
  10eb38:	eb 3b                	jmp    10eb75 <z_mrsh_k_msgq_get_attrs+0x88>
	Z_OOPS(Z_SYSCALL_MEMORY_WRITE(attrs, sizeof(struct k_msgq_attrs)));
  10eb3a:	ba 01 00 00 00       	mov    $0x1,%edx
  10eb3f:	be 10 00 00 00       	mov    $0x10,%esi
  10eb44:	4c 89 e7             	mov    %r12,%rdi
  10eb47:	e8 70 a8 ff ff       	callq  1093bc <arch_buffer_validate>
  10eb4c:	85 c0                	test   %eax,%eax
  10eb4e:	74 38                	je     10eb88 <z_mrsh_k_msgq_get_attrs+0x9b>
  10eb50:	41 b9 a4 d2 11 00    	mov    $0x11d2a4,%r9d
  10eb56:	4c 89 e1             	mov    %r12,%rcx
  10eb59:	ba 50 c2 11 00       	mov    $0x11c250,%edx
  10eb5e:	31 c0                	xor    %eax,%eax
  10eb60:	41 b8 10 00 00 00    	mov    $0x10,%r8d
  10eb66:	be 45 00 00 00       	mov    $0x45,%esi
  10eb6b:	bf 1e cf 11 00       	mov    $0x11cf1e,%edi
  10eb70:	e8 51 45 ff ff       	callq  1030c6 <z_log_minimal_printk>
  10eb75:	48 8b 05 d4 9b 01 00 	mov    0x19bd4(%rip),%rax        # 128750 <_kernel+0x10>
  10eb7c:	48 8b b8 40 01 00 00 	mov    0x140(%rax),%rdi
  10eb83:	e8 85 b0 ff ff       	callq  109c0d <arch_syscall_oops>
	attrs->msg_size = msgq->msg_size;
  10eb88:	48 8b 43 18          	mov    0x18(%rbx),%rax
  10eb8c:	49 89 04 24          	mov    %rax,(%r12)
	attrs->max_msgs = msgq->max_msgs;
  10eb90:	8b 43 20             	mov    0x20(%rbx),%eax
  10eb93:	41 89 44 24 08       	mov    %eax,0x8(%r12)
	attrs->used_msgs = msgq->used_msgs;
  10eb98:	8b 43 48             	mov    0x48(%rbx),%eax
  10eb9b:	41 89 44 24 0c       	mov    %eax,0xc(%r12)
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	z_vrfy_k_msgq_get_attrs(*(struct k_msgq **)&arg0, *(struct k_msgq_attrs **)&arg1)
;
	_current->syscall_frame = NULL;
  10eba0:	48 8b 05 a9 9b 01 00 	mov    0x19ba9(%rip),%rax        # 128750 <_kernel+0x10>
  10eba7:	48 c7 80 40 01 00 00 	movq   $0x0,0x140(%rax)
  10ebae:	00 00 00 00 
	return 0;
}
  10ebb2:	31 c0                	xor    %eax,%eax
  10ebb4:	5b                   	pop    %rbx
  10ebb5:	41 5c                	pop    %r12
  10ebb7:	5d                   	pop    %rbp
  10ebb8:	c3                   	retq   

000000000010ebb9 <z_impl_k_msgq_get>:
}
#include <syscalls/k_msgq_get_attrs_mrsh.c>
#endif

int z_impl_k_msgq_get(struct k_msgq *msgq, void *data, k_timeout_t timeout)
{
  10ebb9:	55                   	push   %rbp
  10ebba:	48 89 e5             	mov    %rsp,%rbp
  10ebbd:	41 57                	push   %r15
  10ebbf:	41 56                	push   %r14
  10ebc1:	49 89 d6             	mov    %rdx,%r14
  10ebc4:	41 55                	push   %r13
  10ebc6:	41 54                	push   %r12
  10ebc8:	49 89 fc             	mov    %rdi,%r12
  10ebcb:	53                   	push   %rbx
  10ebcc:	48 83 ec 18          	sub    $0x18,%rsp
	__ASSERT(!arch_is_in_isr() || K_TIMEOUT_EQ(timeout, K_NO_WAIT), "");
  10ebd0:	83 3d 69 9b 01 00 00 	cmpl   $0x0,0x19b69(%rip)        # 128740 <_kernel>
{
  10ebd7:	48 89 75 c8          	mov    %rsi,-0x38(%rbp)
	__ASSERT(!arch_is_in_isr() || K_TIMEOUT_EQ(timeout, K_NO_WAIT), "");
  10ebdb:	74 3b                	je     10ec18 <z_impl_k_msgq_get+0x5f>
  10ebdd:	48 85 d2             	test   %rdx,%rdx
  10ebe0:	74 36                	je     10ec18 <z_impl_k_msgq_get+0x5f>
  10ebe2:	be dd fb 11 00       	mov    $0x11fbdd,%esi
  10ebe7:	b9 d0 00 00 00       	mov    $0xd0,%ecx
  10ebec:	ba bb fb 11 00       	mov    $0x11fbbb,%edx
  10ebf1:	31 c0                	xor    %eax,%eax
  10ebf3:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  10ebf8:	e8 fb 19 ff ff       	callq  1005f8 <printk>
  10ebfd:	bf 22 fc 11 00       	mov    $0x11fc22,%edi
  10ec02:	31 c0                	xor    %eax,%eax
  10ec04:	e8 ef 19 ff ff       	callq  1005f8 <printk>
  10ec09:	be d0 00 00 00       	mov    $0xd0,%esi
  10ec0e:	bf bb fb 11 00       	mov    $0x11fbbb,%edi
  10ec13:	e8 80 3f ff ff       	callq  102b98 <assert_post_action>

	k_spinlock_key_t key;
	struct k_thread *pending_thread;
	int result;

	key = k_spin_lock(&msgq->lock);
  10ec18:	4d 8d 6c 24 10       	lea    0x10(%r12),%r13
  10ec1d:	9c                   	pushfq 
  10ec1e:	fa                   	cli    
  10ec1f:	5b                   	pop    %rbx
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  10ec20:	4c 89 ef             	mov    %r13,%rdi
  10ec23:	e8 51 ec ff ff       	callq  10d879 <z_spin_lock_valid>
  10ec28:	84 c0                	test   %al,%al
  10ec2a:	75 37                	jne    10ec63 <z_impl_k_msgq_get+0xaa>
  10ec2c:	b9 8e 00 00 00       	mov    $0x8e,%ecx
  10ec31:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  10ec36:	be fd d1 11 00       	mov    $0x11d1fd,%esi
  10ec3b:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  10ec40:	e8 b3 19 ff ff       	callq  1005f8 <printk>
  10ec45:	4c 89 ee             	mov    %r13,%rsi
  10ec48:	bf 12 d2 11 00       	mov    $0x11d212,%edi
  10ec4d:	31 c0                	xor    %eax,%eax
  10ec4f:	e8 a4 19 ff ff       	callq  1005f8 <printk>
  10ec54:	be 8e 00 00 00       	mov    $0x8e,%esi
  10ec59:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  10ec5e:	e8 35 3f ff ff       	callq  102b98 <assert_post_action>
	z_spin_lock_set_owner(l);
  10ec63:	4c 89 ef             	mov    %r13,%rdi
  10ec66:	e8 52 ec ff ff       	callq  10d8bd <z_spin_lock_set_owner>

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_msgq, get, msgq, timeout);

	if (msgq->used_msgs > 0U) {
  10ec6b:	41 83 7c 24 48 00    	cmpl   $0x0,0x48(%r12)
  10ec71:	0f 84 ac 00 00 00    	je     10ed23 <z_impl_k_msgq_get+0x16a>
		/* take first available message from queue */
		(void)memcpy(data, msgq->read_ptr, msgq->msg_size);
  10ec77:	49 8b 54 24 18       	mov    0x18(%r12),%rdx
  10ec7c:	49 8b 74 24 38       	mov    0x38(%r12),%rsi
  10ec81:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
  10ec85:	e8 0e b4 ff ff       	callq  10a098 <memcpy>
		msgq->read_ptr += msgq->msg_size;
  10ec8a:	49 8b 44 24 18       	mov    0x18(%r12),%rax
  10ec8f:	49 03 44 24 38       	add    0x38(%r12),%rax
  10ec94:	49 89 44 24 38       	mov    %rax,0x38(%r12)
		if (msgq->read_ptr == msgq->buffer_end) {
  10ec99:	49 3b 44 24 30       	cmp    0x30(%r12),%rax
  10ec9e:	75 0a                	jne    10ecaa <z_impl_k_msgq_get+0xf1>
			msgq->read_ptr = msgq->buffer_start;
  10eca0:	49 8b 44 24 28       	mov    0x28(%r12),%rax
  10eca5:	49 89 44 24 38       	mov    %rax,0x38(%r12)
		}
		msgq->used_msgs--;
  10ecaa:	41 ff 4c 24 48       	decl   0x48(%r12)

		/* handle first thread waiting to write (if any) */
		pending_thread = z_unpend_first_thread(&msgq->wait_q);
  10ecaf:	4c 89 e7             	mov    %r12,%rdi

			SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_msgq, get, msgq, timeout, 0);

			return 0;
		}
		result = 0;
  10ecb2:	45 31 ff             	xor    %r15d,%r15d
		pending_thread = z_unpend_first_thread(&msgq->wait_q);
  10ecb5:	e8 a3 32 00 00       	callq  111f5d <z_unpend_first_thread>
  10ecba:	49 89 c6             	mov    %rax,%r14
		if (pending_thread != NULL) {
  10ecbd:	48 85 c0             	test   %rax,%rax
  10ecc0:	0f 84 95 00 00 00    	je     10ed5b <z_impl_k_msgq_get+0x1a2>
			(void)memcpy(msgq->write_ptr, pending_thread->base.swap_data,
  10ecc6:	49 8b 54 24 18       	mov    0x18(%r12),%rdx
  10eccb:	48 8b 70 20          	mov    0x20(%rax),%rsi
  10eccf:	49 8b 7c 24 40       	mov    0x40(%r12),%rdi
  10ecd4:	e8 bf b3 ff ff       	callq  10a098 <memcpy>
			msgq->write_ptr += msgq->msg_size;
  10ecd9:	49 8b 44 24 18       	mov    0x18(%r12),%rax
  10ecde:	49 03 44 24 40       	add    0x40(%r12),%rax
  10ece3:	49 89 44 24 40       	mov    %rax,0x40(%r12)
			if (msgq->write_ptr == msgq->buffer_end) {
  10ece8:	49 3b 44 24 30       	cmp    0x30(%r12),%rax
  10eced:	75 0a                	jne    10ecf9 <z_impl_k_msgq_get+0x140>
				msgq->write_ptr = msgq->buffer_start;
  10ecef:	49 8b 44 24 28       	mov    0x28(%r12),%rax
  10ecf4:	49 89 44 24 40       	mov    %rax,0x40(%r12)
			msgq->used_msgs++;
  10ecf9:	41 ff 44 24 48       	incl   0x48(%r12)
			z_ready_thread(pending_thread);
  10ecfe:	4c 89 f7             	mov    %r14,%rdi
			return 0;
  10ed01:	45 31 ff             	xor    %r15d,%r15d
  10ed04:	41 c7 86 48 01 00 00 	movl   $0x0,0x148(%r14)
  10ed0b:	00 00 00 00 
			z_ready_thread(pending_thread);
  10ed0f:	e8 36 27 00 00       	callq  11144a <z_ready_thread>
			z_reschedule(&msgq->lock, key);
  10ed14:	89 de                	mov    %ebx,%esi
  10ed16:	4c 89 ef             	mov    %r13,%rdi
  10ed19:	e8 43 20 00 00       	callq  110d61 <z_reschedule>
			return 0;
  10ed1e:	e9 82 00 00 00       	jmpq   10eda5 <z_impl_k_msgq_get+0x1ec>
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
		/* don't wait for a message to become available */
		result = -ENOMSG;
  10ed23:	41 bf dd ff ff ff    	mov    $0xffffffdd,%r15d
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
  10ed29:	4d 85 f6             	test   %r14,%r14
  10ed2c:	74 2d                	je     10ed5b <z_impl_k_msgq_get+0x1a2>
	} else {
		SYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_msgq, get, msgq, timeout);

		/* wait for get message success or timeout */
		_current->base.swap_data = data;
  10ed2e:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  10ed32:	48 8b 05 17 9a 01 00 	mov    0x19a17(%rip),%rax        # 128750 <_kernel+0x10>

		result = z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
  10ed39:	4c 89 e2             	mov    %r12,%rdx
  10ed3c:	89 de                	mov    %ebx,%esi
  10ed3e:	4c 89 ef             	mov    %r13,%rdi
		_current->base.swap_data = data;
  10ed41:	48 89 48 20          	mov    %rcx,0x20(%rax)
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_msgq, get, msgq, timeout, result);

	k_spin_unlock(&msgq->lock, key);

	return result;
}
  10ed45:	48 83 c4 18          	add    $0x18,%rsp
		result = z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
  10ed49:	4c 89 f1             	mov    %r14,%rcx
}
  10ed4c:	5b                   	pop    %rbx
  10ed4d:	41 5c                	pop    %r12
  10ed4f:	41 5d                	pop    %r13
  10ed51:	41 5e                	pop    %r14
  10ed53:	41 5f                	pop    %r15
  10ed55:	5d                   	pop    %rbp
		result = z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
  10ed56:	e9 8d 2c 00 00       	jmpq   1119e8 <z_pend_curr>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  10ed5b:	4c 89 ef             	mov    %r13,%rdi
  10ed5e:	e8 36 eb ff ff       	callq  10d899 <z_spin_unlock_valid>
  10ed63:	84 c0                	test   %al,%al
  10ed65:	75 37                	jne    10ed9e <z_impl_k_msgq_get+0x1e5>
  10ed67:	b9 b9 00 00 00       	mov    $0xb9,%ecx
  10ed6c:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  10ed71:	be 41 d2 11 00       	mov    $0x11d241,%esi
  10ed76:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  10ed7b:	e8 78 18 ff ff       	callq  1005f8 <printk>
  10ed80:	4c 89 ee             	mov    %r13,%rsi
  10ed83:	bf 58 d2 11 00       	mov    $0x11d258,%edi
  10ed88:	31 c0                	xor    %eax,%eax
  10ed8a:	e8 69 18 ff ff       	callq  1005f8 <printk>
  10ed8f:	be b9 00 00 00       	mov    $0xb9,%esi
  10ed94:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  10ed99:	e8 fa 3d ff ff       	callq  102b98 <assert_post_action>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  10ed9e:	0f ba e3 09          	bt     $0x9,%ebx
  10eda2:	73 01                	jae    10eda5 <z_impl_k_msgq_get+0x1ec>
		__asm__ volatile ("sti" ::: "memory");
  10eda4:	fb                   	sti    
}
  10eda5:	48 83 c4 18          	add    $0x18,%rsp
  10eda9:	44 89 f8             	mov    %r15d,%eax
  10edac:	5b                   	pop    %rbx
  10edad:	41 5c                	pop    %r12
  10edaf:	41 5d                	pop    %r13
  10edb1:	41 5e                	pop    %r14
  10edb3:	41 5f                	pop    %r15
  10edb5:	5d                   	pop    %rbp
  10edb6:	c3                   	retq   

000000000010edb7 <z_mrsh_k_msgq_get>:
#include <syscalls/kernel.h>

extern int z_vrfy_k_msgq_get(struct k_msgq * msgq, void * data, k_timeout_t timeout);
uintptr_t z_mrsh_k_msgq_get(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
  10edb7:	55                   	push   %rbp
  10edb8:	48 89 e5             	mov    %rsp,%rbp
  10edbb:	41 56                	push   %r14
  10edbd:	49 89 d6             	mov    %rdx,%r14
  10edc0:	41 55                	push   %r13
  10edc2:	49 89 f5             	mov    %rsi,%r13
  10edc5:	41 54                	push   %r12
  10edc7:	49 89 fc             	mov    %rdi,%r12
  10edca:	48 83 ec 18          	sub    $0x18,%rsp
  10edce:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	_current->syscall_frame = ssf;
  10edd2:	48 8b 05 77 99 01 00 	mov    0x19977(%rip),%rax        # 128750 <_kernel+0x10>
  10edd9:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  10eddd:	48 89 90 40 01 00 00 	mov    %rdx,0x140(%rax)

#ifdef CONFIG_USERSPACE
static inline int z_vrfy_k_msgq_get(struct k_msgq *msgq, void *data,
				    k_timeout_t timeout)
{
	Z_OOPS(Z_SYSCALL_OBJ(msgq, K_OBJ_MSGQ));
  10ede4:	e8 eb 7c 00 00       	callq  116ad4 <z_object_find>
  10ede9:	31 d2                	xor    %edx,%edx
  10edeb:	4c 89 e6             	mov    %r12,%rsi
  10edee:	48 89 c7             	mov    %rax,%rdi
  10edf1:	e8 8a f8 ff ff       	callq  10e680 <z_obj_validation_check.constprop.0>
  10edf6:	85 c0                	test   %eax,%eax
  10edf8:	74 18                	je     10ee12 <z_mrsh_k_msgq_get+0x5b>
  10edfa:	ba 30 c2 11 00       	mov    $0x11c230,%edx
  10edff:	be 45 00 00 00       	mov    $0x45,%esi
  10ee04:	bf 23 f3 11 00       	mov    $0x11f323,%edi
  10ee09:	31 c0                	xor    %eax,%eax
  10ee0b:	e8 b6 42 ff ff       	callq  1030c6 <z_log_minimal_printk>
  10ee10:	eb 3a                	jmp    10ee4c <z_mrsh_k_msgq_get+0x95>
	Z_OOPS(Z_SYSCALL_MEMORY_WRITE(data, msgq->msg_size));
  10ee12:	49 8b 74 24 18       	mov    0x18(%r12),%rsi
  10ee17:	ba 01 00 00 00       	mov    $0x1,%edx
  10ee1c:	4c 89 ef             	mov    %r13,%rdi
  10ee1f:	e8 98 a5 ff ff       	callq  1093bc <arch_buffer_validate>
  10ee24:	85 c0                	test   %eax,%eax
  10ee26:	74 37                	je     10ee5f <z_mrsh_k_msgq_get+0xa8>
  10ee28:	4d 8b 44 24 18       	mov    0x18(%r12),%r8
  10ee2d:	41 b9 a4 d2 11 00    	mov    $0x11d2a4,%r9d
  10ee33:	4c 89 e9             	mov    %r13,%rcx
  10ee36:	31 c0                	xor    %eax,%eax
  10ee38:	ba 30 c2 11 00       	mov    $0x11c230,%edx
  10ee3d:	be 45 00 00 00       	mov    $0x45,%esi
  10ee42:	bf 1e cf 11 00       	mov    $0x11cf1e,%edi
  10ee47:	e8 7a 42 ff ff       	callq  1030c6 <z_log_minimal_printk>
  10ee4c:	48 8b 05 fd 98 01 00 	mov    0x198fd(%rip),%rax        # 128750 <_kernel+0x10>
  10ee53:	48 8b b8 40 01 00 00 	mov    0x140(%rax),%rdi
  10ee5a:	e8 ae ad ff ff       	callq  109c0d <arch_syscall_oops>

	return z_impl_k_msgq_get(msgq, data, timeout);
  10ee5f:	4c 89 f2             	mov    %r14,%rdx
  10ee62:	4c 89 ee             	mov    %r13,%rsi
  10ee65:	4c 89 e7             	mov    %r12,%rdi
  10ee68:	e8 4c fd ff ff       	callq  10ebb9 <z_impl_k_msgq_get>
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	int ret = z_vrfy_k_msgq_get(*(struct k_msgq **)&arg0, *(void **)&arg1, *(k_timeout_t*)&arg2)
;
	_current->syscall_frame = NULL;
  10ee6d:	48 8b 15 dc 98 01 00 	mov    0x198dc(%rip),%rdx        # 128750 <_kernel+0x10>
	return (uintptr_t) ret;
  10ee74:	48 98                	cltq   
	_current->syscall_frame = NULL;
  10ee76:	48 c7 82 40 01 00 00 	movq   $0x0,0x140(%rdx)
  10ee7d:	00 00 00 00 
}
  10ee81:	48 83 c4 18          	add    $0x18,%rsp
  10ee85:	41 5c                	pop    %r12
  10ee87:	41 5d                	pop    %r13
  10ee89:	41 5e                	pop    %r14
  10ee8b:	5d                   	pop    %rbp
  10ee8c:	c3                   	retq   

000000000010ee8d <z_impl_k_msgq_peek>:
}
#include <syscalls/k_msgq_get_mrsh.c>
#endif

int z_impl_k_msgq_peek(struct k_msgq *msgq, void *data)
{
  10ee8d:	55                   	push   %rbp
  10ee8e:	48 89 e5             	mov    %rsp,%rbp
  10ee91:	41 57                	push   %r15
  10ee93:	41 56                	push   %r14
  10ee95:	41 55                	push   %r13
  10ee97:	49 89 f5             	mov    %rsi,%r13
  10ee9a:	41 54                	push   %r12
	k_spinlock_key_t key;
	int result;

	key = k_spin_lock(&msgq->lock);
  10ee9c:	4c 8d 67 10          	lea    0x10(%rdi),%r12
{
  10eea0:	53                   	push   %rbx
  10eea1:	48 89 fb             	mov    %rdi,%rbx
  10eea4:	51                   	push   %rcx
  10eea5:	9c                   	pushfq 
  10eea6:	fa                   	cli    
  10eea7:	41 5f                	pop    %r15
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  10eea9:	4c 89 e7             	mov    %r12,%rdi
  10eeac:	e8 c8 e9 ff ff       	callq  10d879 <z_spin_lock_valid>
  10eeb1:	84 c0                	test   %al,%al
  10eeb3:	75 37                	jne    10eeec <z_impl_k_msgq_peek+0x5f>
  10eeb5:	b9 8e 00 00 00       	mov    $0x8e,%ecx
  10eeba:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  10eebf:	be fd d1 11 00       	mov    $0x11d1fd,%esi
  10eec4:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  10eec9:	e8 2a 17 ff ff       	callq  1005f8 <printk>
  10eece:	4c 89 e6             	mov    %r12,%rsi
  10eed1:	bf 12 d2 11 00       	mov    $0x11d212,%edi
  10eed6:	31 c0                	xor    %eax,%eax
  10eed8:	e8 1b 17 ff ff       	callq  1005f8 <printk>
  10eedd:	be 8e 00 00 00       	mov    $0x8e,%esi
  10eee2:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  10eee7:	e8 ac 3c ff ff       	callq  102b98 <assert_post_action>
	z_spin_lock_set_owner(l);
  10eeec:	4c 89 e7             	mov    %r12,%rdi
		/* take first available message from queue */
		(void)memcpy(data, msgq->read_ptr, msgq->msg_size);
		result = 0;
	} else {
		/* don't wait for a message to become available */
		result = -ENOMSG;
  10eeef:	41 be dd ff ff ff    	mov    $0xffffffdd,%r14d
  10eef5:	e8 c3 e9 ff ff       	callq  10d8bd <z_spin_lock_set_owner>
	if (msgq->used_msgs > 0U) {
  10eefa:	83 7b 48 00          	cmpl   $0x0,0x48(%rbx)
  10eefe:	74 13                	je     10ef13 <z_impl_k_msgq_peek+0x86>
		(void)memcpy(data, msgq->read_ptr, msgq->msg_size);
  10ef00:	48 8b 53 18          	mov    0x18(%rbx),%rdx
  10ef04:	48 8b 73 38          	mov    0x38(%rbx),%rsi
  10ef08:	4c 89 ef             	mov    %r13,%rdi
		result = 0;
  10ef0b:	45 31 f6             	xor    %r14d,%r14d
		(void)memcpy(data, msgq->read_ptr, msgq->msg_size);
  10ef0e:	e8 85 b1 ff ff       	callq  10a098 <memcpy>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  10ef13:	4c 89 e7             	mov    %r12,%rdi
  10ef16:	e8 7e e9 ff ff       	callq  10d899 <z_spin_unlock_valid>
  10ef1b:	84 c0                	test   %al,%al
  10ef1d:	75 37                	jne    10ef56 <z_impl_k_msgq_peek+0xc9>
  10ef1f:	b9 b9 00 00 00       	mov    $0xb9,%ecx
  10ef24:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  10ef29:	be 41 d2 11 00       	mov    $0x11d241,%esi
  10ef2e:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  10ef33:	e8 c0 16 ff ff       	callq  1005f8 <printk>
  10ef38:	4c 89 e6             	mov    %r12,%rsi
  10ef3b:	bf 58 d2 11 00       	mov    $0x11d258,%edi
  10ef40:	31 c0                	xor    %eax,%eax
  10ef42:	e8 b1 16 ff ff       	callq  1005f8 <printk>
  10ef47:	be b9 00 00 00       	mov    $0xb9,%esi
  10ef4c:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  10ef51:	e8 42 3c ff ff       	callq  102b98 <assert_post_action>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  10ef56:	41 0f ba e7 09       	bt     $0x9,%r15d
  10ef5b:	73 01                	jae    10ef5e <z_impl_k_msgq_peek+0xd1>
		__asm__ volatile ("sti" ::: "memory");
  10ef5d:	fb                   	sti    
	SYS_PORT_TRACING_OBJ_FUNC(k_msgq, peek, msgq, result);

	k_spin_unlock(&msgq->lock, key);

	return result;
}
  10ef5e:	5a                   	pop    %rdx
  10ef5f:	44 89 f0             	mov    %r14d,%eax
  10ef62:	5b                   	pop    %rbx
  10ef63:	41 5c                	pop    %r12
  10ef65:	41 5d                	pop    %r13
  10ef67:	41 5e                	pop    %r14
  10ef69:	41 5f                	pop    %r15
  10ef6b:	5d                   	pop    %rbp
  10ef6c:	c3                   	retq   

000000000010ef6d <z_mrsh_k_msgq_peek>:
#include <syscalls/kernel.h>

extern int z_vrfy_k_msgq_peek(struct k_msgq * msgq, void * data);
uintptr_t z_mrsh_k_msgq_peek(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
  10ef6d:	55                   	push   %rbp
	_current->syscall_frame = ssf;
  10ef6e:	48 8b 05 db 97 01 00 	mov    0x197db(%rip),%rax        # 128750 <_kernel+0x10>
{
  10ef75:	48 89 e5             	mov    %rsp,%rbp
  10ef78:	41 55                	push   %r13
  10ef7a:	49 89 f5             	mov    %rsi,%r13
	_current->syscall_frame = ssf;
  10ef7d:	48 8b 55 10          	mov    0x10(%rbp),%rdx
{
  10ef81:	41 54                	push   %r12
  10ef83:	49 89 fc             	mov    %rdi,%r12
	_current->syscall_frame = ssf;
  10ef86:	48 89 90 40 01 00 00 	mov    %rdx,0x140(%rax)

#ifdef CONFIG_USERSPACE
static inline int z_vrfy_k_msgq_peek(struct k_msgq *msgq, void *data)
{
	Z_OOPS(Z_SYSCALL_OBJ(msgq, K_OBJ_MSGQ));
  10ef8d:	e8 42 7b 00 00       	callq  116ad4 <z_object_find>
  10ef92:	31 d2                	xor    %edx,%edx
  10ef94:	4c 89 e6             	mov    %r12,%rsi
  10ef97:	48 89 c7             	mov    %rax,%rdi
  10ef9a:	e8 e1 f6 ff ff       	callq  10e680 <z_obj_validation_check.constprop.0>
  10ef9f:	85 c0                	test   %eax,%eax
  10efa1:	74 18                	je     10efbb <z_mrsh_k_msgq_peek+0x4e>
  10efa3:	ba 10 c2 11 00       	mov    $0x11c210,%edx
  10efa8:	be 45 00 00 00       	mov    $0x45,%esi
  10efad:	bf 23 f3 11 00       	mov    $0x11f323,%edi
  10efb2:	31 c0                	xor    %eax,%eax
  10efb4:	e8 0d 41 ff ff       	callq  1030c6 <z_log_minimal_printk>
  10efb9:	eb 3a                	jmp    10eff5 <z_mrsh_k_msgq_peek+0x88>
	Z_OOPS(Z_SYSCALL_MEMORY_WRITE(data, msgq->msg_size));
  10efbb:	49 8b 74 24 18       	mov    0x18(%r12),%rsi
  10efc0:	ba 01 00 00 00       	mov    $0x1,%edx
  10efc5:	4c 89 ef             	mov    %r13,%rdi
  10efc8:	e8 ef a3 ff ff       	callq  1093bc <arch_buffer_validate>
  10efcd:	85 c0                	test   %eax,%eax
  10efcf:	74 37                	je     10f008 <z_mrsh_k_msgq_peek+0x9b>
  10efd1:	4d 8b 44 24 18       	mov    0x18(%r12),%r8
  10efd6:	41 b9 a4 d2 11 00    	mov    $0x11d2a4,%r9d
  10efdc:	4c 89 e9             	mov    %r13,%rcx
  10efdf:	31 c0                	xor    %eax,%eax
  10efe1:	ba 10 c2 11 00       	mov    $0x11c210,%edx
  10efe6:	be 45 00 00 00       	mov    $0x45,%esi
  10efeb:	bf 1e cf 11 00       	mov    $0x11cf1e,%edi
  10eff0:	e8 d1 40 ff ff       	callq  1030c6 <z_log_minimal_printk>
  10eff5:	48 8b 05 54 97 01 00 	mov    0x19754(%rip),%rax        # 128750 <_kernel+0x10>
  10effc:	48 8b b8 40 01 00 00 	mov    0x140(%rax),%rdi
  10f003:	e8 05 ac ff ff       	callq  109c0d <arch_syscall_oops>

	return z_impl_k_msgq_peek(msgq, data);
  10f008:	4c 89 ee             	mov    %r13,%rsi
  10f00b:	4c 89 e7             	mov    %r12,%rdi
  10f00e:	e8 7a fe ff ff       	callq  10ee8d <z_impl_k_msgq_peek>
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	int ret = z_vrfy_k_msgq_peek(*(struct k_msgq **)&arg0, *(void **)&arg1)
;
	_current->syscall_frame = NULL;
  10f013:	48 8b 15 36 97 01 00 	mov    0x19736(%rip),%rdx        # 128750 <_kernel+0x10>
	return (uintptr_t) ret;
  10f01a:	48 98                	cltq   
	_current->syscall_frame = NULL;
  10f01c:	48 c7 82 40 01 00 00 	movq   $0x0,0x140(%rdx)
  10f023:	00 00 00 00 
}
  10f027:	41 5c                	pop    %r12
  10f029:	41 5d                	pop    %r13
  10f02b:	5d                   	pop    %rbp
  10f02c:	c3                   	retq   

000000000010f02d <z_impl_k_msgq_purge>:
}
#include <syscalls/k_msgq_peek_mrsh.c>
#endif

void z_impl_k_msgq_purge(struct k_msgq *msgq)
{
  10f02d:	55                   	push   %rbp
  10f02e:	48 89 e5             	mov    %rsp,%rbp
  10f031:	41 55                	push   %r13
  10f033:	41 54                	push   %r12
	k_spinlock_key_t key;
	struct k_thread *pending_thread;

	key = k_spin_lock(&msgq->lock);
  10f035:	4c 8d 67 10          	lea    0x10(%rdi),%r12
{
  10f039:	53                   	push   %rbx
  10f03a:	48 89 fb             	mov    %rdi,%rbx
  10f03d:	52                   	push   %rdx
  10f03e:	9c                   	pushfq 
  10f03f:	fa                   	cli    
  10f040:	41 5d                	pop    %r13
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  10f042:	4c 89 e7             	mov    %r12,%rdi
  10f045:	e8 2f e8 ff ff       	callq  10d879 <z_spin_lock_valid>
  10f04a:	84 c0                	test   %al,%al
  10f04c:	75 37                	jne    10f085 <z_impl_k_msgq_purge+0x58>
  10f04e:	b9 8e 00 00 00       	mov    $0x8e,%ecx
  10f053:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  10f058:	be fd d1 11 00       	mov    $0x11d1fd,%esi
  10f05d:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  10f062:	e8 91 15 ff ff       	callq  1005f8 <printk>
  10f067:	4c 89 e6             	mov    %r12,%rsi
  10f06a:	bf 12 d2 11 00       	mov    $0x11d212,%edi
  10f06f:	31 c0                	xor    %eax,%eax
  10f071:	e8 82 15 ff ff       	callq  1005f8 <printk>
  10f076:	be 8e 00 00 00       	mov    $0x8e,%esi
  10f07b:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  10f080:	e8 13 3b ff ff       	callq  102b98 <assert_post_action>
	z_spin_lock_set_owner(l);
  10f085:	4c 89 e7             	mov    %r12,%rdi
  10f088:	e8 30 e8 ff ff       	callq  10d8bd <z_spin_lock_set_owner>

	SYS_PORT_TRACING_OBJ_FUNC(k_msgq, purge, msgq);

	/* wake up any threads that are waiting to write */
	while ((pending_thread = z_unpend_first_thread(&msgq->wait_q)) != NULL) {
  10f08d:	48 89 df             	mov    %rbx,%rdi
  10f090:	e8 c8 2e 00 00       	callq  111f5d <z_unpend_first_thread>
  10f095:	48 89 c7             	mov    %rax,%rdi
  10f098:	48 85 c0             	test   %rax,%rax
  10f09b:	74 11                	je     10f0ae <z_impl_k_msgq_purge+0x81>
  10f09d:	c7 87 48 01 00 00 dd 	movl   $0xffffffdd,0x148(%rdi)
  10f0a4:	ff ff ff 
		arch_thread_return_value_set(pending_thread, -ENOMSG);
		z_ready_thread(pending_thread);
  10f0a7:	e8 9e 23 00 00       	callq  11144a <z_ready_thread>
  10f0ac:	eb df                	jmp    10f08d <z_impl_k_msgq_purge+0x60>
	}

	msgq->used_msgs = 0;
	msgq->read_ptr = msgq->write_ptr;
  10f0ae:	48 8b 43 40          	mov    0x40(%rbx),%rax
	msgq->used_msgs = 0;
  10f0b2:	c7 43 48 00 00 00 00 	movl   $0x0,0x48(%rbx)

	z_reschedule(&msgq->lock, key);
  10f0b9:	44 89 ee             	mov    %r13d,%esi
  10f0bc:	4c 89 e7             	mov    %r12,%rdi
	msgq->read_ptr = msgq->write_ptr;
  10f0bf:	48 89 43 38          	mov    %rax,0x38(%rbx)
}
  10f0c3:	58                   	pop    %rax
  10f0c4:	5b                   	pop    %rbx
  10f0c5:	41 5c                	pop    %r12
  10f0c7:	41 5d                	pop    %r13
  10f0c9:	5d                   	pop    %rbp
	z_reschedule(&msgq->lock, key);
  10f0ca:	e9 92 1c 00 00       	jmpq   110d61 <z_reschedule>

000000000010f0cf <z_mrsh_k_msgq_purge>:
#include <syscalls/kernel.h>

extern void z_vrfy_k_msgq_purge(struct k_msgq * msgq);
uintptr_t z_mrsh_k_msgq_purge(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
  10f0cf:	55                   	push   %rbp
  10f0d0:	48 89 e5             	mov    %rsp,%rbp
  10f0d3:	41 54                	push   %r12
  10f0d5:	49 89 fc             	mov    %rdi,%r12
  10f0d8:	51                   	push   %rcx
	_current->syscall_frame = ssf;
  10f0d9:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  10f0dd:	48 8b 05 6c 96 01 00 	mov    0x1966c(%rip),%rax        # 128750 <_kernel+0x10>
  10f0e4:	48 89 90 40 01 00 00 	mov    %rdx,0x140(%rax)

#ifdef CONFIG_USERSPACE
static inline void z_vrfy_k_msgq_purge(struct k_msgq *msgq)
{
	Z_OOPS(Z_SYSCALL_OBJ(msgq, K_OBJ_MSGQ));
  10f0eb:	e8 e4 79 00 00       	callq  116ad4 <z_object_find>
  10f0f0:	31 d2                	xor    %edx,%edx
  10f0f2:	4c 89 e6             	mov    %r12,%rsi
  10f0f5:	48 89 c7             	mov    %rax,%rdi
  10f0f8:	e8 83 f5 ff ff       	callq  10e680 <z_obj_validation_check.constprop.0>
  10f0fd:	85 c0                	test   %eax,%eax
  10f0ff:	74 29                	je     10f12a <z_mrsh_k_msgq_purge+0x5b>
  10f101:	bf 23 f3 11 00       	mov    $0x11f323,%edi
  10f106:	31 c0                	xor    %eax,%eax
  10f108:	ba f0 c1 11 00       	mov    $0x11c1f0,%edx
  10f10d:	be 45 00 00 00       	mov    $0x45,%esi
  10f112:	e8 af 3f ff ff       	callq  1030c6 <z_log_minimal_printk>
  10f117:	48 8b 05 32 96 01 00 	mov    0x19632(%rip),%rax        # 128750 <_kernel+0x10>
  10f11e:	48 8b b8 40 01 00 00 	mov    0x140(%rax),%rdi
  10f125:	e8 e3 aa ff ff       	callq  109c0d <arch_syscall_oops>
	z_impl_k_msgq_purge(msgq);
  10f12a:	4c 89 e7             	mov    %r12,%rdi
  10f12d:	e8 fb fe ff ff       	callq  10f02d <z_impl_k_msgq_purge>
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	z_vrfy_k_msgq_purge(*(struct k_msgq **)&arg0)
;
	_current->syscall_frame = NULL;
  10f132:	48 8b 05 17 96 01 00 	mov    0x19617(%rip),%rax        # 128750 <_kernel+0x10>
  10f139:	48 c7 80 40 01 00 00 	movq   $0x0,0x140(%rax)
  10f140:	00 00 00 00 
	return 0;
}
  10f144:	31 c0                	xor    %eax,%eax
  10f146:	5a                   	pop    %rdx
  10f147:	41 5c                	pop    %r12
  10f149:	5d                   	pop    %rbp
  10f14a:	c3                   	retq   

000000000010f14b <z_mrsh_k_msgq_num_free_get>:
#include <syscalls/kernel.h>

extern uint32_t z_vrfy_k_msgq_num_free_get(struct k_msgq * msgq);
uintptr_t z_mrsh_k_msgq_num_free_get(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
  10f14b:	55                   	push   %rbp
  10f14c:	48 89 e5             	mov    %rsp,%rbp
  10f14f:	53                   	push   %rbx
  10f150:	48 89 fb             	mov    %rdi,%rbx
  10f153:	51                   	push   %rcx
	_current->syscall_frame = ssf;
  10f154:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  10f158:	48 8b 05 f1 95 01 00 	mov    0x195f1(%rip),%rax        # 128750 <_kernel+0x10>
  10f15f:	48 89 90 40 01 00 00 	mov    %rdx,0x140(%rax)
}
#include <syscalls/k_msgq_purge_mrsh.c>

static inline uint32_t z_vrfy_k_msgq_num_free_get(struct k_msgq *msgq)
{
	Z_OOPS(Z_SYSCALL_OBJ(msgq, K_OBJ_MSGQ));
  10f166:	e8 69 79 00 00       	callq  116ad4 <z_object_find>
  10f16b:	31 d2                	xor    %edx,%edx
  10f16d:	48 89 de             	mov    %rbx,%rsi
  10f170:	48 89 c7             	mov    %rax,%rdi
  10f173:	e8 08 f5 ff ff       	callq  10e680 <z_obj_validation_check.constprop.0>
  10f178:	85 c0                	test   %eax,%eax
  10f17a:	74 29                	je     10f1a5 <z_mrsh_k_msgq_num_free_get+0x5a>
  10f17c:	bf 23 f3 11 00       	mov    $0x11f323,%edi
  10f181:	31 c0                	xor    %eax,%eax
  10f183:	ba d0 c1 11 00       	mov    $0x11c1d0,%edx
  10f188:	be 45 00 00 00       	mov    $0x45,%esi
  10f18d:	e8 34 3f ff ff       	callq  1030c6 <z_log_minimal_printk>
  10f192:	48 8b 05 b7 95 01 00 	mov    0x195b7(%rip),%rax        # 128750 <_kernel+0x10>
  10f199:	48 8b b8 40 01 00 00 	mov    0x140(%rax),%rdi
  10f1a0:	e8 68 aa ff ff       	callq  109c0d <arch_syscall_oops>
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	uint32_t ret = z_vrfy_k_msgq_num_free_get(*(struct k_msgq **)&arg0)
;
	_current->syscall_frame = NULL;
  10f1a5:	48 8b 15 a4 95 01 00 	mov    0x195a4(%rip),%rdx        # 128750 <_kernel+0x10>
	return msgq->max_msgs - msgq->used_msgs;
  10f1ac:	8b 43 20             	mov    0x20(%rbx),%eax
  10f1af:	2b 43 48             	sub    0x48(%rbx),%eax
  10f1b2:	48 c7 82 40 01 00 00 	movq   $0x0,0x140(%rdx)
  10f1b9:	00 00 00 00 
	return (uintptr_t) ret;
}
  10f1bd:	5a                   	pop    %rdx
  10f1be:	5b                   	pop    %rbx
  10f1bf:	5d                   	pop    %rbp
  10f1c0:	c3                   	retq   

000000000010f1c1 <z_mrsh_k_msgq_num_used_get>:
#include <syscalls/kernel.h>

extern uint32_t z_vrfy_k_msgq_num_used_get(struct k_msgq * msgq);
uintptr_t z_mrsh_k_msgq_num_used_get(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
  10f1c1:	55                   	push   %rbp
  10f1c2:	48 89 e5             	mov    %rsp,%rbp
  10f1c5:	53                   	push   %rbx
  10f1c6:	48 89 fb             	mov    %rdi,%rbx
  10f1c9:	51                   	push   %rcx
	_current->syscall_frame = ssf;
  10f1ca:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  10f1ce:	48 8b 05 7b 95 01 00 	mov    0x1957b(%rip),%rax        # 128750 <_kernel+0x10>
  10f1d5:	48 89 90 40 01 00 00 	mov    %rdx,0x140(%rax)
}
#include <syscalls/k_msgq_num_free_get_mrsh.c>

static inline uint32_t z_vrfy_k_msgq_num_used_get(struct k_msgq *msgq)
{
	Z_OOPS(Z_SYSCALL_OBJ(msgq, K_OBJ_MSGQ));
  10f1dc:	e8 f3 78 00 00       	callq  116ad4 <z_object_find>
  10f1e1:	31 d2                	xor    %edx,%edx
  10f1e3:	48 89 de             	mov    %rbx,%rsi
  10f1e6:	48 89 c7             	mov    %rax,%rdi
  10f1e9:	e8 92 f4 ff ff       	callq  10e680 <z_obj_validation_check.constprop.0>
  10f1ee:	85 c0                	test   %eax,%eax
  10f1f0:	74 29                	je     10f21b <z_mrsh_k_msgq_num_used_get+0x5a>
  10f1f2:	bf 23 f3 11 00       	mov    $0x11f323,%edi
  10f1f7:	31 c0                	xor    %eax,%eax
  10f1f9:	ba b0 c1 11 00       	mov    $0x11c1b0,%edx
  10f1fe:	be 45 00 00 00       	mov    $0x45,%esi
  10f203:	e8 be 3e ff ff       	callq  1030c6 <z_log_minimal_printk>
  10f208:	48 8b 05 41 95 01 00 	mov    0x19541(%rip),%rax        # 128750 <_kernel+0x10>
  10f20f:	48 8b b8 40 01 00 00 	mov    0x140(%rax),%rdi
  10f216:	e8 f2 a9 ff ff       	callq  109c0d <arch_syscall_oops>
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	uint32_t ret = z_vrfy_k_msgq_num_used_get(*(struct k_msgq **)&arg0)
;
	_current->syscall_frame = NULL;
  10f21b:	48 8b 15 2e 95 01 00 	mov    0x1952e(%rip),%rdx        # 128750 <_kernel+0x10>
	return msgq->used_msgs;
  10f222:	8b 43 48             	mov    0x48(%rbx),%eax
  10f225:	48 c7 82 40 01 00 00 	movq   $0x0,0x140(%rdx)
  10f22c:	00 00 00 00 
	return (uintptr_t) ret;
}
  10f230:	5a                   	pop    %rdx
  10f231:	5b                   	pop    %rbx
  10f232:	5d                   	pop    %rbp
  10f233:	c3                   	retq   

000000000010f234 <z_obj_validation_check.constprop.0>:
static inline int z_obj_validation_check(struct z_object *ko,
  10f234:	55                   	push   %rbp
  10f235:	48 89 e5             	mov    %rsp,%rbp
  10f238:	41 56                	push   %r14
  10f23a:	49 89 f6             	mov    %rsi,%r14
	ret = z_object_validate(ko, otype, init);
  10f23d:	be 03 00 00 00       	mov    $0x3,%esi
static inline int z_obj_validation_check(struct z_object *ko,
  10f242:	41 55                	push   %r13
  10f244:	49 89 fd             	mov    %rdi,%r13
  10f247:	48 83 ec 10          	sub    $0x10,%rsp
	ret = z_object_validate(ko, otype, init);
  10f24b:	e8 1c 7d 00 00       	callq  116f6c <z_object_validate>
	if (ret != 0) {
  10f250:	85 c0                	test   %eax,%eax
  10f252:	74 18                	je     10f26c <z_obj_validation_check.constprop.0+0x38>
		z_dump_object_error(ret, obj, ko, otype);
  10f254:	89 c7                	mov    %eax,%edi
  10f256:	b9 03 00 00 00       	mov    $0x3,%ecx
  10f25b:	4c 89 ea             	mov    %r13,%rdx
  10f25e:	4c 89 f6             	mov    %r14,%rsi
  10f261:	89 45 ec             	mov    %eax,-0x14(%rbp)
  10f264:	e8 b8 7b 00 00       	callq  116e21 <z_dump_object_error>
  10f269:	8b 45 ec             	mov    -0x14(%rbp),%eax
}
  10f26c:	5a                   	pop    %rdx
  10f26d:	59                   	pop    %rcx
  10f26e:	41 5d                	pop    %r13
  10f270:	41 5e                	pop    %r14
  10f272:	5d                   	pop    %rbp
  10f273:	c3                   	retq   

000000000010f274 <adjust_owner_prio.isra.0>:
	return new_prio;
}

static bool adjust_owner_prio(struct k_mutex *mutex, int32_t new_prio)
{
	if (mutex->owner->base.prio != new_prio) {
  10f274:	0f be 47 1a          	movsbl 0x1a(%rdi),%eax
  10f278:	39 f0                	cmp    %esi,%eax
  10f27a:	74 05                	je     10f281 <adjust_owner_prio.isra.0+0xd>
		LOG_DBG("%p (ready (y/n): %c) prio changed to %d (was %d)",
			mutex->owner, z_is_thread_ready(mutex->owner) ?
			'y' : 'n',
			new_prio, mutex->owner->base.prio);

		return z_set_prio(mutex->owner, new_prio);
  10f27c:	e9 97 27 00 00       	jmpq   111a18 <z_set_prio>
	}
	return false;
}
  10f281:	31 c0                	xor    %eax,%eax
  10f283:	c3                   	retq   

000000000010f284 <z_impl_k_mutex_init>:
{
  10f284:	55                   	push   %rbp
	mutex->owner = NULL;
  10f285:	48 c7 47 10 00 00 00 	movq   $0x0,0x10(%rdi)
  10f28c:	00 
	mutex->lock_count = 0U;
  10f28d:	c7 47 18 00 00 00 00 	movl   $0x0,0x18(%rdi)
	list->head = (sys_dnode_t *)list;
  10f294:	48 89 3f             	mov    %rdi,(%rdi)
{
  10f297:	48 89 e5             	mov    %rsp,%rbp
	list->tail = (sys_dnode_t *)list;
  10f29a:	48 89 7f 08          	mov    %rdi,0x8(%rdi)
	z_object_init(mutex);
  10f29e:	e8 4e 7d 00 00       	callq  116ff1 <z_object_init>
}
  10f2a3:	31 c0                	xor    %eax,%eax
  10f2a5:	5d                   	pop    %rbp
  10f2a6:	c3                   	retq   

000000000010f2a7 <z_mrsh_k_mutex_init>:
#include <syscalls/kernel.h>

extern int z_vrfy_k_mutex_init(struct k_mutex * mutex);
uintptr_t z_mrsh_k_mutex_init(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
  10f2a7:	55                   	push   %rbp
  10f2a8:	48 89 e5             	mov    %rsp,%rbp
  10f2ab:	41 54                	push   %r12
  10f2ad:	49 89 fc             	mov    %rdi,%r12
  10f2b0:	51                   	push   %rcx
	_current->syscall_frame = ssf;
  10f2b1:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  10f2b5:	48 8b 05 94 94 01 00 	mov    0x19494(%rip),%rax        # 128750 <_kernel+0x10>
  10f2bc:	48 89 90 40 01 00 00 	mov    %rdx,0x140(%rax)
	Z_OOPS(Z_SYSCALL_OBJ_INIT(mutex, K_OBJ_MUTEX));
  10f2c3:	e8 0c 78 00 00       	callq  116ad4 <z_object_find>
  10f2c8:	ba 01 00 00 00       	mov    $0x1,%edx
  10f2cd:	4c 89 e6             	mov    %r12,%rsi
  10f2d0:	48 89 c7             	mov    %rax,%rdi
  10f2d3:	e8 5c ff ff ff       	callq  10f234 <z_obj_validation_check.constprop.0>
  10f2d8:	85 c0                	test   %eax,%eax
  10f2da:	74 29                	je     10f305 <z_mrsh_k_mutex_init+0x5e>
  10f2dc:	bf 23 f3 11 00       	mov    $0x11f323,%edi
  10f2e1:	31 c0                	xor    %eax,%eax
  10f2e3:	ba f0 c2 11 00       	mov    $0x11c2f0,%edx
  10f2e8:	be 45 00 00 00       	mov    $0x45,%esi
  10f2ed:	e8 d4 3d ff ff       	callq  1030c6 <z_log_minimal_printk>
  10f2f2:	48 8b 05 57 94 01 00 	mov    0x19457(%rip),%rax        # 128750 <_kernel+0x10>
  10f2f9:	48 8b b8 40 01 00 00 	mov    0x140(%rax),%rdi
  10f300:	e8 08 a9 ff ff       	callq  109c0d <arch_syscall_oops>
	return z_impl_k_mutex_init(mutex);
  10f305:	4c 89 e7             	mov    %r12,%rdi
  10f308:	e8 77 ff ff ff       	callq  10f284 <z_impl_k_mutex_init>
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	int ret = z_vrfy_k_mutex_init(*(struct k_mutex **)&arg0)
;
	_current->syscall_frame = NULL;
  10f30d:	48 8b 15 3c 94 01 00 	mov    0x1943c(%rip),%rdx        # 128750 <_kernel+0x10>
	return (uintptr_t) ret;
  10f314:	48 98                	cltq   
	_current->syscall_frame = NULL;
  10f316:	48 c7 82 40 01 00 00 	movq   $0x0,0x140(%rdx)
  10f31d:	00 00 00 00 
}
  10f321:	5a                   	pop    %rdx
  10f322:	41 5c                	pop    %r12
  10f324:	5d                   	pop    %rbp
  10f325:	c3                   	retq   

000000000010f326 <z_impl_k_mutex_lock>:

int z_impl_k_mutex_lock(struct k_mutex *mutex, k_timeout_t timeout)
{
  10f326:	55                   	push   %rbp
	int new_prio;
	k_spinlock_key_t key;
	bool resched = false;

	__ASSERT(!arch_is_in_isr(), "mutexes cannot be used inside ISRs");
  10f327:	83 3d 12 94 01 00 00 	cmpl   $0x0,0x19412(%rip)        # 128740 <_kernel>
{
  10f32e:	48 89 e5             	mov    %rsp,%rbp
  10f331:	41 56                	push   %r14
  10f333:	41 55                	push   %r13
  10f335:	49 89 f5             	mov    %rsi,%r13
  10f338:	41 54                	push   %r12
  10f33a:	53                   	push   %rbx
  10f33b:	48 89 fb             	mov    %rdi,%rbx
	__ASSERT(!arch_is_in_isr(), "mutexes cannot be used inside ISRs");
  10f33e:	74 36                	je     10f376 <z_impl_k_mutex_lock+0x50>
  10f340:	be 49 f9 11 00       	mov    $0x11f949,%esi
  10f345:	b9 65 00 00 00       	mov    $0x65,%ecx
  10f34a:	ba 25 fc 11 00       	mov    $0x11fc25,%edx
  10f34f:	31 c0                	xor    %eax,%eax
  10f351:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  10f356:	e8 9d 12 ff ff       	callq  1005f8 <printk>
  10f35b:	bf 47 fc 11 00       	mov    $0x11fc47,%edi
  10f360:	31 c0                	xor    %eax,%eax
  10f362:	e8 91 12 ff ff       	callq  1005f8 <printk>
  10f367:	be 65 00 00 00       	mov    $0x65,%esi
  10f36c:	bf 25 fc 11 00       	mov    $0x11fc25,%edi
  10f371:	e8 22 38 ff ff       	callq  102b98 <assert_post_action>
  10f376:	9c                   	pushfq 
  10f377:	fa                   	cli    
  10f378:	41 5e                	pop    %r14
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  10f37a:	bf b8 cd 1b 00       	mov    $0x1bcdb8,%edi
  10f37f:	e8 f5 e4 ff ff       	callq  10d879 <z_spin_lock_valid>
  10f384:	84 c0                	test   %al,%al
  10f386:	75 39                	jne    10f3c1 <z_impl_k_mutex_lock+0x9b>
  10f388:	b9 8e 00 00 00       	mov    $0x8e,%ecx
  10f38d:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  10f392:	be fd d1 11 00       	mov    $0x11d1fd,%esi
  10f397:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  10f39c:	e8 57 12 ff ff       	callq  1005f8 <printk>
  10f3a1:	be b8 cd 1b 00       	mov    $0x1bcdb8,%esi
  10f3a6:	bf 12 d2 11 00       	mov    $0x11d212,%edi
  10f3ab:	31 c0                	xor    %eax,%eax
  10f3ad:	e8 46 12 ff ff       	callq  1005f8 <printk>
  10f3b2:	be 8e 00 00 00       	mov    $0x8e,%esi
  10f3b7:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  10f3bc:	e8 d7 37 ff ff       	callq  102b98 <assert_post_action>
	z_spin_lock_set_owner(l);
  10f3c1:	bf b8 cd 1b 00       	mov    $0x1bcdb8,%edi
  10f3c6:	e8 f2 e4 ff ff       	callq  10d8bd <z_spin_lock_set_owner>

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mutex, lock, mutex, timeout);

	key = k_spin_lock(&lock);

	if (likely((mutex->lock_count == 0U) || (mutex->owner == _current))) {
  10f3cb:	8b 53 18             	mov    0x18(%rbx),%edx
  10f3ce:	48 8b 05 7b 93 01 00 	mov    0x1937b(%rip),%rax        # 128750 <_kernel+0x10>
  10f3d5:	85 d2                	test   %edx,%edx
  10f3d7:	74 0e                	je     10f3e7 <z_impl_k_mutex_lock+0xc1>
  10f3d9:	48 8b 7b 10          	mov    0x10(%rbx),%rdi
  10f3dd:	48 39 c7             	cmp    %rax,%rdi
  10f3e0:	75 6b                	jne    10f44d <z_impl_k_mutex_lock+0x127>

		mutex->owner_orig_prio = (mutex->lock_count == 0U) ?
					_current->base.prio :
  10f3e2:	8b 4b 1c             	mov    0x1c(%rbx),%ecx
  10f3e5:	eb 04                	jmp    10f3eb <z_impl_k_mutex_lock+0xc5>
  10f3e7:	0f be 48 1a          	movsbl 0x1a(%rax),%ecx
					mutex->owner_orig_prio;

		mutex->lock_count++;
  10f3eb:	ff c2                	inc    %edx
		mutex->owner_orig_prio = (mutex->lock_count == 0U) ?
  10f3ed:	89 4b 1c             	mov    %ecx,0x1c(%rbx)
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  10f3f0:	bf b8 cd 1b 00       	mov    $0x1bcdb8,%edi
		mutex->lock_count++;
  10f3f5:	89 53 18             	mov    %edx,0x18(%rbx)
		mutex->owner = _current;
  10f3f8:	48 89 43 10          	mov    %rax,0x10(%rbx)
  10f3fc:	e8 98 e4 ff ff       	callq  10d899 <z_spin_unlock_valid>
  10f401:	84 c0                	test   %al,%al
  10f403:	75 39                	jne    10f43e <z_impl_k_mutex_lock+0x118>
  10f405:	b9 b9 00 00 00       	mov    $0xb9,%ecx
  10f40a:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  10f40f:	be 41 d2 11 00       	mov    $0x11d241,%esi
  10f414:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  10f419:	e8 da 11 ff ff       	callq  1005f8 <printk>
  10f41e:	be b8 cd 1b 00       	mov    $0x1bcdb8,%esi
  10f423:	bf 58 d2 11 00       	mov    $0x11d258,%edi
  10f428:	31 c0                	xor    %eax,%eax
  10f42a:	e8 c9 11 ff ff       	callq  1005f8 <printk>
  10f42f:	be b9 00 00 00       	mov    $0xb9,%esi
  10f434:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  10f439:	e8 5a 37 ff ff       	callq  102b98 <assert_post_action>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  10f43e:	41 0f ba e6 09       	bt     $0x9,%r14d
  10f443:	73 01                	jae    10f446 <z_impl_k_mutex_lock+0x120>
		__asm__ volatile ("sti" ::: "memory");
  10f445:	fb                   	sti    

		k_spin_unlock(&lock, key);

		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, 0);

		return 0;
  10f446:	31 c0                	xor    %eax,%eax
  10f448:	e9 94 01 00 00       	jmpq   10f5e1 <z_impl_k_mutex_lock+0x2bb>
	}

	if (unlikely(K_TIMEOUT_EQ(timeout, K_NO_WAIT))) {
  10f44d:	4d 85 ed             	test   %r13,%r13
  10f450:	75 56                	jne    10f4a8 <z_impl_k_mutex_lock+0x182>
  10f452:	bf b8 cd 1b 00       	mov    $0x1bcdb8,%edi
  10f457:	e8 3d e4 ff ff       	callq  10d899 <z_spin_unlock_valid>
  10f45c:	84 c0                	test   %al,%al
  10f45e:	75 39                	jne    10f499 <z_impl_k_mutex_lock+0x173>
  10f460:	b9 b9 00 00 00       	mov    $0xb9,%ecx
  10f465:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  10f46a:	be 41 d2 11 00       	mov    $0x11d241,%esi
  10f46f:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  10f474:	e8 7f 11 ff ff       	callq  1005f8 <printk>
  10f479:	be b8 cd 1b 00       	mov    $0x1bcdb8,%esi
  10f47e:	bf 58 d2 11 00       	mov    $0x11d258,%edi
  10f483:	31 c0                	xor    %eax,%eax
  10f485:	e8 6e 11 ff ff       	callq  1005f8 <printk>
  10f48a:	be b9 00 00 00       	mov    $0xb9,%esi
  10f48f:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  10f494:	e8 ff 36 ff ff       	callq  102b98 <assert_post_action>
		k_spin_unlock(&lock, key);

		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, -EBUSY);

		return -EBUSY;
  10f499:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  10f49e:	41 0f ba e6 09       	bt     $0x9,%r14d
  10f4a3:	e9 36 01 00 00       	jmpq   10f5de <z_impl_k_mutex_lock+0x2b8>
	}

	SYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_mutex, lock, mutex, timeout);

	new_prio = new_prio_for_inheritance(_current->base.prio,
  10f4a8:	0f be 70 1a          	movsbl 0x1a(%rax),%esi
  10f4ac:	0f be 57 1a          	movsbl 0x1a(%rdi),%edx
	return prio >= CONFIG_PRIORITY_CEILING;
  10f4b0:	b8 81 ff ff ff       	mov    $0xffffff81,%eax
  10f4b5:	39 d6                	cmp    %edx,%esi
  10f4b7:	0f 4f f2             	cmovg  %edx,%esi
  10f4ba:	83 fe 81             	cmp    $0xffffff81,%esi
  10f4bd:	0f 4c f0             	cmovl  %eax,%esi
	bool resched = false;
  10f4c0:	45 31 e4             	xor    %r12d,%r12d
					    mutex->owner->base.prio);

	LOG_DBG("adjusting prio up on mutex %p", mutex);

	if (z_is_prio_higher(new_prio, mutex->owner->base.prio)) {
  10f4c3:	39 f2                	cmp    %esi,%edx
  10f4c5:	7e 08                	jle    10f4cf <z_impl_k_mutex_lock+0x1a9>
		resched = adjust_owner_prio(mutex, new_prio);
  10f4c7:	e8 a8 fd ff ff       	callq  10f274 <adjust_owner_prio.isra.0>
  10f4cc:	41 89 c4             	mov    %eax,%r12d
	}

	int got_mutex = z_pend_curr(&lock, key, &mutex->wait_q, timeout);
  10f4cf:	4c 89 e9             	mov    %r13,%rcx
  10f4d2:	48 89 da             	mov    %rbx,%rdx
  10f4d5:	44 89 f6             	mov    %r14d,%esi
  10f4d8:	bf b8 cd 1b 00       	mov    $0x1bcdb8,%edi
  10f4dd:	e8 06 25 00 00       	callq  1119e8 <z_pend_curr>
	LOG_DBG("on mutex %p got_mutex value: %d", mutex, got_mutex);

	LOG_DBG("%p got mutex %p (y/n): %c", _current, mutex,
		got_mutex ? 'y' : 'n');

	if (got_mutex == 0) {
  10f4e2:	85 c0                	test   %eax,%eax
  10f4e4:	0f 84 5c ff ff ff    	je     10f446 <z_impl_k_mutex_lock+0x120>
  10f4ea:	9c                   	pushfq 
  10f4eb:	fa                   	cli    
  10f4ec:	41 5d                	pop    %r13
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  10f4ee:	bf b8 cd 1b 00       	mov    $0x1bcdb8,%edi
  10f4f3:	e8 81 e3 ff ff       	callq  10d879 <z_spin_lock_valid>
  10f4f8:	84 c0                	test   %al,%al
  10f4fa:	75 39                	jne    10f535 <z_impl_k_mutex_lock+0x20f>
  10f4fc:	b9 8e 00 00 00       	mov    $0x8e,%ecx
  10f501:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  10f506:	be fd d1 11 00       	mov    $0x11d1fd,%esi
  10f50b:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  10f510:	e8 e3 10 ff ff       	callq  1005f8 <printk>
  10f515:	be b8 cd 1b 00       	mov    $0x1bcdb8,%esi
  10f51a:	bf 12 d2 11 00       	mov    $0x11d212,%edi
  10f51f:	31 c0                	xor    %eax,%eax
  10f521:	e8 d2 10 ff ff       	callq  1005f8 <printk>
  10f526:	be 8e 00 00 00       	mov    $0x8e,%esi
  10f52b:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  10f530:	e8 63 36 ff ff       	callq  102b98 <assert_post_action>
	z_spin_lock_set_owner(l);
  10f535:	bf b8 cd 1b 00       	mov    $0x1bcdb8,%edi
  10f53a:	e8 7e e3 ff ff       	callq  10d8bd <z_spin_lock_set_owner>
	return list->head == list;
  10f53f:	48 8b 03             	mov    (%rbx),%rax
	key = k_spin_lock(&lock);

	struct k_thread *waiter = z_waitq_head(&mutex->wait_q);

	new_prio = (waiter != NULL) ?
		new_prio_for_inheritance(waiter->base.prio, mutex->owner_orig_prio) :
  10f542:	48 85 c0             	test   %rax,%rax
  10f545:	74 1d                	je     10f564 <z_impl_k_mutex_lock+0x23e>
  10f547:	48 39 c3             	cmp    %rax,%rbx
  10f54a:	74 18                	je     10f564 <z_impl_k_mutex_lock+0x23e>
  10f54c:	0f be 70 1a          	movsbl 0x1a(%rax),%esi
  10f550:	39 73 1c             	cmp    %esi,0x1c(%rbx)
  10f553:	b8 81 ff ff ff       	mov    $0xffffff81,%eax
  10f558:	0f 4e 73 1c          	cmovle 0x1c(%rbx),%esi
  10f55c:	83 fe 81             	cmp    $0xffffff81,%esi
  10f55f:	0f 4c f0             	cmovl  %eax,%esi
	return new_prio;
  10f562:	eb 03                	jmp    10f567 <z_impl_k_mutex_lock+0x241>
		new_prio_for_inheritance(waiter->base.prio, mutex->owner_orig_prio) :
  10f564:	8b 73 1c             	mov    0x1c(%rbx),%esi
		mutex->owner_orig_prio;

	LOG_DBG("adjusting prio down on mutex %p", mutex);

	resched = adjust_owner_prio(mutex, new_prio) || resched;
  10f567:	48 8b 7b 10          	mov    0x10(%rbx),%rdi
  10f56b:	e8 04 fd ff ff       	callq  10f274 <adjust_owner_prio.isra.0>

	if (resched) {
  10f570:	45 84 e4             	test   %r12b,%r12b
  10f573:	75 04                	jne    10f579 <z_impl_k_mutex_lock+0x253>
  10f575:	84 c0                	test   %al,%al
  10f577:	74 14                	je     10f58d <z_impl_k_mutex_lock+0x267>
		z_reschedule(&lock, key);
  10f579:	44 89 ee             	mov    %r13d,%esi
  10f57c:	bf b8 cd 1b 00       	mov    $0x1bcdb8,%edi
  10f581:	e8 db 17 00 00       	callq  110d61 <z_reschedule>
		k_spin_unlock(&lock, key);
	}

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, -EAGAIN);

	return -EAGAIN;
  10f586:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  10f58b:	eb 54                	jmp    10f5e1 <z_impl_k_mutex_lock+0x2bb>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  10f58d:	bf b8 cd 1b 00       	mov    $0x1bcdb8,%edi
  10f592:	e8 02 e3 ff ff       	callq  10d899 <z_spin_unlock_valid>
  10f597:	84 c0                	test   %al,%al
  10f599:	75 39                	jne    10f5d4 <z_impl_k_mutex_lock+0x2ae>
  10f59b:	b9 b9 00 00 00       	mov    $0xb9,%ecx
  10f5a0:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  10f5a5:	be 41 d2 11 00       	mov    $0x11d241,%esi
  10f5aa:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  10f5af:	e8 44 10 ff ff       	callq  1005f8 <printk>
  10f5b4:	be b8 cd 1b 00       	mov    $0x1bcdb8,%esi
  10f5b9:	bf 58 d2 11 00       	mov    $0x11d258,%edi
  10f5be:	31 c0                	xor    %eax,%eax
  10f5c0:	e8 33 10 ff ff       	callq  1005f8 <printk>
  10f5c5:	be b9 00 00 00       	mov    $0xb9,%esi
  10f5ca:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  10f5cf:	e8 c4 35 ff ff       	callq  102b98 <assert_post_action>
  10f5d4:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  10f5d9:	41 0f ba e5 09       	bt     $0x9,%r13d
  10f5de:	73 01                	jae    10f5e1 <z_impl_k_mutex_lock+0x2bb>
		__asm__ volatile ("sti" ::: "memory");
  10f5e0:	fb                   	sti    
}
  10f5e1:	5b                   	pop    %rbx
  10f5e2:	41 5c                	pop    %r12
  10f5e4:	41 5d                	pop    %r13
  10f5e6:	41 5e                	pop    %r14
  10f5e8:	5d                   	pop    %rbp
  10f5e9:	c3                   	retq   

000000000010f5ea <z_mrsh_k_mutex_lock>:
#include <syscalls/kernel.h>

extern int z_vrfy_k_mutex_lock(struct k_mutex * mutex, k_timeout_t timeout);
uintptr_t z_mrsh_k_mutex_lock(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
  10f5ea:	55                   	push   %rbp
  10f5eb:	48 89 e5             	mov    %rsp,%rbp
  10f5ee:	41 55                	push   %r13
  10f5f0:	49 89 f5             	mov    %rsi,%r13
  10f5f3:	41 54                	push   %r12
  10f5f5:	49 89 fc             	mov    %rdi,%r12
  10f5f8:	48 83 ec 10          	sub    $0x10,%rsp
	_current->syscall_frame = ssf;
  10f5fc:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  10f600:	48 8b 05 49 91 01 00 	mov    0x19149(%rip),%rax        # 128750 <_kernel+0x10>
{
  10f607:	48 89 75 e8          	mov    %rsi,-0x18(%rbp)
	_current->syscall_frame = ssf;
  10f60b:	48 89 90 40 01 00 00 	mov    %rdx,0x140(%rax)

#ifdef CONFIG_USERSPACE
static inline int z_vrfy_k_mutex_lock(struct k_mutex *mutex,
				      k_timeout_t timeout)
{
	Z_OOPS(Z_SYSCALL_OBJ(mutex, K_OBJ_MUTEX));
  10f612:	e8 bd 74 00 00       	callq  116ad4 <z_object_find>
  10f617:	31 d2                	xor    %edx,%edx
  10f619:	4c 89 e6             	mov    %r12,%rsi
  10f61c:	48 89 c7             	mov    %rax,%rdi
  10f61f:	e8 10 fc ff ff       	callq  10f234 <z_obj_validation_check.constprop.0>
  10f624:	85 c0                	test   %eax,%eax
  10f626:	74 29                	je     10f651 <z_mrsh_k_mutex_lock+0x67>
  10f628:	bf 23 f3 11 00       	mov    $0x11f323,%edi
  10f62d:	31 c0                	xor    %eax,%eax
  10f62f:	ba d0 c2 11 00       	mov    $0x11c2d0,%edx
  10f634:	be 45 00 00 00       	mov    $0x45,%esi
  10f639:	e8 88 3a ff ff       	callq  1030c6 <z_log_minimal_printk>
  10f63e:	48 8b 05 0b 91 01 00 	mov    0x1910b(%rip),%rax        # 128750 <_kernel+0x10>
  10f645:	48 8b b8 40 01 00 00 	mov    0x140(%rax),%rdi
  10f64c:	e8 bc a5 ff ff       	callq  109c0d <arch_syscall_oops>
	return z_impl_k_mutex_lock(mutex, timeout);
  10f651:	4c 89 ee             	mov    %r13,%rsi
  10f654:	4c 89 e7             	mov    %r12,%rdi
  10f657:	e8 ca fc ff ff       	callq  10f326 <z_impl_k_mutex_lock>
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	int ret = z_vrfy_k_mutex_lock(*(struct k_mutex **)&arg0, *(k_timeout_t*)&arg1)
;
	_current->syscall_frame = NULL;
  10f65c:	48 8b 15 ed 90 01 00 	mov    0x190ed(%rip),%rdx        # 128750 <_kernel+0x10>
	return (uintptr_t) ret;
  10f663:	48 98                	cltq   
	_current->syscall_frame = NULL;
  10f665:	48 c7 82 40 01 00 00 	movq   $0x0,0x140(%rdx)
  10f66c:	00 00 00 00 
}
  10f670:	5a                   	pop    %rdx
  10f671:	59                   	pop    %rcx
  10f672:	41 5c                	pop    %r12
  10f674:	41 5d                	pop    %r13
  10f676:	5d                   	pop    %rbp
  10f677:	c3                   	retq   

000000000010f678 <z_impl_k_mutex_unlock>:
}
#include <syscalls/k_mutex_lock_mrsh.c>
#endif

int z_impl_k_mutex_unlock(struct k_mutex *mutex)
{
  10f678:	55                   	push   %rbp
	struct k_thread *new_owner;

	__ASSERT(!arch_is_in_isr(), "mutexes cannot be used inside ISRs");
  10f679:	83 3d c0 90 01 00 00 	cmpl   $0x0,0x190c0(%rip)        # 128740 <_kernel>
{
  10f680:	48 89 e5             	mov    %rsp,%rbp
  10f683:	41 54                	push   %r12
  10f685:	53                   	push   %rbx
  10f686:	48 89 fb             	mov    %rdi,%rbx
	__ASSERT(!arch_is_in_isr(), "mutexes cannot be used inside ISRs");
  10f689:	74 36                	je     10f6c1 <z_impl_k_mutex_unlock+0x49>
  10f68b:	be 49 f9 11 00       	mov    $0x11f949,%esi
  10f690:	b9 c7 00 00 00       	mov    $0xc7,%ecx
  10f695:	ba 25 fc 11 00       	mov    $0x11fc25,%edx
  10f69a:	31 c0                	xor    %eax,%eax
  10f69c:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  10f6a1:	e8 52 0f ff ff       	callq  1005f8 <printk>
  10f6a6:	bf 47 fc 11 00       	mov    $0x11fc47,%edi
  10f6ab:	31 c0                	xor    %eax,%eax
  10f6ad:	e8 46 0f ff ff       	callq  1005f8 <printk>
  10f6b2:	be c7 00 00 00       	mov    $0xc7,%esi
  10f6b7:	bf 25 fc 11 00       	mov    $0x11fc25,%edi
  10f6bc:	e8 d7 34 ff ff       	callq  102b98 <assert_post_action>

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mutex, unlock, mutex);

	CHECKIF(mutex->owner == NULL) {
  10f6c1:	48 8b 53 10          	mov    0x10(%rbx),%rdx
		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, unlock, mutex, -EINVAL);

		return -EINVAL;
  10f6c5:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
	CHECKIF(mutex->owner == NULL) {
  10f6ca:	48 85 d2             	test   %rdx,%rdx
  10f6cd:	0f 84 d5 01 00 00    	je     10f8a8 <z_impl_k_mutex_unlock+0x230>
	 * The current thread does not own the mutex.
	 */
	CHECKIF(mutex->owner != _current) {
		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, unlock, mutex, -EPERM);

		return -EPERM;
  10f6d3:	83 c8 ff             	or     $0xffffffff,%eax
	CHECKIF(mutex->owner != _current) {
  10f6d6:	48 3b 15 73 90 01 00 	cmp    0x19073(%rip),%rdx        # 128750 <_kernel+0x10>
  10f6dd:	0f 85 c5 01 00 00    	jne    10f8a8 <z_impl_k_mutex_unlock+0x230>
	 * Attempt to unlock a mutex which is unlocked. mutex->lock_count
	 * cannot be zero if the current thread is equal to mutex->owner,
	 * therefore no underflow check is required. Use assert to catch
	 * undefined behavior.
	 */
	__ASSERT_NO_MSG(mutex->lock_count > 0U);
  10f6e3:	83 7b 18 00          	cmpl   $0x0,0x18(%rbx)
  10f6e7:	75 2a                	jne    10f713 <z_impl_k_mutex_unlock+0x9b>
  10f6e9:	be 6c fc 11 00       	mov    $0x11fc6c,%esi
  10f6ee:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  10f6f3:	b9 df 00 00 00       	mov    $0xdf,%ecx
  10f6f8:	31 c0                	xor    %eax,%eax
  10f6fa:	ba 25 fc 11 00       	mov    $0x11fc25,%edx
  10f6ff:	e8 f4 0e ff ff       	callq  1005f8 <printk>
  10f704:	be df 00 00 00       	mov    $0xdf,%esi
  10f709:	bf 25 fc 11 00       	mov    $0x11fc25,%edi
  10f70e:	e8 85 34 ff ff       	callq  102b98 <assert_post_action>
	}
}

static inline void z_sched_lock(void)
{
	__ASSERT(!arch_is_in_isr(), "");
  10f713:	83 3d 26 90 01 00 00 	cmpl   $0x0,0x19026(%rip)        # 128740 <_kernel>
  10f71a:	74 36                	je     10f752 <z_impl_k_mutex_unlock+0xda>
  10f71c:	be 49 f9 11 00       	mov    $0x11f949,%esi
  10f721:	b9 fd 00 00 00       	mov    $0xfd,%ecx
  10f726:	ba 83 fc 11 00       	mov    $0x11fc83,%edx
  10f72b:	31 c0                	xor    %eax,%eax
  10f72d:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  10f732:	e8 c1 0e ff ff       	callq  1005f8 <printk>
  10f737:	bf 22 fc 11 00       	mov    $0x11fc22,%edi
  10f73c:	31 c0                	xor    %eax,%eax
  10f73e:	e8 b5 0e ff ff       	callq  1005f8 <printk>
  10f743:	be fd 00 00 00       	mov    $0xfd,%esi
  10f748:	bf 83 fc 11 00       	mov    $0x11fc83,%edi
  10f74d:	e8 46 34 ff ff       	callq  102b98 <assert_post_action>
	__ASSERT(_current->base.sched_locked != 1U, "");
  10f752:	48 8b 05 f7 8f 01 00 	mov    0x18ff7(%rip),%rax        # 128750 <_kernel+0x10>
  10f759:	80 78 1b 01          	cmpb   $0x1,0x1b(%rax)
  10f75d:	75 36                	jne    10f795 <z_impl_k_mutex_unlock+0x11d>
  10f75f:	be ae fc 11 00       	mov    $0x11fcae,%esi
  10f764:	b9 fe 00 00 00       	mov    $0xfe,%ecx
  10f769:	ba 83 fc 11 00       	mov    $0x11fc83,%edx
  10f76e:	31 c0                	xor    %eax,%eax
  10f770:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  10f775:	e8 7e 0e ff ff       	callq  1005f8 <printk>
  10f77a:	bf 22 fc 11 00       	mov    $0x11fc22,%edi
  10f77f:	31 c0                	xor    %eax,%eax
  10f781:	e8 72 0e ff ff       	callq  1005f8 <printk>
  10f786:	be fe 00 00 00       	mov    $0xfe,%esi
  10f78b:	bf 83 fc 11 00       	mov    $0x11fc83,%edi
  10f790:	e8 03 34 ff ff       	callq  102b98 <assert_post_action>

	--_current->base.sched_locked;
  10f795:	48 8b 05 b4 8f 01 00 	mov    0x18fb4(%rip),%rax        # 128750 <_kernel+0x10>
  10f79c:	fe 48 1b             	decb   0x1b(%rax)

	/*
	 * If we are the owner and count is greater than 1, then decrement
	 * the count and return and keep current thread as the owner.
	 */
	if (mutex->lock_count > 1U) {
  10f79f:	8b 43 18             	mov    0x18(%rbx),%eax
  10f7a2:	83 f8 01             	cmp    $0x1,%eax
  10f7a5:	76 0a                	jbe    10f7b1 <z_impl_k_mutex_unlock+0x139>
		mutex->lock_count--;
  10f7a7:	ff c8                	dec    %eax
  10f7a9:	89 43 18             	mov    %eax,0x18(%rbx)
		goto k_mutex_unlock_return;
  10f7ac:	e9 f0 00 00 00       	jmpq   10f8a1 <z_impl_k_mutex_unlock+0x229>
  10f7b1:	9c                   	pushfq 
  10f7b2:	fa                   	cli    
  10f7b3:	41 5c                	pop    %r12
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  10f7b5:	bf b8 cd 1b 00       	mov    $0x1bcdb8,%edi
  10f7ba:	e8 ba e0 ff ff       	callq  10d879 <z_spin_lock_valid>
  10f7bf:	84 c0                	test   %al,%al
  10f7c1:	75 39                	jne    10f7fc <z_impl_k_mutex_unlock+0x184>
  10f7c3:	b9 8e 00 00 00       	mov    $0x8e,%ecx
  10f7c8:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  10f7cd:	be fd d1 11 00       	mov    $0x11d1fd,%esi
  10f7d2:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  10f7d7:	e8 1c 0e ff ff       	callq  1005f8 <printk>
  10f7dc:	be b8 cd 1b 00       	mov    $0x1bcdb8,%esi
  10f7e1:	bf 12 d2 11 00       	mov    $0x11d212,%edi
  10f7e6:	31 c0                	xor    %eax,%eax
  10f7e8:	e8 0b 0e ff ff       	callq  1005f8 <printk>
  10f7ed:	be 8e 00 00 00       	mov    $0x8e,%esi
  10f7f2:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  10f7f7:	e8 9c 33 ff ff       	callq  102b98 <assert_post_action>
	z_spin_lock_set_owner(l);
  10f7fc:	bf b8 cd 1b 00       	mov    $0x1bcdb8,%edi
  10f801:	e8 b7 e0 ff ff       	callq  10d8bd <z_spin_lock_set_owner>
	}

	k_spinlock_key_t key = k_spin_lock(&lock);

	adjust_owner_prio(mutex, mutex->owner_orig_prio);
  10f806:	8b 73 1c             	mov    0x1c(%rbx),%esi
  10f809:	48 8b 7b 10          	mov    0x10(%rbx),%rdi
  10f80d:	e8 62 fa ff ff       	callq  10f274 <adjust_owner_prio.isra.0>

	/* Get the new owner, if any */
	new_owner = z_unpend_first_thread(&mutex->wait_q);
  10f812:	48 89 df             	mov    %rbx,%rdi
  10f815:	e8 43 27 00 00       	callq  111f5d <z_unpend_first_thread>

	mutex->owner = new_owner;
  10f81a:	48 89 43 10          	mov    %rax,0x10(%rbx)
	new_owner = z_unpend_first_thread(&mutex->wait_q);
  10f81e:	48 89 c7             	mov    %rax,%rdi

	LOG_DBG("new owner of mutex %p: %p (prio: %d)",
		mutex, new_owner, new_owner ? new_owner->base.prio : -1000);

	if (new_owner != NULL) {
  10f821:	48 85 c0             	test   %rax,%rax
  10f824:	74 25                	je     10f84b <z_impl_k_mutex_unlock+0x1d3>
		/*
		 * new owner is already of higher or equal prio than first
		 * waiter since the wait queue is priority-based: no need to
		 * ajust its priority
		 */
		mutex->owner_orig_prio = new_owner->base.prio;
  10f826:	0f be 40 1a          	movsbl 0x1a(%rax),%eax
  10f82a:	89 43 1c             	mov    %eax,0x1c(%rbx)
  10f82d:	c7 87 48 01 00 00 00 	movl   $0x0,0x148(%rdi)
  10f834:	00 00 00 
		arch_thread_return_value_set(new_owner, 0);
		z_ready_thread(new_owner);
  10f837:	e8 0e 1c 00 00       	callq  11144a <z_ready_thread>
		z_reschedule(&lock, key);
  10f83c:	44 89 e6             	mov    %r12d,%esi
  10f83f:	bf b8 cd 1b 00       	mov    $0x1bcdb8,%edi
  10f844:	e8 18 15 00 00       	callq  110d61 <z_reschedule>
  10f849:	eb 56                	jmp    10f8a1 <z_impl_k_mutex_unlock+0x229>
	} else {
		mutex->lock_count = 0U;
  10f84b:	c7 43 18 00 00 00 00 	movl   $0x0,0x18(%rbx)
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  10f852:	bf b8 cd 1b 00       	mov    $0x1bcdb8,%edi
  10f857:	e8 3d e0 ff ff       	callq  10d899 <z_spin_unlock_valid>
  10f85c:	84 c0                	test   %al,%al
  10f85e:	75 39                	jne    10f899 <z_impl_k_mutex_unlock+0x221>
  10f860:	b9 b9 00 00 00       	mov    $0xb9,%ecx
  10f865:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  10f86a:	be 41 d2 11 00       	mov    $0x11d241,%esi
  10f86f:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  10f874:	e8 7f 0d ff ff       	callq  1005f8 <printk>
  10f879:	be b8 cd 1b 00       	mov    $0x1bcdb8,%esi
  10f87e:	bf 58 d2 11 00       	mov    $0x11d258,%edi
  10f883:	31 c0                	xor    %eax,%eax
  10f885:	e8 6e 0d ff ff       	callq  1005f8 <printk>
  10f88a:	be b9 00 00 00       	mov    $0xb9,%esi
  10f88f:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  10f894:	e8 ff 32 ff ff       	callq  102b98 <assert_post_action>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  10f899:	41 0f ba e4 09       	bt     $0x9,%r12d
  10f89e:	73 01                	jae    10f8a1 <z_impl_k_mutex_unlock+0x229>
		__asm__ volatile ("sti" ::: "memory");
  10f8a0:	fb                   	sti    


k_mutex_unlock_return:
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, unlock, mutex, 0);

	k_sched_unlock();
  10f8a1:	e8 a8 24 00 00       	callq  111d4e <k_sched_unlock>

	return 0;
  10f8a6:	31 c0                	xor    %eax,%eax
}
  10f8a8:	5b                   	pop    %rbx
  10f8a9:	41 5c                	pop    %r12
  10f8ab:	5d                   	pop    %rbp
  10f8ac:	c3                   	retq   

000000000010f8ad <z_mrsh_k_mutex_unlock>:
#include <syscalls/kernel.h>

extern int z_vrfy_k_mutex_unlock(struct k_mutex * mutex);
uintptr_t z_mrsh_k_mutex_unlock(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
  10f8ad:	55                   	push   %rbp
  10f8ae:	48 89 e5             	mov    %rsp,%rbp
  10f8b1:	41 54                	push   %r12
  10f8b3:	49 89 fc             	mov    %rdi,%r12
  10f8b6:	51                   	push   %rcx
	_current->syscall_frame = ssf;
  10f8b7:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  10f8bb:	48 8b 05 8e 8e 01 00 	mov    0x18e8e(%rip),%rax        # 128750 <_kernel+0x10>
  10f8c2:	48 89 90 40 01 00 00 	mov    %rdx,0x140(%rax)

#ifdef CONFIG_USERSPACE
static inline int z_vrfy_k_mutex_unlock(struct k_mutex *mutex)
{
	Z_OOPS(Z_SYSCALL_OBJ(mutex, K_OBJ_MUTEX));
  10f8c9:	e8 06 72 00 00       	callq  116ad4 <z_object_find>
  10f8ce:	31 d2                	xor    %edx,%edx
  10f8d0:	4c 89 e6             	mov    %r12,%rsi
  10f8d3:	48 89 c7             	mov    %rax,%rdi
  10f8d6:	e8 59 f9 ff ff       	callq  10f234 <z_obj_validation_check.constprop.0>
  10f8db:	85 c0                	test   %eax,%eax
  10f8dd:	74 29                	je     10f908 <z_mrsh_k_mutex_unlock+0x5b>
  10f8df:	bf 23 f3 11 00       	mov    $0x11f323,%edi
  10f8e4:	31 c0                	xor    %eax,%eax
  10f8e6:	ba b0 c2 11 00       	mov    $0x11c2b0,%edx
  10f8eb:	be 45 00 00 00       	mov    $0x45,%esi
  10f8f0:	e8 d1 37 ff ff       	callq  1030c6 <z_log_minimal_printk>
  10f8f5:	48 8b 05 54 8e 01 00 	mov    0x18e54(%rip),%rax        # 128750 <_kernel+0x10>
  10f8fc:	48 8b b8 40 01 00 00 	mov    0x140(%rax),%rdi
  10f903:	e8 05 a3 ff ff       	callq  109c0d <arch_syscall_oops>
	return z_impl_k_mutex_unlock(mutex);
  10f908:	4c 89 e7             	mov    %r12,%rdi
  10f90b:	e8 68 fd ff ff       	callq  10f678 <z_impl_k_mutex_unlock>
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	int ret = z_vrfy_k_mutex_unlock(*(struct k_mutex **)&arg0)
;
	_current->syscall_frame = NULL;
  10f910:	48 8b 15 39 8e 01 00 	mov    0x18e39(%rip),%rdx        # 128750 <_kernel+0x10>
	return (uintptr_t) ret;
  10f917:	48 98                	cltq   
	_current->syscall_frame = NULL;
  10f919:	48 c7 82 40 01 00 00 	movq   $0x0,0x140(%rdx)
  10f920:	00 00 00 00 
}
  10f924:	5a                   	pop    %rdx
  10f925:	41 5c                	pop    %r12
  10f927:	5d                   	pop    %rbp
  10f928:	c3                   	retq   

000000000010f929 <z_obj_validation_check.constprop.0>:
static inline int z_obj_validation_check(struct z_object *ko,
  10f929:	55                   	push   %rbp
  10f92a:	48 89 e5             	mov    %rsp,%rbp
  10f92d:	41 56                	push   %r14
  10f92f:	49 89 f6             	mov    %rsi,%r14
	ret = z_object_validate(ko, otype, init);
  10f932:	be 05 00 00 00       	mov    $0x5,%esi
static inline int z_obj_validation_check(struct z_object *ko,
  10f937:	41 55                	push   %r13
  10f939:	49 89 fd             	mov    %rdi,%r13
  10f93c:	48 83 ec 10          	sub    $0x10,%rsp
	ret = z_object_validate(ko, otype, init);
  10f940:	e8 27 76 00 00       	callq  116f6c <z_object_validate>
	if (ret != 0) {
  10f945:	85 c0                	test   %eax,%eax
  10f947:	74 18                	je     10f961 <z_obj_validation_check.constprop.0+0x38>
		z_dump_object_error(ret, obj, ko, otype);
  10f949:	89 c7                	mov    %eax,%edi
  10f94b:	b9 05 00 00 00       	mov    $0x5,%ecx
  10f950:	4c 89 ea             	mov    %r13,%rdx
  10f953:	4c 89 f6             	mov    %r14,%rsi
  10f956:	89 45 ec             	mov    %eax,-0x14(%rbp)
  10f959:	e8 c3 74 00 00       	callq  116e21 <z_dump_object_error>
  10f95e:	8b 45 ec             	mov    -0x14(%rbp),%eax
}
  10f961:	5a                   	pop    %rdx
  10f962:	59                   	pop    %rcx
  10f963:	41 5d                	pop    %r13
  10f965:	41 5e                	pop    %r14
  10f967:	5d                   	pop    %rbp
  10f968:	c3                   	retq   

000000000010f969 <queue_insert>:
#include <syscalls/k_queue_cancel_wait_mrsh.c>
#endif

static int32_t queue_insert(struct k_queue *queue, void *prev, void *data,
			    bool alloc, bool is_append)
{
  10f969:	55                   	push   %rbp
  10f96a:	48 89 e5             	mov    %rsp,%rbp
  10f96d:	41 57                	push   %r15
  10f96f:	49 89 ff             	mov    %rdi,%r15
  10f972:	41 56                	push   %r14
  10f974:	41 55                	push   %r13
  10f976:	49 89 d5             	mov    %rdx,%r13
  10f979:	41 54                	push   %r12
	struct k_thread *first_pending_thread;
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
  10f97b:	4c 8d 67 10          	lea    0x10(%rdi),%r12
{
  10f97f:	53                   	push   %rbx
  10f980:	48 89 f3             	mov    %rsi,%rbx
  10f983:	48 83 ec 18          	sub    $0x18,%rsp
  10f987:	89 4d cc             	mov    %ecx,-0x34(%rbp)
  10f98a:	44 89 45 c8          	mov    %r8d,-0x38(%rbp)
  10f98e:	9c                   	pushfq 
  10f98f:	fa                   	cli    
  10f990:	41 5e                	pop    %r14
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  10f992:	4c 89 e7             	mov    %r12,%rdi
  10f995:	e8 df de ff ff       	callq  10d879 <z_spin_lock_valid>
  10f99a:	84 c0                	test   %al,%al
  10f99c:	75 37                	jne    10f9d5 <queue_insert+0x6c>
  10f99e:	b9 8e 00 00 00       	mov    $0x8e,%ecx
  10f9a3:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  10f9a8:	be fd d1 11 00       	mov    $0x11d1fd,%esi
  10f9ad:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  10f9b2:	e8 41 0c ff ff       	callq  1005f8 <printk>
  10f9b7:	4c 89 e6             	mov    %r12,%rsi
  10f9ba:	bf 12 d2 11 00       	mov    $0x11d212,%edi
  10f9bf:	31 c0                	xor    %eax,%eax
  10f9c1:	e8 32 0c ff ff       	callq  1005f8 <printk>
  10f9c6:	be 8e 00 00 00       	mov    $0x8e,%esi
  10f9cb:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  10f9d0:	e8 c3 31 ff ff       	callq  102b98 <assert_post_action>
	z_spin_lock_set_owner(l);
  10f9d5:	4c 89 e7             	mov    %r12,%rdi
  10f9d8:	e8 e0 de ff ff       	callq  10d8bd <z_spin_lock_set_owner>

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_queue, queue_insert, queue, alloc);

	if (is_append) {
  10f9dd:	80 7d c8 00          	cmpb   $0x0,-0x38(%rbp)
  10f9e1:	74 04                	je     10f9e7 <queue_insert+0x7e>
 *
 * @return A pointer on the last node of the list (or NULL if none)
 */
static inline sys_sfnode_t *sys_sflist_peek_tail(sys_sflist_t *list)
{
	return list->tail;
  10f9e3:	49 8b 5f 08          	mov    0x8(%r15),%rbx
		prev = sys_sflist_peek_tail(&queue->data_q);
	}
	first_pending_thread = z_unpend_first_thread(&queue->wait_q);
  10f9e7:	49 8d 7f 18          	lea    0x18(%r15),%rdi
  10f9eb:	e8 6d 25 00 00       	callq  111f5d <z_unpend_first_thread>
  10f9f0:	48 89 c7             	mov    %rax,%rdi

	if (first_pending_thread != NULL) {
  10f9f3:	48 85 c0             	test   %rax,%rax
  10f9f6:	74 18                	je     10fa10 <queue_insert+0xa7>
  10f9f8:	c7 80 48 01 00 00 00 	movl   $0x0,0x148(%rax)
  10f9ff:	00 00 00 
z_thread_return_value_set_with_data(struct k_thread *thread,
				   unsigned int value,
				   void *data)
{
	arch_thread_return_value_set(thread, value);
	thread->base.swap_data = data;
  10fa02:	4c 89 68 20          	mov    %r13,0x20(%rax)
	z_ready_thread(thread);
  10fa06:	e8 3f 1a 00 00       	callq  11144a <z_ready_thread>
		SYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_queue, queue_insert, queue, alloc, K_FOREVER);

		prepare_thread_to_run(first_pending_thread, data);
		z_reschedule(&queue->lock, key);
  10fa0b:	e9 f5 00 00 00       	jmpq   10fb05 <queue_insert+0x19c>

		return 0;
	}

	/* Only need to actually allocate if no threads are pending */
	if (alloc) {
  10fa10:	80 7d cc 00          	cmpb   $0x0,-0x34(%rbp)
  10fa14:	74 77                	je     10fa8d <queue_insert+0x124>
	return z_thread_aligned_alloc(0, size);
  10fa16:	31 ff                	xor    %edi,%edi
  10fa18:	be 10 00 00 00       	mov    $0x10,%esi
  10fa1d:	e8 4e 60 00 00       	callq  115a70 <z_thread_aligned_alloc>
		struct alloc_node *anode;

		anode = z_thread_malloc(sizeof(*anode));
		if (anode == NULL) {
  10fa22:	48 85 c0             	test   %rax,%rax
  10fa25:	75 59                	jne    10fa80 <queue_insert+0x117>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  10fa27:	4c 89 e7             	mov    %r12,%rdi
  10fa2a:	e8 6a de ff ff       	callq  10d899 <z_spin_unlock_valid>
  10fa2f:	84 c0                	test   %al,%al
  10fa31:	75 37                	jne    10fa6a <queue_insert+0x101>
  10fa33:	b9 b9 00 00 00       	mov    $0xb9,%ecx
  10fa38:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  10fa3d:	be 41 d2 11 00       	mov    $0x11d241,%esi
  10fa42:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  10fa47:	e8 ac 0b ff ff       	callq  1005f8 <printk>
  10fa4c:	4c 89 e6             	mov    %r12,%rsi
  10fa4f:	bf 58 d2 11 00       	mov    $0x11d258,%edi
  10fa54:	31 c0                	xor    %eax,%eax
  10fa56:	e8 9d 0b ff ff       	callq  1005f8 <printk>
  10fa5b:	be b9 00 00 00       	mov    $0xb9,%esi
  10fa60:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  10fa65:	e8 2e 31 ff ff       	callq  102b98 <assert_post_action>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  10fa6a:	41 0f ba e6 09       	bt     $0x9,%r14d
			k_spin_unlock(&queue->lock, key);

			SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, queue_insert, queue, alloc,
				-ENOMEM);

			return -ENOMEM;
  10fa6f:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
  10fa74:	0f 83 98 00 00 00    	jae    10fb12 <queue_insert+0x1a9>
		__asm__ volatile ("sti" ::: "memory");
  10fa7a:	fb                   	sti    
  10fa7b:	e9 92 00 00 00       	jmpq   10fb12 <queue_insert+0x1a9>
		}
		anode->data = data;
  10fa80:	4c 89 68 08          	mov    %r13,0x8(%rax)
 * @param flags A value between 0 and 3 to set the flags value
 */
static inline void sys_sfnode_init(sys_sfnode_t *node, uint8_t flags)
{
	__ASSERT((flags & ~SYS_SFLIST_FLAGS_MASK) == 0UL, "flags too large");
	node->next_and_flags = flags;
  10fa84:	48 c7 00 01 00 00 00 	movq   $0x1,(%rax)
}
  10fa8b:	eb 0b                	jmp    10fa98 <queue_insert+0x12f>
	node->next_and_flags = flags;
  10fa8d:	49 c7 45 00 00 00 00 	movq   $0x0,0x0(%r13)
  10fa94:	00 
}
  10fa95:	4c 89 e8             	mov    %r13,%rax
	parent->next_and_flags = cur_flags | (unative_t)child;
  10fa98:	48 8b 10             	mov    (%rax),%rdx
  10fa9b:	83 e2 03             	and    $0x3,%edx
 */
static inline void sys_sflist_insert(sys_sflist_t *list,
				     sys_sfnode_t *prev,
				     sys_sfnode_t *node);

Z_GENLIST_INSERT(sflist, sfnode)
  10fa9e:	48 85 db             	test   %rbx,%rbx
  10faa1:	75 12                	jne    10fab5 <queue_insert+0x14c>
	parent->next_and_flags = cur_flags | (unative_t)child;
  10faa3:	49 0b 17             	or     (%r15),%rdx
Z_GENLIST_PREPEND(sflist, sfnode)
  10faa6:	49 83 7f 08 00       	cmpq   $0x0,0x8(%r15)
	parent->next_and_flags = cur_flags | (unative_t)child;
  10faab:	48 89 10             	mov    %rdx,(%rax)
	list->head = node;
  10faae:	49 89 07             	mov    %rax,(%r15)
Z_GENLIST_PREPEND(sflist, sfnode)
  10fab1:	75 44                	jne    10faf7 <queue_insert+0x18e>
  10fab3:	eb 2a                	jmp    10fadf <queue_insert+0x176>
Z_GENLIST_INSERT(sflist, sfnode)
  10fab5:	48 8b 0b             	mov    (%rbx),%rcx
  10fab8:	48 83 e1 fc          	and    $0xfffffffffffffffc,%rcx
  10fabc:	75 27                	jne    10fae5 <queue_insert+0x17c>
	return list->tail;
  10fabe:	49 8b 4f 08          	mov    0x8(%r15),%rcx
	parent->next_and_flags = cur_flags | (unative_t)child;
  10fac2:	48 89 10             	mov    %rdx,(%rax)
Z_GENLIST_APPEND(sflist, sfnode)
  10fac5:	48 85 c9             	test   %rcx,%rcx
  10fac8:	75 09                	jne    10fad3 <queue_insert+0x16a>
	list->tail = node;
  10faca:	49 89 47 08          	mov    %rax,0x8(%r15)
	list->head = node;
  10face:	49 89 07             	mov    %rax,(%r15)
}
  10fad1:	eb 24                	jmp    10faf7 <queue_insert+0x18e>
	parent->next_and_flags = cur_flags | (unative_t)child;
  10fad3:	48 8b 11             	mov    (%rcx),%rdx
  10fad6:	83 e2 03             	and    $0x3,%edx
  10fad9:	48 09 c2             	or     %rax,%rdx
  10fadc:	48 89 11             	mov    %rdx,(%rcx)
	list->tail = node;
  10fadf:	49 89 47 08          	mov    %rax,0x8(%r15)
}
  10fae3:	eb 12                	jmp    10faf7 <queue_insert+0x18e>
	parent->next_and_flags = cur_flags | (unative_t)child;
  10fae5:	48 09 ca             	or     %rcx,%rdx
  10fae8:	48 89 10             	mov    %rdx,(%rax)
  10faeb:	48 8b 13             	mov    (%rbx),%rdx
  10faee:	83 e2 03             	and    $0x3,%edx
  10faf1:	48 09 d0             	or     %rdx,%rax
  10faf4:	48 89 03             	mov    %rax,(%rbx)
	z_handle_obj_poll_events(&queue->poll_events, state);
  10faf7:	49 8d 7f 28          	lea    0x28(%r15),%rdi
  10fafb:	be 04 00 00 00       	mov    $0x4,%esi
  10fb00:	e8 e0 5a 00 00       	callq  1155e5 <z_handle_obj_poll_events>

	SYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_queue, queue_insert, queue, alloc, K_FOREVER);

	sys_sflist_insert(&queue->data_q, prev, data);
	handle_poll_events(queue, K_POLL_STATE_DATA_AVAILABLE);
	z_reschedule(&queue->lock, key);
  10fb05:	44 89 f6             	mov    %r14d,%esi
  10fb08:	4c 89 e7             	mov    %r12,%rdi
  10fb0b:	e8 51 12 00 00       	callq  110d61 <z_reschedule>

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, queue_insert, queue, alloc, 0);

	return 0;
  10fb10:	31 c0                	xor    %eax,%eax
}
  10fb12:	48 83 c4 18          	add    $0x18,%rsp
  10fb16:	5b                   	pop    %rbx
  10fb17:	41 5c                	pop    %r12
  10fb19:	41 5d                	pop    %r13
  10fb1b:	41 5e                	pop    %r14
  10fb1d:	41 5f                	pop    %r15
  10fb1f:	5d                   	pop    %rbp
  10fb20:	c3                   	retq   

000000000010fb21 <z_queue_node_peek>:
{
  10fb21:	48 89 f8             	mov    %rdi,%rax
	if ((node != NULL) && (sys_sfnode_flags_get(node) != (uint8_t)0)) {
  10fb24:	48 85 ff             	test   %rdi,%rdi
  10fb27:	74 20                	je     10fb49 <z_queue_node_peek+0x28>
  10fb29:	f6 07 03             	testb  $0x3,(%rdi)
  10fb2c:	74 1b                	je     10fb49 <z_queue_node_peek+0x28>
{
  10fb2e:	55                   	push   %rbp
  10fb2f:	48 89 e5             	mov    %rsp,%rbp
  10fb32:	53                   	push   %rbx
  10fb33:	51                   	push   %rcx
		ret = anode->data;
  10fb34:	48 8b 5f 08          	mov    0x8(%rdi),%rbx
		if (needs_free) {
  10fb38:	40 84 f6             	test   %sil,%sil
  10fb3b:	74 05                	je     10fb42 <z_queue_node_peek+0x21>
			k_free(anode);
  10fb3d:	e8 1b 5f 00 00       	callq  115a5d <k_free>
  10fb42:	48 89 d8             	mov    %rbx,%rax
}
  10fb45:	5a                   	pop    %rdx
  10fb46:	5b                   	pop    %rbx
  10fb47:	5d                   	pop    %rbp
  10fb48:	c3                   	retq   
  10fb49:	c3                   	retq   

000000000010fb4a <z_impl_k_queue_init>:
  10fb4a:	48 8d 47 18          	lea    0x18(%rdi),%rax
	list->head = NULL;
  10fb4e:	48 c7 07 00 00 00 00 	movq   $0x0,(%rdi)
	list->head = (sys_dnode_t *)list;
  10fb55:	48 89 47 18          	mov    %rax,0x18(%rdi)
	list->tail = (sys_dnode_t *)list;
  10fb59:	48 89 47 20          	mov    %rax,0x20(%rdi)
	sys_dlist_init(&queue->poll_events);
  10fb5d:	48 8d 47 28          	lea    0x28(%rdi),%rax
	list->tail = NULL;
  10fb61:	48 c7 47 08 00 00 00 	movq   $0x0,0x8(%rdi)
  10fb68:	00 
	queue->lock = (struct k_spinlock) {};
  10fb69:	48 c7 47 10 00 00 00 	movq   $0x0,0x10(%rdi)
  10fb70:	00 
	list->head = (sys_dnode_t *)list;
  10fb71:	48 89 47 28          	mov    %rax,0x28(%rdi)
	list->tail = (sys_dnode_t *)list;
  10fb75:	48 89 47 30          	mov    %rax,0x30(%rdi)
	z_object_init(queue);
  10fb79:	e9 73 74 00 00       	jmpq   116ff1 <z_object_init>

000000000010fb7e <z_mrsh_k_queue_init>:
#include <syscalls/kernel.h>

extern void z_vrfy_k_queue_init(struct k_queue * queue);
uintptr_t z_mrsh_k_queue_init(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
  10fb7e:	55                   	push   %rbp
  10fb7f:	48 89 e5             	mov    %rsp,%rbp
  10fb82:	41 54                	push   %r12
  10fb84:	49 89 fc             	mov    %rdi,%r12
  10fb87:	51                   	push   %rcx
	_current->syscall_frame = ssf;
  10fb88:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  10fb8c:	48 8b 05 bd 8b 01 00 	mov    0x18bbd(%rip),%rax        # 128750 <_kernel+0x10>
  10fb93:	48 89 90 40 01 00 00 	mov    %rdx,0x140(%rax)
	Z_OOPS(Z_SYSCALL_OBJ_NEVER_INIT(queue, K_OBJ_QUEUE));
  10fb9a:	e8 35 6f 00 00       	callq  116ad4 <z_object_find>
  10fb9f:	83 ca ff             	or     $0xffffffff,%edx
  10fba2:	4c 89 e6             	mov    %r12,%rsi
  10fba5:	48 89 c7             	mov    %rax,%rdi
  10fba8:	e8 7c fd ff ff       	callq  10f929 <z_obj_validation_check.constprop.0>
  10fbad:	85 c0                	test   %eax,%eax
  10fbaf:	74 29                	je     10fbda <z_mrsh_k_queue_init+0x5c>
  10fbb1:	bf 23 f3 11 00       	mov    $0x11f323,%edi
  10fbb6:	31 c0                	xor    %eax,%eax
  10fbb8:	ba f0 c3 11 00       	mov    $0x11c3f0,%edx
  10fbbd:	be 45 00 00 00       	mov    $0x45,%esi
  10fbc2:	e8 ff 34 ff ff       	callq  1030c6 <z_log_minimal_printk>
  10fbc7:	48 8b 05 82 8b 01 00 	mov    0x18b82(%rip),%rax        # 128750 <_kernel+0x10>
  10fbce:	48 8b b8 40 01 00 00 	mov    0x140(%rax),%rdi
  10fbd5:	e8 33 a0 ff ff       	callq  109c0d <arch_syscall_oops>
	z_impl_k_queue_init(queue);
  10fbda:	4c 89 e7             	mov    %r12,%rdi
  10fbdd:	e8 68 ff ff ff       	callq  10fb4a <z_impl_k_queue_init>
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	z_vrfy_k_queue_init(*(struct k_queue **)&arg0)
;
	_current->syscall_frame = NULL;
  10fbe2:	48 8b 05 67 8b 01 00 	mov    0x18b67(%rip),%rax        # 128750 <_kernel+0x10>
  10fbe9:	48 c7 80 40 01 00 00 	movq   $0x0,0x140(%rax)
  10fbf0:	00 00 00 00 
	return 0;
}
  10fbf4:	31 c0                	xor    %eax,%eax
  10fbf6:	5a                   	pop    %rdx
  10fbf7:	41 5c                	pop    %r12
  10fbf9:	5d                   	pop    %rbp
  10fbfa:	c3                   	retq   

000000000010fbfb <z_impl_k_queue_cancel_wait>:
{
  10fbfb:	55                   	push   %rbp
  10fbfc:	48 89 e5             	mov    %rsp,%rbp
  10fbff:	41 55                	push   %r13
  10fc01:	41 54                	push   %r12
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
  10fc03:	4c 8d 67 10          	lea    0x10(%rdi),%r12
{
  10fc07:	53                   	push   %rbx
  10fc08:	48 89 fb             	mov    %rdi,%rbx
  10fc0b:	52                   	push   %rdx
  10fc0c:	9c                   	pushfq 
  10fc0d:	fa                   	cli    
  10fc0e:	41 5d                	pop    %r13
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  10fc10:	4c 89 e7             	mov    %r12,%rdi
  10fc13:	e8 61 dc ff ff       	callq  10d879 <z_spin_lock_valid>
  10fc18:	84 c0                	test   %al,%al
  10fc1a:	75 37                	jne    10fc53 <z_impl_k_queue_cancel_wait+0x58>
  10fc1c:	b9 8e 00 00 00       	mov    $0x8e,%ecx
  10fc21:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  10fc26:	be fd d1 11 00       	mov    $0x11d1fd,%esi
  10fc2b:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  10fc30:	e8 c3 09 ff ff       	callq  1005f8 <printk>
  10fc35:	4c 89 e6             	mov    %r12,%rsi
  10fc38:	bf 12 d2 11 00       	mov    $0x11d212,%edi
  10fc3d:	31 c0                	xor    %eax,%eax
  10fc3f:	e8 b4 09 ff ff       	callq  1005f8 <printk>
  10fc44:	be 8e 00 00 00       	mov    $0x8e,%esi
  10fc49:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  10fc4e:	e8 45 2f ff ff       	callq  102b98 <assert_post_action>
	z_spin_lock_set_owner(l);
  10fc53:	4c 89 e7             	mov    %r12,%rdi
  10fc56:	e8 62 dc ff ff       	callq  10d8bd <z_spin_lock_set_owner>
	first_pending_thread = z_unpend_first_thread(&queue->wait_q);
  10fc5b:	48 8d 7b 18          	lea    0x18(%rbx),%rdi
  10fc5f:	e8 f9 22 00 00       	callq  111f5d <z_unpend_first_thread>
  10fc64:	48 89 c7             	mov    %rax,%rdi
	if (first_pending_thread != NULL) {
  10fc67:	48 85 c0             	test   %rax,%rax
  10fc6a:	74 17                	je     10fc83 <z_impl_k_queue_cancel_wait+0x88>
	thread->swap_retval = value;
  10fc6c:	c7 80 48 01 00 00 00 	movl   $0x0,0x148(%rax)
  10fc73:	00 00 00 
	thread->base.swap_data = data;
  10fc76:	48 c7 40 20 00 00 00 	movq   $0x0,0x20(%rax)
  10fc7d:	00 
	z_ready_thread(thread);
  10fc7e:	e8 c7 17 00 00       	callq  11144a <z_ready_thread>
	z_handle_obj_poll_events(&queue->poll_events, state);
  10fc83:	48 8d 7b 28          	lea    0x28(%rbx),%rdi
  10fc87:	be 08 00 00 00       	mov    $0x8,%esi
  10fc8c:	e8 54 59 00 00       	callq  1155e5 <z_handle_obj_poll_events>
}
  10fc91:	58                   	pop    %rax
	z_reschedule(&queue->lock, key);
  10fc92:	44 89 ee             	mov    %r13d,%esi
}
  10fc95:	5b                   	pop    %rbx
	z_reschedule(&queue->lock, key);
  10fc96:	4c 89 e7             	mov    %r12,%rdi
}
  10fc99:	41 5c                	pop    %r12
  10fc9b:	41 5d                	pop    %r13
  10fc9d:	5d                   	pop    %rbp
	z_reschedule(&queue->lock, key);
  10fc9e:	e9 be 10 00 00       	jmpq   110d61 <z_reschedule>

000000000010fca3 <z_mrsh_k_queue_cancel_wait>:
#include <syscalls/kernel.h>

extern void z_vrfy_k_queue_cancel_wait(struct k_queue * queue);
uintptr_t z_mrsh_k_queue_cancel_wait(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
  10fca3:	55                   	push   %rbp
  10fca4:	48 89 e5             	mov    %rsp,%rbp
  10fca7:	41 54                	push   %r12
  10fca9:	49 89 fc             	mov    %rdi,%r12
  10fcac:	51                   	push   %rcx
	_current->syscall_frame = ssf;
  10fcad:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  10fcb1:	48 8b 05 98 8a 01 00 	mov    0x18a98(%rip),%rax        # 128750 <_kernel+0x10>
  10fcb8:	48 89 90 40 01 00 00 	mov    %rdx,0x140(%rax)
	Z_OOPS(Z_SYSCALL_OBJ(queue, K_OBJ_QUEUE));
  10fcbf:	e8 10 6e 00 00       	callq  116ad4 <z_object_find>
  10fcc4:	31 d2                	xor    %edx,%edx
  10fcc6:	4c 89 e6             	mov    %r12,%rsi
  10fcc9:	48 89 c7             	mov    %rax,%rdi
  10fccc:	e8 58 fc ff ff       	callq  10f929 <z_obj_validation_check.constprop.0>
  10fcd1:	85 c0                	test   %eax,%eax
  10fcd3:	74 29                	je     10fcfe <z_mrsh_k_queue_cancel_wait+0x5b>
  10fcd5:	bf 23 f3 11 00       	mov    $0x11f323,%edi
  10fcda:	31 c0                	xor    %eax,%eax
  10fcdc:	ba d0 c3 11 00       	mov    $0x11c3d0,%edx
  10fce1:	be 45 00 00 00       	mov    $0x45,%esi
  10fce6:	e8 db 33 ff ff       	callq  1030c6 <z_log_minimal_printk>
  10fceb:	48 8b 05 5e 8a 01 00 	mov    0x18a5e(%rip),%rax        # 128750 <_kernel+0x10>
  10fcf2:	48 8b b8 40 01 00 00 	mov    0x140(%rax),%rdi
  10fcf9:	e8 0f 9f ff ff       	callq  109c0d <arch_syscall_oops>
	z_impl_k_queue_cancel_wait(queue);
  10fcfe:	4c 89 e7             	mov    %r12,%rdi
  10fd01:	e8 f5 fe ff ff       	callq  10fbfb <z_impl_k_queue_cancel_wait>
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	z_vrfy_k_queue_cancel_wait(*(struct k_queue **)&arg0)
;
	_current->syscall_frame = NULL;
  10fd06:	48 8b 05 43 8a 01 00 	mov    0x18a43(%rip),%rax        # 128750 <_kernel+0x10>
  10fd0d:	48 c7 80 40 01 00 00 	movq   $0x0,0x140(%rax)
  10fd14:	00 00 00 00 
	return 0;
}
  10fd18:	31 c0                	xor    %eax,%eax
  10fd1a:	5a                   	pop    %rdx
  10fd1b:	41 5c                	pop    %r12
  10fd1d:	5d                   	pop    %rbp
  10fd1e:	c3                   	retq   

000000000010fd1f <z_impl_k_queue_alloc_append>:

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, prepend, queue);
}

int32_t z_impl_k_queue_alloc_append(struct k_queue *queue, void *data)
{
  10fd1f:	48 89 f2             	mov    %rsi,%rdx
	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_queue, alloc_append, queue);

	int32_t ret = queue_insert(queue, NULL, data, true, true);
  10fd22:	41 b8 01 00 00 00    	mov    $0x1,%r8d
  10fd28:	b9 01 00 00 00       	mov    $0x1,%ecx
  10fd2d:	31 f6                	xor    %esi,%esi
  10fd2f:	e9 35 fc ff ff       	jmpq   10f969 <queue_insert>

000000000010fd34 <z_mrsh_k_queue_alloc_append>:
#include <syscalls/kernel.h>

extern int32_t z_vrfy_k_queue_alloc_append(struct k_queue * queue, void * data);
uintptr_t z_mrsh_k_queue_alloc_append(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
  10fd34:	55                   	push   %rbp
	_current->syscall_frame = ssf;
  10fd35:	48 8b 05 14 8a 01 00 	mov    0x18a14(%rip),%rax        # 128750 <_kernel+0x10>
{
  10fd3c:	48 89 e5             	mov    %rsp,%rbp
  10fd3f:	41 55                	push   %r13
  10fd41:	49 89 f5             	mov    %rsi,%r13
	_current->syscall_frame = ssf;
  10fd44:	48 8b 55 10          	mov    0x10(%rbp),%rdx
{
  10fd48:	41 54                	push   %r12
  10fd4a:	49 89 fc             	mov    %rdi,%r12
	_current->syscall_frame = ssf;
  10fd4d:	48 89 90 40 01 00 00 	mov    %rdx,0x140(%rax)

#ifdef CONFIG_USERSPACE
static inline int32_t z_vrfy_k_queue_alloc_append(struct k_queue *queue,
						  void *data)
{
	Z_OOPS(Z_SYSCALL_OBJ(queue, K_OBJ_QUEUE));
  10fd54:	e8 7b 6d 00 00       	callq  116ad4 <z_object_find>
  10fd59:	31 d2                	xor    %edx,%edx
  10fd5b:	4c 89 e6             	mov    %r12,%rsi
  10fd5e:	48 89 c7             	mov    %rax,%rdi
  10fd61:	e8 c3 fb ff ff       	callq  10f929 <z_obj_validation_check.constprop.0>
  10fd66:	85 c0                	test   %eax,%eax
  10fd68:	74 29                	je     10fd93 <z_mrsh_k_queue_alloc_append+0x5f>
  10fd6a:	bf 23 f3 11 00       	mov    $0x11f323,%edi
  10fd6f:	31 c0                	xor    %eax,%eax
  10fd71:	ba b0 c3 11 00       	mov    $0x11c3b0,%edx
  10fd76:	be 45 00 00 00       	mov    $0x45,%esi
  10fd7b:	e8 46 33 ff ff       	callq  1030c6 <z_log_minimal_printk>
  10fd80:	48 8b 05 c9 89 01 00 	mov    0x189c9(%rip),%rax        # 128750 <_kernel+0x10>
  10fd87:	48 8b b8 40 01 00 00 	mov    0x140(%rax),%rdi
  10fd8e:	e8 7a 9e ff ff       	callq  109c0d <arch_syscall_oops>
	return z_impl_k_queue_alloc_append(queue, data);
  10fd93:	4c 89 ee             	mov    %r13,%rsi
  10fd96:	4c 89 e7             	mov    %r12,%rdi
  10fd99:	e8 81 ff ff ff       	callq  10fd1f <z_impl_k_queue_alloc_append>
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	int32_t ret = z_vrfy_k_queue_alloc_append(*(struct k_queue **)&arg0, *(void **)&arg1)
;
	_current->syscall_frame = NULL;
  10fd9e:	48 8b 15 ab 89 01 00 	mov    0x189ab(%rip),%rdx        # 128750 <_kernel+0x10>
	return (uintptr_t) ret;
  10fda5:	48 98                	cltq   
	_current->syscall_frame = NULL;
  10fda7:	48 c7 82 40 01 00 00 	movq   $0x0,0x140(%rdx)
  10fdae:	00 00 00 00 
}
  10fdb2:	41 5c                	pop    %r12
  10fdb4:	41 5d                	pop    %r13
  10fdb6:	5d                   	pop    %rbp
  10fdb7:	c3                   	retq   

000000000010fdb8 <z_impl_k_queue_alloc_prepend>:
}
#include <syscalls/k_queue_alloc_append_mrsh.c>
#endif

int32_t z_impl_k_queue_alloc_prepend(struct k_queue *queue, void *data)
{
  10fdb8:	48 89 f2             	mov    %rsi,%rdx
	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_queue, alloc_prepend, queue);

	int32_t ret = queue_insert(queue, NULL, data, true, false);
  10fdbb:	45 31 c0             	xor    %r8d,%r8d
  10fdbe:	b9 01 00 00 00       	mov    $0x1,%ecx
  10fdc3:	31 f6                	xor    %esi,%esi
  10fdc5:	e9 9f fb ff ff       	jmpq   10f969 <queue_insert>

000000000010fdca <z_mrsh_k_queue_alloc_prepend>:
#include <syscalls/kernel.h>

extern int32_t z_vrfy_k_queue_alloc_prepend(struct k_queue * queue, void * data);
uintptr_t z_mrsh_k_queue_alloc_prepend(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
  10fdca:	55                   	push   %rbp
	_current->syscall_frame = ssf;
  10fdcb:	48 8b 05 7e 89 01 00 	mov    0x1897e(%rip),%rax        # 128750 <_kernel+0x10>
{
  10fdd2:	48 89 e5             	mov    %rsp,%rbp
  10fdd5:	41 55                	push   %r13
  10fdd7:	49 89 f5             	mov    %rsi,%r13
	_current->syscall_frame = ssf;
  10fdda:	48 8b 55 10          	mov    0x10(%rbp),%rdx
{
  10fdde:	41 54                	push   %r12
  10fde0:	49 89 fc             	mov    %rdi,%r12
	_current->syscall_frame = ssf;
  10fde3:	48 89 90 40 01 00 00 	mov    %rdx,0x140(%rax)

#ifdef CONFIG_USERSPACE
static inline int32_t z_vrfy_k_queue_alloc_prepend(struct k_queue *queue,
						   void *data)
{
	Z_OOPS(Z_SYSCALL_OBJ(queue, K_OBJ_QUEUE));
  10fdea:	e8 e5 6c 00 00       	callq  116ad4 <z_object_find>
  10fdef:	31 d2                	xor    %edx,%edx
  10fdf1:	4c 89 e6             	mov    %r12,%rsi
  10fdf4:	48 89 c7             	mov    %rax,%rdi
  10fdf7:	e8 2d fb ff ff       	callq  10f929 <z_obj_validation_check.constprop.0>
  10fdfc:	85 c0                	test   %eax,%eax
  10fdfe:	74 29                	je     10fe29 <z_mrsh_k_queue_alloc_prepend+0x5f>
  10fe00:	bf 23 f3 11 00       	mov    $0x11f323,%edi
  10fe05:	31 c0                	xor    %eax,%eax
  10fe07:	ba 90 c3 11 00       	mov    $0x11c390,%edx
  10fe0c:	be 45 00 00 00       	mov    $0x45,%esi
  10fe11:	e8 b0 32 ff ff       	callq  1030c6 <z_log_minimal_printk>
  10fe16:	48 8b 05 33 89 01 00 	mov    0x18933(%rip),%rax        # 128750 <_kernel+0x10>
  10fe1d:	48 8b b8 40 01 00 00 	mov    0x140(%rax),%rdi
  10fe24:	e8 e4 9d ff ff       	callq  109c0d <arch_syscall_oops>
	return z_impl_k_queue_alloc_prepend(queue, data);
  10fe29:	4c 89 ee             	mov    %r13,%rsi
  10fe2c:	4c 89 e7             	mov    %r12,%rdi
  10fe2f:	e8 84 ff ff ff       	callq  10fdb8 <z_impl_k_queue_alloc_prepend>
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	int32_t ret = z_vrfy_k_queue_alloc_prepend(*(struct k_queue **)&arg0, *(void **)&arg1)
;
	_current->syscall_frame = NULL;
  10fe34:	48 8b 15 15 89 01 00 	mov    0x18915(%rip),%rdx        # 128750 <_kernel+0x10>
	return (uintptr_t) ret;
  10fe3b:	48 98                	cltq   
	_current->syscall_frame = NULL;
  10fe3d:	48 c7 82 40 01 00 00 	movq   $0x0,0x140(%rdx)
  10fe44:	00 00 00 00 
}
  10fe48:	41 5c                	pop    %r12
  10fe4a:	41 5d                	pop    %r13
  10fe4c:	5d                   	pop    %rbp
  10fe4d:	c3                   	retq   

000000000010fe4e <z_impl_k_queue_get>:

	return 0;
}

void *z_impl_k_queue_get(struct k_queue *queue, k_timeout_t timeout)
{
  10fe4e:	55                   	push   %rbp
  10fe4f:	48 89 e5             	mov    %rsp,%rbp
  10fe52:	41 57                	push   %r15
  10fe54:	41 56                	push   %r14
  10fe56:	49 89 f6             	mov    %rsi,%r14
  10fe59:	41 55                	push   %r13
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
  10fe5b:	4c 8d 6f 10          	lea    0x10(%rdi),%r13
{
  10fe5f:	41 54                	push   %r12
  10fe61:	53                   	push   %rbx
  10fe62:	48 89 fb             	mov    %rdi,%rbx
  10fe65:	51                   	push   %rcx
  10fe66:	9c                   	pushfq 
  10fe67:	fa                   	cli    
  10fe68:	41 5f                	pop    %r15
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  10fe6a:	4c 89 ef             	mov    %r13,%rdi
  10fe6d:	e8 07 da ff ff       	callq  10d879 <z_spin_lock_valid>
  10fe72:	84 c0                	test   %al,%al
  10fe74:	75 37                	jne    10fead <z_impl_k_queue_get+0x5f>
  10fe76:	b9 8e 00 00 00       	mov    $0x8e,%ecx
  10fe7b:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  10fe80:	be fd d1 11 00       	mov    $0x11d1fd,%esi
  10fe85:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  10fe8a:	e8 69 07 ff ff       	callq  1005f8 <printk>
  10fe8f:	4c 89 ee             	mov    %r13,%rsi
  10fe92:	bf 12 d2 11 00       	mov    $0x11d212,%edi
  10fe97:	31 c0                	xor    %eax,%eax
  10fe99:	e8 5a 07 ff ff       	callq  1005f8 <printk>
  10fe9e:	be 8e 00 00 00       	mov    $0x8e,%esi
  10fea3:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  10fea8:	e8 eb 2c ff ff       	callq  102b98 <assert_post_action>
	z_spin_lock_set_owner(l);
  10fead:	4c 89 ef             	mov    %r13,%rdi
  10feb0:	e8 08 da ff ff       	callq  10d8bd <z_spin_lock_set_owner>
	return list->head;
  10feb5:	4c 8b 23             	mov    (%rbx),%r12
	void *data;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_queue, get, queue, timeout);

	if (likely(!sys_sflist_is_empty(&queue->data_q))) {
  10feb8:	4d 85 e4             	test   %r12,%r12
  10febb:	74 27                	je     10fee4 <z_impl_k_queue_get+0x96>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
  10febd:	49 8b 04 24          	mov    (%r12),%rax
  10fec1:	48 83 e0 fc          	and    $0xfffffffffffffffc,%rax
	list->head = node;
  10fec5:	48 89 03             	mov    %rax,(%rbx)
 *
 * @return A pointer to the first node of the list
 */
static inline sys_sfnode_t *sys_sflist_get_not_empty(sys_sflist_t *list);

Z_GENLIST_GET_NOT_EMPTY(sflist, sfnode)
  10fec8:	4c 3b 63 08          	cmp    0x8(%rbx),%r12
  10fecc:	75 04                	jne    10fed2 <z_impl_k_queue_get+0x84>
	list->tail = node;
  10fece:	48 89 43 08          	mov    %rax,0x8(%rbx)
		sys_sfnode_t *node;

		node = sys_sflist_get_not_empty(&queue->data_q);
		data = z_queue_node_peek(node, true);
  10fed2:	4c 89 e7             	mov    %r12,%rdi
  10fed5:	be 01 00 00 00       	mov    $0x1,%esi
  10feda:	e8 42 fc ff ff       	callq  10fb21 <z_queue_node_peek>
  10fedf:	49 89 c4             	mov    %rax,%r12
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  10fee2:	eb 05                	jmp    10fee9 <z_impl_k_queue_get+0x9b>
		return data;
	}

	SYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_queue, get, queue, timeout);

	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
  10fee4:	4d 85 f6             	test   %r14,%r14
  10fee7:	75 4d                	jne    10ff36 <z_impl_k_queue_get+0xe8>
  10fee9:	4c 89 ef             	mov    %r13,%rdi
  10feec:	e8 a8 d9 ff ff       	callq  10d899 <z_spin_unlock_valid>
  10fef1:	84 c0                	test   %al,%al
  10fef3:	75 37                	jne    10ff2c <z_impl_k_queue_get+0xde>
  10fef5:	b9 b9 00 00 00       	mov    $0xb9,%ecx
  10fefa:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  10feff:	be 41 d2 11 00       	mov    $0x11d241,%esi
  10ff04:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  10ff09:	e8 ea 06 ff ff       	callq  1005f8 <printk>
  10ff0e:	4c 89 ee             	mov    %r13,%rsi
  10ff11:	bf 58 d2 11 00       	mov    $0x11d258,%edi
  10ff16:	31 c0                	xor    %eax,%eax
  10ff18:	e8 db 06 ff ff       	callq  1005f8 <printk>
  10ff1d:	be b9 00 00 00       	mov    $0xb9,%esi
  10ff22:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  10ff27:	e8 6c 2c ff ff       	callq  102b98 <assert_post_action>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  10ff2c:	41 0f ba e7 09       	bt     $0x9,%r15d
  10ff31:	73 24                	jae    10ff57 <z_impl_k_queue_get+0x109>
		__asm__ volatile ("sti" ::: "memory");
  10ff33:	fb                   	sti    
  10ff34:	eb 21                	jmp    10ff57 <z_impl_k_queue_get+0x109>
		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, get, queue, timeout, NULL);

		return NULL;
	}

	int ret = z_pend_curr(&queue->lock, key, &queue->wait_q, timeout);
  10ff36:	48 8d 53 18          	lea    0x18(%rbx),%rdx
  10ff3a:	4c 89 f1             	mov    %r14,%rcx
  10ff3d:	44 89 fe             	mov    %r15d,%esi
  10ff40:	4c 89 ef             	mov    %r13,%rdi
  10ff43:	e8 a0 1a 00 00       	callq  1119e8 <z_pend_curr>

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, get, queue, timeout,
		(ret != 0) ? NULL : _current->base.swap_data);

	return (ret != 0) ? NULL : _current->base.swap_data;
  10ff48:	85 c0                	test   %eax,%eax
  10ff4a:	75 0b                	jne    10ff57 <z_impl_k_queue_get+0x109>
  10ff4c:	48 8b 05 fd 87 01 00 	mov    0x187fd(%rip),%rax        # 128750 <_kernel+0x10>
  10ff53:	4c 8b 60 20          	mov    0x20(%rax),%r12
}
  10ff57:	5a                   	pop    %rdx
  10ff58:	4c 89 e0             	mov    %r12,%rax
  10ff5b:	5b                   	pop    %rbx
  10ff5c:	41 5c                	pop    %r12
  10ff5e:	41 5d                	pop    %r13
  10ff60:	41 5e                	pop    %r14
  10ff62:	41 5f                	pop    %r15
  10ff64:	5d                   	pop    %rbp
  10ff65:	c3                   	retq   

000000000010ff66 <z_impl_k_queue_peek_head>:
	return true;
}

void *z_impl_k_queue_peek_head(struct k_queue *queue)
{
	void *ret = z_queue_node_peek(sys_sflist_peek_head(&queue->data_q), false);
  10ff66:	48 8b 3f             	mov    (%rdi),%rdi
  10ff69:	31 f6                	xor    %esi,%esi
  10ff6b:	e9 b1 fb ff ff       	jmpq   10fb21 <z_queue_node_peek>

000000000010ff70 <z_impl_k_queue_peek_tail>:
	return ret;
}

void *z_impl_k_queue_peek_tail(struct k_queue *queue)
{
	void *ret = z_queue_node_peek(sys_sflist_peek_tail(&queue->data_q), false);
  10ff70:	48 8b 7f 08          	mov    0x8(%rdi),%rdi
  10ff74:	31 f6                	xor    %esi,%esi
  10ff76:	e9 a6 fb ff ff       	jmpq   10fb21 <z_queue_node_peek>

000000000010ff7b <z_mrsh_k_queue_get>:
#include <syscalls/kernel.h>

extern void * z_vrfy_k_queue_get(struct k_queue * queue, k_timeout_t timeout);
uintptr_t z_mrsh_k_queue_get(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
  10ff7b:	55                   	push   %rbp
  10ff7c:	48 89 e5             	mov    %rsp,%rbp
  10ff7f:	41 55                	push   %r13
  10ff81:	49 89 f5             	mov    %rsi,%r13
  10ff84:	41 54                	push   %r12
  10ff86:	49 89 fc             	mov    %rdi,%r12
  10ff89:	48 83 ec 10          	sub    $0x10,%rsp
	_current->syscall_frame = ssf;
  10ff8d:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  10ff91:	48 8b 05 b8 87 01 00 	mov    0x187b8(%rip),%rax        # 128750 <_kernel+0x10>
{
  10ff98:	48 89 75 e8          	mov    %rsi,-0x18(%rbp)
	_current->syscall_frame = ssf;
  10ff9c:	48 89 90 40 01 00 00 	mov    %rdx,0x140(%rax)

#ifdef CONFIG_USERSPACE
static inline void *z_vrfy_k_queue_get(struct k_queue *queue,
				       k_timeout_t timeout)
{
	Z_OOPS(Z_SYSCALL_OBJ(queue, K_OBJ_QUEUE));
  10ffa3:	e8 2c 6b 00 00       	callq  116ad4 <z_object_find>
  10ffa8:	31 d2                	xor    %edx,%edx
  10ffaa:	4c 89 e6             	mov    %r12,%rsi
  10ffad:	48 89 c7             	mov    %rax,%rdi
  10ffb0:	e8 74 f9 ff ff       	callq  10f929 <z_obj_validation_check.constprop.0>
  10ffb5:	85 c0                	test   %eax,%eax
  10ffb7:	74 29                	je     10ffe2 <z_mrsh_k_queue_get+0x67>
  10ffb9:	bf 23 f3 11 00       	mov    $0x11f323,%edi
  10ffbe:	31 c0                	xor    %eax,%eax
  10ffc0:	ba 70 c3 11 00       	mov    $0x11c370,%edx
  10ffc5:	be 45 00 00 00       	mov    $0x45,%esi
  10ffca:	e8 f7 30 ff ff       	callq  1030c6 <z_log_minimal_printk>
  10ffcf:	48 8b 05 7a 87 01 00 	mov    0x1877a(%rip),%rax        # 128750 <_kernel+0x10>
  10ffd6:	48 8b b8 40 01 00 00 	mov    0x140(%rax),%rdi
  10ffdd:	e8 2b 9c ff ff       	callq  109c0d <arch_syscall_oops>
	return z_impl_k_queue_get(queue, timeout);
  10ffe2:	4c 89 ee             	mov    %r13,%rsi
  10ffe5:	4c 89 e7             	mov    %r12,%rdi
  10ffe8:	e8 61 fe ff ff       	callq  10fe4e <z_impl_k_queue_get>
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	void * ret = z_vrfy_k_queue_get(*(struct k_queue **)&arg0, *(k_timeout_t*)&arg1)
;
	_current->syscall_frame = NULL;
  10ffed:	48 8b 15 5c 87 01 00 	mov    0x1875c(%rip),%rdx        # 128750 <_kernel+0x10>
  10fff4:	48 c7 82 40 01 00 00 	movq   $0x0,0x140(%rdx)
  10fffb:	00 00 00 00 
	return (uintptr_t) ret;
}
  10ffff:	5a                   	pop    %rdx
  110000:	59                   	pop    %rcx
  110001:	41 5c                	pop    %r12
  110003:	41 5d                	pop    %r13
  110005:	5d                   	pop    %rbp
  110006:	c3                   	retq   

0000000000110007 <z_mrsh_k_queue_is_empty>:
#include <syscalls/kernel.h>

extern int z_vrfy_k_queue_is_empty(struct k_queue * queue);
uintptr_t z_mrsh_k_queue_is_empty(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
  110007:	55                   	push   %rbp
  110008:	48 89 e5             	mov    %rsp,%rbp
  11000b:	53                   	push   %rbx
  11000c:	48 89 fb             	mov    %rdi,%rbx
  11000f:	51                   	push   %rcx
	_current->syscall_frame = ssf;
  110010:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  110014:	48 8b 05 35 87 01 00 	mov    0x18735(%rip),%rax        # 128750 <_kernel+0x10>
  11001b:	48 89 90 40 01 00 00 	mov    %rdx,0x140(%rax)
}
#include <syscalls/k_queue_get_mrsh.c>

static inline int z_vrfy_k_queue_is_empty(struct k_queue *queue)
{
	Z_OOPS(Z_SYSCALL_OBJ(queue, K_OBJ_QUEUE));
  110022:	e8 ad 6a 00 00       	callq  116ad4 <z_object_find>
  110027:	31 d2                	xor    %edx,%edx
  110029:	48 89 de             	mov    %rbx,%rsi
  11002c:	48 89 c7             	mov    %rax,%rdi
  11002f:	e8 f5 f8 ff ff       	callq  10f929 <z_obj_validation_check.constprop.0>
  110034:	85 c0                	test   %eax,%eax
  110036:	74 29                	je     110061 <z_mrsh_k_queue_is_empty+0x5a>
  110038:	bf 23 f3 11 00       	mov    $0x11f323,%edi
  11003d:	31 c0                	xor    %eax,%eax
  11003f:	ba 50 c3 11 00       	mov    $0x11c350,%edx
  110044:	be 45 00 00 00       	mov    $0x45,%esi
  110049:	e8 78 30 ff ff       	callq  1030c6 <z_log_minimal_printk>
  11004e:	48 8b 05 fb 86 01 00 	mov    0x186fb(%rip),%rax        # 128750 <_kernel+0x10>
  110055:	48 8b b8 40 01 00 00 	mov    0x140(%rax),%rdi
  11005c:	e8 ac 9b ff ff       	callq  109c0d <arch_syscall_oops>
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	int ret = z_vrfy_k_queue_is_empty(*(struct k_queue **)&arg0)
;
	_current->syscall_frame = NULL;
  110061:	48 8b 05 e8 86 01 00 	mov    0x186e8(%rip),%rax        # 128750 <_kernel+0x10>
Z_GENLIST_IS_EMPTY(sflist)
  110068:	48 83 3b 00          	cmpq   $0x0,(%rbx)
  11006c:	48 c7 80 40 01 00 00 	movq   $0x0,0x140(%rax)
  110073:	00 00 00 00 
	return (uintptr_t) ret;
  110077:	0f 94 c0             	sete   %al
}
  11007a:	5a                   	pop    %rdx
	return (uintptr_t) ret;
  11007b:	0f b6 c0             	movzbl %al,%eax
}
  11007e:	5b                   	pop    %rbx
  11007f:	5d                   	pop    %rbp
  110080:	c3                   	retq   

0000000000110081 <z_mrsh_k_queue_peek_head>:
#include <syscalls/kernel.h>

extern void * z_vrfy_k_queue_peek_head(struct k_queue * queue);
uintptr_t z_mrsh_k_queue_peek_head(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
  110081:	55                   	push   %rbp
  110082:	48 89 e5             	mov    %rsp,%rbp
  110085:	41 54                	push   %r12
  110087:	49 89 fc             	mov    %rdi,%r12
  11008a:	51                   	push   %rcx
	_current->syscall_frame = ssf;
  11008b:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  11008f:	48 8b 05 ba 86 01 00 	mov    0x186ba(%rip),%rax        # 128750 <_kernel+0x10>
  110096:	48 89 90 40 01 00 00 	mov    %rdx,0x140(%rax)
}
#include <syscalls/k_queue_is_empty_mrsh.c>

static inline void *z_vrfy_k_queue_peek_head(struct k_queue *queue)
{
	Z_OOPS(Z_SYSCALL_OBJ(queue, K_OBJ_QUEUE));
  11009d:	e8 32 6a 00 00       	callq  116ad4 <z_object_find>
  1100a2:	31 d2                	xor    %edx,%edx
  1100a4:	4c 89 e6             	mov    %r12,%rsi
  1100a7:	48 89 c7             	mov    %rax,%rdi
  1100aa:	e8 7a f8 ff ff       	callq  10f929 <z_obj_validation_check.constprop.0>
  1100af:	85 c0                	test   %eax,%eax
  1100b1:	74 29                	je     1100dc <z_mrsh_k_queue_peek_head+0x5b>
  1100b3:	bf 23 f3 11 00       	mov    $0x11f323,%edi
  1100b8:	31 c0                	xor    %eax,%eax
  1100ba:	ba 30 c3 11 00       	mov    $0x11c330,%edx
  1100bf:	be 45 00 00 00       	mov    $0x45,%esi
  1100c4:	e8 fd 2f ff ff       	callq  1030c6 <z_log_minimal_printk>
  1100c9:	48 8b 05 80 86 01 00 	mov    0x18680(%rip),%rax        # 128750 <_kernel+0x10>
  1100d0:	48 8b b8 40 01 00 00 	mov    0x140(%rax),%rdi
  1100d7:	e8 31 9b ff ff       	callq  109c0d <arch_syscall_oops>
	return z_impl_k_queue_peek_head(queue);
  1100dc:	4c 89 e7             	mov    %r12,%rdi
  1100df:	e8 82 fe ff ff       	callq  10ff66 <z_impl_k_queue_peek_head>
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	void * ret = z_vrfy_k_queue_peek_head(*(struct k_queue **)&arg0)
;
	_current->syscall_frame = NULL;
  1100e4:	48 8b 15 65 86 01 00 	mov    0x18665(%rip),%rdx        # 128750 <_kernel+0x10>
  1100eb:	48 c7 82 40 01 00 00 	movq   $0x0,0x140(%rdx)
  1100f2:	00 00 00 00 
	return (uintptr_t) ret;
}
  1100f6:	5a                   	pop    %rdx
  1100f7:	41 5c                	pop    %r12
  1100f9:	5d                   	pop    %rbp
  1100fa:	c3                   	retq   

00000000001100fb <z_mrsh_k_queue_peek_tail>:
#include <syscalls/kernel.h>

extern void * z_vrfy_k_queue_peek_tail(struct k_queue * queue);
uintptr_t z_mrsh_k_queue_peek_tail(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
  1100fb:	55                   	push   %rbp
  1100fc:	48 89 e5             	mov    %rsp,%rbp
  1100ff:	41 54                	push   %r12
  110101:	49 89 fc             	mov    %rdi,%r12
  110104:	51                   	push   %rcx
	_current->syscall_frame = ssf;
  110105:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  110109:	48 8b 05 40 86 01 00 	mov    0x18640(%rip),%rax        # 128750 <_kernel+0x10>
  110110:	48 89 90 40 01 00 00 	mov    %rdx,0x140(%rax)
}
#include <syscalls/k_queue_peek_head_mrsh.c>

static inline void *z_vrfy_k_queue_peek_tail(struct k_queue *queue)
{
	Z_OOPS(Z_SYSCALL_OBJ(queue, K_OBJ_QUEUE));
  110117:	e8 b8 69 00 00       	callq  116ad4 <z_object_find>
  11011c:	31 d2                	xor    %edx,%edx
  11011e:	4c 89 e6             	mov    %r12,%rsi
  110121:	48 89 c7             	mov    %rax,%rdi
  110124:	e8 00 f8 ff ff       	callq  10f929 <z_obj_validation_check.constprop.0>
  110129:	85 c0                	test   %eax,%eax
  11012b:	74 29                	je     110156 <z_mrsh_k_queue_peek_tail+0x5b>
  11012d:	bf 23 f3 11 00       	mov    $0x11f323,%edi
  110132:	31 c0                	xor    %eax,%eax
  110134:	ba 10 c3 11 00       	mov    $0x11c310,%edx
  110139:	be 45 00 00 00       	mov    $0x45,%esi
  11013e:	e8 83 2f ff ff       	callq  1030c6 <z_log_minimal_printk>
  110143:	48 8b 05 06 86 01 00 	mov    0x18606(%rip),%rax        # 128750 <_kernel+0x10>
  11014a:	48 8b b8 40 01 00 00 	mov    0x140(%rax),%rdi
  110151:	e8 b7 9a ff ff       	callq  109c0d <arch_syscall_oops>
	return z_impl_k_queue_peek_tail(queue);
  110156:	4c 89 e7             	mov    %r12,%rdi
  110159:	e8 12 fe ff ff       	callq  10ff70 <z_impl_k_queue_peek_tail>
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	void * ret = z_vrfy_k_queue_peek_tail(*(struct k_queue **)&arg0)
;
	_current->syscall_frame = NULL;
  11015e:	48 8b 15 eb 85 01 00 	mov    0x185eb(%rip),%rdx        # 128750 <_kernel+0x10>
  110165:	48 c7 82 40 01 00 00 	movq   $0x0,0x140(%rdx)
  11016c:	00 00 00 00 
	return (uintptr_t) ret;
}
  110170:	5a                   	pop    %rdx
  110171:	41 5c                	pop    %r12
  110173:	5d                   	pop    %rbp
  110174:	c3                   	retq   

0000000000110175 <z_obj_validation_check.constprop.0>:
static inline int z_obj_validation_check(struct z_object *ko,
  110175:	55                   	push   %rbp
  110176:	48 89 e5             	mov    %rsp,%rbp
  110179:	41 56                	push   %r14
  11017b:	49 89 f6             	mov    %rsi,%r14
	ret = z_object_validate(ko, otype, init);
  11017e:	be 07 00 00 00       	mov    $0x7,%esi
static inline int z_obj_validation_check(struct z_object *ko,
  110183:	41 55                	push   %r13
  110185:	49 89 fd             	mov    %rdi,%r13
  110188:	48 83 ec 10          	sub    $0x10,%rsp
	ret = z_object_validate(ko, otype, init);
  11018c:	e8 db 6d 00 00       	callq  116f6c <z_object_validate>
	if (ret != 0) {
  110191:	85 c0                	test   %eax,%eax
  110193:	74 18                	je     1101ad <z_obj_validation_check.constprop.0+0x38>
		z_dump_object_error(ret, obj, ko, otype);
  110195:	89 c7                	mov    %eax,%edi
  110197:	b9 07 00 00 00       	mov    $0x7,%ecx
  11019c:	4c 89 ea             	mov    %r13,%rdx
  11019f:	4c 89 f6             	mov    %r14,%rsi
  1101a2:	89 45 ec             	mov    %eax,-0x14(%rbp)
  1101a5:	e8 77 6c 00 00       	callq  116e21 <z_dump_object_error>
  1101aa:	8b 45 ec             	mov    -0x14(%rbp),%eax
}
  1101ad:	5a                   	pop    %rdx
  1101ae:	59                   	pop    %rcx
  1101af:	41 5d                	pop    %r13
  1101b1:	41 5e                	pop    %r14
  1101b3:	5d                   	pop    %rbp
  1101b4:	c3                   	retq   

00000000001101b5 <z_impl_k_sem_init>:
		      unsigned int limit)
{
	/*
	 * Limit cannot be zero and count cannot be greater than limit
	 */
	CHECKIF(limit == 0U || limit > K_SEM_MAX_LIMIT || initial_count > limit) {
  1101b5:	85 d2                	test   %edx,%edx
  1101b7:	74 2a                	je     1101e3 <z_impl_k_sem_init+0x2e>
  1101b9:	39 f2                	cmp    %esi,%edx
  1101bb:	72 26                	jb     1101e3 <z_impl_k_sem_init+0x2e>

	SYS_PORT_TRACING_OBJ_FUNC(k_sem, init, sem, 0);

	z_waitq_init(&sem->wait_q);
#if defined(CONFIG_POLL)
	sys_dlist_init(&sem->poll_events);
  1101bd:	48 8d 47 18          	lea    0x18(%rdi),%rax
{
  1101c1:	55                   	push   %rbp
	list->head = (sys_dnode_t *)list;
  1101c2:	48 89 47 18          	mov    %rax,0x18(%rdi)
	list->tail = (sys_dnode_t *)list;
  1101c6:	48 89 47 20          	mov    %rax,0x20(%rdi)
	sem->count = initial_count;
  1101ca:	89 77 10             	mov    %esi,0x10(%rdi)
{
  1101cd:	48 89 e5             	mov    %rsp,%rbp
	sem->limit = limit;
  1101d0:	89 57 14             	mov    %edx,0x14(%rdi)
	list->head = (sys_dnode_t *)list;
  1101d3:	48 89 3f             	mov    %rdi,(%rdi)
	list->tail = (sys_dnode_t *)list;
  1101d6:	48 89 7f 08          	mov    %rdi,0x8(%rdi)
#endif
	z_object_init(sem);
  1101da:	e8 12 6e 00 00       	callq  116ff1 <z_object_init>

	return 0;
  1101df:	31 c0                	xor    %eax,%eax
}
  1101e1:	5d                   	pop    %rbp
  1101e2:	c3                   	retq   
		return -EINVAL;
  1101e3:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
}
  1101e8:	c3                   	retq   

00000000001101e9 <z_vrfy_k_sem_init>:

#ifdef CONFIG_USERSPACE
int z_vrfy_k_sem_init(struct k_sem *sem, unsigned int initial_count,
		      unsigned int limit)
{
  1101e9:	55                   	push   %rbp
  1101ea:	48 89 e5             	mov    %rsp,%rbp
  1101ed:	41 56                	push   %r14
  1101ef:	41 89 d6             	mov    %edx,%r14d
  1101f2:	41 55                	push   %r13
  1101f4:	41 89 f5             	mov    %esi,%r13d
  1101f7:	41 54                	push   %r12
  1101f9:	49 89 fc             	mov    %rdi,%r12
  1101fc:	51                   	push   %rcx
	Z_OOPS(Z_SYSCALL_OBJ_INIT(sem, K_OBJ_SEM));
  1101fd:	e8 d2 68 00 00       	callq  116ad4 <z_object_find>
  110202:	ba 01 00 00 00       	mov    $0x1,%edx
  110207:	4c 89 e6             	mov    %r12,%rsi
  11020a:	48 89 c7             	mov    %rax,%rdi
  11020d:	e8 63 ff ff ff       	callq  110175 <z_obj_validation_check.constprop.0>
  110212:	85 c0                	test   %eax,%eax
  110214:	74 29                	je     11023f <z_vrfy_k_sem_init+0x56>
  110216:	bf 23 f3 11 00       	mov    $0x11f323,%edi
  11021b:	31 c0                	xor    %eax,%eax
  11021d:	ba 90 c4 11 00       	mov    $0x11c490,%edx
  110222:	be 45 00 00 00       	mov    $0x45,%esi
  110227:	e8 9a 2e ff ff       	callq  1030c6 <z_log_minimal_printk>
  11022c:	48 8b 05 1d 85 01 00 	mov    0x1851d(%rip),%rax        # 128750 <_kernel+0x10>
  110233:	48 8b b8 40 01 00 00 	mov    0x140(%rax),%rdi
  11023a:	e8 ce 99 ff ff       	callq  109c0d <arch_syscall_oops>
	return z_impl_k_sem_init(sem, initial_count, limit);
}
  11023f:	58                   	pop    %rax
	return z_impl_k_sem_init(sem, initial_count, limit);
  110240:	44 89 f2             	mov    %r14d,%edx
  110243:	44 89 ee             	mov    %r13d,%esi
  110246:	4c 89 e7             	mov    %r12,%rdi
}
  110249:	41 5c                	pop    %r12
  11024b:	41 5d                	pop    %r13
  11024d:	41 5e                	pop    %r14
  11024f:	5d                   	pop    %rbp
	return z_impl_k_sem_init(sem, initial_count, limit);
  110250:	e9 60 ff ff ff       	jmpq   1101b5 <z_impl_k_sem_init>

0000000000110255 <z_mrsh_k_sem_init>:
#include <syscalls/kernel.h>

extern int z_vrfy_k_sem_init(struct k_sem * sem, unsigned int initial_count, unsigned int limit);
uintptr_t z_mrsh_k_sem_init(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
  110255:	55                   	push   %rbp
	_current->syscall_frame = ssf;
  110256:	48 8b 05 f3 84 01 00 	mov    0x184f3(%rip),%rax        # 128750 <_kernel+0x10>
{
  11025d:	48 89 e5             	mov    %rsp,%rbp
	_current->syscall_frame = ssf;
  110260:	48 8b 4d 10          	mov    0x10(%rbp),%rcx
  110264:	48 89 88 40 01 00 00 	mov    %rcx,0x140(%rax)
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	int ret = z_vrfy_k_sem_init(*(struct k_sem **)&arg0, *(unsigned int*)&arg1, *(unsigned int*)&arg2)
  11026b:	e8 79 ff ff ff       	callq  1101e9 <z_vrfy_k_sem_init>
;
	_current->syscall_frame = NULL;
  110270:	48 8b 15 d9 84 01 00 	mov    0x184d9(%rip),%rdx        # 128750 <_kernel+0x10>
	return (uintptr_t) ret;
  110277:	48 98                	cltq   
	_current->syscall_frame = NULL;
  110279:	48 c7 82 40 01 00 00 	movq   $0x0,0x140(%rdx)
  110280:	00 00 00 00 
}
  110284:	5d                   	pop    %rbp
  110285:	c3                   	retq   

0000000000110286 <z_impl_k_sem_give>:
	ARG_UNUSED(sem);
#endif
}

void z_impl_k_sem_give(struct k_sem *sem)
{
  110286:	55                   	push   %rbp
  110287:	48 89 e5             	mov    %rsp,%rbp
  11028a:	41 54                	push   %r12
  11028c:	53                   	push   %rbx
  11028d:	48 89 fb             	mov    %rdi,%rbx
  110290:	9c                   	pushfq 
  110291:	fa                   	cli    
  110292:	41 5c                	pop    %r12
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  110294:	bf c0 cd 1b 00       	mov    $0x1bcdc0,%edi
  110299:	e8 db d5 ff ff       	callq  10d879 <z_spin_lock_valid>
  11029e:	84 c0                	test   %al,%al
  1102a0:	75 39                	jne    1102db <z_impl_k_sem_give+0x55>
  1102a2:	b9 8e 00 00 00       	mov    $0x8e,%ecx
  1102a7:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  1102ac:	be fd d1 11 00       	mov    $0x11d1fd,%esi
  1102b1:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  1102b6:	e8 3d 03 ff ff       	callq  1005f8 <printk>
  1102bb:	be c0 cd 1b 00       	mov    $0x1bcdc0,%esi
  1102c0:	bf 12 d2 11 00       	mov    $0x11d212,%edi
  1102c5:	31 c0                	xor    %eax,%eax
  1102c7:	e8 2c 03 ff ff       	callq  1005f8 <printk>
  1102cc:	be 8e 00 00 00       	mov    $0x8e,%esi
  1102d1:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  1102d6:	e8 bd 28 ff ff       	callq  102b98 <assert_post_action>
	z_spin_lock_set_owner(l);
  1102db:	bf c0 cd 1b 00       	mov    $0x1bcdc0,%edi
  1102e0:	e8 d8 d5 ff ff       	callq  10d8bd <z_spin_lock_set_owner>
	k_spinlock_key_t key = k_spin_lock(&lock);
	struct k_thread *thread;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_sem, give, sem);

	thread = z_unpend_first_thread(&sem->wait_q);
  1102e5:	48 89 df             	mov    %rbx,%rdi
  1102e8:	e8 70 1c 00 00       	callq  111f5d <z_unpend_first_thread>
  1102ed:	48 89 c7             	mov    %rax,%rdi

	if (thread != NULL) {
  1102f0:	48 85 c0             	test   %rax,%rax
  1102f3:	74 11                	je     110306 <z_impl_k_sem_give+0x80>
	thread->swap_retval = value;
  1102f5:	c7 80 48 01 00 00 00 	movl   $0x0,0x148(%rax)
  1102fc:	00 00 00 
		arch_thread_return_value_set(thread, 0);
		z_ready_thread(thread);
  1102ff:	e8 46 11 00 00       	callq  11144a <z_ready_thread>
  110304:	eb 1e                	jmp    110324 <z_impl_k_sem_give+0x9e>
	} else {
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
  110306:	8b 53 10             	mov    0x10(%rbx),%edx
  110309:	31 c0                	xor    %eax,%eax
  11030b:	39 53 14             	cmp    %edx,0x14(%rbx)
	z_handle_obj_poll_events(&sem->poll_events, K_POLL_STATE_SEM_AVAILABLE);
  11030e:	48 8d 7b 18          	lea    0x18(%rbx),%rdi
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
  110312:	0f 95 c0             	setne  %al
	z_handle_obj_poll_events(&sem->poll_events, K_POLL_STATE_SEM_AVAILABLE);
  110315:	be 02 00 00 00       	mov    $0x2,%esi
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
  11031a:	01 d0                	add    %edx,%eax
  11031c:	89 43 10             	mov    %eax,0x10(%rbx)
	z_handle_obj_poll_events(&sem->poll_events, K_POLL_STATE_SEM_AVAILABLE);
  11031f:	e8 c1 52 00 00       	callq  1155e5 <z_handle_obj_poll_events>
	}

	z_reschedule(&lock, key);

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_sem, give, sem);
}
  110324:	5b                   	pop    %rbx
	z_reschedule(&lock, key);
  110325:	44 89 e6             	mov    %r12d,%esi
  110328:	bf c0 cd 1b 00       	mov    $0x1bcdc0,%edi
}
  11032d:	41 5c                	pop    %r12
  11032f:	5d                   	pop    %rbp
	z_reschedule(&lock, key);
  110330:	e9 2c 0a 00 00       	jmpq   110d61 <z_reschedule>

0000000000110335 <z_mrsh_k_sem_give>:
#include <syscalls/kernel.h>

extern void z_vrfy_k_sem_give(struct k_sem * sem);
uintptr_t z_mrsh_k_sem_give(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
  110335:	55                   	push   %rbp
  110336:	48 89 e5             	mov    %rsp,%rbp
  110339:	41 54                	push   %r12
  11033b:	49 89 fc             	mov    %rdi,%r12
  11033e:	51                   	push   %rcx
	_current->syscall_frame = ssf;
  11033f:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  110343:	48 8b 05 06 84 01 00 	mov    0x18406(%rip),%rax        # 128750 <_kernel+0x10>
  11034a:	48 89 90 40 01 00 00 	mov    %rdx,0x140(%rax)

#ifdef CONFIG_USERSPACE
static inline void z_vrfy_k_sem_give(struct k_sem *sem)
{
	Z_OOPS(Z_SYSCALL_OBJ(sem, K_OBJ_SEM));
  110351:	e8 7e 67 00 00       	callq  116ad4 <z_object_find>
  110356:	31 d2                	xor    %edx,%edx
  110358:	4c 89 e6             	mov    %r12,%rsi
  11035b:	48 89 c7             	mov    %rax,%rdi
  11035e:	e8 12 fe ff ff       	callq  110175 <z_obj_validation_check.constprop.0>
  110363:	85 c0                	test   %eax,%eax
  110365:	74 29                	je     110390 <z_mrsh_k_sem_give+0x5b>
  110367:	bf 23 f3 11 00       	mov    $0x11f323,%edi
  11036c:	31 c0                	xor    %eax,%eax
  11036e:	ba 70 c4 11 00       	mov    $0x11c470,%edx
  110373:	be 45 00 00 00       	mov    $0x45,%esi
  110378:	e8 49 2d ff ff       	callq  1030c6 <z_log_minimal_printk>
  11037d:	48 8b 05 cc 83 01 00 	mov    0x183cc(%rip),%rax        # 128750 <_kernel+0x10>
  110384:	48 8b b8 40 01 00 00 	mov    0x140(%rax),%rdi
  11038b:	e8 7d 98 ff ff       	callq  109c0d <arch_syscall_oops>
	z_impl_k_sem_give(sem);
  110390:	4c 89 e7             	mov    %r12,%rdi
  110393:	e8 ee fe ff ff       	callq  110286 <z_impl_k_sem_give>
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	z_vrfy_k_sem_give(*(struct k_sem **)&arg0)
;
	_current->syscall_frame = NULL;
  110398:	48 8b 05 b1 83 01 00 	mov    0x183b1(%rip),%rax        # 128750 <_kernel+0x10>
  11039f:	48 c7 80 40 01 00 00 	movq   $0x0,0x140(%rax)
  1103a6:	00 00 00 00 
	return 0;
}
  1103aa:	31 c0                	xor    %eax,%eax
  1103ac:	5a                   	pop    %rdx
  1103ad:	41 5c                	pop    %r12
  1103af:	5d                   	pop    %rbp
  1103b0:	c3                   	retq   

00000000001103b1 <z_impl_k_sem_take>:
}
#include <syscalls/k_sem_give_mrsh.c>
#endif

int z_impl_k_sem_take(struct k_sem *sem, k_timeout_t timeout)
{
  1103b1:	55                   	push   %rbp
  1103b2:	48 89 e5             	mov    %rsp,%rbp
  1103b5:	41 55                	push   %r13
  1103b7:	49 89 f5             	mov    %rsi,%r13
  1103ba:	41 54                	push   %r12
  1103bc:	49 89 fc             	mov    %rdi,%r12
  1103bf:	53                   	push   %rbx
  1103c0:	41 51                	push   %r9
	int ret = 0;

	__ASSERT(((arch_is_in_isr() == false) ||
  1103c2:	83 3d 77 83 01 00 00 	cmpl   $0x0,0x18377(%rip)        # 128740 <_kernel>
  1103c9:	74 3b                	je     110406 <z_impl_k_sem_take+0x55>
  1103cb:	48 85 f6             	test   %rsi,%rsi
  1103ce:	74 36                	je     110406 <z_impl_k_sem_take+0x55>
  1103d0:	be ff fc 11 00       	mov    $0x11fcff,%esi
  1103d5:	b9 79 00 00 00       	mov    $0x79,%ecx
  1103da:	ba df fc 11 00       	mov    $0x11fcdf,%edx
  1103df:	31 c0                	xor    %eax,%eax
  1103e1:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  1103e6:	e8 0d 02 ff ff       	callq  1005f8 <printk>
  1103eb:	bf 22 fc 11 00       	mov    $0x11fc22,%edi
  1103f0:	31 c0                	xor    %eax,%eax
  1103f2:	e8 01 02 ff ff       	callq  1005f8 <printk>
  1103f7:	be 79 00 00 00       	mov    $0x79,%esi
  1103fc:	bf df fc 11 00       	mov    $0x11fcdf,%edi
  110401:	e8 92 27 ff ff       	callq  102b98 <assert_post_action>
  110406:	9c                   	pushfq 
  110407:	fa                   	cli    
  110408:	5b                   	pop    %rbx
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  110409:	bf c0 cd 1b 00       	mov    $0x1bcdc0,%edi
  11040e:	e8 66 d4 ff ff       	callq  10d879 <z_spin_lock_valid>
  110413:	84 c0                	test   %al,%al
  110415:	75 39                	jne    110450 <z_impl_k_sem_take+0x9f>
  110417:	b9 8e 00 00 00       	mov    $0x8e,%ecx
  11041c:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  110421:	be fd d1 11 00       	mov    $0x11d1fd,%esi
  110426:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  11042b:	e8 c8 01 ff ff       	callq  1005f8 <printk>
  110430:	be c0 cd 1b 00       	mov    $0x1bcdc0,%esi
  110435:	bf 12 d2 11 00       	mov    $0x11d212,%edi
  11043a:	31 c0                	xor    %eax,%eax
  11043c:	e8 b7 01 ff ff       	callq  1005f8 <printk>
  110441:	be 8e 00 00 00       	mov    $0x8e,%esi
  110446:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  11044b:	e8 48 27 ff ff       	callq  102b98 <assert_post_action>
	z_spin_lock_set_owner(l);
  110450:	bf c0 cd 1b 00       	mov    $0x1bcdc0,%edi
  110455:	e8 63 d4 ff ff       	callq  10d8bd <z_spin_lock_set_owner>

	k_spinlock_key_t key = k_spin_lock(&lock);

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_sem, take, sem, timeout);

	if (likely(sem->count > 0U)) {
  11045a:	41 8b 44 24 10       	mov    0x10(%r12),%eax
  11045f:	85 c0                	test   %eax,%eax
  110461:	74 52                	je     1104b5 <z_impl_k_sem_take+0x104>
		sem->count--;
  110463:	ff c8                	dec    %eax
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  110465:	bf c0 cd 1b 00       	mov    $0x1bcdc0,%edi
  11046a:	41 89 44 24 10       	mov    %eax,0x10(%r12)
  11046f:	e8 25 d4 ff ff       	callq  10d899 <z_spin_unlock_valid>
  110474:	84 c0                	test   %al,%al
  110476:	75 39                	jne    1104b1 <z_impl_k_sem_take+0x100>
  110478:	b9 b9 00 00 00       	mov    $0xb9,%ecx
  11047d:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  110482:	be 41 d2 11 00       	mov    $0x11d241,%esi
  110487:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  11048c:	e8 67 01 ff ff       	callq  1005f8 <printk>
  110491:	be c0 cd 1b 00       	mov    $0x1bcdc0,%esi
  110496:	bf 58 d2 11 00       	mov    $0x11d258,%edi
  11049b:	31 c0                	xor    %eax,%eax
  11049d:	e8 56 01 ff ff       	callq  1005f8 <printk>
  1104a2:	be b9 00 00 00       	mov    $0xb9,%esi
  1104a7:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  1104ac:	e8 e7 26 ff ff       	callq  102b98 <assert_post_action>
		k_spin_unlock(&lock, key);
		ret = 0;
  1104b1:	31 c0                	xor    %eax,%eax
  1104b3:	eb 51                	jmp    110506 <z_impl_k_sem_take+0x155>
		goto out;
	}

	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
  1104b5:	4d 85 ed             	test   %r13,%r13
  1104b8:	75 55                	jne    11050f <z_impl_k_sem_take+0x15e>
  1104ba:	bf c0 cd 1b 00       	mov    $0x1bcdc0,%edi
  1104bf:	e8 d5 d3 ff ff       	callq  10d899 <z_spin_unlock_valid>
  1104c4:	84 c0                	test   %al,%al
  1104c6:	75 39                	jne    110501 <z_impl_k_sem_take+0x150>
  1104c8:	b9 b9 00 00 00       	mov    $0xb9,%ecx
  1104cd:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  1104d2:	be 41 d2 11 00       	mov    $0x11d241,%esi
  1104d7:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  1104dc:	e8 17 01 ff ff       	callq  1005f8 <printk>
  1104e1:	be c0 cd 1b 00       	mov    $0x1bcdc0,%esi
  1104e6:	bf 58 d2 11 00       	mov    $0x11d258,%edi
  1104eb:	31 c0                	xor    %eax,%eax
  1104ed:	e8 06 01 ff ff       	callq  1005f8 <printk>
  1104f2:	be b9 00 00 00       	mov    $0xb9,%esi
  1104f7:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  1104fc:	e8 97 26 ff ff       	callq  102b98 <assert_post_action>
		k_spin_unlock(&lock, key);
		ret = -EBUSY;
  110501:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  110506:	0f ba e3 09          	bt     $0x9,%ebx
  11050a:	73 1d                	jae    110529 <z_impl_k_sem_take+0x178>
		__asm__ volatile ("sti" ::: "memory");
  11050c:	fb                   	sti    
  11050d:	eb 1a                	jmp    110529 <z_impl_k_sem_take+0x178>

out:
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_sem, take, sem, timeout, ret);

	return ret;
}
  11050f:	41 58                	pop    %r8
	ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
  110511:	4c 89 e9             	mov    %r13,%rcx
  110514:	4c 89 e2             	mov    %r12,%rdx
  110517:	89 de                	mov    %ebx,%esi
  110519:	bf c0 cd 1b 00       	mov    $0x1bcdc0,%edi
}
  11051e:	5b                   	pop    %rbx
  11051f:	41 5c                	pop    %r12
  110521:	41 5d                	pop    %r13
  110523:	5d                   	pop    %rbp
	ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
  110524:	e9 bf 14 00 00       	jmpq   1119e8 <z_pend_curr>
}
  110529:	5a                   	pop    %rdx
  11052a:	5b                   	pop    %rbx
  11052b:	41 5c                	pop    %r12
  11052d:	41 5d                	pop    %r13
  11052f:	5d                   	pop    %rbp
  110530:	c3                   	retq   

0000000000110531 <z_impl_k_sem_reset>:

void z_impl_k_sem_reset(struct k_sem *sem)
{
  110531:	55                   	push   %rbp
  110532:	48 89 e5             	mov    %rsp,%rbp
  110535:	41 54                	push   %r12
  110537:	53                   	push   %rbx
  110538:	48 89 fb             	mov    %rdi,%rbx
  11053b:	9c                   	pushfq 
  11053c:	fa                   	cli    
  11053d:	41 5c                	pop    %r12
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  11053f:	bf c0 cd 1b 00       	mov    $0x1bcdc0,%edi
  110544:	e8 30 d3 ff ff       	callq  10d879 <z_spin_lock_valid>
  110549:	84 c0                	test   %al,%al
  11054b:	75 39                	jne    110586 <z_impl_k_sem_reset+0x55>
  11054d:	b9 8e 00 00 00       	mov    $0x8e,%ecx
  110552:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  110557:	be fd d1 11 00       	mov    $0x11d1fd,%esi
  11055c:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  110561:	e8 92 00 ff ff       	callq  1005f8 <printk>
  110566:	be c0 cd 1b 00       	mov    $0x1bcdc0,%esi
  11056b:	bf 12 d2 11 00       	mov    $0x11d212,%edi
  110570:	31 c0                	xor    %eax,%eax
  110572:	e8 81 00 ff ff       	callq  1005f8 <printk>
  110577:	be 8e 00 00 00       	mov    $0x8e,%esi
  11057c:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  110581:	e8 12 26 ff ff       	callq  102b98 <assert_post_action>
	z_spin_lock_set_owner(l);
  110586:	bf c0 cd 1b 00       	mov    $0x1bcdc0,%edi
  11058b:	e8 2d d3 ff ff       	callq  10d8bd <z_spin_lock_set_owner>
	struct k_thread *thread;
	k_spinlock_key_t key = k_spin_lock(&lock);

	while (true) {
		thread = z_unpend_first_thread(&sem->wait_q);
  110590:	48 89 df             	mov    %rbx,%rdi
  110593:	e8 c5 19 00 00       	callq  111f5d <z_unpend_first_thread>
  110598:	48 89 c7             	mov    %rax,%rdi
		if (thread == NULL) {
  11059b:	48 85 c0             	test   %rax,%rax
  11059e:	74 11                	je     1105b1 <z_impl_k_sem_reset+0x80>
  1105a0:	c7 80 48 01 00 00 f5 	movl   $0xfffffff5,0x148(%rax)
  1105a7:	ff ff ff 
			break;
		}
		arch_thread_return_value_set(thread, -EAGAIN);
		z_ready_thread(thread);
  1105aa:	e8 9b 0e 00 00       	callq  11144a <z_ready_thread>
		thread = z_unpend_first_thread(&sem->wait_q);
  1105af:	eb df                	jmp    110590 <z_impl_k_sem_reset+0x5f>
	}
	sem->count = 0;
  1105b1:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%rbx)
	z_handle_obj_poll_events(&sem->poll_events, K_POLL_STATE_SEM_AVAILABLE);
  1105b8:	48 8d 7b 18          	lea    0x18(%rbx),%rdi
  1105bc:	be 02 00 00 00       	mov    $0x2,%esi
  1105c1:	e8 1f 50 00 00       	callq  1155e5 <z_handle_obj_poll_events>
	SYS_PORT_TRACING_OBJ_FUNC(k_sem, reset, sem);

	handle_poll_events(sem);

	z_reschedule(&lock, key);
}
  1105c6:	5b                   	pop    %rbx
	z_reschedule(&lock, key);
  1105c7:	44 89 e6             	mov    %r12d,%esi
  1105ca:	bf c0 cd 1b 00       	mov    $0x1bcdc0,%edi
}
  1105cf:	41 5c                	pop    %r12
  1105d1:	5d                   	pop    %rbp
	z_reschedule(&lock, key);
  1105d2:	e9 8a 07 00 00       	jmpq   110d61 <z_reschedule>

00000000001105d7 <z_mrsh_k_sem_take>:
#include <syscalls/kernel.h>

extern int z_vrfy_k_sem_take(struct k_sem * sem, k_timeout_t timeout);
uintptr_t z_mrsh_k_sem_take(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
  1105d7:	55                   	push   %rbp
  1105d8:	48 89 e5             	mov    %rsp,%rbp
  1105db:	41 55                	push   %r13
  1105dd:	49 89 f5             	mov    %rsi,%r13
  1105e0:	41 54                	push   %r12
  1105e2:	49 89 fc             	mov    %rdi,%r12
  1105e5:	48 83 ec 10          	sub    $0x10,%rsp
	_current->syscall_frame = ssf;
  1105e9:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  1105ed:	48 8b 05 5c 81 01 00 	mov    0x1815c(%rip),%rax        # 128750 <_kernel+0x10>
{
  1105f4:	48 89 75 e8          	mov    %rsi,-0x18(%rbp)
	_current->syscall_frame = ssf;
  1105f8:	48 89 90 40 01 00 00 	mov    %rdx,0x140(%rax)

#ifdef CONFIG_USERSPACE
static inline int z_vrfy_k_sem_take(struct k_sem *sem, k_timeout_t timeout)
{
	Z_OOPS(Z_SYSCALL_OBJ(sem, K_OBJ_SEM));
  1105ff:	e8 d0 64 00 00       	callq  116ad4 <z_object_find>
  110604:	31 d2                	xor    %edx,%edx
  110606:	4c 89 e6             	mov    %r12,%rsi
  110609:	48 89 c7             	mov    %rax,%rdi
  11060c:	e8 64 fb ff ff       	callq  110175 <z_obj_validation_check.constprop.0>
  110611:	85 c0                	test   %eax,%eax
  110613:	74 29                	je     11063e <z_mrsh_k_sem_take+0x67>
  110615:	bf 23 f3 11 00       	mov    $0x11f323,%edi
  11061a:	31 c0                	xor    %eax,%eax
  11061c:	ba 50 c4 11 00       	mov    $0x11c450,%edx
  110621:	be 45 00 00 00       	mov    $0x45,%esi
  110626:	e8 9b 2a ff ff       	callq  1030c6 <z_log_minimal_printk>
  11062b:	48 8b 05 1e 81 01 00 	mov    0x1811e(%rip),%rax        # 128750 <_kernel+0x10>
  110632:	48 8b b8 40 01 00 00 	mov    0x140(%rax),%rdi
  110639:	e8 cf 95 ff ff       	callq  109c0d <arch_syscall_oops>
	return z_impl_k_sem_take((struct k_sem *)sem, timeout);
  11063e:	4c 89 ee             	mov    %r13,%rsi
  110641:	4c 89 e7             	mov    %r12,%rdi
  110644:	e8 68 fd ff ff       	callq  1103b1 <z_impl_k_sem_take>
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	int ret = z_vrfy_k_sem_take(*(struct k_sem **)&arg0, *(k_timeout_t*)&arg1)
;
	_current->syscall_frame = NULL;
  110649:	48 8b 15 00 81 01 00 	mov    0x18100(%rip),%rdx        # 128750 <_kernel+0x10>
	return (uintptr_t) ret;
  110650:	48 98                	cltq   
	_current->syscall_frame = NULL;
  110652:	48 c7 82 40 01 00 00 	movq   $0x0,0x140(%rdx)
  110659:	00 00 00 00 
}
  11065d:	5a                   	pop    %rdx
  11065e:	59                   	pop    %rcx
  11065f:	41 5c                	pop    %r12
  110661:	41 5d                	pop    %r13
  110663:	5d                   	pop    %rbp
  110664:	c3                   	retq   

0000000000110665 <z_mrsh_k_sem_reset>:
#include <syscalls/kernel.h>

extern void z_vrfy_k_sem_reset(struct k_sem * sem);
uintptr_t z_mrsh_k_sem_reset(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
  110665:	55                   	push   %rbp
  110666:	48 89 e5             	mov    %rsp,%rbp
  110669:	41 54                	push   %r12
  11066b:	49 89 fc             	mov    %rdi,%r12
  11066e:	51                   	push   %rcx
	_current->syscall_frame = ssf;
  11066f:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  110673:	48 8b 05 d6 80 01 00 	mov    0x180d6(%rip),%rax        # 128750 <_kernel+0x10>
  11067a:	48 89 90 40 01 00 00 	mov    %rdx,0x140(%rax)
}
#include <syscalls/k_sem_take_mrsh.c>

static inline void z_vrfy_k_sem_reset(struct k_sem *sem)
{
	Z_OOPS(Z_SYSCALL_OBJ(sem, K_OBJ_SEM));
  110681:	e8 4e 64 00 00       	callq  116ad4 <z_object_find>
  110686:	31 d2                	xor    %edx,%edx
  110688:	4c 89 e6             	mov    %r12,%rsi
  11068b:	48 89 c7             	mov    %rax,%rdi
  11068e:	e8 e2 fa ff ff       	callq  110175 <z_obj_validation_check.constprop.0>
  110693:	85 c0                	test   %eax,%eax
  110695:	74 29                	je     1106c0 <z_mrsh_k_sem_reset+0x5b>
  110697:	bf 23 f3 11 00       	mov    $0x11f323,%edi
  11069c:	31 c0                	xor    %eax,%eax
  11069e:	ba 30 c4 11 00       	mov    $0x11c430,%edx
  1106a3:	be 45 00 00 00       	mov    $0x45,%esi
  1106a8:	e8 19 2a ff ff       	callq  1030c6 <z_log_minimal_printk>
  1106ad:	48 8b 05 9c 80 01 00 	mov    0x1809c(%rip),%rax        # 128750 <_kernel+0x10>
  1106b4:	48 8b b8 40 01 00 00 	mov    0x140(%rax),%rdi
  1106bb:	e8 4d 95 ff ff       	callq  109c0d <arch_syscall_oops>
	z_impl_k_sem_reset(sem);
  1106c0:	4c 89 e7             	mov    %r12,%rdi
  1106c3:	e8 69 fe ff ff       	callq  110531 <z_impl_k_sem_reset>
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	z_vrfy_k_sem_reset(*(struct k_sem **)&arg0)
;
	_current->syscall_frame = NULL;
  1106c8:	48 8b 05 81 80 01 00 	mov    0x18081(%rip),%rax        # 128750 <_kernel+0x10>
  1106cf:	48 c7 80 40 01 00 00 	movq   $0x0,0x140(%rax)
  1106d6:	00 00 00 00 
	return 0;
}
  1106da:	31 c0                	xor    %eax,%eax
  1106dc:	5a                   	pop    %rdx
  1106dd:	41 5c                	pop    %r12
  1106df:	5d                   	pop    %rbp
  1106e0:	c3                   	retq   

00000000001106e1 <z_mrsh_k_sem_count_get>:
#include <syscalls/kernel.h>

extern unsigned int z_vrfy_k_sem_count_get(struct k_sem * sem);
uintptr_t z_mrsh_k_sem_count_get(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
  1106e1:	55                   	push   %rbp
  1106e2:	48 89 e5             	mov    %rsp,%rbp
  1106e5:	53                   	push   %rbx
  1106e6:	48 89 fb             	mov    %rdi,%rbx
  1106e9:	51                   	push   %rcx
	_current->syscall_frame = ssf;
  1106ea:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  1106ee:	48 8b 05 5b 80 01 00 	mov    0x1805b(%rip),%rax        # 128750 <_kernel+0x10>
  1106f5:	48 89 90 40 01 00 00 	mov    %rdx,0x140(%rax)
}
#include <syscalls/k_sem_reset_mrsh.c>

static inline unsigned int z_vrfy_k_sem_count_get(struct k_sem *sem)
{
	Z_OOPS(Z_SYSCALL_OBJ(sem, K_OBJ_SEM));
  1106fc:	e8 d3 63 00 00       	callq  116ad4 <z_object_find>
  110701:	31 d2                	xor    %edx,%edx
  110703:	48 89 de             	mov    %rbx,%rsi
  110706:	48 89 c7             	mov    %rax,%rdi
  110709:	e8 67 fa ff ff       	callq  110175 <z_obj_validation_check.constprop.0>
  11070e:	85 c0                	test   %eax,%eax
  110710:	74 29                	je     11073b <z_mrsh_k_sem_count_get+0x5a>
  110712:	bf 23 f3 11 00       	mov    $0x11f323,%edi
  110717:	31 c0                	xor    %eax,%eax
  110719:	ba 10 c4 11 00       	mov    $0x11c410,%edx
  11071e:	be 45 00 00 00       	mov    $0x45,%esi
  110723:	e8 9e 29 ff ff       	callq  1030c6 <z_log_minimal_printk>
  110728:	48 8b 05 21 80 01 00 	mov    0x18021(%rip),%rax        # 128750 <_kernel+0x10>
  11072f:	48 8b b8 40 01 00 00 	mov    0x140(%rax),%rdi
  110736:	e8 d2 94 ff ff       	callq  109c0d <arch_syscall_oops>
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	unsigned int ret = z_vrfy_k_sem_count_get(*(struct k_sem **)&arg0)
;
	_current->syscall_frame = NULL;
  11073b:	48 8b 15 0e 80 01 00 	mov    0x1800e(%rip),%rdx        # 128750 <_kernel+0x10>
	return sem->count;
  110742:	8b 43 10             	mov    0x10(%rbx),%eax
  110745:	48 c7 82 40 01 00 00 	movq   $0x0,0x140(%rdx)
  11074c:	00 00 00 00 
	return (uintptr_t) ret;
}
  110750:	5a                   	pop    %rdx
  110751:	5b                   	pop    %rbx
  110752:	5d                   	pop    %rbp
  110753:	c3                   	retq   

0000000000110754 <thread_obj_validate>:
 *
 * Return true in this case indicating we should just do nothing and return
 * success to the caller.
 */
static bool thread_obj_validate(struct k_thread *thread)
{
  110754:	55                   	push   %rbp
  110755:	48 89 e5             	mov    %rsp,%rbp
  110758:	41 55                	push   %r13
  11075a:	41 54                	push   %r12
  11075c:	49 89 fc             	mov    %rdi,%r12
	struct z_object *ko = z_object_find(thread);
  11075f:	e8 70 63 00 00       	callq  116ad4 <z_object_find>
	int ret = z_object_validate(ko, K_OBJ_THREAD, _OBJ_INIT_TRUE);
  110764:	31 d2                	xor    %edx,%edx
  110766:	be 09 00 00 00       	mov    $0x9,%esi
  11076b:	48 89 c7             	mov    %rax,%rdi
	struct z_object *ko = z_object_find(thread);
  11076e:	49 89 c5             	mov    %rax,%r13
	int ret = z_object_validate(ko, K_OBJ_THREAD, _OBJ_INIT_TRUE);
  110771:	e8 f6 67 00 00       	callq  116f6c <z_object_validate>

	switch (ret) {
  110776:	83 f8 ea             	cmp    $0xffffffea,%eax
  110779:	74 18                	je     110793 <thread_obj_validate+0x3f>
  11077b:	89 c7                	mov    %eax,%edi
	case 0:
		return false;
  11077d:	31 c0                	xor    %eax,%eax
	switch (ret) {
  11077f:	85 ff                	test   %edi,%edi
  110781:	74 12                	je     110795 <thread_obj_validate+0x41>
	case -EINVAL:
		return true;
	default:
#ifdef CONFIG_LOG
		z_dump_object_error(ret, thread, ko, K_OBJ_THREAD);
  110783:	b9 09 00 00 00       	mov    $0x9,%ecx
  110788:	4c 89 ea             	mov    %r13,%rdx
  11078b:	4c 89 e6             	mov    %r12,%rsi
  11078e:	e8 8e 66 00 00       	callq  116e21 <z_dump_object_error>
	switch (ret) {
  110793:	b0 01                	mov    $0x1,%al
#endif
		Z_OOPS(Z_SYSCALL_VERIFY_MSG(ret, "access denied"));
	}
	CODE_UNREACHABLE; /* LCOV_EXCL_LINE */
}
  110795:	41 5c                	pop    %r12
  110797:	41 5d                	pop    %r13
  110799:	5d                   	pop    %rbp
  11079a:	c3                   	retq   

000000000011079b <z_obj_validation_check.constprop.0>:
static inline int z_obj_validation_check(struct z_object *ko,
  11079b:	55                   	push   %rbp
	ret = z_object_validate(ko, otype, init);
  11079c:	31 d2                	xor    %edx,%edx
static inline int z_obj_validation_check(struct z_object *ko,
  11079e:	48 89 e5             	mov    %rsp,%rbp
  1107a1:	41 56                	push   %r14
  1107a3:	49 89 f6             	mov    %rsi,%r14
	ret = z_object_validate(ko, otype, init);
  1107a6:	be 09 00 00 00       	mov    $0x9,%esi
static inline int z_obj_validation_check(struct z_object *ko,
  1107ab:	41 55                	push   %r13
  1107ad:	49 89 fd             	mov    %rdi,%r13
  1107b0:	48 83 ec 10          	sub    $0x10,%rsp
	ret = z_object_validate(ko, otype, init);
  1107b4:	e8 b3 67 00 00       	callq  116f6c <z_object_validate>
	if (ret != 0) {
  1107b9:	85 c0                	test   %eax,%eax
  1107bb:	74 18                	je     1107d5 <z_obj_validation_check.constprop.0+0x3a>
		z_dump_object_error(ret, obj, ko, otype);
  1107bd:	89 c7                	mov    %eax,%edi
  1107bf:	b9 09 00 00 00       	mov    $0x9,%ecx
  1107c4:	4c 89 ea             	mov    %r13,%rdx
  1107c7:	4c 89 f6             	mov    %r14,%rsi
  1107ca:	89 45 ec             	mov    %eax,-0x14(%rbp)
  1107cd:	e8 4f 66 00 00       	callq  116e21 <z_dump_object_error>
  1107d2:	8b 45 ec             	mov    -0x14(%rbp),%eax
}
  1107d5:	5a                   	pop    %rdx
  1107d6:	59                   	pop    %rcx
  1107d7:	41 5d                	pop    %r13
  1107d9:	41 5e                	pop    %r14
  1107db:	5d                   	pop    %rbp
  1107dc:	c3                   	retq   

00000000001107dd <z_sched_prio_cmp>:
	int32_t b1 = thread_1->base.prio;
  1107dd:	0f be 57 1a          	movsbl 0x1a(%rdi),%edx
	int32_t b2 = thread_2->base.prio;
  1107e1:	0f be 4e 1a          	movsbl 0x1a(%rsi),%ecx
	return 0;
  1107e5:	31 c0                	xor    %eax,%eax
	if (b1 != b2) {
  1107e7:	39 ca                	cmp    %ecx,%edx
  1107e9:	74 04                	je     1107ef <z_sched_prio_cmp+0x12>
		return b2 - b1;
  1107eb:	89 c8                	mov    %ecx,%eax
  1107ed:	29 d0                	sub    %edx,%eax
}
  1107ef:	c3                   	retq   

00000000001107f0 <z_reset_time_slice>:
	if (slice_time != 0) {
  1107f0:	83 3d 45 c6 0a 00 00 	cmpl   $0x0,0xac645(%rip)        # 1bce3c <slice_time>
  1107f7:	74 1f                	je     110818 <z_reset_time_slice+0x28>
{
  1107f9:	55                   	push   %rbp
  1107fa:	48 89 e5             	mov    %rsp,%rbp
		_current_cpu->slice_ticks = slice_time + sys_clock_elapsed();
  1107fd:	e8 85 c3 ff ff       	callq  10cb87 <sys_clock_elapsed>
  110802:	8b 3d 34 c6 0a 00    	mov    0xac634(%rip),%edi        # 1bce3c <slice_time>
		z_set_timeout_expiry(slice_time, false);
  110808:	31 f6                	xor    %esi,%esi
}
  11080a:	5d                   	pop    %rbp
		_current_cpu->slice_ticks = slice_time + sys_clock_elapsed();
  11080b:	01 f8                	add    %edi,%eax
  11080d:	89 05 4d 7f 01 00    	mov    %eax,0x17f4d(%rip)        # 128760 <_kernel+0x20>
		z_set_timeout_expiry(slice_time, false);
  110813:	e9 19 2a 00 00       	jmpq   113231 <z_set_timeout_expiry>
  110818:	c3                   	retq   

0000000000110819 <z_swap_irqlock>:
{
  110819:	55                   	push   %rbp
	__ASSERT(arch_irq_unlocked(key) ||
  11081a:	81 e7 00 02 00 00    	and    $0x200,%edi
{
  110820:	48 89 e5             	mov    %rsp,%rbp
  110823:	41 55                	push   %r13
	__ASSERT(arch_irq_unlocked(key) ||
  110825:	41 89 fd             	mov    %edi,%r13d
{
  110828:	41 54                	push   %r12
  11082a:	53                   	push   %rbx
  11082b:	51                   	push   %rcx
	__ASSERT(arch_irq_unlocked(key) ||
  11082c:	75 43                	jne    110871 <z_swap_irqlock+0x58>
  11082e:	48 8b 05 1b 7f 01 00 	mov    0x17f1b(%rip),%rax        # 128750 <_kernel+0x10>
  110835:	f6 40 19 09          	testb  $0x9,0x19(%rax)
  110839:	75 36                	jne    110871 <z_swap_irqlock+0x58>
  11083b:	be e0 f5 11 00       	mov    $0x11f5e0,%esi
  110840:	b9 53 00 00 00       	mov    $0x53,%ecx
  110845:	ba b6 f5 11 00       	mov    $0x11f5b6,%edx
  11084a:	31 c0                	xor    %eax,%eax
  11084c:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  110851:	e8 a2 fd fe ff       	callq  1005f8 <printk>
  110856:	bf 49 f6 11 00       	mov    $0x11f649,%edi
  11085b:	31 c0                	xor    %eax,%eax
  11085d:	e8 96 fd fe ff       	callq  1005f8 <printk>
  110862:	be 53 00 00 00       	mov    $0x53,%esi
  110867:	bf b6 f5 11 00       	mov    $0x11f5b6,%edi
  11086c:	e8 27 23 ff ff       	callq  102b98 <assert_post_action>
	old_thread = _current;
  110871:	48 8b 1d d8 7e 01 00 	mov    0x17ed8(%rip),%rbx        # 128750 <_kernel+0x10>
	old_thread->swap_retval = -EAGAIN;
  110878:	c7 83 48 01 00 00 f5 	movl   $0xfffffff5,0x148(%rbx)
  11087f:	ff ff ff 
  110882:	9c                   	pushfq 
  110883:	fa                   	cli    
  110884:	58                   	pop    %rax
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  110885:	bf c8 cd 1b 00       	mov    $0x1bcdc8,%edi
  11088a:	e8 ea cf ff ff       	callq  10d879 <z_spin_lock_valid>
  11088f:	84 c0                	test   %al,%al
  110891:	75 39                	jne    1108cc <z_swap_irqlock+0xb3>
  110893:	b9 8e 00 00 00       	mov    $0x8e,%ecx
  110898:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  11089d:	be fd d1 11 00       	mov    $0x11d1fd,%esi
  1108a2:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  1108a7:	e8 4c fd fe ff       	callq  1005f8 <printk>
  1108ac:	be c8 cd 1b 00       	mov    $0x1bcdc8,%esi
  1108b1:	bf 12 d2 11 00       	mov    $0x11d212,%edi
  1108b6:	31 c0                	xor    %eax,%eax
  1108b8:	e8 3b fd fe ff       	callq  1005f8 <printk>
  1108bd:	be 8e 00 00 00       	mov    $0x8e,%esi
  1108c2:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  1108c7:	e8 cc 22 ff ff       	callq  102b98 <assert_post_action>
	z_spin_lock_set_owner(l);
  1108cc:	bf c8 cd 1b 00       	mov    $0x1bcdc8,%edi
  1108d1:	e8 e7 cf ff ff       	callq  10d8bd <z_spin_lock_set_owner>
	return _kernel.ready_q.cache;
  1108d6:	4c 8b 25 8b 7e 01 00 	mov    0x17e8b(%rip),%r12        # 128768 <_kernel+0x28>
	if (new_thread != old_thread) {
  1108dd:	4c 39 e3             	cmp    %r12,%rbx
  1108e0:	74 7b                	je     11095d <z_swap_irqlock+0x144>
		z_reset_time_slice();
  1108e2:	e8 09 ff ff ff       	callq  1107f0 <z_reset_time_slice>
		z_thread_mark_switched_out();
  1108e7:	e8 b4 dc ff ff       	callq  10e5a0 <z_thread_mark_switched_out>
		z_spin_lock_set_owner(&sched_spinlock);
  1108ec:	bf c8 cd 1b 00       	mov    $0x1bcdc8,%edi
		_current_cpu->current = new_thread;
  1108f1:	4c 89 25 58 7e 01 00 	mov    %r12,0x17e58(%rip)        # 128750 <_kernel+0x10>
		z_spin_lock_set_owner(&sched_spinlock);
  1108f8:	e8 c0 cf ff ff       	callq  10d8bd <z_spin_lock_set_owner>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  1108fd:	bf c8 cd 1b 00       	mov    $0x1bcdc8,%edi
		void *newsh = new_thread->switch_handle;
  110902:	4d 8b a4 24 50 01 00 	mov    0x150(%r12),%r12
  110909:	00 
  11090a:	e8 8a cf ff ff       	callq  10d899 <z_spin_unlock_valid>
  11090f:	84 c0                	test   %al,%al
  110911:	75 39                	jne    11094c <z_swap_irqlock+0x133>
  110913:	b9 d0 00 00 00       	mov    $0xd0,%ecx
  110918:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  11091d:	be 41 d2 11 00       	mov    $0x11d241,%esi
  110922:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  110927:	e8 cc fc fe ff       	callq  1005f8 <printk>
  11092c:	be c8 cd 1b 00       	mov    $0x1bcdc8,%esi
  110931:	bf 58 d2 11 00       	mov    $0x11d258,%edi
  110936:	31 c0                	xor    %eax,%eax
  110938:	e8 bb fc fe ff       	callq  1005f8 <printk>
  11093d:	be d0 00 00 00       	mov    $0xd0,%esi
  110942:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  110947:	e8 4c 22 ff ff       	callq  102b98 <assert_post_action>
		arch_switch(newsh, &old_thread->switch_handle);
  11094c:	48 8d b3 50 01 00 00 	lea    0x150(%rbx),%rsi
	z_x86_switch(switch_to, switched_from);
  110953:	4c 89 e7             	mov    %r12,%rdi
  110956:	e8 28 08 ef ff       	callq  1183 <z_x86_switch>
}
  11095b:	eb 47                	jmp    1109a4 <z_swap_irqlock+0x18b>
  11095d:	bf c8 cd 1b 00       	mov    $0x1bcdc8,%edi
  110962:	e8 32 cf ff ff       	callq  10d899 <z_spin_unlock_valid>
  110967:	84 c0                	test   %al,%al
  110969:	75 39                	jne    1109a4 <z_swap_irqlock+0x18b>
  11096b:	b9 d0 00 00 00       	mov    $0xd0,%ecx
  110970:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  110975:	be 41 d2 11 00       	mov    $0x11d241,%esi
  11097a:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  11097f:	e8 74 fc fe ff       	callq  1005f8 <printk>
  110984:	be c8 cd 1b 00       	mov    $0x1bcdc8,%esi
  110989:	bf 58 d2 11 00       	mov    $0x11d258,%edi
  11098e:	31 c0                	xor    %eax,%eax
  110990:	e8 63 fc fe ff       	callq  1005f8 <printk>
  110995:	be d0 00 00 00       	mov    $0xd0,%esi
  11099a:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  11099f:	e8 f4 21 ff ff       	callq  102b98 <assert_post_action>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  1109a4:	45 85 ed             	test   %r13d,%r13d
  1109a7:	74 01                	je     1109aa <z_swap_irqlock+0x191>
		__asm__ volatile ("sti" ::: "memory");
  1109a9:	fb                   	sti    
	return _current->swap_retval;
  1109aa:	48 8b 05 9f 7d 01 00 	mov    0x17d9f(%rip),%rax        # 128750 <_kernel+0x10>
	return do_swap(key, NULL, 0);
  1109b1:	8b 80 48 01 00 00    	mov    0x148(%rax),%eax
}
  1109b7:	5a                   	pop    %rdx
  1109b8:	5b                   	pop    %rbx
  1109b9:	41 5c                	pop    %r12
  1109bb:	41 5d                	pop    %r13
  1109bd:	5d                   	pop    %rbp
  1109be:	c3                   	retq   

00000000001109bf <z_swap>:
{
  1109bf:	55                   	push   %rbp
	__ASSERT(arch_irq_unlocked(key) ||
  1109c0:	81 e6 00 02 00 00    	and    $0x200,%esi
{
  1109c6:	48 89 e5             	mov    %rsp,%rbp
  1109c9:	41 55                	push   %r13
	__ASSERT(arch_irq_unlocked(key) ||
  1109cb:	41 89 f5             	mov    %esi,%r13d
{
  1109ce:	41 54                	push   %r12
  1109d0:	49 89 fc             	mov    %rdi,%r12
  1109d3:	53                   	push   %rbx
  1109d4:	51                   	push   %rcx
	__ASSERT(arch_irq_unlocked(key) ||
  1109d5:	75 43                	jne    110a1a <z_swap+0x5b>
  1109d7:	48 8b 05 72 7d 01 00 	mov    0x17d72(%rip),%rax        # 128750 <_kernel+0x10>
  1109de:	f6 40 19 09          	testb  $0x9,0x19(%rax)
  1109e2:	75 36                	jne    110a1a <z_swap+0x5b>
  1109e4:	be e0 f5 11 00       	mov    $0x11f5e0,%esi
  1109e9:	b9 53 00 00 00       	mov    $0x53,%ecx
  1109ee:	ba b6 f5 11 00       	mov    $0x11f5b6,%edx
  1109f3:	31 c0                	xor    %eax,%eax
  1109f5:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  1109fa:	e8 f9 fb fe ff       	callq  1005f8 <printk>
  1109ff:	bf 49 f6 11 00       	mov    $0x11f649,%edi
  110a04:	31 c0                	xor    %eax,%eax
  110a06:	e8 ed fb fe ff       	callq  1005f8 <printk>
  110a0b:	be 53 00 00 00       	mov    $0x53,%esi
  110a10:	bf b6 f5 11 00       	mov    $0x11f5b6,%edi
  110a15:	e8 7e 21 ff ff       	callq  102b98 <assert_post_action>
	old_thread = _current;
  110a1a:	48 8b 1d 2f 7d 01 00 	mov    0x17d2f(%rip),%rbx        # 128750 <_kernel+0x10>
	old_thread->swap_retval = -EAGAIN;
  110a21:	c7 83 48 01 00 00 f5 	movl   $0xfffffff5,0x148(%rbx)
  110a28:	ff ff ff 
	if (is_spinlock && lock != NULL && lock != &sched_spinlock) {
  110a2b:	4d 85 e4             	test   %r12,%r12
  110a2e:	74 50                	je     110a80 <z_swap+0xc1>
  110a30:	49 81 fc c8 cd 1b 00 	cmp    $0x1bcdc8,%r12
  110a37:	0f 84 99 00 00 00    	je     110ad6 <z_swap+0x117>
  110a3d:	4c 89 e7             	mov    %r12,%rdi
  110a40:	e8 54 ce ff ff       	callq  10d899 <z_spin_unlock_valid>
  110a45:	84 c0                	test   %al,%al
  110a47:	75 37                	jne    110a80 <z_swap+0xc1>
  110a49:	b9 d0 00 00 00       	mov    $0xd0,%ecx
  110a4e:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  110a53:	be 41 d2 11 00       	mov    $0x11d241,%esi
  110a58:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  110a5d:	e8 96 fb fe ff       	callq  1005f8 <printk>
  110a62:	4c 89 e6             	mov    %r12,%rsi
  110a65:	bf 58 d2 11 00       	mov    $0x11d258,%edi
  110a6a:	31 c0                	xor    %eax,%eax
  110a6c:	e8 87 fb fe ff       	callq  1005f8 <printk>
  110a71:	be d0 00 00 00       	mov    $0xd0,%esi
  110a76:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  110a7b:	e8 18 21 ff ff       	callq  102b98 <assert_post_action>
  110a80:	9c                   	pushfq 
  110a81:	fa                   	cli    
  110a82:	58                   	pop    %rax
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  110a83:	bf c8 cd 1b 00       	mov    $0x1bcdc8,%edi
  110a88:	e8 ec cd ff ff       	callq  10d879 <z_spin_lock_valid>
  110a8d:	84 c0                	test   %al,%al
  110a8f:	75 3b                	jne    110acc <z_swap+0x10d>
  110a91:	b9 8e 00 00 00       	mov    $0x8e,%ecx
  110a96:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  110a9b:	be fd d1 11 00       	mov    $0x11d1fd,%esi
  110aa0:	31 c0                	xor    %eax,%eax
  110aa2:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  110aa7:	e8 4c fb fe ff       	callq  1005f8 <printk>
  110aac:	be c8 cd 1b 00       	mov    $0x1bcdc8,%esi
  110ab1:	bf 12 d2 11 00       	mov    $0x11d212,%edi
  110ab6:	31 c0                	xor    %eax,%eax
  110ab8:	e8 3b fb fe ff       	callq  1005f8 <printk>
  110abd:	be 8e 00 00 00       	mov    $0x8e,%esi
  110ac2:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  110ac7:	e8 cc 20 ff ff       	callq  102b98 <assert_post_action>
	z_spin_lock_set_owner(l);
  110acc:	bf c8 cd 1b 00       	mov    $0x1bcdc8,%edi
  110ad1:	e8 e7 cd ff ff       	callq  10d8bd <z_spin_lock_set_owner>
  110ad6:	4c 8b 25 8b 7c 01 00 	mov    0x17c8b(%rip),%r12        # 128768 <_kernel+0x28>
	if (new_thread != old_thread) {
  110add:	4c 39 e3             	cmp    %r12,%rbx
  110ae0:	74 7b                	je     110b5d <z_swap+0x19e>
		z_reset_time_slice();
  110ae2:	e8 09 fd ff ff       	callq  1107f0 <z_reset_time_slice>
		z_thread_mark_switched_out();
  110ae7:	e8 b4 da ff ff       	callq  10e5a0 <z_thread_mark_switched_out>
		z_spin_lock_set_owner(&sched_spinlock);
  110aec:	bf c8 cd 1b 00       	mov    $0x1bcdc8,%edi
		_current_cpu->current = new_thread;
  110af1:	4c 89 25 58 7c 01 00 	mov    %r12,0x17c58(%rip)        # 128750 <_kernel+0x10>
		z_spin_lock_set_owner(&sched_spinlock);
  110af8:	e8 c0 cd ff ff       	callq  10d8bd <z_spin_lock_set_owner>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  110afd:	bf c8 cd 1b 00       	mov    $0x1bcdc8,%edi
		void *newsh = new_thread->switch_handle;
  110b02:	4d 8b a4 24 50 01 00 	mov    0x150(%r12),%r12
  110b09:	00 
  110b0a:	e8 8a cd ff ff       	callq  10d899 <z_spin_unlock_valid>
  110b0f:	84 c0                	test   %al,%al
  110b11:	75 39                	jne    110b4c <z_swap+0x18d>
  110b13:	b9 d0 00 00 00       	mov    $0xd0,%ecx
  110b18:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  110b1d:	be 41 d2 11 00       	mov    $0x11d241,%esi
  110b22:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  110b27:	e8 cc fa fe ff       	callq  1005f8 <printk>
  110b2c:	be c8 cd 1b 00       	mov    $0x1bcdc8,%esi
  110b31:	bf 58 d2 11 00       	mov    $0x11d258,%edi
  110b36:	31 c0                	xor    %eax,%eax
  110b38:	e8 bb fa fe ff       	callq  1005f8 <printk>
  110b3d:	be d0 00 00 00       	mov    $0xd0,%esi
  110b42:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  110b47:	e8 4c 20 ff ff       	callq  102b98 <assert_post_action>
		arch_switch(newsh, &old_thread->switch_handle);
  110b4c:	48 8d b3 50 01 00 00 	lea    0x150(%rbx),%rsi
	z_x86_switch(switch_to, switched_from);
  110b53:	4c 89 e7             	mov    %r12,%rdi
  110b56:	e8 28 06 ef ff       	callq  1183 <z_x86_switch>
}
  110b5b:	eb 47                	jmp    110ba4 <z_swap+0x1e5>
  110b5d:	bf c8 cd 1b 00       	mov    $0x1bcdc8,%edi
  110b62:	e8 32 cd ff ff       	callq  10d899 <z_spin_unlock_valid>
  110b67:	84 c0                	test   %al,%al
  110b69:	75 39                	jne    110ba4 <z_swap+0x1e5>
  110b6b:	b9 d0 00 00 00       	mov    $0xd0,%ecx
  110b70:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  110b75:	be 41 d2 11 00       	mov    $0x11d241,%esi
  110b7a:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  110b7f:	e8 74 fa fe ff       	callq  1005f8 <printk>
  110b84:	be c8 cd 1b 00       	mov    $0x1bcdc8,%esi
  110b89:	bf 58 d2 11 00       	mov    $0x11d258,%edi
  110b8e:	31 c0                	xor    %eax,%eax
  110b90:	e8 63 fa fe ff       	callq  1005f8 <printk>
  110b95:	be d0 00 00 00       	mov    $0xd0,%esi
  110b9a:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  110b9f:	e8 f4 1f ff ff       	callq  102b98 <assert_post_action>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  110ba4:	45 85 ed             	test   %r13d,%r13d
  110ba7:	74 01                	je     110baa <z_swap+0x1eb>
		__asm__ volatile ("sti" ::: "memory");
  110ba9:	fb                   	sti    
	return _current->swap_retval;
  110baa:	48 8b 05 9f 7b 01 00 	mov    0x17b9f(%rip),%rax        # 128750 <_kernel+0x10>
	return do_swap(key.key, lock, 1);
  110bb1:	8b 80 48 01 00 00    	mov    0x148(%rax),%eax
}
  110bb7:	5a                   	pop    %rdx
  110bb8:	5b                   	pop    %rbx
  110bb9:	41 5c                	pop    %r12
  110bbb:	41 5d                	pop    %r13
  110bbd:	5d                   	pop    %rbp
  110bbe:	c3                   	retq   

0000000000110bbf <k_sched_time_slice_set>:
{
  110bbf:	55                   	push   %rbp
  110bc0:	48 89 e5             	mov    %rsp,%rbp
  110bc3:	41 55                	push   %r13
  110bc5:	41 54                	push   %r12
  110bc7:	41 89 f4             	mov    %esi,%r12d
  110bca:	53                   	push   %rbx
  110bcb:	89 fb                	mov    %edi,%ebx
  110bcd:	52                   	push   %rdx
  110bce:	9c                   	pushfq 
  110bcf:	fa                   	cli    
  110bd0:	41 5d                	pop    %r13
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  110bd2:	bf c8 cd 1b 00       	mov    $0x1bcdc8,%edi
  110bd7:	e8 9d cc ff ff       	callq  10d879 <z_spin_lock_valid>
  110bdc:	84 c0                	test   %al,%al
  110bde:	75 39                	jne    110c19 <k_sched_time_slice_set+0x5a>
  110be0:	b9 8e 00 00 00       	mov    $0x8e,%ecx
  110be5:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  110bea:	be fd d1 11 00       	mov    $0x11d1fd,%esi
  110bef:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  110bf4:	e8 ff f9 fe ff       	callq  1005f8 <printk>
  110bf9:	be c8 cd 1b 00       	mov    $0x1bcdc8,%esi
  110bfe:	bf 12 d2 11 00       	mov    $0x11d212,%edi
  110c03:	31 c0                	xor    %eax,%eax
  110c05:	e8 ee f9 fe ff       	callq  1005f8 <printk>
  110c0a:	be 8e 00 00 00       	mov    $0x8e,%esi
  110c0f:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  110c14:	e8 7f 1f ff ff       	callq  102b98 <assert_post_action>
	z_spin_lock_set_owner(l);
  110c19:	bf c8 cd 1b 00       	mov    $0x1bcdc8,%edi
  110c1e:	e8 9a cc ff ff       	callq  10d8bd <z_spin_lock_set_owner>
			return ((uint32_t)t) * (to_hz / from_hz);
  110c23:	6b c3 0a             	imul   $0xa,%ebx,%eax
		_current_cpu->slice_ticks = 0;
  110c26:	c7 05 30 7b 01 00 00 	movl   $0x0,0x17b30(%rip)        # 128760 <_kernel+0x20>
  110c2d:	00 00 00 
		if (IS_ENABLED(CONFIG_TICKLESS_KERNEL) && slice > 0) {
  110c30:	85 db                	test   %ebx,%ebx
  110c32:	7e 0b                	jle    110c3f <k_sched_time_slice_set+0x80>
			slice_time = MAX(2, slice_time);
  110c34:	83 f8 02             	cmp    $0x2,%eax
  110c37:	ba 02 00 00 00       	mov    $0x2,%edx
  110c3c:	0f 4c c2             	cmovl  %edx,%eax
  110c3f:	89 05 f7 c1 0a 00    	mov    %eax,0xac1f7(%rip)        # 1bce3c <slice_time>
		slice_max_prio = prio;
  110c45:	44 89 25 ec c1 0a 00 	mov    %r12d,0xac1ec(%rip)        # 1bce38 <slice_max_prio>
		z_reset_time_slice();
  110c4c:	e8 9f fb ff ff       	callq  1107f0 <z_reset_time_slice>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  110c51:	bf c8 cd 1b 00       	mov    $0x1bcdc8,%edi
  110c56:	e8 3e cc ff ff       	callq  10d899 <z_spin_unlock_valid>
  110c5b:	84 c0                	test   %al,%al
  110c5d:	75 39                	jne    110c98 <k_sched_time_slice_set+0xd9>
  110c5f:	b9 b9 00 00 00       	mov    $0xb9,%ecx
  110c64:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  110c69:	be 41 d2 11 00       	mov    $0x11d241,%esi
  110c6e:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  110c73:	e8 80 f9 fe ff       	callq  1005f8 <printk>
  110c78:	be c8 cd 1b 00       	mov    $0x1bcdc8,%esi
  110c7d:	bf 58 d2 11 00       	mov    $0x11d258,%edi
  110c82:	31 c0                	xor    %eax,%eax
  110c84:	e8 6f f9 fe ff       	callq  1005f8 <printk>
  110c89:	be b9 00 00 00       	mov    $0xb9,%esi
  110c8e:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  110c93:	e8 00 1f ff ff       	callq  102b98 <assert_post_action>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  110c98:	41 0f ba e5 09       	bt     $0x9,%r13d
  110c9d:	73 01                	jae    110ca0 <k_sched_time_slice_set+0xe1>
		__asm__ volatile ("sti" ::: "memory");
  110c9f:	fb                   	sti    
}
  110ca0:	58                   	pop    %rax
  110ca1:	5b                   	pop    %rbx
  110ca2:	41 5c                	pop    %r12
  110ca4:	41 5d                	pop    %r13
  110ca6:	5d                   	pop    %rbp
  110ca7:	c3                   	retq   

0000000000110ca8 <z_unpend_thread_no_timeout>:
{
  110ca8:	55                   	push   %rbp
  110ca9:	48 89 e5             	mov    %rsp,%rbp
  110cac:	41 54                	push   %r12
  110cae:	49 89 fc             	mov    %rdi,%r12
  110cb1:	53                   	push   %rbx
  110cb2:	9c                   	pushfq 
  110cb3:	fa                   	cli    
  110cb4:	5b                   	pop    %rbx
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  110cb5:	bf c8 cd 1b 00       	mov    $0x1bcdc8,%edi
  110cba:	e8 ba cb ff ff       	callq  10d879 <z_spin_lock_valid>
  110cbf:	84 c0                	test   %al,%al
  110cc1:	75 39                	jne    110cfc <z_unpend_thread_no_timeout+0x54>
  110cc3:	b9 8e 00 00 00       	mov    $0x8e,%ecx
  110cc8:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  110ccd:	be fd d1 11 00       	mov    $0x11d1fd,%esi
  110cd2:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  110cd7:	e8 1c f9 fe ff       	callq  1005f8 <printk>
  110cdc:	be c8 cd 1b 00       	mov    $0x1bcdc8,%esi
  110ce1:	bf 12 d2 11 00       	mov    $0x11d212,%edi
  110ce6:	31 c0                	xor    %eax,%eax
  110ce8:	e8 0b f9 fe ff       	callq  1005f8 <printk>
  110ced:	be 8e 00 00 00       	mov    $0x8e,%esi
  110cf2:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  110cf7:	e8 9c 1e ff ff       	callq  102b98 <assert_post_action>
	z_spin_lock_set_owner(l);
  110cfc:	bf c8 cd 1b 00       	mov    $0x1bcdc8,%edi
  110d01:	e8 b7 cb ff ff       	callq  10d8bd <z_spin_lock_set_owner>
		unpend_thread_no_timeout(thread);
  110d06:	4c 89 e7             	mov    %r12,%rdi
  110d09:	e8 c6 02 00 00       	callq  110fd4 <unpend_thread_no_timeout>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  110d0e:	bf c8 cd 1b 00       	mov    $0x1bcdc8,%edi
  110d13:	e8 81 cb ff ff       	callq  10d899 <z_spin_unlock_valid>
  110d18:	84 c0                	test   %al,%al
  110d1a:	75 39                	jne    110d55 <z_unpend_thread_no_timeout+0xad>
  110d1c:	b9 b9 00 00 00       	mov    $0xb9,%ecx
  110d21:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  110d26:	be 41 d2 11 00       	mov    $0x11d241,%esi
  110d2b:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  110d30:	e8 c3 f8 fe ff       	callq  1005f8 <printk>
  110d35:	be c8 cd 1b 00       	mov    $0x1bcdc8,%esi
  110d3a:	bf 58 d2 11 00       	mov    $0x11d258,%edi
  110d3f:	31 c0                	xor    %eax,%eax
  110d41:	e8 b2 f8 fe ff       	callq  1005f8 <printk>
  110d46:	be b9 00 00 00       	mov    $0xb9,%esi
  110d4b:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  110d50:	e8 43 1e ff ff       	callq  102b98 <assert_post_action>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  110d55:	0f ba e3 09          	bt     $0x9,%ebx
  110d59:	73 01                	jae    110d5c <z_unpend_thread_no_timeout+0xb4>
		__asm__ volatile ("sti" ::: "memory");
  110d5b:	fb                   	sti    
}
  110d5c:	5b                   	pop    %rbx
  110d5d:	41 5c                	pop    %r12
  110d5f:	5d                   	pop    %rbp
  110d60:	c3                   	retq   

0000000000110d61 <z_reschedule>:
{
  110d61:	55                   	push   %rbp
  110d62:	48 89 e5             	mov    %rsp,%rbp
  110d65:	41 54                	push   %r12
	return arch_irq_unlocked(key) && !arch_is_in_isr();
  110d67:	41 89 f4             	mov    %esi,%r12d
{
  110d6a:	53                   	push   %rbx
  110d6b:	48 89 fb             	mov    %rdi,%rbx
	return arch_irq_unlocked(key) && !arch_is_in_isr();
  110d6e:	41 81 e4 00 02 00 00 	and    $0x200,%r12d
  110d75:	74 22                	je     110d99 <z_reschedule+0x38>
	if (resched(key.key) && need_swap()) {
  110d77:	83 3d c2 79 01 00 00 	cmpl   $0x0,0x179c2(%rip)        # 128740 <_kernel>
  110d7e:	75 19                	jne    110d99 <z_reschedule+0x38>
  110d80:	48 8b 05 c9 79 01 00 	mov    0x179c9(%rip),%rax        # 128750 <_kernel+0x10>
  110d87:	48 39 05 da 79 01 00 	cmp    %rax,0x179da(%rip)        # 128768 <_kernel+0x28>
  110d8e:	74 09                	je     110d99 <z_reschedule+0x38>
}
  110d90:	5b                   	pop    %rbx
  110d91:	41 5c                	pop    %r12
  110d93:	5d                   	pop    %rbp
		z_swap(lock, key);
  110d94:	e9 26 fc ff ff       	jmpq   1109bf <z_swap>
  110d99:	48 89 df             	mov    %rbx,%rdi
  110d9c:	e8 f8 ca ff ff       	callq  10d899 <z_spin_unlock_valid>
  110da1:	84 c0                	test   %al,%al
  110da3:	75 37                	jne    110ddc <z_reschedule+0x7b>
  110da5:	b9 b9 00 00 00       	mov    $0xb9,%ecx
  110daa:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  110daf:	be 41 d2 11 00       	mov    $0x11d241,%esi
  110db4:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  110db9:	e8 3a f8 fe ff       	callq  1005f8 <printk>
  110dbe:	48 89 de             	mov    %rbx,%rsi
  110dc1:	bf 58 d2 11 00       	mov    $0x11d258,%edi
  110dc6:	31 c0                	xor    %eax,%eax
  110dc8:	e8 2b f8 fe ff       	callq  1005f8 <printk>
  110dcd:	be b9 00 00 00       	mov    $0xb9,%esi
  110dd2:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  110dd7:	e8 bc 1d ff ff       	callq  102b98 <assert_post_action>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  110ddc:	45 85 e4             	test   %r12d,%r12d
  110ddf:	74 01                	je     110de2 <z_reschedule+0x81>
		__asm__ volatile ("sti" ::: "memory");
  110de1:	fb                   	sti    
}
  110de2:	5b                   	pop    %rbx
  110de3:	41 5c                	pop    %r12
  110de5:	5d                   	pop    %rbp
  110de6:	c3                   	retq   

0000000000110de7 <z_reschedule_irqlock>:
	return arch_irq_unlocked(key) && !arch_is_in_isr();
  110de7:	0f ba e7 09          	bt     $0x9,%edi
  110deb:	73 0f                	jae    110dfc <z_reschedule_irqlock+0x15>
	if (resched(key)) {
  110ded:	83 3d 4c 79 01 00 00 	cmpl   $0x0,0x1794c(%rip)        # 128740 <_kernel>
  110df4:	75 05                	jne    110dfb <z_reschedule_irqlock+0x14>
		z_swap_irqlock(key);
  110df6:	e9 1e fa ff ff       	jmpq   110819 <z_swap_irqlock>
  110dfb:	fb                   	sti    
}
  110dfc:	c3                   	retq   

0000000000110dfd <z_reschedule_unlocked>:
  110dfd:	9c                   	pushfq 
  110dfe:	fa                   	cli    
  110dff:	5f                   	pop    %rdi
	(void) z_reschedule_irqlock(arch_irq_lock());
  110e00:	e9 e2 ff ff ff       	jmpq   110de7 <z_reschedule_irqlock>

0000000000110e05 <k_sched_lock>:
{
  110e05:	55                   	push   %rbp
  110e06:	48 89 e5             	mov    %rsp,%rbp
  110e09:	53                   	push   %rbx
  110e0a:	52                   	push   %rdx
  110e0b:	9c                   	pushfq 
  110e0c:	fa                   	cli    
  110e0d:	5b                   	pop    %rbx
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  110e0e:	bf c8 cd 1b 00       	mov    $0x1bcdc8,%edi
  110e13:	e8 61 ca ff ff       	callq  10d879 <z_spin_lock_valid>
  110e18:	84 c0                	test   %al,%al
  110e1a:	75 39                	jne    110e55 <k_sched_lock+0x50>
  110e1c:	b9 8e 00 00 00       	mov    $0x8e,%ecx
  110e21:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  110e26:	be fd d1 11 00       	mov    $0x11d1fd,%esi
  110e2b:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  110e30:	e8 c3 f7 fe ff       	callq  1005f8 <printk>
  110e35:	be c8 cd 1b 00       	mov    $0x1bcdc8,%esi
  110e3a:	bf 12 d2 11 00       	mov    $0x11d212,%edi
  110e3f:	31 c0                	xor    %eax,%eax
  110e41:	e8 b2 f7 fe ff       	callq  1005f8 <printk>
  110e46:	be 8e 00 00 00       	mov    $0x8e,%esi
  110e4b:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  110e50:	e8 43 1d ff ff       	callq  102b98 <assert_post_action>
	z_spin_lock_set_owner(l);
  110e55:	bf c8 cd 1b 00       	mov    $0x1bcdc8,%edi
  110e5a:	e8 5e ca ff ff       	callq  10d8bd <z_spin_lock_set_owner>
	__ASSERT(!arch_is_in_isr(), "");
  110e5f:	83 3d da 78 01 00 00 	cmpl   $0x0,0x178da(%rip)        # 128740 <_kernel>
  110e66:	74 36                	je     110e9e <k_sched_lock+0x99>
  110e68:	be 49 f9 11 00       	mov    $0x11f949,%esi
  110e6d:	b9 fd 00 00 00       	mov    $0xfd,%ecx
  110e72:	ba 83 fc 11 00       	mov    $0x11fc83,%edx
  110e77:	31 c0                	xor    %eax,%eax
  110e79:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  110e7e:	e8 75 f7 fe ff       	callq  1005f8 <printk>
  110e83:	bf 22 fc 11 00       	mov    $0x11fc22,%edi
  110e88:	31 c0                	xor    %eax,%eax
  110e8a:	e8 69 f7 fe ff       	callq  1005f8 <printk>
  110e8f:	be fd 00 00 00       	mov    $0xfd,%esi
  110e94:	bf 83 fc 11 00       	mov    $0x11fc83,%edi
  110e99:	e8 fa 1c ff ff       	callq  102b98 <assert_post_action>
	__ASSERT(_current->base.sched_locked != 1U, "");
  110e9e:	48 8b 05 ab 78 01 00 	mov    0x178ab(%rip),%rax        # 128750 <_kernel+0x10>
  110ea5:	80 78 1b 01          	cmpb   $0x1,0x1b(%rax)
  110ea9:	75 36                	jne    110ee1 <k_sched_lock+0xdc>
  110eab:	be ae fc 11 00       	mov    $0x11fcae,%esi
  110eb0:	b9 fe 00 00 00       	mov    $0xfe,%ecx
  110eb5:	ba 83 fc 11 00       	mov    $0x11fc83,%edx
  110eba:	31 c0                	xor    %eax,%eax
  110ebc:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  110ec1:	e8 32 f7 fe ff       	callq  1005f8 <printk>
  110ec6:	bf 22 fc 11 00       	mov    $0x11fc22,%edi
  110ecb:	31 c0                	xor    %eax,%eax
  110ecd:	e8 26 f7 fe ff       	callq  1005f8 <printk>
  110ed2:	be fe 00 00 00       	mov    $0xfe,%esi
  110ed7:	bf 83 fc 11 00       	mov    $0x11fc83,%edi
  110edc:	e8 b7 1c ff ff       	callq  102b98 <assert_post_action>
	--_current->base.sched_locked;
  110ee1:	48 8b 05 68 78 01 00 	mov    0x17868(%rip),%rax        # 128750 <_kernel+0x10>
  110ee8:	fe 48 1b             	decb   0x1b(%rax)
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  110eeb:	bf c8 cd 1b 00       	mov    $0x1bcdc8,%edi
  110ef0:	e8 a4 c9 ff ff       	callq  10d899 <z_spin_unlock_valid>
  110ef5:	84 c0                	test   %al,%al
  110ef7:	75 39                	jne    110f32 <k_sched_lock+0x12d>
  110ef9:	b9 b9 00 00 00       	mov    $0xb9,%ecx
  110efe:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  110f03:	be 41 d2 11 00       	mov    $0x11d241,%esi
  110f08:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  110f0d:	e8 e6 f6 fe ff       	callq  1005f8 <printk>
  110f12:	be c8 cd 1b 00       	mov    $0x1bcdc8,%esi
  110f17:	bf 58 d2 11 00       	mov    $0x11d258,%edi
  110f1c:	31 c0                	xor    %eax,%eax
  110f1e:	e8 d5 f6 fe ff       	callq  1005f8 <printk>
  110f23:	be b9 00 00 00       	mov    $0xb9,%esi
  110f28:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  110f2d:	e8 66 1c ff ff       	callq  102b98 <assert_post_action>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  110f32:	0f ba e3 09          	bt     $0x9,%ebx
  110f36:	73 01                	jae    110f39 <k_sched_lock+0x134>
		__asm__ volatile ("sti" ::: "memory");
  110f38:	fb                   	sti    
}
  110f39:	58                   	pop    %rax
  110f3a:	5b                   	pop    %rbx
  110f3b:	5d                   	pop    %rbp
  110f3c:	c3                   	retq   

0000000000110f3d <z_swap_next_thread>:
}
  110f3d:	48 8b 05 24 78 01 00 	mov    0x17824(%rip),%rax        # 128768 <_kernel+0x28>
  110f44:	c3                   	retq   

0000000000110f45 <z_get_next_switch_handle>:
{
  110f45:	55                   	push   %rbp
  110f46:	48 89 e5             	mov    %rsp,%rbp
  110f49:	53                   	push   %rbx
  110f4a:	50                   	push   %rax
	_current->switch_handle = interrupted;
  110f4b:	48 8b 05 fe 77 01 00 	mov    0x177fe(%rip),%rax        # 128750 <_kernel+0x10>
	set_current(_kernel.ready_q.cache);
  110f52:	48 8b 1d 0f 78 01 00 	mov    0x1780f(%rip),%rbx        # 128768 <_kernel+0x28>
	_current->switch_handle = interrupted;
  110f59:	48 89 b8 50 01 00 00 	mov    %rdi,0x150(%rax)
	z_thread_mark_switched_out();
  110f60:	e8 3b d6 ff ff       	callq  10e5a0 <z_thread_mark_switched_out>
	return _current->switch_handle;
  110f65:	48 8b 83 50 01 00 00 	mov    0x150(%rbx),%rax
	_current_cpu->current = new_thread;
  110f6c:	48 89 1d dd 77 01 00 	mov    %rbx,0x177dd(%rip)        # 128750 <_kernel+0x10>
}
  110f73:	5a                   	pop    %rdx
  110f74:	5b                   	pop    %rbx
  110f75:	5d                   	pop    %rbp
  110f76:	c3                   	retq   

0000000000110f77 <z_priq_dumb_remove>:
{
  110f77:	55                   	push   %rbp
  110f78:	48 89 e5             	mov    %rsp,%rbp
  110f7b:	53                   	push   %rbx
  110f7c:	48 89 f3             	mov    %rsi,%rbx
  110f7f:	52                   	push   %rdx
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
  110f80:	48 81 fe 80 7f 12 00 	cmp    $0x127f80,%rsi
  110f87:	75 2a                	jne    110fb3 <z_priq_dumb_remove+0x3c>
  110f89:	be 6e fd 11 00       	mov    $0x11fd6e,%esi
  110f8e:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  110f93:	b9 b5 03 00 00       	mov    $0x3b5,%ecx
  110f98:	31 c0                	xor    %eax,%eax
  110f9a:	ba 4c fd 11 00       	mov    $0x11fd4c,%edx
  110f9f:	e8 54 f6 fe ff       	callq  1005f8 <printk>
  110fa4:	be b5 03 00 00       	mov    $0x3b5,%esi
  110fa9:	bf 4c fd 11 00       	mov    $0x11fd4c,%edi
  110fae:	e8 e5 1b ff ff       	callq  102b98 <assert_post_action>
	sys_dnode_t *const prev = node->prev;
  110fb3:	48 8b 53 08          	mov    0x8(%rbx),%rdx
	sys_dnode_t *const next = node->next;
  110fb7:	48 8b 03             	mov    (%rbx),%rax
	prev->next = next;
  110fba:	48 89 02             	mov    %rax,(%rdx)
	next->prev = prev;
  110fbd:	48 89 50 08          	mov    %rdx,0x8(%rax)
	node->next = NULL;
  110fc1:	48 c7 03 00 00 00 00 	movq   $0x0,(%rbx)
	node->prev = NULL;
  110fc8:	48 c7 43 08 00 00 00 	movq   $0x0,0x8(%rbx)
  110fcf:	00 
}
  110fd0:	58                   	pop    %rax
  110fd1:	5b                   	pop    %rbx
  110fd2:	5d                   	pop    %rbp
  110fd3:	c3                   	retq   

0000000000110fd4 <unpend_thread_no_timeout>:
{
  110fd4:	55                   	push   %rbp
  110fd5:	48 89 e5             	mov    %rsp,%rbp
  110fd8:	53                   	push   %rbx
  110fd9:	48 89 fb             	mov    %rdi,%rbx
  110fdc:	52                   	push   %rdx
	__ASSERT_NO_MSG(thread->base.pended_on);
  110fdd:	48 83 7f 10 00       	cmpq   $0x0,0x10(%rdi)
  110fe2:	75 2a                	jne    11100e <unpend_thread_no_timeout+0x3a>
  110fe4:	be 8f fd 11 00       	mov    $0x11fd8f,%esi
  110fe9:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  110fee:	b9 53 02 00 00       	mov    $0x253,%ecx
  110ff3:	31 c0                	xor    %eax,%eax
  110ff5:	ba 4c fd 11 00       	mov    $0x11fd4c,%edx
  110ffa:	e8 f9 f5 fe ff       	callq  1005f8 <printk>
  110fff:	be 53 02 00 00       	mov    $0x253,%esi
  111004:	bf 4c fd 11 00       	mov    $0x11fd4c,%edi
  111009:	e8 8a 1b ff ff       	callq  102b98 <assert_post_action>
	_priq_wait_remove(&pended_on_thread(thread)->waitq, thread);
  11100e:	48 8b 7b 10          	mov    0x10(%rbx),%rdi
  111012:	48 89 de             	mov    %rbx,%rsi
  111015:	e8 5d ff ff ff       	callq  110f77 <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
  11101a:	80 63 19 fd          	andb   $0xfd,0x19(%rbx)
	thread->base.pended_on = NULL;
  11101e:	48 c7 43 10 00 00 00 	movq   $0x0,0x10(%rbx)
  111025:	00 
}
  111026:	58                   	pop    %rax
  111027:	5b                   	pop    %rbx
  111028:	5d                   	pop    %rbp
  111029:	c3                   	retq   

000000000011102a <z_unpend_thread>:
{
  11102a:	55                   	push   %rbp
  11102b:	48 89 e5             	mov    %rsp,%rbp
  11102e:	41 54                	push   %r12
  111030:	53                   	push   %rbx
  111031:	48 89 fb             	mov    %rdi,%rbx
  111034:	9c                   	pushfq 
  111035:	fa                   	cli    
  111036:	41 5c                	pop    %r12
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  111038:	bf c8 cd 1b 00       	mov    $0x1bcdc8,%edi
  11103d:	e8 37 c8 ff ff       	callq  10d879 <z_spin_lock_valid>
  111042:	84 c0                	test   %al,%al
  111044:	75 39                	jne    11107f <z_unpend_thread+0x55>
  111046:	b9 8e 00 00 00       	mov    $0x8e,%ecx
  11104b:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  111050:	be fd d1 11 00       	mov    $0x11d1fd,%esi
  111055:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  11105a:	e8 99 f5 fe ff       	callq  1005f8 <printk>
  11105f:	be c8 cd 1b 00       	mov    $0x1bcdc8,%esi
  111064:	bf 12 d2 11 00       	mov    $0x11d212,%edi
  111069:	31 c0                	xor    %eax,%eax
  11106b:	e8 88 f5 fe ff       	callq  1005f8 <printk>
  111070:	be 8e 00 00 00       	mov    $0x8e,%esi
  111075:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  11107a:	e8 19 1b ff ff       	callq  102b98 <assert_post_action>
	z_spin_lock_set_owner(l);
  11107f:	bf c8 cd 1b 00       	mov    $0x1bcdc8,%edi
  111084:	e8 34 c8 ff ff       	callq  10d8bd <z_spin_lock_set_owner>
		unpend_thread_no_timeout(thread);
  111089:	48 89 df             	mov    %rbx,%rdi
  11108c:	e8 43 ff ff ff       	callq  110fd4 <unpend_thread_no_timeout>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  111091:	bf c8 cd 1b 00       	mov    $0x1bcdc8,%edi
  111096:	e8 fe c7 ff ff       	callq  10d899 <z_spin_unlock_valid>
  11109b:	84 c0                	test   %al,%al
  11109d:	75 39                	jne    1110d8 <z_unpend_thread+0xae>
  11109f:	b9 b9 00 00 00       	mov    $0xb9,%ecx
  1110a4:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  1110a9:	be 41 d2 11 00       	mov    $0x11d241,%esi
  1110ae:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  1110b3:	e8 40 f5 fe ff       	callq  1005f8 <printk>
  1110b8:	be c8 cd 1b 00       	mov    $0x1bcdc8,%esi
  1110bd:	bf 58 d2 11 00       	mov    $0x11d258,%edi
  1110c2:	31 c0                	xor    %eax,%eax
  1110c4:	e8 2f f5 fe ff       	callq  1005f8 <printk>
  1110c9:	be b9 00 00 00       	mov    $0xb9,%esi
  1110ce:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  1110d3:	e8 c0 1a ff ff       	callq  102b98 <assert_post_action>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  1110d8:	41 0f ba e4 09       	bt     $0x9,%r12d
  1110dd:	73 01                	jae    1110e0 <z_unpend_thread+0xb6>
		__asm__ volatile ("sti" ::: "memory");
  1110df:	fb                   	sti    
}

static inline int z_abort_thread_timeout(struct k_thread *thread)
{
	return z_abort_timeout(&thread->base.timeout);
  1110e0:	48 8d 7b 28          	lea    0x28(%rbx),%rdi
}
  1110e4:	5b                   	pop    %rbx
  1110e5:	41 5c                	pop    %r12
  1110e7:	5d                   	pop    %rbp
  1110e8:	e9 ed 1e 00 00       	jmpq   112fda <z_abort_timeout>

00000000001110ed <z_priq_dumb_best>:
	return list->head == list;
  1110ed:	48 8b 07             	mov    (%rdi),%rax
	if (n != NULL) {
  1110f0:	48 85 c0             	test   %rax,%rax
  1110f3:	74 05                	je     1110fa <z_priq_dumb_best+0xd>
  1110f5:	48 39 c7             	cmp    %rax,%rdi
  1110f8:	75 02                	jne    1110fc <z_priq_dumb_best+0xf>
	struct k_thread *thread = NULL;
  1110fa:	31 c0                	xor    %eax,%eax
}
  1110fc:	c3                   	retq   

00000000001110fd <update_cache>:
{
  1110fd:	55                   	push   %rbp
  1110fe:	48 89 e5             	mov    %rsp,%rbp
  111101:	53                   	push   %rbx
  111102:	52                   	push   %rdx
  111103:	89 fa                	mov    %edi,%edx
	thread = _priq_run_best(&_kernel.ready_q.runq);
  111105:	bf 70 87 12 00       	mov    $0x128770,%edi
  11110a:	e8 de ff ff ff       	callq  1110ed <z_priq_dumb_best>
	return (thread != NULL) ? thread : _current_cpu->idle_thread;
  11110f:	48 8b 1d 42 76 01 00 	mov    0x17642(%rip),%rbx        # 128758 <_kernel+0x18>
  111116:	48 85 c0             	test   %rax,%rax
  111119:	74 03                	je     11111e <update_cache+0x21>
  11111b:	48 89 c3             	mov    %rax,%rbx
	if (preempt_ok != 0) {
  11111e:	85 d2                	test   %edx,%edx
  111120:	75 5d                	jne    11117f <update_cache+0x82>
	__ASSERT(_current != NULL, "");
  111122:	48 83 3d 26 76 01 00 	cmpq   $0x0,0x17626(%rip)        # 128750 <_kernel+0x10>
  111129:	00 
  11112a:	75 36                	jne    111162 <update_cache+0x65>
  11112c:	be a6 fd 11 00       	mov    $0x11fda6,%esi
  111131:	b9 81 00 00 00       	mov    $0x81,%ecx
  111136:	ba 4c fd 11 00       	mov    $0x11fd4c,%edx
  11113b:	31 c0                	xor    %eax,%eax
  11113d:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  111142:	e8 b1 f4 fe ff       	callq  1005f8 <printk>
  111147:	bf 22 fc 11 00       	mov    $0x11fc22,%edi
  11114c:	31 c0                	xor    %eax,%eax
  11114e:	e8 a5 f4 fe ff       	callq  1005f8 <printk>
  111153:	be 81 00 00 00       	mov    $0x81,%esi
  111158:	bf 4c fd 11 00       	mov    $0x11fd4c,%edi
  11115d:	e8 36 1a ff ff       	callq  102b98 <assert_post_action>
	if (z_is_thread_prevented_from_running(_current)) {
  111162:	48 8b 05 e7 75 01 00 	mov    0x175e7(%rip),%rax        # 128750 <_kernel+0x10>
  111169:	f6 40 19 1f          	testb  $0x1f,0x19(%rax)
  11116d:	75 10                	jne    11117f <update_cache+0x82>
	if (is_preempt(_current) || is_metairq(thread)) {
  11116f:	66 83 78 1a 7f       	cmpw   $0x7f,0x1a(%rax)
  111174:	76 09                	jbe    11117f <update_cache+0x82>
		_kernel.ready_q.cache = _current;
  111176:	48 89 05 eb 75 01 00 	mov    %rax,0x175eb(%rip)        # 128768 <_kernel+0x28>
  11117d:	eb 15                	jmp    111194 <update_cache+0x97>
		if (thread != _current) {
  11117f:	48 39 1d ca 75 01 00 	cmp    %rbx,0x175ca(%rip)        # 128750 <_kernel+0x10>
  111186:	74 05                	je     11118d <update_cache+0x90>
			z_reset_time_slice();
  111188:	e8 63 f6 ff ff       	callq  1107f0 <z_reset_time_slice>
		_kernel.ready_q.cache = thread;
  11118d:	48 89 1d d4 75 01 00 	mov    %rbx,0x175d4(%rip)        # 128768 <_kernel+0x28>
}
  111194:	58                   	pop    %rax
  111195:	5b                   	pop    %rbx
  111196:	5d                   	pop    %rbp
  111197:	c3                   	retq   

0000000000111198 <move_thread_to_end_of_prio_q>:
{
  111198:	55                   	push   %rbp
  111199:	48 89 e5             	mov    %rsp,%rbp
  11119c:	53                   	push   %rbx
  11119d:	48 89 fb             	mov    %rdi,%rbx
  1111a0:	52                   	push   %rdx
	return (thread->base.thread_state & state) != 0U;
  1111a1:	8a 47 19             	mov    0x19(%rdi),%al
	if (z_is_thread_queued(thread)) {
  1111a4:	84 c0                	test   %al,%al
  1111a6:	79 13                	jns    1111bb <move_thread_to_end_of_prio_q+0x23>
	thread->base.thread_state &= ~_THREAD_QUEUED;
  1111a8:	83 e0 7f             	and    $0x7f,%eax
		_priq_run_remove(pq, thread);
  1111ab:	48 89 fe             	mov    %rdi,%rsi
	thread->base.thread_state &= ~_THREAD_QUEUED;
  1111ae:	88 47 19             	mov    %al,0x19(%rdi)
		_priq_run_remove(pq, thread);
  1111b1:	bf 70 87 12 00       	mov    $0x128770,%edi
  1111b6:	e8 bc fd ff ff       	callq  110f77 <z_priq_dumb_remove>
	thread->base.thread_state |= _THREAD_QUEUED;
  1111bb:	80 4b 19 80          	orb    $0x80,0x19(%rbx)
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
  1111bf:	48 81 fb 80 7f 12 00 	cmp    $0x127f80,%rbx
  1111c6:	75 2a                	jne    1111f2 <move_thread_to_end_of_prio_q+0x5a>
  1111c8:	be 6e fd 11 00       	mov    $0x11fd6e,%esi
  1111cd:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  1111d2:	b9 b1 00 00 00       	mov    $0xb1,%ecx
  1111d7:	31 c0                	xor    %eax,%eax
  1111d9:	ba 4c fd 11 00       	mov    $0x11fd4c,%edx
  1111de:	e8 15 f4 fe ff       	callq  1005f8 <printk>
  1111e3:	be b1 00 00 00       	mov    $0xb1,%esi
  1111e8:	bf 4c fd 11 00       	mov    $0x11fd4c,%edi
  1111ed:	e8 a6 19 ff ff       	callq  102b98 <assert_post_action>
  1111f2:	48 8b 05 77 75 01 00 	mov    0x17577(%rip),%rax        # 128770 <_kernel+0x30>
	sys_dnode_t *const tail = list->tail;
  1111f9:	48 8b 0d 78 75 01 00 	mov    0x17578(%rip),%rcx        # 128778 <_kernel+0x38>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
  111200:	48 85 c0             	test   %rax,%rax
  111203:	74 3b                	je     111240 <move_thread_to_end_of_prio_q+0xa8>
  111205:	48 3d 70 87 12 00    	cmp    $0x128770,%rax
  11120b:	74 33                	je     111240 <move_thread_to_end_of_prio_q+0xa8>
	int32_t b1 = thread_1->base.prio;
  11120d:	0f be 73 1a          	movsbl 0x1a(%rbx),%esi
	int32_t b2 = thread_2->base.prio;
  111211:	0f be 50 1a          	movsbl 0x1a(%rax),%edx
	if (b1 != b2) {
  111215:	39 d6                	cmp    %edx,%esi
  111217:	74 1a                	je     111233 <move_thread_to_end_of_prio_q+0x9b>
		return b2 - b1;
  111219:	29 f2                	sub    %esi,%edx
		if (z_sched_prio_cmp(thread, t) > 0) {
  11121b:	85 d2                	test   %edx,%edx
  11121d:	7e 14                	jle    111233 <move_thread_to_end_of_prio_q+0x9b>
	sys_dnode_t *const prev = successor->prev;
  11121f:	48 8b 50 08          	mov    0x8(%rax),%rdx
	node->next = successor;
  111223:	48 89 03             	mov    %rax,(%rbx)
	node->prev = prev;
  111226:	48 89 53 08          	mov    %rdx,0x8(%rbx)
	prev->next = node;
  11122a:	48 89 1a             	mov    %rbx,(%rdx)
	successor->prev = node;
  11122d:	48 89 58 08          	mov    %rbx,0x8(%rax)
}
  111231:	eb 22                	jmp    111255 <move_thread_to_end_of_prio_q+0xbd>
	return (node == list->tail) ? NULL : node->next;
  111233:	48 39 c8             	cmp    %rcx,%rax
  111236:	74 08                	je     111240 <move_thread_to_end_of_prio_q+0xa8>
  111238:	48 8b 00             	mov    (%rax),%rax
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
  11123b:	48 85 c0             	test   %rax,%rax
  11123e:	75 d1                	jne    111211 <move_thread_to_end_of_prio_q+0x79>
	node->next = list;
  111240:	48 c7 03 70 87 12 00 	movq   $0x128770,(%rbx)
	node->prev = tail;
  111247:	48 89 4b 08          	mov    %rcx,0x8(%rbx)
	tail->next = node;
  11124b:	48 89 19             	mov    %rbx,(%rcx)
	list->tail = node;
  11124e:	48 89 1d 23 75 01 00 	mov    %rbx,0x17523(%rip)        # 128778 <_kernel+0x38>
	update_cache(thread == _current);
  111255:	31 ff                	xor    %edi,%edi
  111257:	48 39 1d f2 74 01 00 	cmp    %rbx,0x174f2(%rip)        # 128750 <_kernel+0x10>
}
  11125e:	58                   	pop    %rax
	update_cache(thread == _current);
  11125f:	40 0f 94 c7          	sete   %dil
}
  111263:	5b                   	pop    %rbx
  111264:	5d                   	pop    %rbp
	update_cache(thread == _current);
  111265:	e9 93 fe ff ff       	jmpq   1110fd <update_cache>

000000000011126a <z_time_slice>:
{
  11126a:	55                   	push   %rbp
  11126b:	48 89 e5             	mov    %rsp,%rbp
  11126e:	41 54                	push   %r12
  111270:	53                   	push   %rbx
  111271:	89 fb                	mov    %edi,%ebx
  111273:	9c                   	pushfq 
  111274:	fa                   	cli    
  111275:	41 5c                	pop    %r12
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  111277:	bf c8 cd 1b 00       	mov    $0x1bcdc8,%edi
  11127c:	e8 f8 c5 ff ff       	callq  10d879 <z_spin_lock_valid>
  111281:	84 c0                	test   %al,%al
  111283:	75 39                	jne    1112be <z_time_slice+0x54>
  111285:	b9 8e 00 00 00       	mov    $0x8e,%ecx
  11128a:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  11128f:	be fd d1 11 00       	mov    $0x11d1fd,%esi
  111294:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  111299:	e8 5a f3 fe ff       	callq  1005f8 <printk>
  11129e:	be c8 cd 1b 00       	mov    $0x1bcdc8,%esi
  1112a3:	bf 12 d2 11 00       	mov    $0x11d212,%edi
  1112a8:	31 c0                	xor    %eax,%eax
  1112aa:	e8 49 f3 fe ff       	callq  1005f8 <printk>
  1112af:	be 8e 00 00 00       	mov    $0x8e,%esi
  1112b4:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  1112b9:	e8 da 18 ff ff       	callq  102b98 <assert_post_action>
	z_spin_lock_set_owner(l);
  1112be:	bf c8 cd 1b 00       	mov    $0x1bcdc8,%edi
  1112c3:	e8 f5 c5 ff ff       	callq  10d8bd <z_spin_lock_set_owner>
	if (slice_time && sliceable(_current)) {
  1112c8:	83 3d 6d bb 0a 00 00 	cmpl   $0x0,0xabb6d(%rip)        # 1bce3c <slice_time>
  1112cf:	74 49                	je     11131a <z_time_slice+0xb0>
  1112d1:	48 8b 3d 78 74 01 00 	mov    0x17478(%rip),%rdi        # 128750 <_kernel+0x10>
		&& !z_is_idle_thread_object(thread);
  1112d8:	66 83 7f 1a 7f       	cmpw   $0x7f,0x1a(%rdi)
  1112dd:	77 3b                	ja     11131a <z_time_slice+0xb0>
		&& !z_is_thread_prevented_from_running(thread)
  1112df:	f6 47 19 1f          	testb  $0x1f,0x19(%rdi)
  1112e3:	75 35                	jne    11131a <z_time_slice+0xb0>
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
  1112e5:	0f be 47 1a          	movsbl 0x1a(%rdi),%eax
		&& !z_is_idle_thread_object(thread);
  1112e9:	39 05 49 bb 0a 00    	cmp    %eax,0xabb49(%rip)        # 1bce38 <slice_max_prio>
  1112ef:	7f 29                	jg     11131a <z_time_slice+0xb0>
  1112f1:	48 81 ff 80 7f 12 00 	cmp    $0x127f80,%rdi
  1112f8:	74 20                	je     11131a <z_time_slice+0xb0>
		if (ticks >= _current_cpu->slice_ticks) {
  1112fa:	8b 05 60 74 01 00    	mov    0x17460(%rip),%eax        # 128760 <_kernel+0x20>
  111300:	39 d8                	cmp    %ebx,%eax
  111302:	7f 0c                	jg     111310 <z_time_slice+0xa6>
			move_thread_to_end_of_prio_q(_current);
  111304:	e8 8f fe ff ff       	callq  111198 <move_thread_to_end_of_prio_q>
			z_reset_time_slice();
  111309:	e8 e2 f4 ff ff       	callq  1107f0 <z_reset_time_slice>
  11130e:	eb 14                	jmp    111324 <z_time_slice+0xba>
			_current_cpu->slice_ticks -= ticks;
  111310:	29 d8                	sub    %ebx,%eax
  111312:	89 05 48 74 01 00    	mov    %eax,0x17448(%rip)        # 128760 <_kernel+0x20>
  111318:	eb 0a                	jmp    111324 <z_time_slice+0xba>
		_current_cpu->slice_ticks = 0;
  11131a:	c7 05 3c 74 01 00 00 	movl   $0x0,0x1743c(%rip)        # 128760 <_kernel+0x20>
  111321:	00 00 00 
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  111324:	bf c8 cd 1b 00       	mov    $0x1bcdc8,%edi
  111329:	e8 6b c5 ff ff       	callq  10d899 <z_spin_unlock_valid>
  11132e:	84 c0                	test   %al,%al
  111330:	75 39                	jne    11136b <z_time_slice+0x101>
  111332:	b9 b9 00 00 00       	mov    $0xb9,%ecx
  111337:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  11133c:	be 41 d2 11 00       	mov    $0x11d241,%esi
  111341:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  111346:	e8 ad f2 fe ff       	callq  1005f8 <printk>
  11134b:	be c8 cd 1b 00       	mov    $0x1bcdc8,%esi
  111350:	bf 58 d2 11 00       	mov    $0x11d258,%edi
  111355:	31 c0                	xor    %eax,%eax
  111357:	e8 9c f2 fe ff       	callq  1005f8 <printk>
  11135c:	be b9 00 00 00       	mov    $0xb9,%esi
  111361:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  111366:	e8 2d 18 ff ff       	callq  102b98 <assert_post_action>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  11136b:	41 0f ba e4 09       	bt     $0x9,%r12d
  111370:	73 01                	jae    111373 <z_time_slice+0x109>
		__asm__ volatile ("sti" ::: "memory");
  111372:	fb                   	sti    
}
  111373:	5b                   	pop    %rbx
  111374:	41 5c                	pop    %r12
  111376:	5d                   	pop    %rbp
  111377:	c3                   	retq   

0000000000111378 <ready_thread>:
  111378:	8a 47 19             	mov    0x19(%rdi),%al
	if (!z_is_thread_queued(thread) && z_is_thread_ready(thread)) {
  11137b:	84 c0                	test   %al,%al
  11137d:	0f 88 c6 00 00 00    	js     111449 <ready_thread+0xd1>
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
  111383:	a8 1f                	test   $0x1f,%al
  111385:	0f 85 be 00 00 00    	jne    111449 <ready_thread+0xd1>
{
  11138b:	55                   	push   %rbp
  11138c:	48 89 e5             	mov    %rsp,%rbp
  11138f:	53                   	push   %rbx
  111390:	48 89 fb             	mov    %rdi,%rbx
  111393:	51                   	push   %rcx
	if (!z_is_thread_queued(thread) && z_is_thread_ready(thread)) {
  111394:	48 83 7f 28 00       	cmpq   $0x0,0x28(%rdi)
  111399:	0f 85 a6 00 00 00    	jne    111445 <ready_thread+0xcd>
	thread->base.thread_state |= _THREAD_QUEUED;
  11139f:	83 c8 80             	or     $0xffffff80,%eax
  1113a2:	88 47 19             	mov    %al,0x19(%rdi)
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
  1113a5:	48 81 ff 80 7f 12 00 	cmp    $0x127f80,%rdi
  1113ac:	75 2a                	jne    1113d8 <ready_thread+0x60>
  1113ae:	be 6e fd 11 00       	mov    $0x11fd6e,%esi
  1113b3:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  1113b8:	b9 b1 00 00 00       	mov    $0xb1,%ecx
  1113bd:	31 c0                	xor    %eax,%eax
  1113bf:	ba 4c fd 11 00       	mov    $0x11fd4c,%edx
  1113c4:	e8 2f f2 fe ff       	callq  1005f8 <printk>
  1113c9:	be b1 00 00 00       	mov    $0xb1,%esi
  1113ce:	bf 4c fd 11 00       	mov    $0x11fd4c,%edi
  1113d3:	e8 c0 17 ff ff       	callq  102b98 <assert_post_action>
	return list->head == list;
  1113d8:	48 8b 05 91 73 01 00 	mov    0x17391(%rip),%rax        # 128770 <_kernel+0x30>
	sys_dnode_t *const tail = list->tail;
  1113df:	48 8b 0d 92 73 01 00 	mov    0x17392(%rip),%rcx        # 128778 <_kernel+0x38>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
  1113e6:	48 85 c0             	test   %rax,%rax
  1113e9:	74 3b                	je     111426 <ready_thread+0xae>
  1113eb:	48 3d 70 87 12 00    	cmp    $0x128770,%rax
  1113f1:	74 33                	je     111426 <ready_thread+0xae>
	int32_t b1 = thread_1->base.prio;
  1113f3:	0f be 73 1a          	movsbl 0x1a(%rbx),%esi
	int32_t b2 = thread_2->base.prio;
  1113f7:	0f be 50 1a          	movsbl 0x1a(%rax),%edx
	if (b1 != b2) {
  1113fb:	39 d6                	cmp    %edx,%esi
  1113fd:	74 1a                	je     111419 <ready_thread+0xa1>
		return b2 - b1;
  1113ff:	29 f2                	sub    %esi,%edx
		if (z_sched_prio_cmp(thread, t) > 0) {
  111401:	85 d2                	test   %edx,%edx
  111403:	7e 14                	jle    111419 <ready_thread+0xa1>
	sys_dnode_t *const prev = successor->prev;
  111405:	48 8b 50 08          	mov    0x8(%rax),%rdx
	node->next = successor;
  111409:	48 89 03             	mov    %rax,(%rbx)
	node->prev = prev;
  11140c:	48 89 53 08          	mov    %rdx,0x8(%rbx)
	prev->next = node;
  111410:	48 89 1a             	mov    %rbx,(%rdx)
	successor->prev = node;
  111413:	48 89 58 08          	mov    %rbx,0x8(%rax)
}
  111417:	eb 22                	jmp    11143b <ready_thread+0xc3>
	return (node == list->tail) ? NULL : node->next;
  111419:	48 39 c8             	cmp    %rcx,%rax
  11141c:	74 08                	je     111426 <ready_thread+0xae>
  11141e:	48 8b 00             	mov    (%rax),%rax
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
  111421:	48 85 c0             	test   %rax,%rax
  111424:	75 d1                	jne    1113f7 <ready_thread+0x7f>
	node->next = list;
  111426:	48 c7 03 70 87 12 00 	movq   $0x128770,(%rbx)
	node->prev = tail;
  11142d:	48 89 4b 08          	mov    %rcx,0x8(%rbx)
	tail->next = node;
  111431:	48 89 19             	mov    %rbx,(%rcx)
	list->tail = node;
  111434:	48 89 1d 3d 73 01 00 	mov    %rbx,0x1733d(%rip)        # 128778 <_kernel+0x38>
}
  11143b:	5a                   	pop    %rdx
		update_cache(0);
  11143c:	31 ff                	xor    %edi,%edi
}
  11143e:	5b                   	pop    %rbx
  11143f:	5d                   	pop    %rbp
		update_cache(0);
  111440:	e9 b8 fc ff ff       	jmpq   1110fd <update_cache>
}
  111445:	58                   	pop    %rax
  111446:	5b                   	pop    %rbx
  111447:	5d                   	pop    %rbp
  111448:	c3                   	retq   
  111449:	c3                   	retq   

000000000011144a <z_ready_thread>:
{
  11144a:	55                   	push   %rbp
  11144b:	48 89 e5             	mov    %rsp,%rbp
  11144e:	41 54                	push   %r12
  111450:	49 89 fc             	mov    %rdi,%r12
  111453:	53                   	push   %rbx
  111454:	9c                   	pushfq 
  111455:	fa                   	cli    
  111456:	5b                   	pop    %rbx
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  111457:	bf c8 cd 1b 00       	mov    $0x1bcdc8,%edi
  11145c:	e8 18 c4 ff ff       	callq  10d879 <z_spin_lock_valid>
  111461:	84 c0                	test   %al,%al
  111463:	75 39                	jne    11149e <z_ready_thread+0x54>
  111465:	b9 8e 00 00 00       	mov    $0x8e,%ecx
  11146a:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  11146f:	be fd d1 11 00       	mov    $0x11d1fd,%esi
  111474:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  111479:	e8 7a f1 fe ff       	callq  1005f8 <printk>
  11147e:	be c8 cd 1b 00       	mov    $0x1bcdc8,%esi
  111483:	bf 12 d2 11 00       	mov    $0x11d212,%edi
  111488:	31 c0                	xor    %eax,%eax
  11148a:	e8 69 f1 fe ff       	callq  1005f8 <printk>
  11148f:	be 8e 00 00 00       	mov    $0x8e,%esi
  111494:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  111499:	e8 fa 16 ff ff       	callq  102b98 <assert_post_action>
	z_spin_lock_set_owner(l);
  11149e:	bf c8 cd 1b 00       	mov    $0x1bcdc8,%edi
  1114a3:	e8 15 c4 ff ff       	callq  10d8bd <z_spin_lock_set_owner>
			ready_thread(thread);
  1114a8:	4c 89 e7             	mov    %r12,%rdi
  1114ab:	e8 c8 fe ff ff       	callq  111378 <ready_thread>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  1114b0:	bf c8 cd 1b 00       	mov    $0x1bcdc8,%edi
  1114b5:	e8 df c3 ff ff       	callq  10d899 <z_spin_unlock_valid>
  1114ba:	84 c0                	test   %al,%al
  1114bc:	75 39                	jne    1114f7 <z_ready_thread+0xad>
  1114be:	b9 b9 00 00 00       	mov    $0xb9,%ecx
  1114c3:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  1114c8:	be 41 d2 11 00       	mov    $0x11d241,%esi
  1114cd:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  1114d2:	e8 21 f1 fe ff       	callq  1005f8 <printk>
  1114d7:	be c8 cd 1b 00       	mov    $0x1bcdc8,%esi
  1114dc:	bf 58 d2 11 00       	mov    $0x11d258,%edi
  1114e1:	31 c0                	xor    %eax,%eax
  1114e3:	e8 10 f1 fe ff       	callq  1005f8 <printk>
  1114e8:	be b9 00 00 00       	mov    $0xb9,%esi
  1114ed:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  1114f2:	e8 a1 16 ff ff       	callq  102b98 <assert_post_action>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  1114f7:	0f ba e3 09          	bt     $0x9,%ebx
  1114fb:	73 01                	jae    1114fe <z_ready_thread+0xb4>
		__asm__ volatile ("sti" ::: "memory");
  1114fd:	fb                   	sti    
}
  1114fe:	5b                   	pop    %rbx
  1114ff:	41 5c                	pop    %r12
  111501:	5d                   	pop    %rbp
  111502:	c3                   	retq   

0000000000111503 <z_sched_start>:
{
  111503:	55                   	push   %rbp
  111504:	48 89 e5             	mov    %rsp,%rbp
  111507:	41 54                	push   %r12
  111509:	49 89 fc             	mov    %rdi,%r12
  11150c:	53                   	push   %rbx
  11150d:	9c                   	pushfq 
  11150e:	fa                   	cli    
  11150f:	5b                   	pop    %rbx
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  111510:	bf c8 cd 1b 00       	mov    $0x1bcdc8,%edi
  111515:	e8 5f c3 ff ff       	callq  10d879 <z_spin_lock_valid>
  11151a:	84 c0                	test   %al,%al
  11151c:	75 39                	jne    111557 <z_sched_start+0x54>
  11151e:	b9 8e 00 00 00       	mov    $0x8e,%ecx
  111523:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  111528:	be fd d1 11 00       	mov    $0x11d1fd,%esi
  11152d:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  111532:	e8 c1 f0 fe ff       	callq  1005f8 <printk>
  111537:	be c8 cd 1b 00       	mov    $0x1bcdc8,%esi
  11153c:	bf 12 d2 11 00       	mov    $0x11d212,%edi
  111541:	31 c0                	xor    %eax,%eax
  111543:	e8 b0 f0 fe ff       	callq  1005f8 <printk>
  111548:	be 8e 00 00 00       	mov    $0x8e,%esi
  11154d:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  111552:	e8 41 16 ff ff       	callq  102b98 <assert_post_action>
	z_spin_lock_set_owner(l);
  111557:	bf c8 cd 1b 00       	mov    $0x1bcdc8,%edi
  11155c:	e8 5c c3 ff ff       	callq  10d8bd <z_spin_lock_set_owner>
	return (thread->base.thread_state & _THREAD_PRESTART) == 0U;
  111561:	41 8a 44 24 19       	mov    0x19(%r12),%al
	if (z_has_thread_started(thread)) {
  111566:	a8 04                	test   $0x4,%al
  111568:	75 50                	jne    1115ba <z_sched_start+0xb7>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  11156a:	bf c8 cd 1b 00       	mov    $0x1bcdc8,%edi
  11156f:	e8 25 c3 ff ff       	callq  10d899 <z_spin_unlock_valid>
  111574:	84 c0                	test   %al,%al
  111576:	75 39                	jne    1115b1 <z_sched_start+0xae>
  111578:	b9 b9 00 00 00       	mov    $0xb9,%ecx
  11157d:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  111582:	be 41 d2 11 00       	mov    $0x11d241,%esi
  111587:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  11158c:	e8 67 f0 fe ff       	callq  1005f8 <printk>
  111591:	be c8 cd 1b 00       	mov    $0x1bcdc8,%esi
  111596:	bf 58 d2 11 00       	mov    $0x11d258,%edi
  11159b:	31 c0                	xor    %eax,%eax
  11159d:	e8 56 f0 fe ff       	callq  1005f8 <printk>
  1115a2:	be b9 00 00 00       	mov    $0xb9,%esi
  1115a7:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  1115ac:	e8 e7 15 ff ff       	callq  102b98 <assert_post_action>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  1115b1:	0f ba e3 09          	bt     $0x9,%ebx
  1115b5:	73 23                	jae    1115da <z_sched_start+0xd7>
		__asm__ volatile ("sti" ::: "memory");
  1115b7:	fb                   	sti    
  1115b8:	eb 20                	jmp    1115da <z_sched_start+0xd7>
	thread->base.thread_state &= ~_THREAD_PRESTART;
  1115ba:	83 e0 fb             	and    $0xfffffffb,%eax
	ready_thread(thread);
  1115bd:	4c 89 e7             	mov    %r12,%rdi
  1115c0:	41 88 44 24 19       	mov    %al,0x19(%r12)
  1115c5:	e8 ae fd ff ff       	callq  111378 <ready_thread>
	z_reschedule(&sched_spinlock, key);
  1115ca:	89 de                	mov    %ebx,%esi
  1115cc:	bf c8 cd 1b 00       	mov    $0x1bcdc8,%edi
}
  1115d1:	5b                   	pop    %rbx
  1115d2:	41 5c                	pop    %r12
  1115d4:	5d                   	pop    %rbp
	z_reschedule(&sched_spinlock, key);
  1115d5:	e9 87 f7 ff ff       	jmpq   110d61 <z_reschedule>
}
  1115da:	5b                   	pop    %rbx
  1115db:	41 5c                	pop    %r12
  1115dd:	5d                   	pop    %rbp
  1115de:	c3                   	retq   

00000000001115df <z_impl_k_thread_resume>:
{
  1115df:	55                   	push   %rbp
  1115e0:	48 89 e5             	mov    %rsp,%rbp
  1115e3:	41 54                	push   %r12
  1115e5:	49 89 fc             	mov    %rdi,%r12
  1115e8:	53                   	push   %rbx
  1115e9:	9c                   	pushfq 
  1115ea:	fa                   	cli    
  1115eb:	5b                   	pop    %rbx
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  1115ec:	bf c8 cd 1b 00       	mov    $0x1bcdc8,%edi
  1115f1:	e8 83 c2 ff ff       	callq  10d879 <z_spin_lock_valid>
  1115f6:	84 c0                	test   %al,%al
  1115f8:	75 39                	jne    111633 <z_impl_k_thread_resume+0x54>
  1115fa:	b9 8e 00 00 00       	mov    $0x8e,%ecx
  1115ff:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  111604:	be fd d1 11 00       	mov    $0x11d1fd,%esi
  111609:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  11160e:	e8 e5 ef fe ff       	callq  1005f8 <printk>
  111613:	be c8 cd 1b 00       	mov    $0x1bcdc8,%esi
  111618:	bf 12 d2 11 00       	mov    $0x11d212,%edi
  11161d:	31 c0                	xor    %eax,%eax
  11161f:	e8 d4 ef fe ff       	callq  1005f8 <printk>
  111624:	be 8e 00 00 00       	mov    $0x8e,%esi
  111629:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  11162e:	e8 65 15 ff ff       	callq  102b98 <assert_post_action>
	z_spin_lock_set_owner(l);
  111633:	bf c8 cd 1b 00       	mov    $0x1bcdc8,%edi
  111638:	e8 80 c2 ff ff       	callq  10d8bd <z_spin_lock_set_owner>
	return (thread->base.thread_state & _THREAD_SUSPENDED) != 0U;
  11163d:	41 8a 44 24 19       	mov    0x19(%r12),%al
	if (!z_is_thread_suspended(thread)) {
  111642:	a8 10                	test   $0x10,%al
  111644:	75 50                	jne    111696 <z_impl_k_thread_resume+0xb7>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  111646:	bf c8 cd 1b 00       	mov    $0x1bcdc8,%edi
  11164b:	e8 49 c2 ff ff       	callq  10d899 <z_spin_unlock_valid>
  111650:	84 c0                	test   %al,%al
  111652:	75 39                	jne    11168d <z_impl_k_thread_resume+0xae>
  111654:	b9 b9 00 00 00       	mov    $0xb9,%ecx
  111659:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  11165e:	be 41 d2 11 00       	mov    $0x11d241,%esi
  111663:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  111668:	e8 8b ef fe ff       	callq  1005f8 <printk>
  11166d:	be c8 cd 1b 00       	mov    $0x1bcdc8,%esi
  111672:	bf 58 d2 11 00       	mov    $0x11d258,%edi
  111677:	31 c0                	xor    %eax,%eax
  111679:	e8 7a ef fe ff       	callq  1005f8 <printk>
  11167e:	be b9 00 00 00       	mov    $0xb9,%esi
  111683:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  111688:	e8 0b 15 ff ff       	callq  102b98 <assert_post_action>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  11168d:	0f ba e3 09          	bt     $0x9,%ebx
  111691:	73 23                	jae    1116b6 <z_impl_k_thread_resume+0xd7>
		__asm__ volatile ("sti" ::: "memory");
  111693:	fb                   	sti    
  111694:	eb 20                	jmp    1116b6 <z_impl_k_thread_resume+0xd7>
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
  111696:	83 e0 ef             	and    $0xffffffef,%eax
	ready_thread(thread);
  111699:	4c 89 e7             	mov    %r12,%rdi
  11169c:	41 88 44 24 19       	mov    %al,0x19(%r12)
  1116a1:	e8 d2 fc ff ff       	callq  111378 <ready_thread>
	z_reschedule(&sched_spinlock, key);
  1116a6:	89 de                	mov    %ebx,%esi
  1116a8:	bf c8 cd 1b 00       	mov    $0x1bcdc8,%edi
}
  1116ad:	5b                   	pop    %rbx
  1116ae:	41 5c                	pop    %r12
  1116b0:	5d                   	pop    %rbp
	z_reschedule(&sched_spinlock, key);
  1116b1:	e9 ab f6 ff ff       	jmpq   110d61 <z_reschedule>
}
  1116b6:	5b                   	pop    %rbx
  1116b7:	41 5c                	pop    %r12
  1116b9:	5d                   	pop    %rbp
  1116ba:	c3                   	retq   

00000000001116bb <z_mrsh_k_thread_resume>:
#include <syscalls/kernel.h>

extern void z_vrfy_k_thread_resume(k_tid_t thread);
uintptr_t z_mrsh_k_thread_resume(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
  1116bb:	55                   	push   %rbp
  1116bc:	48 89 e5             	mov    %rsp,%rbp
  1116bf:	41 54                	push   %r12
  1116c1:	49 89 fc             	mov    %rdi,%r12
  1116c4:	51                   	push   %rcx
	_current->syscall_frame = ssf;
  1116c5:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  1116c9:	48 8b 05 80 70 01 00 	mov    0x17080(%rip),%rax        # 128750 <_kernel+0x10>
  1116d0:	48 89 90 40 01 00 00 	mov    %rdx,0x140(%rax)
	Z_OOPS(Z_SYSCALL_OBJ(thread, K_OBJ_THREAD));
  1116d7:	e8 f8 53 00 00       	callq  116ad4 <z_object_find>
  1116dc:	4c 89 e6             	mov    %r12,%rsi
  1116df:	48 89 c7             	mov    %rax,%rdi
  1116e2:	e8 b4 f0 ff ff       	callq  11079b <z_obj_validation_check.constprop.0>
  1116e7:	85 c0                	test   %eax,%eax
  1116e9:	74 29                	je     111714 <z_mrsh_k_thread_resume+0x59>
  1116eb:	bf 23 f3 11 00       	mov    $0x11f323,%edi
  1116f0:	31 c0                	xor    %eax,%eax
  1116f2:	ba 20 c5 11 00       	mov    $0x11c520,%edx
  1116f7:	be 45 00 00 00       	mov    $0x45,%esi
  1116fc:	e8 c5 19 ff ff       	callq  1030c6 <z_log_minimal_printk>
  111701:	48 8b 05 48 70 01 00 	mov    0x17048(%rip),%rax        # 128750 <_kernel+0x10>
  111708:	48 8b b8 40 01 00 00 	mov    0x140(%rax),%rdi
  11170f:	e8 f9 84 ff ff       	callq  109c0d <arch_syscall_oops>
	z_impl_k_thread_resume(thread);
  111714:	4c 89 e7             	mov    %r12,%rdi
  111717:	e8 c3 fe ff ff       	callq  1115df <z_impl_k_thread_resume>
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	z_vrfy_k_thread_resume(*(k_tid_t*)&arg0)
;
	_current->syscall_frame = NULL;
  11171c:	48 8b 05 2d 70 01 00 	mov    0x1702d(%rip),%rax        # 128750 <_kernel+0x10>
  111723:	48 c7 80 40 01 00 00 	movq   $0x0,0x140(%rax)
  11172a:	00 00 00 00 
	return 0;
}
  11172e:	31 c0                	xor    %eax,%eax
  111730:	5a                   	pop    %rdx
  111731:	41 5c                	pop    %r12
  111733:	5d                   	pop    %rbp
  111734:	c3                   	retq   

0000000000111735 <z_thread_timeout>:
{
  111735:	55                   	push   %rbp
  111736:	48 89 e5             	mov    %rsp,%rbp
  111739:	41 55                	push   %r13
  11173b:	41 54                	push   %r12
	struct k_thread *thread = CONTAINER_OF(timeout,
  11173d:	4c 8d 67 d8          	lea    -0x28(%rdi),%r12
{
  111741:	53                   	push   %rbx
  111742:	48 89 fb             	mov    %rdi,%rbx
  111745:	52                   	push   %rdx
  111746:	9c                   	pushfq 
  111747:	fa                   	cli    
  111748:	41 5d                	pop    %r13
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  11174a:	bf c8 cd 1b 00       	mov    $0x1bcdc8,%edi
  11174f:	e8 25 c1 ff ff       	callq  10d879 <z_spin_lock_valid>
  111754:	84 c0                	test   %al,%al
  111756:	75 39                	jne    111791 <z_thread_timeout+0x5c>
  111758:	b9 8e 00 00 00       	mov    $0x8e,%ecx
  11175d:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  111762:	be fd d1 11 00       	mov    $0x11d1fd,%esi
  111767:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  11176c:	e8 87 ee fe ff       	callq  1005f8 <printk>
  111771:	be c8 cd 1b 00       	mov    $0x1bcdc8,%esi
  111776:	bf 12 d2 11 00       	mov    $0x11d212,%edi
  11177b:	31 c0                	xor    %eax,%eax
  11177d:	e8 76 ee fe ff       	callq  1005f8 <printk>
  111782:	be 8e 00 00 00       	mov    $0x8e,%esi
  111787:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  11178c:	e8 07 14 ff ff       	callq  102b98 <assert_post_action>
	z_spin_lock_set_owner(l);
  111791:	bf c8 cd 1b 00       	mov    $0x1bcdc8,%edi
  111796:	e8 22 c1 ff ff       	callq  10d8bd <z_spin_lock_set_owner>
		if (!killed) {
  11179b:	f6 43 f1 28          	testb  $0x28,-0xf(%rbx)
  11179f:	75 1b                	jne    1117bc <z_thread_timeout+0x87>
			if (thread->base.pended_on != NULL) {
  1117a1:	48 83 7b e8 00       	cmpq   $0x0,-0x18(%rbx)
  1117a6:	74 08                	je     1117b0 <z_thread_timeout+0x7b>
				unpend_thread_no_timeout(thread);
  1117a8:	4c 89 e7             	mov    %r12,%rdi
  1117ab:	e8 24 f8 ff ff       	callq  110fd4 <unpend_thread_no_timeout>
  1117b0:	80 63 f1 eb          	andb   $0xeb,-0xf(%rbx)
			ready_thread(thread);
  1117b4:	4c 89 e7             	mov    %r12,%rdi
  1117b7:	e8 bc fb ff ff       	callq  111378 <ready_thread>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  1117bc:	bf c8 cd 1b 00       	mov    $0x1bcdc8,%edi
  1117c1:	e8 d3 c0 ff ff       	callq  10d899 <z_spin_unlock_valid>
  1117c6:	84 c0                	test   %al,%al
  1117c8:	75 39                	jne    111803 <z_thread_timeout+0xce>
  1117ca:	b9 b9 00 00 00       	mov    $0xb9,%ecx
  1117cf:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  1117d4:	be 41 d2 11 00       	mov    $0x11d241,%esi
  1117d9:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  1117de:	e8 15 ee fe ff       	callq  1005f8 <printk>
  1117e3:	be c8 cd 1b 00       	mov    $0x1bcdc8,%esi
  1117e8:	bf 58 d2 11 00       	mov    $0x11d258,%edi
  1117ed:	31 c0                	xor    %eax,%eax
  1117ef:	e8 04 ee fe ff       	callq  1005f8 <printk>
  1117f4:	be b9 00 00 00       	mov    $0xb9,%esi
  1117f9:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  1117fe:	e8 95 13 ff ff       	callq  102b98 <assert_post_action>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  111803:	41 0f ba e5 09       	bt     $0x9,%r13d
  111808:	73 01                	jae    11180b <z_thread_timeout+0xd6>
		__asm__ volatile ("sti" ::: "memory");
  11180a:	fb                   	sti    
}
  11180b:	58                   	pop    %rax
  11180c:	5b                   	pop    %rbx
  11180d:	41 5c                	pop    %r12
  11180f:	41 5d                	pop    %r13
  111811:	5d                   	pop    %rbp
  111812:	c3                   	retq   

0000000000111813 <unready_thread>:
{
  111813:	55                   	push   %rbp
  111814:	48 89 e5             	mov    %rsp,%rbp
  111817:	53                   	push   %rbx
  111818:	48 89 fb             	mov    %rdi,%rbx
  11181b:	52                   	push   %rdx
	return (thread->base.thread_state & state) != 0U;
  11181c:	8a 47 19             	mov    0x19(%rdi),%al
	if (z_is_thread_queued(thread)) {
  11181f:	84 c0                	test   %al,%al
  111821:	79 13                	jns    111836 <unready_thread+0x23>
	thread->base.thread_state &= ~_THREAD_QUEUED;
  111823:	83 e0 7f             	and    $0x7f,%eax
		_priq_run_remove(pq, thread);
  111826:	48 89 fe             	mov    %rdi,%rsi
	thread->base.thread_state &= ~_THREAD_QUEUED;
  111829:	88 47 19             	mov    %al,0x19(%rdi)
		_priq_run_remove(pq, thread);
  11182c:	bf 70 87 12 00       	mov    $0x128770,%edi
  111831:	e8 41 f7 ff ff       	callq  110f77 <z_priq_dumb_remove>
	update_cache(thread == _current);
  111836:	31 ff                	xor    %edi,%edi
  111838:	48 39 1d 11 6f 01 00 	cmp    %rbx,0x16f11(%rip)        # 128750 <_kernel+0x10>
}
  11183f:	58                   	pop    %rax
	update_cache(thread == _current);
  111840:	40 0f 94 c7          	sete   %dil
}
  111844:	5b                   	pop    %rbx
  111845:	5d                   	pop    %rbp
	update_cache(thread == _current);
  111846:	e9 b2 f8 ff ff       	jmpq   1110fd <update_cache>

000000000011184b <add_to_waitq_locked>:
{
  11184b:	55                   	push   %rbp
  11184c:	48 89 e5             	mov    %rsp,%rbp
  11184f:	41 54                	push   %r12
  111851:	49 89 f4             	mov    %rsi,%r12
  111854:	53                   	push   %rbx
  111855:	48 89 fb             	mov    %rdi,%rbx
	unready_thread(thread);
  111858:	e8 b6 ff ff ff       	callq  111813 <unready_thread>
	thread->base.thread_state |= _THREAD_PENDING;
  11185d:	80 4b 19 02          	orb    $0x2,0x19(%rbx)
	if (wait_q != NULL) {
  111861:	4d 85 e4             	test   %r12,%r12
  111864:	0f 84 8e 00 00 00    	je     1118f8 <add_to_waitq_locked+0xad>
		thread->base.pended_on = wait_q;
  11186a:	4c 89 63 10          	mov    %r12,0x10(%rbx)
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
  11186e:	48 81 fb 80 7f 12 00 	cmp    $0x127f80,%rbx
  111875:	75 2a                	jne    1118a1 <add_to_waitq_locked+0x56>
  111877:	be 6e fd 11 00       	mov    $0x11fd6e,%esi
  11187c:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  111881:	b9 b1 00 00 00       	mov    $0xb1,%ecx
  111886:	31 c0                	xor    %eax,%eax
  111888:	ba 4c fd 11 00       	mov    $0x11fd4c,%edx
  11188d:	e8 66 ed fe ff       	callq  1005f8 <printk>
  111892:	be b1 00 00 00       	mov    $0xb1,%esi
  111897:	bf 4c fd 11 00       	mov    $0x11fd4c,%edi
  11189c:	e8 f7 12 ff ff       	callq  102b98 <assert_post_action>
	return list->head == list;
  1118a1:	49 8b 04 24          	mov    (%r12),%rax
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
  1118a5:	48 85 c0             	test   %rax,%rax
  1118a8:	74 3a                	je     1118e4 <add_to_waitq_locked+0x99>
  1118aa:	49 39 c4             	cmp    %rax,%r12
  1118ad:	74 35                	je     1118e4 <add_to_waitq_locked+0x99>
	int32_t b1 = thread_1->base.prio;
  1118af:	0f be 4b 1a          	movsbl 0x1a(%rbx),%ecx
	int32_t b2 = thread_2->base.prio;
  1118b3:	0f be 50 1a          	movsbl 0x1a(%rax),%edx
	if (b1 != b2) {
  1118b7:	39 d1                	cmp    %edx,%ecx
  1118b9:	74 1a                	je     1118d5 <add_to_waitq_locked+0x8a>
		return b2 - b1;
  1118bb:	29 ca                	sub    %ecx,%edx
		if (z_sched_prio_cmp(thread, t) > 0) {
  1118bd:	85 d2                	test   %edx,%edx
  1118bf:	7e 14                	jle    1118d5 <add_to_waitq_locked+0x8a>
	sys_dnode_t *const prev = successor->prev;
  1118c1:	48 8b 50 08          	mov    0x8(%rax),%rdx
	node->next = successor;
  1118c5:	48 89 03             	mov    %rax,(%rbx)
	node->prev = prev;
  1118c8:	48 89 53 08          	mov    %rdx,0x8(%rbx)
	prev->next = node;
  1118cc:	48 89 1a             	mov    %rbx,(%rdx)
	successor->prev = node;
  1118cf:	48 89 58 08          	mov    %rbx,0x8(%rax)
}
  1118d3:	eb 23                	jmp    1118f8 <add_to_waitq_locked+0xad>
	return (node == list->tail) ? NULL : node->next;
  1118d5:	49 3b 44 24 08       	cmp    0x8(%r12),%rax
  1118da:	74 08                	je     1118e4 <add_to_waitq_locked+0x99>
  1118dc:	48 8b 00             	mov    (%rax),%rax
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
  1118df:	48 85 c0             	test   %rax,%rax
  1118e2:	75 cf                	jne    1118b3 <add_to_waitq_locked+0x68>
	sys_dnode_t *const tail = list->tail;
  1118e4:	49 8b 44 24 08       	mov    0x8(%r12),%rax
	node->next = list;
  1118e9:	4c 89 23             	mov    %r12,(%rbx)
	node->prev = tail;
  1118ec:	48 89 43 08          	mov    %rax,0x8(%rbx)
	tail->next = node;
  1118f0:	48 89 18             	mov    %rbx,(%rax)
	list->tail = node;
  1118f3:	49 89 5c 24 08       	mov    %rbx,0x8(%r12)
}
  1118f8:	5b                   	pop    %rbx
  1118f9:	41 5c                	pop    %r12
  1118fb:	5d                   	pop    %rbp
  1118fc:	c3                   	retq   

00000000001118fd <pend>:
{
  1118fd:	55                   	push   %rbp
  1118fe:	48 89 e5             	mov    %rsp,%rbp
  111901:	41 56                	push   %r14
  111903:	41 55                	push   %r13
  111905:	49 89 f5             	mov    %rsi,%r13
  111908:	41 54                	push   %r12
  11190a:	49 89 d4             	mov    %rdx,%r12
  11190d:	53                   	push   %rbx
  11190e:	48 89 fb             	mov    %rdi,%rbx
  111911:	9c                   	pushfq 
  111912:	fa                   	cli    
  111913:	41 5e                	pop    %r14
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  111915:	bf c8 cd 1b 00       	mov    $0x1bcdc8,%edi
  11191a:	e8 5a bf ff ff       	callq  10d879 <z_spin_lock_valid>
  11191f:	84 c0                	test   %al,%al
  111921:	75 39                	jne    11195c <pend+0x5f>
  111923:	b9 8e 00 00 00       	mov    $0x8e,%ecx
  111928:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  11192d:	be fd d1 11 00       	mov    $0x11d1fd,%esi
  111932:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  111937:	e8 bc ec fe ff       	callq  1005f8 <printk>
  11193c:	be c8 cd 1b 00       	mov    $0x1bcdc8,%esi
  111941:	bf 12 d2 11 00       	mov    $0x11d212,%edi
  111946:	31 c0                	xor    %eax,%eax
  111948:	e8 ab ec fe ff       	callq  1005f8 <printk>
  11194d:	be 8e 00 00 00       	mov    $0x8e,%esi
  111952:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  111957:	e8 3c 12 ff ff       	callq  102b98 <assert_post_action>
	z_spin_lock_set_owner(l);
  11195c:	bf c8 cd 1b 00       	mov    $0x1bcdc8,%edi
  111961:	e8 57 bf ff ff       	callq  10d8bd <z_spin_lock_set_owner>
		add_to_waitq_locked(thread, wait_q);
  111966:	48 89 df             	mov    %rbx,%rdi
  111969:	4c 89 ee             	mov    %r13,%rsi
  11196c:	e8 da fe ff ff       	callq  11184b <add_to_waitq_locked>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  111971:	bf c8 cd 1b 00       	mov    $0x1bcdc8,%edi
  111976:	e8 1e bf ff ff       	callq  10d899 <z_spin_unlock_valid>
  11197b:	84 c0                	test   %al,%al
  11197d:	75 39                	jne    1119b8 <pend+0xbb>
  11197f:	b9 b9 00 00 00       	mov    $0xb9,%ecx
  111984:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  111989:	be 41 d2 11 00       	mov    $0x11d241,%esi
  11198e:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  111993:	e8 60 ec fe ff       	callq  1005f8 <printk>
  111998:	be c8 cd 1b 00       	mov    $0x1bcdc8,%esi
  11199d:	bf 58 d2 11 00       	mov    $0x11d258,%edi
  1119a2:	31 c0                	xor    %eax,%eax
  1119a4:	e8 4f ec fe ff       	callq  1005f8 <printk>
  1119a9:	be b9 00 00 00       	mov    $0xb9,%esi
  1119ae:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  1119b3:	e8 e0 11 ff ff       	callq  102b98 <assert_post_action>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  1119b8:	41 0f ba e6 09       	bt     $0x9,%r14d
  1119bd:	73 01                	jae    1119c0 <pend+0xc3>
		__asm__ volatile ("sti" ::: "memory");
  1119bf:	fb                   	sti    
	if (!K_TIMEOUT_EQ(timeout, K_FOREVER)) {
  1119c0:	49 83 fc ff          	cmp    $0xffffffffffffffff,%r12
  1119c4:	74 19                	je     1119df <pend+0xe2>
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
  1119c6:	48 8d 7b 28          	lea    0x28(%rbx),%rdi
  1119ca:	4c 89 e2             	mov    %r12,%rdx
}
  1119cd:	5b                   	pop    %rbx
  1119ce:	be 35 17 11 00       	mov    $0x111735,%esi
  1119d3:	41 5c                	pop    %r12
  1119d5:	41 5d                	pop    %r13
  1119d7:	41 5e                	pop    %r14
  1119d9:	5d                   	pop    %rbp
  1119da:	e9 26 14 00 00       	jmpq   112e05 <z_add_timeout>
  1119df:	5b                   	pop    %rbx
  1119e0:	41 5c                	pop    %r12
  1119e2:	41 5d                	pop    %r13
  1119e4:	41 5e                	pop    %r14
  1119e6:	5d                   	pop    %rbp
  1119e7:	c3                   	retq   

00000000001119e8 <z_pend_curr>:
{
  1119e8:	55                   	push   %rbp
  1119e9:	48 89 e5             	mov    %rsp,%rbp
  1119ec:	41 55                	push   %r13
  1119ee:	41 89 f5             	mov    %esi,%r13d
  1119f1:	48 89 d6             	mov    %rdx,%rsi
  1119f4:	41 54                	push   %r12
  1119f6:	49 89 fc             	mov    %rdi,%r12
	pend(_current, wait_q, timeout);
  1119f9:	48 8b 3d 50 6d 01 00 	mov    0x16d50(%rip),%rdi        # 128750 <_kernel+0x10>
{
  111a00:	48 89 ca             	mov    %rcx,%rdx
	pend(_current, wait_q, timeout);
  111a03:	e8 f5 fe ff ff       	callq  1118fd <pend>
	return z_swap(lock, key);
  111a08:	44 89 ee             	mov    %r13d,%esi
  111a0b:	4c 89 e7             	mov    %r12,%rdi
}
  111a0e:	41 5c                	pop    %r12
  111a10:	41 5d                	pop    %r13
  111a12:	5d                   	pop    %rbp
	return z_swap(lock, key);
  111a13:	e9 a7 ef ff ff       	jmpq   1109bf <z_swap>

0000000000111a18 <z_set_prio>:
{
  111a18:	55                   	push   %rbp
  111a19:	48 89 e5             	mov    %rsp,%rbp
  111a1c:	41 55                	push   %r13
  111a1e:	41 54                	push   %r12
  111a20:	41 89 f4             	mov    %esi,%r12d
  111a23:	53                   	push   %rbx
  111a24:	48 89 fb             	mov    %rdi,%rbx
  111a27:	51                   	push   %rcx
  111a28:	9c                   	pushfq 
  111a29:	fa                   	cli    
  111a2a:	41 5d                	pop    %r13
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  111a2c:	bf c8 cd 1b 00       	mov    $0x1bcdc8,%edi
  111a31:	e8 43 be ff ff       	callq  10d879 <z_spin_lock_valid>
  111a36:	84 c0                	test   %al,%al
  111a38:	75 39                	jne    111a73 <z_set_prio+0x5b>
  111a3a:	b9 8e 00 00 00       	mov    $0x8e,%ecx
  111a3f:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  111a44:	be fd d1 11 00       	mov    $0x11d1fd,%esi
  111a49:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  111a4e:	e8 a5 eb fe ff       	callq  1005f8 <printk>
  111a53:	be c8 cd 1b 00       	mov    $0x1bcdc8,%esi
  111a58:	bf 12 d2 11 00       	mov    $0x11d212,%edi
  111a5d:	31 c0                	xor    %eax,%eax
  111a5f:	e8 94 eb fe ff       	callq  1005f8 <printk>
  111a64:	be 8e 00 00 00       	mov    $0x8e,%esi
  111a69:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  111a6e:	e8 25 11 ff ff       	callq  102b98 <assert_post_action>
	z_spin_lock_set_owner(l);
  111a73:	bf c8 cd 1b 00       	mov    $0x1bcdc8,%edi
  111a78:	e8 40 be ff ff       	callq  10d8bd <z_spin_lock_set_owner>
	uint8_t state = thread->base.thread_state;
  111a7d:	8a 43 19             	mov    0x19(%rbx),%al
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
  111a80:	a8 1f                	test   $0x1f,%al
  111a82:	0f 85 cb 00 00 00    	jne    111b53 <z_set_prio+0x13b>
		if (need_sched) {
  111a88:	48 83 7b 28 00       	cmpq   $0x0,0x28(%rbx)
  111a8d:	0f 85 c0 00 00 00    	jne    111b53 <z_set_prio+0x13b>
	thread->base.thread_state &= ~_THREAD_QUEUED;
  111a93:	83 e0 7f             	and    $0x7f,%eax
		_priq_run_remove(pq, thread);
  111a96:	48 89 de             	mov    %rbx,%rsi
  111a99:	bf 70 87 12 00       	mov    $0x128770,%edi
	thread->base.thread_state &= ~_THREAD_QUEUED;
  111a9e:	88 43 19             	mov    %al,0x19(%rbx)
		_priq_run_remove(pq, thread);
  111aa1:	e8 d1 f4 ff ff       	callq  110f77 <z_priq_dumb_remove>
	thread->base.thread_state |= _THREAD_QUEUED;
  111aa6:	80 4b 19 80          	orb    $0x80,0x19(%rbx)
				thread->base.prio = prio;
  111aaa:	44 88 63 1a          	mov    %r12b,0x1a(%rbx)
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
  111aae:	48 81 fb 80 7f 12 00 	cmp    $0x127f80,%rbx
  111ab5:	75 2a                	jne    111ae1 <z_set_prio+0xc9>
  111ab7:	be 6e fd 11 00       	mov    $0x11fd6e,%esi
  111abc:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  111ac1:	b9 b1 00 00 00       	mov    $0xb1,%ecx
  111ac6:	31 c0                	xor    %eax,%eax
  111ac8:	ba 4c fd 11 00       	mov    $0x11fd4c,%edx
  111acd:	e8 26 eb fe ff       	callq  1005f8 <printk>
  111ad2:	be b1 00 00 00       	mov    $0xb1,%esi
  111ad7:	bf 4c fd 11 00       	mov    $0x11fd4c,%edi
  111adc:	e8 b7 10 ff ff       	callq  102b98 <assert_post_action>
	return list->head == list;
  111ae1:	48 8b 05 88 6c 01 00 	mov    0x16c88(%rip),%rax        # 128770 <_kernel+0x30>
	sys_dnode_t *const tail = list->tail;
  111ae8:	48 8b 0d 89 6c 01 00 	mov    0x16c89(%rip),%rcx        # 128778 <_kernel+0x38>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
  111aef:	48 85 c0             	test   %rax,%rax
  111af2:	74 3b                	je     111b2f <z_set_prio+0x117>
  111af4:	48 3d 70 87 12 00    	cmp    $0x128770,%rax
  111afa:	74 33                	je     111b2f <z_set_prio+0x117>
	int32_t b1 = thread_1->base.prio;
  111afc:	0f be 73 1a          	movsbl 0x1a(%rbx),%esi
	int32_t b2 = thread_2->base.prio;
  111b00:	0f be 50 1a          	movsbl 0x1a(%rax),%edx
	if (b1 != b2) {
  111b04:	39 d6                	cmp    %edx,%esi
  111b06:	74 1a                	je     111b22 <z_set_prio+0x10a>
		return b2 - b1;
  111b08:	29 f2                	sub    %esi,%edx
		if (z_sched_prio_cmp(thread, t) > 0) {
  111b0a:	85 d2                	test   %edx,%edx
  111b0c:	7e 14                	jle    111b22 <z_set_prio+0x10a>
	sys_dnode_t *const prev = successor->prev;
  111b0e:	48 8b 50 08          	mov    0x8(%rax),%rdx
	node->next = successor;
  111b12:	48 89 03             	mov    %rax,(%rbx)
	node->prev = prev;
  111b15:	48 89 53 08          	mov    %rdx,0x8(%rbx)
	prev->next = node;
  111b19:	48 89 1a             	mov    %rbx,(%rdx)
	successor->prev = node;
  111b1c:	48 89 58 08          	mov    %rbx,0x8(%rax)
}
  111b20:	eb 22                	jmp    111b44 <z_set_prio+0x12c>
	return (node == list->tail) ? NULL : node->next;
  111b22:	48 39 c8             	cmp    %rcx,%rax
  111b25:	74 08                	je     111b2f <z_set_prio+0x117>
  111b27:	48 8b 00             	mov    (%rax),%rax
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
  111b2a:	48 85 c0             	test   %rax,%rax
  111b2d:	75 d1                	jne    111b00 <z_set_prio+0xe8>
	node->next = list;
  111b2f:	48 c7 03 70 87 12 00 	movq   $0x128770,(%rbx)
	node->prev = tail;
  111b36:	48 89 4b 08          	mov    %rcx,0x8(%rbx)
	tail->next = node;
  111b3a:	48 89 19             	mov    %rbx,(%rcx)
	list->tail = node;
  111b3d:	48 89 1d 34 6c 01 00 	mov    %rbx,0x16c34(%rip)        # 128778 <_kernel+0x38>
			update_cache(1);
  111b44:	bf 01 00 00 00       	mov    $0x1,%edi
  111b49:	41 b4 01             	mov    $0x1,%r12b
  111b4c:	e8 ac f5 ff ff       	callq  1110fd <update_cache>
  111b51:	eb 07                	jmp    111b5a <z_set_prio+0x142>
			thread->base.prio = prio;
  111b53:	44 88 63 1a          	mov    %r12b,0x1a(%rbx)
  111b57:	45 31 e4             	xor    %r12d,%r12d
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  111b5a:	bf c8 cd 1b 00       	mov    $0x1bcdc8,%edi
  111b5f:	e8 35 bd ff ff       	callq  10d899 <z_spin_unlock_valid>
  111b64:	84 c0                	test   %al,%al
  111b66:	75 39                	jne    111ba1 <z_set_prio+0x189>
  111b68:	b9 b9 00 00 00       	mov    $0xb9,%ecx
  111b6d:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  111b72:	be 41 d2 11 00       	mov    $0x11d241,%esi
  111b77:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  111b7c:	e8 77 ea fe ff       	callq  1005f8 <printk>
  111b81:	be c8 cd 1b 00       	mov    $0x1bcdc8,%esi
  111b86:	bf 58 d2 11 00       	mov    $0x11d258,%edi
  111b8b:	31 c0                	xor    %eax,%eax
  111b8d:	e8 66 ea fe ff       	callq  1005f8 <printk>
  111b92:	be b9 00 00 00       	mov    $0xb9,%esi
  111b97:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  111b9c:	e8 f7 0f ff ff       	callq  102b98 <assert_post_action>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  111ba1:	41 0f ba e5 09       	bt     $0x9,%r13d
  111ba6:	73 01                	jae    111ba9 <z_set_prio+0x191>
		__asm__ volatile ("sti" ::: "memory");
  111ba8:	fb                   	sti    
}
  111ba9:	5a                   	pop    %rdx
  111baa:	44 89 e0             	mov    %r12d,%eax
  111bad:	5b                   	pop    %rbx
  111bae:	41 5c                	pop    %r12
  111bb0:	41 5d                	pop    %r13
  111bb2:	5d                   	pop    %rbp
  111bb3:	c3                   	retq   

0000000000111bb4 <z_thread_priority_set>:
{
  111bb4:	55                   	push   %rbp
  111bb5:	48 89 e5             	mov    %rsp,%rbp
	bool need_sched = z_set_prio(thread, prio);
  111bb8:	e8 5b fe ff ff       	callq  111a18 <z_set_prio>
	if (need_sched && _current->base.sched_locked == 0U) {
  111bbd:	84 c0                	test   %al,%al
  111bbf:	74 13                	je     111bd4 <z_thread_priority_set+0x20>
  111bc1:	48 8b 05 88 6b 01 00 	mov    0x16b88(%rip),%rax        # 128750 <_kernel+0x10>
  111bc8:	80 78 1b 00          	cmpb   $0x0,0x1b(%rax)
  111bcc:	75 06                	jne    111bd4 <z_thread_priority_set+0x20>
}
  111bce:	5d                   	pop    %rbp
		z_reschedule_unlocked();
  111bcf:	e9 29 f2 ff ff       	jmpq   110dfd <z_reschedule_unlocked>
}
  111bd4:	5d                   	pop    %rbp
  111bd5:	c3                   	retq   

0000000000111bd6 <z_impl_k_thread_suspend>:
{
  111bd6:	55                   	push   %rbp
  111bd7:	48 89 e5             	mov    %rsp,%rbp
  111bda:	41 54                	push   %r12
  111bdc:	53                   	push   %rbx
  111bdd:	48 89 fb             	mov    %rdi,%rbx
	return z_abort_timeout(&thread->base.timeout);
  111be0:	48 83 c7 28          	add    $0x28,%rdi
  111be4:	e8 f1 13 00 00       	callq  112fda <z_abort_timeout>
  111be9:	9c                   	pushfq 
  111bea:	fa                   	cli    
  111beb:	41 5c                	pop    %r12
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  111bed:	bf c8 cd 1b 00       	mov    $0x1bcdc8,%edi
  111bf2:	e8 82 bc ff ff       	callq  10d879 <z_spin_lock_valid>
  111bf7:	84 c0                	test   %al,%al
  111bf9:	75 39                	jne    111c34 <z_impl_k_thread_suspend+0x5e>
  111bfb:	b9 8e 00 00 00       	mov    $0x8e,%ecx
  111c00:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  111c05:	be fd d1 11 00       	mov    $0x11d1fd,%esi
  111c0a:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  111c0f:	e8 e4 e9 fe ff       	callq  1005f8 <printk>
  111c14:	be c8 cd 1b 00       	mov    $0x1bcdc8,%esi
  111c19:	bf 12 d2 11 00       	mov    $0x11d212,%edi
  111c1e:	31 c0                	xor    %eax,%eax
  111c20:	e8 d3 e9 fe ff       	callq  1005f8 <printk>
  111c25:	be 8e 00 00 00       	mov    $0x8e,%esi
  111c2a:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  111c2f:	e8 64 0f ff ff       	callq  102b98 <assert_post_action>
	z_spin_lock_set_owner(l);
  111c34:	bf c8 cd 1b 00       	mov    $0x1bcdc8,%edi
  111c39:	e8 7f bc ff ff       	callq  10d8bd <z_spin_lock_set_owner>
	return (thread->base.thread_state & state) != 0U;
  111c3e:	8a 43 19             	mov    0x19(%rbx),%al
		if (z_is_thread_queued(thread)) {
  111c41:	84 c0                	test   %al,%al
  111c43:	79 13                	jns    111c58 <z_impl_k_thread_suspend+0x82>
	thread->base.thread_state &= ~_THREAD_QUEUED;
  111c45:	83 e0 7f             	and    $0x7f,%eax
		_priq_run_remove(pq, thread);
  111c48:	48 89 de             	mov    %rbx,%rsi
  111c4b:	bf 70 87 12 00       	mov    $0x128770,%edi
	thread->base.thread_state &= ~_THREAD_QUEUED;
  111c50:	88 43 19             	mov    %al,0x19(%rbx)
		_priq_run_remove(pq, thread);
  111c53:	e8 1f f3 ff ff       	callq  110f77 <z_priq_dumb_remove>
	thread->base.thread_state |= _THREAD_SUSPENDED;
  111c58:	80 4b 19 10          	orb    $0x10,0x19(%rbx)
		update_cache(thread == _current);
  111c5c:	31 ff                	xor    %edi,%edi
  111c5e:	48 39 1d eb 6a 01 00 	cmp    %rbx,0x16aeb(%rip)        # 128750 <_kernel+0x10>
  111c65:	40 0f 94 c7          	sete   %dil
  111c69:	e8 8f f4 ff ff       	callq  1110fd <update_cache>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  111c6e:	bf c8 cd 1b 00       	mov    $0x1bcdc8,%edi
  111c73:	e8 21 bc ff ff       	callq  10d899 <z_spin_unlock_valid>
  111c78:	84 c0                	test   %al,%al
  111c7a:	75 39                	jne    111cb5 <z_impl_k_thread_suspend+0xdf>
  111c7c:	b9 b9 00 00 00       	mov    $0xb9,%ecx
  111c81:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  111c86:	be 41 d2 11 00       	mov    $0x11d241,%esi
  111c8b:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  111c90:	e8 63 e9 fe ff       	callq  1005f8 <printk>
  111c95:	be c8 cd 1b 00       	mov    $0x1bcdc8,%esi
  111c9a:	bf 58 d2 11 00       	mov    $0x11d258,%edi
  111c9f:	31 c0                	xor    %eax,%eax
  111ca1:	e8 52 e9 fe ff       	callq  1005f8 <printk>
  111ca6:	be b9 00 00 00       	mov    $0xb9,%esi
  111cab:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  111cb0:	e8 e3 0e ff ff       	callq  102b98 <assert_post_action>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  111cb5:	41 0f ba e4 09       	bt     $0x9,%r12d
  111cba:	73 01                	jae    111cbd <z_impl_k_thread_suspend+0xe7>
		__asm__ volatile ("sti" ::: "memory");
  111cbc:	fb                   	sti    
	if (thread == _current) {
  111cbd:	48 39 1d 8c 6a 01 00 	cmp    %rbx,0x16a8c(%rip)        # 128750 <_kernel+0x10>
  111cc4:	75 09                	jne    111ccf <z_impl_k_thread_suspend+0xf9>
}
  111cc6:	5b                   	pop    %rbx
  111cc7:	41 5c                	pop    %r12
  111cc9:	5d                   	pop    %rbp
		z_reschedule_unlocked();
  111cca:	e9 2e f1 ff ff       	jmpq   110dfd <z_reschedule_unlocked>
}
  111ccf:	5b                   	pop    %rbx
  111cd0:	41 5c                	pop    %r12
  111cd2:	5d                   	pop    %rbp
  111cd3:	c3                   	retq   

0000000000111cd4 <z_mrsh_k_thread_suspend>:
#include <syscalls/kernel.h>

extern void z_vrfy_k_thread_suspend(k_tid_t thread);
uintptr_t z_mrsh_k_thread_suspend(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
  111cd4:	55                   	push   %rbp
  111cd5:	48 89 e5             	mov    %rsp,%rbp
  111cd8:	41 54                	push   %r12
  111cda:	49 89 fc             	mov    %rdi,%r12
  111cdd:	51                   	push   %rcx
	_current->syscall_frame = ssf;
  111cde:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  111ce2:	48 8b 05 67 6a 01 00 	mov    0x16a67(%rip),%rax        # 128750 <_kernel+0x10>
  111ce9:	48 89 90 40 01 00 00 	mov    %rdx,0x140(%rax)
	Z_OOPS(Z_SYSCALL_OBJ(thread, K_OBJ_THREAD));
  111cf0:	e8 df 4d 00 00       	callq  116ad4 <z_object_find>
  111cf5:	4c 89 e6             	mov    %r12,%rsi
  111cf8:	48 89 c7             	mov    %rax,%rdi
  111cfb:	e8 9b ea ff ff       	callq  11079b <z_obj_validation_check.constprop.0>
  111d00:	85 c0                	test   %eax,%eax
  111d02:	74 29                	je     111d2d <z_mrsh_k_thread_suspend+0x59>
  111d04:	bf 23 f3 11 00       	mov    $0x11f323,%edi
  111d09:	31 c0                	xor    %eax,%eax
  111d0b:	ba 40 c5 11 00       	mov    $0x11c540,%edx
  111d10:	be 45 00 00 00       	mov    $0x45,%esi
  111d15:	e8 ac 13 ff ff       	callq  1030c6 <z_log_minimal_printk>
  111d1a:	48 8b 05 2f 6a 01 00 	mov    0x16a2f(%rip),%rax        # 128750 <_kernel+0x10>
  111d21:	48 8b b8 40 01 00 00 	mov    0x140(%rax),%rdi
  111d28:	e8 e0 7e ff ff       	callq  109c0d <arch_syscall_oops>
	z_impl_k_thread_suspend(thread);
  111d2d:	4c 89 e7             	mov    %r12,%rdi
  111d30:	e8 a1 fe ff ff       	callq  111bd6 <z_impl_k_thread_suspend>
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	z_vrfy_k_thread_suspend(*(k_tid_t*)&arg0)
;
	_current->syscall_frame = NULL;
  111d35:	48 8b 05 14 6a 01 00 	mov    0x16a14(%rip),%rax        # 128750 <_kernel+0x10>
  111d3c:	48 c7 80 40 01 00 00 	movq   $0x0,0x140(%rax)
  111d43:	00 00 00 00 
	return 0;
}
  111d47:	31 c0                	xor    %eax,%eax
  111d49:	5a                   	pop    %rdx
  111d4a:	41 5c                	pop    %r12
  111d4c:	5d                   	pop    %rbp
  111d4d:	c3                   	retq   

0000000000111d4e <k_sched_unlock>:
{
  111d4e:	55                   	push   %rbp
  111d4f:	48 89 e5             	mov    %rsp,%rbp
  111d52:	53                   	push   %rbx
  111d53:	52                   	push   %rdx
  111d54:	9c                   	pushfq 
  111d55:	fa                   	cli    
  111d56:	5b                   	pop    %rbx
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  111d57:	bf c8 cd 1b 00       	mov    $0x1bcdc8,%edi
  111d5c:	e8 18 bb ff ff       	callq  10d879 <z_spin_lock_valid>
  111d61:	84 c0                	test   %al,%al
  111d63:	75 39                	jne    111d9e <k_sched_unlock+0x50>
  111d65:	b9 8e 00 00 00       	mov    $0x8e,%ecx
  111d6a:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  111d6f:	be fd d1 11 00       	mov    $0x11d1fd,%esi
  111d74:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  111d79:	e8 7a e8 fe ff       	callq  1005f8 <printk>
  111d7e:	be c8 cd 1b 00       	mov    $0x1bcdc8,%esi
  111d83:	bf 12 d2 11 00       	mov    $0x11d212,%edi
  111d88:	31 c0                	xor    %eax,%eax
  111d8a:	e8 69 e8 fe ff       	callq  1005f8 <printk>
  111d8f:	be 8e 00 00 00       	mov    $0x8e,%esi
  111d94:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  111d99:	e8 fa 0d ff ff       	callq  102b98 <assert_post_action>
	z_spin_lock_set_owner(l);
  111d9e:	bf c8 cd 1b 00       	mov    $0x1bcdc8,%edi
  111da3:	e8 15 bb ff ff       	callq  10d8bd <z_spin_lock_set_owner>
		__ASSERT(_current->base.sched_locked != 0U, "");
  111da8:	48 8b 05 a1 69 01 00 	mov    0x169a1(%rip),%rax        # 128750 <_kernel+0x10>
  111daf:	80 78 1b 00          	cmpb   $0x0,0x1b(%rax)
  111db3:	75 36                	jne    111deb <k_sched_unlock+0x9d>
  111db5:	be cd fd 11 00       	mov    $0x11fdcd,%esi
  111dba:	b9 55 03 00 00       	mov    $0x355,%ecx
  111dbf:	ba 4c fd 11 00       	mov    $0x11fd4c,%edx
  111dc4:	31 c0                	xor    %eax,%eax
  111dc6:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  111dcb:	e8 28 e8 fe ff       	callq  1005f8 <printk>
  111dd0:	bf 22 fc 11 00       	mov    $0x11fc22,%edi
  111dd5:	31 c0                	xor    %eax,%eax
  111dd7:	e8 1c e8 fe ff       	callq  1005f8 <printk>
  111ddc:	be 55 03 00 00       	mov    $0x355,%esi
  111de1:	bf 4c fd 11 00       	mov    $0x11fd4c,%edi
  111de6:	e8 ad 0d ff ff       	callq  102b98 <assert_post_action>
		__ASSERT(!arch_is_in_isr(), "");
  111deb:	83 3d 4e 69 01 00 00 	cmpl   $0x0,0x1694e(%rip)        # 128740 <_kernel>
  111df2:	74 36                	je     111e2a <k_sched_unlock+0xdc>
  111df4:	be 49 f9 11 00       	mov    $0x11f949,%esi
  111df9:	b9 56 03 00 00       	mov    $0x356,%ecx
  111dfe:	ba 4c fd 11 00       	mov    $0x11fd4c,%edx
  111e03:	31 c0                	xor    %eax,%eax
  111e05:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  111e0a:	e8 e9 e7 fe ff       	callq  1005f8 <printk>
  111e0f:	bf 22 fc 11 00       	mov    $0x11fc22,%edi
  111e14:	31 c0                	xor    %eax,%eax
  111e16:	e8 dd e7 fe ff       	callq  1005f8 <printk>
  111e1b:	be 56 03 00 00       	mov    $0x356,%esi
  111e20:	bf 4c fd 11 00       	mov    $0x11fd4c,%edi
  111e25:	e8 6e 0d ff ff       	callq  102b98 <assert_post_action>
		++_current->base.sched_locked;
  111e2a:	48 8b 05 1f 69 01 00 	mov    0x1691f(%rip),%rax        # 128750 <_kernel+0x10>
		update_cache(0);
  111e31:	31 ff                	xor    %edi,%edi
		++_current->base.sched_locked;
  111e33:	fe 40 1b             	incb   0x1b(%rax)
		update_cache(0);
  111e36:	e8 c2 f2 ff ff       	callq  1110fd <update_cache>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  111e3b:	bf c8 cd 1b 00       	mov    $0x1bcdc8,%edi
  111e40:	e8 54 ba ff ff       	callq  10d899 <z_spin_unlock_valid>
  111e45:	84 c0                	test   %al,%al
  111e47:	75 39                	jne    111e82 <k_sched_unlock+0x134>
  111e49:	b9 b9 00 00 00       	mov    $0xb9,%ecx
  111e4e:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  111e53:	be 41 d2 11 00       	mov    $0x11d241,%esi
  111e58:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  111e5d:	e8 96 e7 fe ff       	callq  1005f8 <printk>
  111e62:	be c8 cd 1b 00       	mov    $0x1bcdc8,%esi
  111e67:	bf 58 d2 11 00       	mov    $0x11d258,%edi
  111e6c:	31 c0                	xor    %eax,%eax
  111e6e:	e8 85 e7 fe ff       	callq  1005f8 <printk>
  111e73:	be b9 00 00 00       	mov    $0xb9,%esi
  111e78:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  111e7d:	e8 16 0d ff ff       	callq  102b98 <assert_post_action>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  111e82:	0f ba e3 09          	bt     $0x9,%ebx
  111e86:	73 01                	jae    111e89 <k_sched_unlock+0x13b>
		__asm__ volatile ("sti" ::: "memory");
  111e88:	fb                   	sti    
}
  111e89:	58                   	pop    %rax
  111e8a:	5b                   	pop    %rbx
  111e8b:	5d                   	pop    %rbp
	z_reschedule_unlocked();
  111e8c:	e9 6c ef ff ff       	jmpq   110dfd <z_reschedule_unlocked>

0000000000111e91 <z_unpend1_no_timeout>:
{
  111e91:	55                   	push   %rbp
  111e92:	48 89 e5             	mov    %rsp,%rbp
  111e95:	41 54                	push   %r12
  111e97:	49 89 fc             	mov    %rdi,%r12
  111e9a:	53                   	push   %rbx
  111e9b:	9c                   	pushfq 
  111e9c:	fa                   	cli    
  111e9d:	5b                   	pop    %rbx
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  111e9e:	bf c8 cd 1b 00       	mov    $0x1bcdc8,%edi
  111ea3:	e8 d1 b9 ff ff       	callq  10d879 <z_spin_lock_valid>
  111ea8:	84 c0                	test   %al,%al
  111eaa:	75 39                	jne    111ee5 <z_unpend1_no_timeout+0x54>
  111eac:	b9 8e 00 00 00       	mov    $0x8e,%ecx
  111eb1:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  111eb6:	be fd d1 11 00       	mov    $0x11d1fd,%esi
  111ebb:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  111ec0:	e8 33 e7 fe ff       	callq  1005f8 <printk>
  111ec5:	be c8 cd 1b 00       	mov    $0x1bcdc8,%esi
  111eca:	bf 12 d2 11 00       	mov    $0x11d212,%edi
  111ecf:	31 c0                	xor    %eax,%eax
  111ed1:	e8 22 e7 fe ff       	callq  1005f8 <printk>
  111ed6:	be 8e 00 00 00       	mov    $0x8e,%esi
  111edb:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  111ee0:	e8 b3 0c ff ff       	callq  102b98 <assert_post_action>
	z_spin_lock_set_owner(l);
  111ee5:	bf c8 cd 1b 00       	mov    $0x1bcdc8,%edi
  111eea:	e8 ce b9 ff ff       	callq  10d8bd <z_spin_lock_set_owner>
		thread = _priq_wait_best(&wait_q->waitq);
  111eef:	4c 89 e7             	mov    %r12,%rdi
  111ef2:	e8 f6 f1 ff ff       	callq  1110ed <z_priq_dumb_best>
  111ef7:	49 89 c4             	mov    %rax,%r12
		if (thread != NULL) {
  111efa:	48 85 c0             	test   %rax,%rax
  111efd:	74 08                	je     111f07 <z_unpend1_no_timeout+0x76>
			unpend_thread_no_timeout(thread);
  111eff:	48 89 c7             	mov    %rax,%rdi
  111f02:	e8 cd f0 ff ff       	callq  110fd4 <unpend_thread_no_timeout>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  111f07:	bf c8 cd 1b 00       	mov    $0x1bcdc8,%edi
  111f0c:	e8 88 b9 ff ff       	callq  10d899 <z_spin_unlock_valid>
  111f11:	84 c0                	test   %al,%al
  111f13:	75 39                	jne    111f4e <z_unpend1_no_timeout+0xbd>
  111f15:	b9 b9 00 00 00       	mov    $0xb9,%ecx
  111f1a:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  111f1f:	be 41 d2 11 00       	mov    $0x11d241,%esi
  111f24:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  111f29:	e8 ca e6 fe ff       	callq  1005f8 <printk>
  111f2e:	be c8 cd 1b 00       	mov    $0x1bcdc8,%esi
  111f33:	bf 58 d2 11 00       	mov    $0x11d258,%edi
  111f38:	31 c0                	xor    %eax,%eax
  111f3a:	e8 b9 e6 fe ff       	callq  1005f8 <printk>
  111f3f:	be b9 00 00 00       	mov    $0xb9,%esi
  111f44:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  111f49:	e8 4a 0c ff ff       	callq  102b98 <assert_post_action>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  111f4e:	0f ba e3 09          	bt     $0x9,%ebx
  111f52:	73 01                	jae    111f55 <z_unpend1_no_timeout+0xc4>
		__asm__ volatile ("sti" ::: "memory");
  111f54:	fb                   	sti    
}
  111f55:	4c 89 e0             	mov    %r12,%rax
  111f58:	5b                   	pop    %rbx
  111f59:	41 5c                	pop    %r12
  111f5b:	5d                   	pop    %rbp
  111f5c:	c3                   	retq   

0000000000111f5d <z_unpend_first_thread>:
{
  111f5d:	55                   	push   %rbp
  111f5e:	48 89 e5             	mov    %rsp,%rbp
  111f61:	41 54                	push   %r12
  111f63:	49 89 fc             	mov    %rdi,%r12
  111f66:	53                   	push   %rbx
  111f67:	9c                   	pushfq 
  111f68:	fa                   	cli    
  111f69:	5b                   	pop    %rbx
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  111f6a:	bf c8 cd 1b 00       	mov    $0x1bcdc8,%edi
  111f6f:	e8 05 b9 ff ff       	callq  10d879 <z_spin_lock_valid>
  111f74:	84 c0                	test   %al,%al
  111f76:	75 39                	jne    111fb1 <z_unpend_first_thread+0x54>
  111f78:	b9 8e 00 00 00       	mov    $0x8e,%ecx
  111f7d:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  111f82:	be fd d1 11 00       	mov    $0x11d1fd,%esi
  111f87:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  111f8c:	e8 67 e6 fe ff       	callq  1005f8 <printk>
  111f91:	be c8 cd 1b 00       	mov    $0x1bcdc8,%esi
  111f96:	bf 12 d2 11 00       	mov    $0x11d212,%edi
  111f9b:	31 c0                	xor    %eax,%eax
  111f9d:	e8 56 e6 fe ff       	callq  1005f8 <printk>
  111fa2:	be 8e 00 00 00       	mov    $0x8e,%esi
  111fa7:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  111fac:	e8 e7 0b ff ff       	callq  102b98 <assert_post_action>
	z_spin_lock_set_owner(l);
  111fb1:	bf c8 cd 1b 00       	mov    $0x1bcdc8,%edi
  111fb6:	e8 02 b9 ff ff       	callq  10d8bd <z_spin_lock_set_owner>
		thread = _priq_wait_best(&wait_q->waitq);
  111fbb:	4c 89 e7             	mov    %r12,%rdi
  111fbe:	e8 2a f1 ff ff       	callq  1110ed <z_priq_dumb_best>
  111fc3:	49 89 c4             	mov    %rax,%r12
		if (thread != NULL) {
  111fc6:	48 85 c0             	test   %rax,%rax
  111fc9:	74 12                	je     111fdd <z_unpend_first_thread+0x80>
			unpend_thread_no_timeout(thread);
  111fcb:	48 89 c7             	mov    %rax,%rdi
  111fce:	e8 01 f0 ff ff       	callq  110fd4 <unpend_thread_no_timeout>
  111fd3:	49 8d 7c 24 28       	lea    0x28(%r12),%rdi
  111fd8:	e8 fd 0f 00 00       	callq  112fda <z_abort_timeout>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  111fdd:	bf c8 cd 1b 00       	mov    $0x1bcdc8,%edi
  111fe2:	e8 b2 b8 ff ff       	callq  10d899 <z_spin_unlock_valid>
  111fe7:	84 c0                	test   %al,%al
  111fe9:	75 39                	jne    112024 <z_unpend_first_thread+0xc7>
  111feb:	b9 b9 00 00 00       	mov    $0xb9,%ecx
  111ff0:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  111ff5:	be 41 d2 11 00       	mov    $0x11d241,%esi
  111ffa:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  111fff:	e8 f4 e5 fe ff       	callq  1005f8 <printk>
  112004:	be c8 cd 1b 00       	mov    $0x1bcdc8,%esi
  112009:	bf 58 d2 11 00       	mov    $0x11d258,%edi
  11200e:	31 c0                	xor    %eax,%eax
  112010:	e8 e3 e5 fe ff       	callq  1005f8 <printk>
  112015:	be b9 00 00 00       	mov    $0xb9,%esi
  11201a:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  11201f:	e8 74 0b ff ff       	callq  102b98 <assert_post_action>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  112024:	0f ba e3 09          	bt     $0x9,%ebx
  112028:	73 01                	jae    11202b <z_unpend_first_thread+0xce>
		__asm__ volatile ("sti" ::: "memory");
  11202a:	fb                   	sti    
}
  11202b:	4c 89 e0             	mov    %r12,%rax
  11202e:	5b                   	pop    %rbx
  11202f:	41 5c                	pop    %r12
  112031:	5d                   	pop    %rbp
  112032:	c3                   	retq   

0000000000112033 <z_unpend_all>:
{
  112033:	55                   	push   %rbp
	int need_sched = 0;
  112034:	31 c0                	xor    %eax,%eax
{
  112036:	48 89 e5             	mov    %rsp,%rbp
  112039:	41 54                	push   %r12
  11203b:	53                   	push   %rbx
  11203c:	48 89 fb             	mov    %rdi,%rbx
	return list->head == list;
  11203f:	4c 8b 23             	mov    (%rbx),%r12
	while ((thread = z_waitq_head(wait_q)) != NULL) {
  112042:	4d 85 e4             	test   %r12,%r12
  112045:	74 1c                	je     112063 <z_unpend_all+0x30>
  112047:	4c 39 e3             	cmp    %r12,%rbx
  11204a:	74 17                	je     112063 <z_unpend_all+0x30>
		z_unpend_thread(thread);
  11204c:	4c 89 e7             	mov    %r12,%rdi
  11204f:	e8 d6 ef ff ff       	callq  11102a <z_unpend_thread>
		z_ready_thread(thread);
  112054:	4c 89 e7             	mov    %r12,%rdi
  112057:	e8 ee f3 ff ff       	callq  11144a <z_ready_thread>
		need_sched = 1;
  11205c:	b8 01 00 00 00       	mov    $0x1,%eax
  112061:	eb dc                	jmp    11203f <z_unpend_all+0xc>
}
  112063:	5b                   	pop    %rbx
  112064:	41 5c                	pop    %r12
  112066:	5d                   	pop    %rbp
  112067:	c3                   	retq   

0000000000112068 <z_sched_init>:
	list->head = (sys_dnode_t *)list;
  112068:	48 c7 05 fd 66 01 00 	movq   $0x128770,0x166fd(%rip)        # 128770 <_kernel+0x30>
  11206f:	70 87 12 00 
	k_sched_time_slice_set(CONFIG_TIMESLICE_SIZE,
  112073:	31 f6                	xor    %esi,%esi
  112075:	31 ff                	xor    %edi,%edi
	list->tail = (sys_dnode_t *)list;
  112077:	48 c7 05 f6 66 01 00 	movq   $0x128770,0x166f6(%rip)        # 128778 <_kernel+0x38>
  11207e:	70 87 12 00 
  112082:	e9 38 eb ff ff       	jmpq   110bbf <k_sched_time_slice_set>

0000000000112087 <z_mrsh_k_thread_priority_get>:
#include <syscalls/kernel.h>

extern int z_vrfy_k_thread_priority_get(k_tid_t thread);
uintptr_t z_mrsh_k_thread_priority_get(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
  112087:	55                   	push   %rbp
  112088:	48 89 e5             	mov    %rsp,%rbp
  11208b:	53                   	push   %rbx
  11208c:	48 89 fb             	mov    %rdi,%rbx
  11208f:	51                   	push   %rcx
	_current->syscall_frame = ssf;
  112090:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  112094:	48 8b 05 b5 66 01 00 	mov    0x166b5(%rip),%rax        # 128750 <_kernel+0x10>
  11209b:	48 89 90 40 01 00 00 	mov    %rdx,0x140(%rax)
	Z_OOPS(Z_SYSCALL_OBJ(thread, K_OBJ_THREAD));
  1120a2:	e8 2d 4a 00 00       	callq  116ad4 <z_object_find>
  1120a7:	48 89 de             	mov    %rbx,%rsi
  1120aa:	48 89 c7             	mov    %rax,%rdi
  1120ad:	e8 e9 e6 ff ff       	callq  11079b <z_obj_validation_check.constprop.0>
  1120b2:	85 c0                	test   %eax,%eax
  1120b4:	74 29                	je     1120df <z_mrsh_k_thread_priority_get+0x58>
  1120b6:	bf 23 f3 11 00       	mov    $0x11f323,%edi
  1120bb:	31 c0                	xor    %eax,%eax
  1120bd:	ba 00 c5 11 00       	mov    $0x11c500,%edx
  1120c2:	be 45 00 00 00       	mov    $0x45,%esi
  1120c7:	e8 fa 0f ff ff       	callq  1030c6 <z_log_minimal_printk>
  1120cc:	48 8b 05 7d 66 01 00 	mov    0x1667d(%rip),%rax        # 128750 <_kernel+0x10>
  1120d3:	48 8b b8 40 01 00 00 	mov    0x140(%rax),%rdi
  1120da:	e8 2e 7b ff ff       	callq  109c0d <arch_syscall_oops>
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	int ret = z_vrfy_k_thread_priority_get(*(k_tid_t*)&arg0)
;
	_current->syscall_frame = NULL;
  1120df:	48 8b 15 6a 66 01 00 	mov    0x1666a(%rip),%rdx        # 128750 <_kernel+0x10>
	return thread->base.prio;
  1120e6:	48 0f be 43 1a       	movsbq 0x1a(%rbx),%rax
  1120eb:	48 c7 82 40 01 00 00 	movq   $0x0,0x140(%rdx)
  1120f2:	00 00 00 00 
	return (uintptr_t) ret;
}
  1120f6:	5a                   	pop    %rdx
  1120f7:	5b                   	pop    %rbx
  1120f8:	5d                   	pop    %rbp
  1120f9:	c3                   	retq   

00000000001120fa <z_impl_k_thread_priority_set>:
{
  1120fa:	55                   	push   %rbp
	Z_ASSERT_VALID_PRIO(prio, NULL);
  1120fb:	8d 46 10             	lea    0x10(%rsi),%eax
{
  1120fe:	48 89 e5             	mov    %rsp,%rbp
  112101:	41 55                	push   %r13
  112103:	49 89 fd             	mov    %rdi,%r13
  112106:	41 54                	push   %r12
  112108:	41 89 f4             	mov    %esi,%r12d
	Z_ASSERT_VALID_PRIO(prio, NULL);
  11210b:	83 f8 1e             	cmp    $0x1e,%eax
  11210e:	76 43                	jbe    112153 <z_impl_k_thread_priority_set+0x59>
  112110:	b9 6a 04 00 00       	mov    $0x46a,%ecx
  112115:	ba 4c fd 11 00       	mov    $0x11fd4c,%edx
  11211a:	be fe fd 11 00       	mov    $0x11fdfe,%esi
  11211f:	31 c0                	xor    %eax,%eax
  112121:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  112126:	e8 cd e4 fe ff       	callq  1005f8 <printk>
  11212b:	44 89 e6             	mov    %r12d,%esi
  11212e:	bf 51 f8 11 00       	mov    $0x11f851,%edi
  112133:	31 c0                	xor    %eax,%eax
  112135:	b9 f0 ff ff ff       	mov    $0xfffffff0,%ecx
  11213a:	ba 0e 00 00 00       	mov    $0xe,%edx
  11213f:	e8 b4 e4 fe ff       	callq  1005f8 <printk>
  112144:	be 6a 04 00 00       	mov    $0x46a,%esi
  112149:	bf 4c fd 11 00       	mov    $0x11fd4c,%edi
  11214e:	e8 45 0a ff ff       	callq  102b98 <assert_post_action>
	__ASSERT(!arch_is_in_isr(), "");
  112153:	83 3d e6 65 01 00 00 	cmpl   $0x0,0x165e6(%rip)        # 128740 <_kernel>
  11215a:	74 36                	je     112192 <z_impl_k_thread_priority_set+0x98>
  11215c:	be 49 f9 11 00       	mov    $0x11f949,%esi
  112161:	b9 6b 04 00 00       	mov    $0x46b,%ecx
  112166:	ba 4c fd 11 00       	mov    $0x11fd4c,%edx
  11216b:	31 c0                	xor    %eax,%eax
  11216d:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  112172:	e8 81 e4 fe ff       	callq  1005f8 <printk>
  112177:	bf 22 fc 11 00       	mov    $0x11fc22,%edi
  11217c:	31 c0                	xor    %eax,%eax
  11217e:	e8 75 e4 fe ff       	callq  1005f8 <printk>
  112183:	be 6b 04 00 00       	mov    $0x46b,%esi
  112188:	bf 4c fd 11 00       	mov    $0x11fd4c,%edi
  11218d:	e8 06 0a ff ff       	callq  102b98 <assert_post_action>
	z_thread_priority_set(th, prio);
  112192:	44 89 e6             	mov    %r12d,%esi
  112195:	4c 89 ef             	mov    %r13,%rdi
}
  112198:	41 5c                	pop    %r12
  11219a:	41 5d                	pop    %r13
  11219c:	5d                   	pop    %rbp
	z_thread_priority_set(th, prio);
  11219d:	e9 12 fa ff ff       	jmpq   111bb4 <z_thread_priority_set>

00000000001121a2 <z_mrsh_k_thread_priority_set>:
#include <syscalls/kernel.h>

extern void z_vrfy_k_thread_priority_set(k_tid_t thread, int prio);
uintptr_t z_mrsh_k_thread_priority_set(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
  1121a2:	55                   	push   %rbp
  1121a3:	48 89 e5             	mov    %rsp,%rbp
  1121a6:	41 54                	push   %r12
  1121a8:	49 89 fc             	mov    %rdi,%r12
  1121ab:	48 83 ec 18          	sub    $0x18,%rsp
	_current->syscall_frame = ssf;
  1121af:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  1121b3:	48 8b 05 96 65 01 00 	mov    0x16596(%rip),%rax        # 128750 <_kernel+0x10>
{
  1121ba:	48 89 75 e8          	mov    %rsi,-0x18(%rbp)
	_current->syscall_frame = ssf;
  1121be:	48 89 90 40 01 00 00 	mov    %rdx,0x140(%rax)
	Z_OOPS(Z_SYSCALL_OBJ(thread, K_OBJ_THREAD));
  1121c5:	e8 0a 49 00 00       	callq  116ad4 <z_object_find>
  1121ca:	4c 89 e6             	mov    %r12,%rsi
  1121cd:	48 89 c7             	mov    %rax,%rdi
  1121d0:	e8 c6 e5 ff ff       	callq  11079b <z_obj_validation_check.constprop.0>
  1121d5:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  1121d9:	85 c0                	test   %eax,%eax
  1121db:	74 18                	je     1121f5 <z_mrsh_k_thread_priority_set+0x53>
  1121dd:	ba e0 c4 11 00       	mov    $0x11c4e0,%edx
  1121e2:	be 45 00 00 00       	mov    $0x45,%esi
  1121e7:	bf 23 f3 11 00       	mov    $0x11f323,%edi
  1121ec:	31 c0                	xor    %eax,%eax
  1121ee:	e8 d3 0e ff ff       	callq  1030c6 <z_log_minimal_printk>
  1121f3:	eb 1e                	jmp    112213 <z_mrsh_k_thread_priority_set+0x71>
	if (!z_is_prio_lower_or_equal(prio,
  1121f5:	8d 41 10             	lea    0x10(%rcx),%eax
	Z_OOPS(Z_SYSCALL_VERIFY_MSG(_is_valid_prio(prio, NULL),
  1121f8:	83 f8 1e             	cmp    $0x1e,%eax
  1121fb:	76 29                	jbe    112226 <z_mrsh_k_thread_priority_set+0x84>
  1121fd:	ba e0 c4 11 00       	mov    $0x11c4e0,%edx
  112202:	be 45 00 00 00       	mov    $0x45,%esi
  112207:	bf 84 fe 11 00       	mov    $0x11fe84,%edi
  11220c:	31 c0                	xor    %eax,%eax
  11220e:	e8 b3 0e ff ff       	callq  1030c6 <z_log_minimal_printk>
  112213:	48 8b 05 36 65 01 00 	mov    0x16536(%rip),%rax        # 128750 <_kernel+0x10>
  11221a:	48 8b b8 40 01 00 00 	mov    0x140(%rax),%rdi
  112221:	e8 e7 79 ff ff       	callq  109c0d <arch_syscall_oops>
	Z_OOPS(Z_SYSCALL_VERIFY_MSG((int8_t)prio >= thread->base.prio,
  112226:	45 0f be 44 24 1a    	movsbl 0x1a(%r12),%r8d
  11222c:	41 38 c8             	cmp    %cl,%r8b
  11222f:	7e 18                	jle    112249 <z_mrsh_k_thread_priority_set+0xa7>
  112231:	ba e0 c4 11 00       	mov    $0x11c4e0,%edx
  112236:	be 45 00 00 00       	mov    $0x45,%esi
  11223b:	bf bd fe 11 00       	mov    $0x11febd,%edi
  112240:	31 c0                	xor    %eax,%eax
  112242:	e8 7f 0e ff ff       	callq  1030c6 <z_log_minimal_printk>
  112247:	eb ca                	jmp    112213 <z_mrsh_k_thread_priority_set+0x71>
	z_impl_k_thread_priority_set(thread, prio);
  112249:	4c 89 e7             	mov    %r12,%rdi
  11224c:	89 ce                	mov    %ecx,%esi
  11224e:	e8 a7 fe ff ff       	callq  1120fa <z_impl_k_thread_priority_set>
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	z_vrfy_k_thread_priority_set(*(k_tid_t*)&arg0, *(int*)&arg1)
;
	_current->syscall_frame = NULL;
  112253:	48 8b 05 f6 64 01 00 	mov    0x164f6(%rip),%rax        # 128750 <_kernel+0x10>
  11225a:	48 c7 80 40 01 00 00 	movq   $0x0,0x140(%rax)
  112261:	00 00 00 00 
	return 0;
}
  112265:	48 83 c4 18          	add    $0x18,%rsp
  112269:	31 c0                	xor    %eax,%eax
  11226b:	41 5c                	pop    %r12
  11226d:	5d                   	pop    %rbp
  11226e:	c3                   	retq   

000000000011226f <z_impl_k_yield>:
{
  11226f:	55                   	push   %rbp
	__ASSERT(!arch_is_in_isr(), "");
  112270:	83 3d c9 64 01 00 00 	cmpl   $0x0,0x164c9(%rip)        # 128740 <_kernel>
{
  112277:	48 89 e5             	mov    %rsp,%rbp
  11227a:	41 54                	push   %r12
  11227c:	53                   	push   %rbx
	__ASSERT(!arch_is_in_isr(), "");
  11227d:	74 36                	je     1122b5 <z_impl_k_yield+0x46>
  11227f:	be 49 f9 11 00       	mov    $0x11f949,%esi
  112284:	b9 a1 04 00 00       	mov    $0x4a1,%ecx
  112289:	ba 4c fd 11 00       	mov    $0x11fd4c,%edx
  11228e:	31 c0                	xor    %eax,%eax
  112290:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  112295:	e8 5e e3 fe ff       	callq  1005f8 <printk>
  11229a:	bf 22 fc 11 00       	mov    $0x11fc22,%edi
  11229f:	31 c0                	xor    %eax,%eax
  1122a1:	e8 52 e3 fe ff       	callq  1005f8 <printk>
  1122a6:	be a1 04 00 00       	mov    $0x4a1,%esi
  1122ab:	bf 4c fd 11 00       	mov    $0x11fd4c,%edi
  1122b0:	e8 e3 08 ff ff       	callq  102b98 <assert_post_action>
  1122b5:	9c                   	pushfq 
  1122b6:	fa                   	cli    
  1122b7:	41 5c                	pop    %r12
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  1122b9:	bf c8 cd 1b 00       	mov    $0x1bcdc8,%edi
  1122be:	e8 b6 b5 ff ff       	callq  10d879 <z_spin_lock_valid>
  1122c3:	84 c0                	test   %al,%al
  1122c5:	75 39                	jne    112300 <z_impl_k_yield+0x91>
  1122c7:	b9 8e 00 00 00       	mov    $0x8e,%ecx
  1122cc:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  1122d1:	be fd d1 11 00       	mov    $0x11d1fd,%esi
  1122d6:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  1122db:	e8 18 e3 fe ff       	callq  1005f8 <printk>
  1122e0:	be c8 cd 1b 00       	mov    $0x1bcdc8,%esi
  1122e5:	bf 12 d2 11 00       	mov    $0x11d212,%edi
  1122ea:	31 c0                	xor    %eax,%eax
  1122ec:	e8 07 e3 fe ff       	callq  1005f8 <printk>
  1122f1:	be 8e 00 00 00       	mov    $0x8e,%esi
  1122f6:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  1122fb:	e8 98 08 ff ff       	callq  102b98 <assert_post_action>
	z_spin_lock_set_owner(l);
  112300:	bf c8 cd 1b 00       	mov    $0x1bcdc8,%edi
  112305:	e8 b3 b5 ff ff       	callq  10d8bd <z_spin_lock_set_owner>
		dequeue_thread(&_kernel.ready_q.runq,
  11230a:	48 8b 35 3f 64 01 00 	mov    0x1643f(%rip),%rsi        # 128750 <_kernel+0x10>
		_priq_run_remove(pq, thread);
  112311:	bf 70 87 12 00       	mov    $0x128770,%edi
	thread->base.thread_state &= ~_THREAD_QUEUED;
  112316:	80 66 19 7f          	andb   $0x7f,0x19(%rsi)
		_priq_run_remove(pq, thread);
  11231a:	e8 58 ec ff ff       	callq  110f77 <z_priq_dumb_remove>
	queue_thread(&_kernel.ready_q.runq, _current);
  11231f:	48 8b 1d 2a 64 01 00 	mov    0x1642a(%rip),%rbx        # 128750 <_kernel+0x10>
	thread->base.thread_state |= _THREAD_QUEUED;
  112326:	80 4b 19 80          	orb    $0x80,0x19(%rbx)
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
  11232a:	48 81 fb 80 7f 12 00 	cmp    $0x127f80,%rbx
  112331:	75 2a                	jne    11235d <z_impl_k_yield+0xee>
  112333:	be 6e fd 11 00       	mov    $0x11fd6e,%esi
  112338:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  11233d:	b9 b1 00 00 00       	mov    $0xb1,%ecx
  112342:	31 c0                	xor    %eax,%eax
  112344:	ba 4c fd 11 00       	mov    $0x11fd4c,%edx
  112349:	e8 aa e2 fe ff       	callq  1005f8 <printk>
  11234e:	be b1 00 00 00       	mov    $0xb1,%esi
  112353:	bf 4c fd 11 00       	mov    $0x11fd4c,%edi
  112358:	e8 3b 08 ff ff       	callq  102b98 <assert_post_action>
	return list->head == list;
  11235d:	48 8b 05 0c 64 01 00 	mov    0x1640c(%rip),%rax        # 128770 <_kernel+0x30>
	sys_dnode_t *const tail = list->tail;
  112364:	48 8b 0d 0d 64 01 00 	mov    0x1640d(%rip),%rcx        # 128778 <_kernel+0x38>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
  11236b:	48 85 c0             	test   %rax,%rax
  11236e:	74 3b                	je     1123ab <z_impl_k_yield+0x13c>
  112370:	48 3d 70 87 12 00    	cmp    $0x128770,%rax
  112376:	74 33                	je     1123ab <z_impl_k_yield+0x13c>
	int32_t b1 = thread_1->base.prio;
  112378:	0f be 73 1a          	movsbl 0x1a(%rbx),%esi
	int32_t b2 = thread_2->base.prio;
  11237c:	0f be 50 1a          	movsbl 0x1a(%rax),%edx
	if (b1 != b2) {
  112380:	39 d6                	cmp    %edx,%esi
  112382:	74 1a                	je     11239e <z_impl_k_yield+0x12f>
		return b2 - b1;
  112384:	29 f2                	sub    %esi,%edx
		if (z_sched_prio_cmp(thread, t) > 0) {
  112386:	85 d2                	test   %edx,%edx
  112388:	7e 14                	jle    11239e <z_impl_k_yield+0x12f>
	sys_dnode_t *const prev = successor->prev;
  11238a:	48 8b 50 08          	mov    0x8(%rax),%rdx
	node->next = successor;
  11238e:	48 89 03             	mov    %rax,(%rbx)
	node->prev = prev;
  112391:	48 89 53 08          	mov    %rdx,0x8(%rbx)
	prev->next = node;
  112395:	48 89 1a             	mov    %rbx,(%rdx)
	successor->prev = node;
  112398:	48 89 58 08          	mov    %rbx,0x8(%rax)
}
  11239c:	eb 22                	jmp    1123c0 <z_impl_k_yield+0x151>
	return (node == list->tail) ? NULL : node->next;
  11239e:	48 39 c8             	cmp    %rcx,%rax
  1123a1:	74 08                	je     1123ab <z_impl_k_yield+0x13c>
  1123a3:	48 8b 00             	mov    (%rax),%rax
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
  1123a6:	48 85 c0             	test   %rax,%rax
  1123a9:	75 d1                	jne    11237c <z_impl_k_yield+0x10d>
	node->next = list;
  1123ab:	48 c7 03 70 87 12 00 	movq   $0x128770,(%rbx)
	node->prev = tail;
  1123b2:	48 89 4b 08          	mov    %rcx,0x8(%rbx)
	tail->next = node;
  1123b6:	48 89 19             	mov    %rbx,(%rcx)
	list->tail = node;
  1123b9:	48 89 1d b8 63 01 00 	mov    %rbx,0x163b8(%rip)        # 128778 <_kernel+0x38>
	update_cache(1);
  1123c0:	bf 01 00 00 00       	mov    $0x1,%edi
  1123c5:	e8 33 ed ff ff       	callq  1110fd <update_cache>
}
  1123ca:	5b                   	pop    %rbx
	z_swap(&sched_spinlock, key);
  1123cb:	44 89 e6             	mov    %r12d,%esi
  1123ce:	bf c8 cd 1b 00       	mov    $0x1bcdc8,%edi
}
  1123d3:	41 5c                	pop    %r12
  1123d5:	5d                   	pop    %rbp
	z_swap(&sched_spinlock, key);
  1123d6:	e9 e4 e5 ff ff       	jmpq   1109bf <z_swap>

00000000001123db <z_tick_sleep>:
{
  1123db:	55                   	push   %rbp
  1123dc:	48 89 e5             	mov    %rsp,%rbp
  1123df:	41 55                	push   %r13
  1123e1:	41 54                	push   %r12
  1123e3:	49 89 fc             	mov    %rdi,%r12
  1123e6:	53                   	push   %rbx
  1123e7:	51                   	push   %rcx
	__ASSERT(!arch_is_in_isr(), "");
  1123e8:	83 3d 51 63 01 00 00 	cmpl   $0x0,0x16351(%rip)        # 128740 <_kernel>
  1123ef:	74 36                	je     112427 <z_tick_sleep+0x4c>
  1123f1:	be 49 f9 11 00       	mov    $0x11f949,%esi
  1123f6:	b9 be 04 00 00       	mov    $0x4be,%ecx
  1123fb:	ba 4c fd 11 00       	mov    $0x11fd4c,%edx
  112400:	31 c0                	xor    %eax,%eax
  112402:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  112407:	e8 ec e1 fe ff       	callq  1005f8 <printk>
  11240c:	bf 22 fc 11 00       	mov    $0x11fc22,%edi
  112411:	31 c0                	xor    %eax,%eax
  112413:	e8 e0 e1 fe ff       	callq  1005f8 <printk>
  112418:	be be 04 00 00       	mov    $0x4be,%esi
  11241d:	bf 4c fd 11 00       	mov    $0x11fd4c,%edi
  112422:	e8 71 07 ff ff       	callq  102b98 <assert_post_action>
	if (ticks == 0) {
  112427:	4d 85 e4             	test   %r12,%r12
  11242a:	75 0c                	jne    112438 <z_tick_sleep+0x5d>
	z_impl_k_yield();
  11242c:	e8 3e fe ff ff       	callq  11226f <z_impl_k_yield>
		return 0;
  112431:	31 c0                	xor    %eax,%eax
  112433:	e9 10 01 00 00       	jmpq   112548 <z_tick_sleep+0x16d>
	if (Z_TICK_ABS(ticks) <= 0) {
  112438:	48 c7 c0 fe ff ff ff 	mov    $0xfffffffffffffffe,%rax
  11243f:	4c 29 e0             	sub    %r12,%rax
  112442:	48 85 c0             	test   %rax,%rax
  112445:	7f 0b                	jg     112452 <z_tick_sleep+0x77>
		expected_wakeup_ticks = ticks + sys_clock_tick_get_32();
  112447:	e8 80 11 00 00       	callq  1135cc <sys_clock_tick_get_32>
  11244c:	42 8d 1c 20          	lea    (%rax,%r12,1),%ebx
  112450:	eb 08                	jmp    11245a <z_tick_sleep+0x7f>
		expected_wakeup_ticks = Z_TICK_ABS(ticks);
  112452:	bb fe ff ff ff       	mov    $0xfffffffe,%ebx
  112457:	44 29 e3             	sub    %r12d,%ebx
  11245a:	9c                   	pushfq 
  11245b:	fa                   	cli    
  11245c:	41 5d                	pop    %r13
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  11245e:	bf c8 cd 1b 00       	mov    $0x1bcdc8,%edi
  112463:	e8 11 b4 ff ff       	callq  10d879 <z_spin_lock_valid>
  112468:	84 c0                	test   %al,%al
  11246a:	75 39                	jne    1124a5 <z_tick_sleep+0xca>
  11246c:	b9 8e 00 00 00       	mov    $0x8e,%ecx
  112471:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  112476:	be fd d1 11 00       	mov    $0x11d1fd,%esi
  11247b:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  112480:	e8 73 e1 fe ff       	callq  1005f8 <printk>
  112485:	be c8 cd 1b 00       	mov    $0x1bcdc8,%esi
  11248a:	bf 12 d2 11 00       	mov    $0x11d212,%edi
  11248f:	31 c0                	xor    %eax,%eax
  112491:	e8 62 e1 fe ff       	callq  1005f8 <printk>
  112496:	be 8e 00 00 00       	mov    $0x8e,%esi
  11249b:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  1124a0:	e8 f3 06 ff ff       	callq  102b98 <assert_post_action>
	z_spin_lock_set_owner(l);
  1124a5:	bf c8 cd 1b 00       	mov    $0x1bcdc8,%edi
  1124aa:	e8 0e b4 ff ff       	callq  10d8bd <z_spin_lock_set_owner>
	unready_thread(_current);
  1124af:	48 8b 3d 9a 62 01 00 	mov    0x1629a(%rip),%rdi        # 128750 <_kernel+0x10>
  1124b6:	e8 58 f3 ff ff       	callq  111813 <unready_thread>
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
  1124bb:	48 8b 05 8e 62 01 00 	mov    0x1628e(%rip),%rax        # 128750 <_kernel+0x10>
  1124c2:	4c 89 e2             	mov    %r12,%rdx
  1124c5:	be 35 17 11 00       	mov    $0x111735,%esi
  1124ca:	48 8d 78 28          	lea    0x28(%rax),%rdi
  1124ce:	e8 32 09 00 00       	callq  112e05 <z_add_timeout>
	z_mark_thread_as_suspended(_current);
  1124d3:	48 8b 05 76 62 01 00 	mov    0x16276(%rip),%rax        # 128750 <_kernel+0x10>
	(void)z_swap(&sched_spinlock, key);
  1124da:	44 89 ee             	mov    %r13d,%esi
  1124dd:	bf c8 cd 1b 00       	mov    $0x1bcdc8,%edi
	thread->base.thread_state |= _THREAD_SUSPENDED;
  1124e2:	80 48 19 10          	orb    $0x10,0x19(%rax)
  1124e6:	e8 d4 e4 ff ff       	callq  1109bf <z_swap>
	__ASSERT(!z_is_thread_state_set(_current, _THREAD_SUSPENDED), "");
  1124eb:	48 8b 05 5e 62 01 00 	mov    0x1625e(%rip),%rax        # 128750 <_kernel+0x10>
  1124f2:	f6 40 19 10          	testb  $0x10,0x19(%rax)
  1124f6:	74 36                	je     11252e <z_tick_sleep+0x153>
  1124f8:	be 0c ff 11 00       	mov    $0x11ff0c,%esi
  1124fd:	b9 df 04 00 00       	mov    $0x4df,%ecx
  112502:	ba 4c fd 11 00       	mov    $0x11fd4c,%edx
  112507:	31 c0                	xor    %eax,%eax
  112509:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  11250e:	e8 e5 e0 fe ff       	callq  1005f8 <printk>
  112513:	bf 22 fc 11 00       	mov    $0x11fc22,%edi
  112518:	31 c0                	xor    %eax,%eax
  11251a:	e8 d9 e0 fe ff       	callq  1005f8 <printk>
  11251f:	be df 04 00 00       	mov    $0x4df,%esi
  112524:	bf 4c fd 11 00       	mov    $0x11fd4c,%edi
  112529:	e8 6a 06 ff ff       	callq  102b98 <assert_post_action>
	ticks = (k_ticks_t)expected_wakeup_ticks - sys_clock_tick_get_32();
  11252e:	e8 99 10 00 00       	callq  1135cc <sys_clock_tick_get_32>
  112533:	89 c2                	mov    %eax,%edx
  112535:	89 d8                	mov    %ebx,%eax
  112537:	48 29 d0             	sub    %rdx,%rax
  11253a:	48 89 c3             	mov    %rax,%rbx
		return ticks;
  11253d:	48 85 c0             	test   %rax,%rax
  112540:	b8 00 00 00 00       	mov    $0x0,%eax
  112545:	0f 4f c3             	cmovg  %ebx,%eax
}
  112548:	5a                   	pop    %rdx
  112549:	5b                   	pop    %rbx
  11254a:	41 5c                	pop    %r12
  11254c:	41 5d                	pop    %r13
  11254e:	5d                   	pop    %rbp
  11254f:	c3                   	retq   

0000000000112550 <z_mrsh_k_yield>:
#include <syscalls/kernel.h>

extern void z_vrfy_k_yield();
uintptr_t z_mrsh_k_yield(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
  112550:	55                   	push   %rbp
	_current->syscall_frame = ssf;
  112551:	48 8b 05 f8 61 01 00 	mov    0x161f8(%rip),%rax        # 128750 <_kernel+0x10>
{
  112558:	48 89 e5             	mov    %rsp,%rbp
	_current->syscall_frame = ssf;
  11255b:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  11255f:	48 89 90 40 01 00 00 	mov    %rdx,0x140(%rax)
	z_impl_k_yield();
  112566:	e8 04 fd ff ff       	callq  11226f <z_impl_k_yield>
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	z_vrfy_k_yield()
;
	_current->syscall_frame = NULL;
  11256b:	48 8b 05 de 61 01 00 	mov    0x161de(%rip),%rax        # 128750 <_kernel+0x10>
  112572:	48 c7 80 40 01 00 00 	movq   $0x0,0x140(%rax)
  112579:	00 00 00 00 
	return 0;
}
  11257d:	31 c0                	xor    %eax,%eax
  11257f:	5d                   	pop    %rbp
  112580:	c3                   	retq   

0000000000112581 <z_impl_k_sleep>:
{
  112581:	55                   	push   %rbp
  112582:	48 89 e5             	mov    %rsp,%rbp
  112585:	41 54                	push   %r12
  112587:	49 89 fc             	mov    %rdi,%r12
  11258a:	51                   	push   %rcx
	__ASSERT(!arch_is_in_isr(), "");
  11258b:	83 3d ae 61 01 00 00 	cmpl   $0x0,0x161ae(%rip)        # 128740 <_kernel>
  112592:	74 36                	je     1125ca <z_impl_k_sleep+0x49>
  112594:	be 49 f9 11 00       	mov    $0x11f949,%esi
  112599:	b9 ee 04 00 00       	mov    $0x4ee,%ecx
  11259e:	ba 4c fd 11 00       	mov    $0x11fd4c,%edx
  1125a3:	31 c0                	xor    %eax,%eax
  1125a5:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  1125aa:	e8 49 e0 fe ff       	callq  1005f8 <printk>
  1125af:	bf 22 fc 11 00       	mov    $0x11fc22,%edi
  1125b4:	31 c0                	xor    %eax,%eax
  1125b6:	e8 3d e0 fe ff       	callq  1005f8 <printk>
  1125bb:	be ee 04 00 00       	mov    $0x4ee,%esi
  1125c0:	bf 4c fd 11 00       	mov    $0x11fd4c,%edi
  1125c5:	e8 ce 05 ff ff       	callq  102b98 <assert_post_action>
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
  1125ca:	49 83 fc ff          	cmp    $0xffffffffffffffff,%r12
  1125ce:	75 11                	jne    1125e1 <z_impl_k_sleep+0x60>
		k_thread_suspend(_current);
  1125d0:	48 8b 3d 79 61 01 00 	mov    0x16179(%rip),%rdi        # 128750 <_kernel+0x10>
	z_impl_k_thread_suspend(thread);
  1125d7:	e8 fa f5 ff ff       	callq  111bd6 <z_impl_k_thread_suspend>
  1125dc:	83 c8 ff             	or     $0xffffffff,%eax
  1125df:	eb 14                	jmp    1125f5 <z_impl_k_sleep+0x74>
	ticks = z_tick_sleep(ticks);
  1125e1:	4c 89 e7             	mov    %r12,%rdi
  1125e4:	e8 f2 fd ff ff       	callq  1123db <z_tick_sleep>
			return t / ((uint64_t)from_hz / to_hz);
  1125e9:	b9 0a 00 00 00       	mov    $0xa,%ecx
	int32_t ret = k_ticks_to_ms_floor64(ticks);
  1125ee:	31 d2                	xor    %edx,%edx
  1125f0:	48 98                	cltq   
  1125f2:	48 f7 f1             	div    %rcx
}
  1125f5:	5a                   	pop    %rdx
  1125f6:	41 5c                	pop    %r12
  1125f8:	5d                   	pop    %rbp
  1125f9:	c3                   	retq   

00000000001125fa <z_mrsh_k_sleep>:
#include <syscalls/kernel.h>

extern int32_t z_vrfy_k_sleep(k_timeout_t timeout);
uintptr_t z_mrsh_k_sleep(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
  1125fa:	55                   	push   %rbp
  1125fb:	48 89 e5             	mov    %rsp,%rbp
  1125fe:	48 83 ec 10          	sub    $0x10,%rsp
	_current->syscall_frame = ssf;
  112602:	48 8b 05 47 61 01 00 	mov    0x16147(%rip),%rax        # 128750 <_kernel+0x10>
  112609:	48 8b 55 10          	mov    0x10(%rbp),%rdx
{
  11260d:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	_current->syscall_frame = ssf;
  112611:	48 89 90 40 01 00 00 	mov    %rdx,0x140(%rax)
	return z_impl_k_sleep(timeout);
  112618:	e8 64 ff ff ff       	callq  112581 <z_impl_k_sleep>
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	int32_t ret = z_vrfy_k_sleep(*(k_timeout_t*)&arg0)
;
	_current->syscall_frame = NULL;
  11261d:	48 8b 15 2c 61 01 00 	mov    0x1612c(%rip),%rdx        # 128750 <_kernel+0x10>
	return (uintptr_t) ret;
  112624:	48 98                	cltq   
	_current->syscall_frame = NULL;
  112626:	48 c7 82 40 01 00 00 	movq   $0x0,0x140(%rdx)
  11262d:	00 00 00 00 
}
  112631:	c9                   	leaveq 
  112632:	c3                   	retq   

0000000000112633 <z_impl_k_usleep>:
	ticks = k_us_to_ticks_ceil64(us);
  112633:	48 63 c7             	movslq %edi,%rax
  112636:	b9 64 00 00 00       	mov    $0x64,%ecx
  11263b:	31 d2                	xor    %edx,%edx
{
  11263d:	55                   	push   %rbp
		t += off;
  11263e:	48 83 c0 63          	add    $0x63,%rax
			return t / ((uint64_t)from_hz / to_hz);
  112642:	48 f7 f1             	div    %rcx
  112645:	48 89 e5             	mov    %rsp,%rbp
	ticks = z_tick_sleep(ticks);
  112648:	48 63 f8             	movslq %eax,%rdi
  11264b:	e8 8b fd ff ff       	callq  1123db <z_tick_sleep>
}
  112650:	5d                   	pop    %rbp
	return k_ticks_to_us_floor64(ticks);
  112651:	48 98                	cltq   
			return t * ((uint64_t)to_hz / from_hz);
  112653:	48 6b c0 64          	imul   $0x64,%rax,%rax
}
  112657:	c3                   	retq   

0000000000112658 <z_mrsh_k_usleep>:
#include <syscalls/kernel.h>

extern int32_t z_vrfy_k_usleep(int32_t us);
uintptr_t z_mrsh_k_usleep(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
  112658:	55                   	push   %rbp
	_current->syscall_frame = ssf;
  112659:	48 8b 05 f0 60 01 00 	mov    0x160f0(%rip),%rax        # 128750 <_kernel+0x10>
{
  112660:	48 89 e5             	mov    %rsp,%rbp
	_current->syscall_frame = ssf;
  112663:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  112667:	48 89 90 40 01 00 00 	mov    %rdx,0x140(%rax)
	return z_impl_k_usleep(us);
  11266e:	e8 c0 ff ff ff       	callq  112633 <z_impl_k_usleep>
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	int32_t ret = z_vrfy_k_usleep(*(int32_t*)&arg0)
;
	_current->syscall_frame = NULL;
  112673:	48 8b 15 d6 60 01 00 	mov    0x160d6(%rip),%rdx        # 128750 <_kernel+0x10>
	return (uintptr_t) ret;
  11267a:	48 98                	cltq   
	_current->syscall_frame = NULL;
  11267c:	48 c7 82 40 01 00 00 	movq   $0x0,0x140(%rdx)
  112683:	00 00 00 00 
}
  112687:	5d                   	pop    %rbp
  112688:	c3                   	retq   

0000000000112689 <z_impl_k_wakeup>:
	if (z_is_thread_pending(thread)) {
  112689:	f6 47 19 02          	testb  $0x2,0x19(%rdi)
  11268d:	75 44                	jne    1126d3 <z_impl_k_wakeup+0x4a>
{
  11268f:	55                   	push   %rbp
  112690:	48 89 e5             	mov    %rsp,%rbp
  112693:	41 54                	push   %r12
  112695:	49 89 fc             	mov    %rdi,%r12
	return z_abort_timeout(&thread->base.timeout);
  112698:	48 8d 7f 28          	lea    0x28(%rdi),%rdi
  11269c:	51                   	push   %rcx
  11269d:	e8 38 09 00 00       	callq  112fda <z_abort_timeout>
	if (z_abort_thread_timeout(thread) < 0) {
  1126a2:	85 c0                	test   %eax,%eax
  1126a4:	79 08                	jns    1126ae <z_impl_k_wakeup+0x25>
		if (thread->base.thread_state != _THREAD_SUSPENDED) {
  1126a6:	41 80 7c 24 19 10    	cmpb   $0x10,0x19(%r12)
  1126ac:	75 20                	jne    1126ce <z_impl_k_wakeup+0x45>
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
  1126ae:	41 80 64 24 19 ef    	andb   $0xef,0x19(%r12)
	z_ready_thread(thread);
  1126b4:	4c 89 e7             	mov    %r12,%rdi
  1126b7:	e8 8e ed ff ff       	callq  11144a <z_ready_thread>
	if (!arch_is_in_isr()) {
  1126bc:	83 3d 7d 60 01 00 00 	cmpl   $0x0,0x1607d(%rip)        # 128740 <_kernel>
  1126c3:	75 09                	jne    1126ce <z_impl_k_wakeup+0x45>
}
  1126c5:	5a                   	pop    %rdx
  1126c6:	41 5c                	pop    %r12
  1126c8:	5d                   	pop    %rbp
		z_reschedule_unlocked();
  1126c9:	e9 2f e7 ff ff       	jmpq   110dfd <z_reschedule_unlocked>
}
  1126ce:	58                   	pop    %rax
  1126cf:	41 5c                	pop    %r12
  1126d1:	5d                   	pop    %rbp
  1126d2:	c3                   	retq   
  1126d3:	c3                   	retq   

00000000001126d4 <z_mrsh_k_wakeup>:
#include <syscalls/kernel.h>

extern void z_vrfy_k_wakeup(k_tid_t thread);
uintptr_t z_mrsh_k_wakeup(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
  1126d4:	55                   	push   %rbp
  1126d5:	48 89 e5             	mov    %rsp,%rbp
  1126d8:	41 54                	push   %r12
  1126da:	49 89 fc             	mov    %rdi,%r12
  1126dd:	51                   	push   %rcx
	_current->syscall_frame = ssf;
  1126de:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  1126e2:	48 8b 05 67 60 01 00 	mov    0x16067(%rip),%rax        # 128750 <_kernel+0x10>
  1126e9:	48 89 90 40 01 00 00 	mov    %rdx,0x140(%rax)
	Z_OOPS(Z_SYSCALL_OBJ(thread, K_OBJ_THREAD));
  1126f0:	e8 df 43 00 00       	callq  116ad4 <z_object_find>
  1126f5:	4c 89 e6             	mov    %r12,%rsi
  1126f8:	48 89 c7             	mov    %rax,%rdi
  1126fb:	e8 9b e0 ff ff       	callq  11079b <z_obj_validation_check.constprop.0>
  112700:	85 c0                	test   %eax,%eax
  112702:	74 29                	je     11272d <z_mrsh_k_wakeup+0x59>
  112704:	bf 23 f3 11 00       	mov    $0x11f323,%edi
  112709:	31 c0                	xor    %eax,%eax
  11270b:	ba d0 c4 11 00       	mov    $0x11c4d0,%edx
  112710:	be 45 00 00 00       	mov    $0x45,%esi
  112715:	e8 ac 09 ff ff       	callq  1030c6 <z_log_minimal_printk>
  11271a:	48 8b 05 2f 60 01 00 	mov    0x1602f(%rip),%rax        # 128750 <_kernel+0x10>
  112721:	48 8b b8 40 01 00 00 	mov    0x140(%rax),%rdi
  112728:	e8 e0 74 ff ff       	callq  109c0d <arch_syscall_oops>
	z_impl_k_wakeup(thread);
  11272d:	4c 89 e7             	mov    %r12,%rdi
  112730:	e8 54 ff ff ff       	callq  112689 <z_impl_k_wakeup>
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	z_vrfy_k_wakeup(*(k_tid_t*)&arg0)
;
	_current->syscall_frame = NULL;
  112735:	48 8b 05 14 60 01 00 	mov    0x16014(%rip),%rax        # 128750 <_kernel+0x10>
  11273c:	48 c7 80 40 01 00 00 	movq   $0x0,0x140(%rax)
  112743:	00 00 00 00 
	return 0;
}
  112747:	31 c0                	xor    %eax,%eax
  112749:	5a                   	pop    %rdx
  11274a:	41 5c                	pop    %r12
  11274c:	5d                   	pop    %rbp
  11274d:	c3                   	retq   

000000000011274e <z_impl_z_current_get>:
}
  11274e:	48 8b 05 fb 5f 01 00 	mov    0x15ffb(%rip),%rax        # 128750 <_kernel+0x10>
  112755:	c3                   	retq   

0000000000112756 <z_mrsh_z_current_get>:

extern k_tid_t z_vrfy_z_current_get();
uintptr_t z_mrsh_z_current_get(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
	_current->syscall_frame = ssf;
  112756:	48 8b 05 f3 5f 01 00 	mov    0x15ff3(%rip),%rax        # 128750 <_kernel+0x10>
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	k_tid_t ret = z_vrfy_z_current_get()
;
	_current->syscall_frame = NULL;
  11275d:	48 c7 80 40 01 00 00 	movq   $0x0,0x140(%rax)
  112764:	00 00 00 00 
	return (uintptr_t) ret;
}
  112768:	c3                   	retq   

0000000000112769 <z_impl_k_is_preempt_thread>:
	return !arch_is_in_isr() && is_preempt(_current);
  112769:	31 c0                	xor    %eax,%eax
  11276b:	83 3d ce 5f 01 00 00 	cmpl   $0x0,0x15fce(%rip)        # 128740 <_kernel>
  112772:	75 12                	jne    112786 <z_impl_k_is_preempt_thread+0x1d>
	return thread->base.preempt <= _PREEMPT_THRESHOLD;
  112774:	48 8b 05 d5 5f 01 00 	mov    0x15fd5(%rip),%rax        # 128750 <_kernel+0x10>
	return !arch_is_in_isr() && is_preempt(_current);
  11277b:	66 83 78 1a 7f       	cmpw   $0x7f,0x1a(%rax)
  112780:	0f 96 c0             	setbe  %al
  112783:	0f b6 c0             	movzbl %al,%eax
}
  112786:	c3                   	retq   

0000000000112787 <z_mrsh_k_is_preempt_thread>:
#include <syscalls/kernel.h>

extern int z_vrfy_k_is_preempt_thread();
uintptr_t z_mrsh_k_is_preempt_thread(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
  112787:	55                   	push   %rbp
	_current->syscall_frame = ssf;
  112788:	48 8b 15 c1 5f 01 00 	mov    0x15fc1(%rip),%rdx        # 128750 <_kernel+0x10>
{
  11278f:	48 89 e5             	mov    %rsp,%rbp
	_current->syscall_frame = ssf;
  112792:	48 8b 45 10          	mov    0x10(%rbp),%rax
  112796:	48 89 82 40 01 00 00 	mov    %rax,0x140(%rdx)
	return z_impl_k_is_preempt_thread();
  11279d:	e8 c7 ff ff ff       	callq  112769 <z_impl_k_is_preempt_thread>
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	int ret = z_vrfy_k_is_preempt_thread()
;
	_current->syscall_frame = NULL;
  1127a2:	48 c7 82 40 01 00 00 	movq   $0x0,0x140(%rdx)
  1127a9:	00 00 00 00 
	return (uintptr_t) ret;
}
  1127ad:	5d                   	pop    %rbp
	return (uintptr_t) ret;
  1127ae:	48 98                	cltq   
}
  1127b0:	c3                   	retq   

00000000001127b1 <z_thread_abort>:
{
  1127b1:	55                   	push   %rbp
  1127b2:	48 89 e5             	mov    %rsp,%rbp
  1127b5:	41 56                	push   %r14
  1127b7:	41 55                	push   %r13
  1127b9:	41 54                	push   %r12
  1127bb:	53                   	push   %rbx
  1127bc:	48 89 fb             	mov    %rdi,%rbx
  1127bf:	9c                   	pushfq 
  1127c0:	fa                   	cli    
  1127c1:	41 5c                	pop    %r12
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  1127c3:	bf c8 cd 1b 00       	mov    $0x1bcdc8,%edi
  1127c8:	e8 ac b0 ff ff       	callq  10d879 <z_spin_lock_valid>
  1127cd:	84 c0                	test   %al,%al
  1127cf:	75 39                	jne    11280a <z_thread_abort+0x59>
  1127d1:	b9 8e 00 00 00       	mov    $0x8e,%ecx
  1127d6:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  1127db:	be fd d1 11 00       	mov    $0x11d1fd,%esi
  1127e0:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  1127e5:	e8 0e de fe ff       	callq  1005f8 <printk>
  1127ea:	be c8 cd 1b 00       	mov    $0x1bcdc8,%esi
  1127ef:	bf 12 d2 11 00       	mov    $0x11d212,%edi
  1127f4:	31 c0                	xor    %eax,%eax
  1127f6:	e8 fd dd fe ff       	callq  1005f8 <printk>
  1127fb:	be 8e 00 00 00       	mov    $0x8e,%esi
  112800:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  112805:	e8 8e 03 ff ff       	callq  102b98 <assert_post_action>
	z_spin_lock_set_owner(l);
  11280a:	bf c8 cd 1b 00       	mov    $0x1bcdc8,%edi
  11280f:	e8 a9 b0 ff ff       	callq  10d8bd <z_spin_lock_set_owner>
	if ((thread->base.thread_state & _THREAD_DEAD) != 0U) {
  112814:	8a 43 19             	mov    0x19(%rbx),%al
  112817:	a8 08                	test   $0x8,%al
  112819:	0f 85 06 01 00 00    	jne    112925 <z_thread_abort+0x174>
		thread->base.thread_state &= ~_THREAD_ABORTING;
  11281f:	89 c2                	mov    %eax,%edx
  112821:	83 e2 df             	and    $0xffffffdf,%edx
		if (z_is_thread_queued(thread)) {
  112824:	80 ca 08             	or     $0x8,%dl
  112827:	78 05                	js     11282e <z_thread_abort+0x7d>
		thread->base.thread_state &= ~_THREAD_ABORTING;
  112829:	88 53 19             	mov    %dl,0x19(%rbx)
  11282c:	eb 16                	jmp    112844 <z_thread_abort+0x93>
	thread->base.thread_state &= ~_THREAD_QUEUED;
  11282e:	83 e0 5f             	and    $0x5f,%eax
		_priq_run_remove(pq, thread);
  112831:	48 89 de             	mov    %rbx,%rsi
  112834:	bf 70 87 12 00       	mov    $0x128770,%edi
	thread->base.thread_state &= ~_THREAD_QUEUED;
  112839:	83 c8 08             	or     $0x8,%eax
  11283c:	88 43 19             	mov    %al,0x19(%rbx)
		_priq_run_remove(pq, thread);
  11283f:	e8 33 e7 ff ff       	callq  110f77 <z_priq_dumb_remove>
		if (thread->base.pended_on != NULL) {
  112844:	48 83 7b 10 00       	cmpq   $0x0,0x10(%rbx)
  112849:	74 08                	je     112853 <z_thread_abort+0xa2>
			unpend_thread_no_timeout(thread);
  11284b:	48 89 df             	mov    %rbx,%rdi
  11284e:	e8 81 e7 ff ff       	callq  110fd4 <unpend_thread_no_timeout>
  112853:	48 8d 7b 28          	lea    0x28(%rbx),%rdi
}

static inline struct k_thread *z_waitq_head(_wait_q_t *w)
{
	return (struct k_thread *)sys_dlist_peek_head(&w->waitq);
  112857:	4c 8d b3 98 00 00 00 	lea    0x98(%rbx),%r14
  11285e:	e8 77 07 00 00       	callq  112fda <z_abort_timeout>
	return list->head == list;
  112863:	4c 8b ab 98 00 00 00 	mov    0x98(%rbx),%r13
	while ((thread = z_waitq_head(wait_q)) != NULL) {
  11286a:	4d 85 ed             	test   %r13,%r13
  11286d:	74 2b                	je     11289a <z_thread_abort+0xe9>
  11286f:	4d 39 f5             	cmp    %r14,%r13
  112872:	74 26                	je     11289a <z_thread_abort+0xe9>
		unpend_thread_no_timeout(thread);
  112874:	4c 89 ef             	mov    %r13,%rdi
  112877:	e8 58 e7 ff ff       	callq  110fd4 <unpend_thread_no_timeout>
  11287c:	49 8d 7d 28          	lea    0x28(%r13),%rdi
  112880:	e8 55 07 00 00       	callq  112fda <z_abort_timeout>
		ready_thread(thread);
  112885:	4c 89 ef             	mov    %r13,%rdi
  112888:	41 c7 85 48 01 00 00 	movl   $0x0,0x148(%r13)
  11288f:	00 00 00 00 
  112893:	e8 e0 ea ff ff       	callq  111378 <ready_thread>
  112898:	eb c9                	jmp    112863 <z_thread_abort+0xb2>
		update_cache(1);
  11289a:	bf 01 00 00 00       	mov    $0x1,%edi
  11289f:	e8 59 e8 ff ff       	callq  1110fd <update_cache>
		z_thread_monitor_exit(thread);
  1128a4:	48 89 df             	mov    %rbx,%rdi
  1128a7:	e8 3a b1 ff ff       	callq  10d9e6 <z_thread_monitor_exit>
		z_mem_domain_exit_thread(thread);
  1128ac:	48 89 df             	mov    %rbx,%rdi
  1128af:	e8 06 3c 00 00       	callq  1164ba <z_mem_domain_exit_thread>
		z_thread_perms_all_clear(thread);
  1128b4:	48 89 df             	mov    %rbx,%rdi
  1128b7:	e8 48 45 00 00       	callq  116e04 <z_thread_perms_all_clear>
		z_object_uninit(thread->stack_obj);
  1128bc:	48 8b bb 38 01 00 00 	mov    0x138(%rbx),%rdi
  1128c3:	e8 3d 47 00 00       	callq  117005 <z_object_uninit>
		z_object_uninit(thread);
  1128c8:	48 89 df             	mov    %rbx,%rdi
  1128cb:	e8 35 47 00 00       	callq  117005 <z_object_uninit>
	if (thread == _current && !arch_is_in_isr()) {
  1128d0:	48 39 1d 79 5e 01 00 	cmp    %rbx,0x15e79(%rip)        # 128750 <_kernel+0x10>
  1128d7:	75 4c                	jne    112925 <z_thread_abort+0x174>
  1128d9:	83 3d 60 5e 01 00 00 	cmpl   $0x0,0x15e60(%rip)        # 128740 <_kernel>
  1128e0:	75 43                	jne    112925 <z_thread_abort+0x174>
		z_swap(&sched_spinlock, key);
  1128e2:	44 89 e6             	mov    %r12d,%esi
  1128e5:	bf c8 cd 1b 00       	mov    $0x1bcdc8,%edi
  1128ea:	e8 d0 e0 ff ff       	callq  1109bf <z_swap>
		__ASSERT(false, "aborted _current back from dead");
  1128ef:	be cb f4 11 00       	mov    $0x11f4cb,%esi
  1128f4:	b9 09 06 00 00       	mov    $0x609,%ecx
  1128f9:	31 c0                	xor    %eax,%eax
  1128fb:	ba 4c fd 11 00       	mov    $0x11fd4c,%edx
  112900:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  112905:	e8 ee dc fe ff       	callq  1005f8 <printk>
  11290a:	bf 4c ff 11 00       	mov    $0x11ff4c,%edi
  11290f:	31 c0                	xor    %eax,%eax
  112911:	e8 e2 dc fe ff       	callq  1005f8 <printk>
  112916:	be 09 06 00 00       	mov    $0x609,%esi
  11291b:	bf 4c fd 11 00       	mov    $0x11fd4c,%edi
  112920:	e8 73 02 ff ff       	callq  102b98 <assert_post_action>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  112925:	bf c8 cd 1b 00       	mov    $0x1bcdc8,%edi
  11292a:	e8 6a af ff ff       	callq  10d899 <z_spin_unlock_valid>
  11292f:	84 c0                	test   %al,%al
  112931:	75 39                	jne    11296c <z_thread_abort+0x1bb>
  112933:	b9 b9 00 00 00       	mov    $0xb9,%ecx
  112938:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  11293d:	be 41 d2 11 00       	mov    $0x11d241,%esi
  112942:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  112947:	e8 ac dc fe ff       	callq  1005f8 <printk>
  11294c:	be c8 cd 1b 00       	mov    $0x1bcdc8,%esi
  112951:	bf 58 d2 11 00       	mov    $0x11d258,%edi
  112956:	31 c0                	xor    %eax,%eax
  112958:	e8 9b dc fe ff       	callq  1005f8 <printk>
  11295d:	be b9 00 00 00       	mov    $0xb9,%esi
  112962:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  112967:	e8 2c 02 ff ff       	callq  102b98 <assert_post_action>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  11296c:	41 0f ba e4 09       	bt     $0x9,%r12d
  112971:	73 01                	jae    112974 <z_thread_abort+0x1c3>
		__asm__ volatile ("sti" ::: "memory");
  112973:	fb                   	sti    
}
  112974:	5b                   	pop    %rbx
  112975:	41 5c                	pop    %r12
  112977:	41 5d                	pop    %r13
  112979:	41 5e                	pop    %r14
  11297b:	5d                   	pop    %rbp
  11297c:	c3                   	retq   

000000000011297d <z_impl_k_thread_abort>:
	z_thread_abort(thread);
  11297d:	e9 2f fe ff ff       	jmpq   1127b1 <z_thread_abort>

0000000000112982 <z_impl_k_thread_join>:
{
  112982:	55                   	push   %rbp
  112983:	48 89 e5             	mov    %rsp,%rbp
  112986:	41 55                	push   %r13
  112988:	41 54                	push   %r12
  11298a:	49 89 f4             	mov    %rsi,%r12
  11298d:	53                   	push   %rbx
  11298e:	48 89 fb             	mov    %rdi,%rbx
  112991:	41 50                	push   %r8
  112993:	9c                   	pushfq 
  112994:	fa                   	cli    
  112995:	41 5d                	pop    %r13
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  112997:	bf c8 cd 1b 00       	mov    $0x1bcdc8,%edi
  11299c:	e8 d8 ae ff ff       	callq  10d879 <z_spin_lock_valid>
  1129a1:	84 c0                	test   %al,%al
  1129a3:	75 39                	jne    1129de <z_impl_k_thread_join+0x5c>
  1129a5:	b9 8e 00 00 00       	mov    $0x8e,%ecx
  1129aa:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  1129af:	be fd d1 11 00       	mov    $0x11d1fd,%esi
  1129b4:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  1129b9:	e8 3a dc fe ff       	callq  1005f8 <printk>
  1129be:	be c8 cd 1b 00       	mov    $0x1bcdc8,%esi
  1129c3:	bf 12 d2 11 00       	mov    $0x11d212,%edi
  1129c8:	31 c0                	xor    %eax,%eax
  1129ca:	e8 29 dc fe ff       	callq  1005f8 <printk>
  1129cf:	be 8e 00 00 00       	mov    $0x8e,%esi
  1129d4:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  1129d9:	e8 ba 01 ff ff       	callq  102b98 <assert_post_action>
	z_spin_lock_set_owner(l);
  1129de:	bf c8 cd 1b 00       	mov    $0x1bcdc8,%edi
  1129e3:	e8 d5 ae ff ff       	callq  10d8bd <z_spin_lock_set_owner>
	if ((thread->base.thread_state & _THREAD_DEAD) != 0U) {
  1129e8:	f6 43 19 08          	testb  $0x8,0x19(%rbx)
  1129ec:	0f 85 ad 00 00 00    	jne    112a9f <z_impl_k_thread_join+0x11d>
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
  1129f2:	4d 85 e4             	test   %r12,%r12
  1129f5:	0f 84 a9 00 00 00    	je     112aa4 <z_impl_k_thread_join+0x122>
	} else if ((thread == _current) ||
  1129fb:	48 8b 05 4e 5d 01 00 	mov    0x15d4e(%rip),%rax        # 128750 <_kernel+0x10>
  112a02:	48 39 d8             	cmp    %rbx,%rax
  112a05:	0f 84 a1 00 00 00    	je     112aac <z_impl_k_thread_join+0x12a>
		   (thread->base.pended_on == &_current->join_queue)) {
  112a0b:	48 05 98 00 00 00    	add    $0x98,%rax
	} else if ((thread == _current) ||
  112a11:	48 39 43 10          	cmp    %rax,0x10(%rbx)
  112a15:	0f 84 91 00 00 00    	je     112aac <z_impl_k_thread_join+0x12a>
		__ASSERT(!arch_is_in_isr(), "cannot join in ISR");
  112a1b:	83 3d 1e 5d 01 00 00 	cmpl   $0x0,0x15d1e(%rip)        # 128740 <_kernel>
  112a22:	74 36                	je     112a5a <z_impl_k_thread_join+0xd8>
  112a24:	be 49 f9 11 00       	mov    $0x11f949,%esi
  112a29:	b9 28 06 00 00       	mov    $0x628,%ecx
  112a2e:	ba 4c fd 11 00       	mov    $0x11fd4c,%edx
  112a33:	31 c0                	xor    %eax,%eax
  112a35:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  112a3a:	e8 b9 db fe ff       	callq  1005f8 <printk>
  112a3f:	bf 6e ff 11 00       	mov    $0x11ff6e,%edi
  112a44:	31 c0                	xor    %eax,%eax
  112a46:	e8 ad db fe ff       	callq  1005f8 <printk>
  112a4b:	be 28 06 00 00       	mov    $0x628,%esi
  112a50:	bf 4c fd 11 00       	mov    $0x11fd4c,%edi
  112a55:	e8 3e 01 ff ff       	callq  102b98 <assert_post_action>
		add_to_waitq_locked(_current, &thread->join_queue);
  112a5a:	48 8b 3d ef 5c 01 00 	mov    0x15cef(%rip),%rdi        # 128750 <_kernel+0x10>
  112a61:	48 8d b3 98 00 00 00 	lea    0x98(%rbx),%rsi
  112a68:	e8 de ed ff ff       	callq  11184b <add_to_waitq_locked>
	if (!K_TIMEOUT_EQ(timeout, K_FOREVER)) {
  112a6d:	49 83 fc ff          	cmp    $0xffffffffffffffff,%r12
  112a71:	74 18                	je     112a8b <z_impl_k_thread_join+0x109>
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
  112a73:	48 8b 05 d6 5c 01 00 	mov    0x15cd6(%rip),%rax        # 128750 <_kernel+0x10>
  112a7a:	4c 89 e2             	mov    %r12,%rdx
  112a7d:	be 35 17 11 00       	mov    $0x111735,%esi
  112a82:	48 8d 78 28          	lea    0x28(%rax),%rdi
  112a86:	e8 7a 03 00 00       	callq  112e05 <z_add_timeout>
}
  112a8b:	59                   	pop    %rcx
		ret = z_swap(&sched_spinlock, key);
  112a8c:	44 89 ee             	mov    %r13d,%esi
}
  112a8f:	5b                   	pop    %rbx
		ret = z_swap(&sched_spinlock, key);
  112a90:	bf c8 cd 1b 00       	mov    $0x1bcdc8,%edi
}
  112a95:	41 5c                	pop    %r12
  112a97:	41 5d                	pop    %r13
  112a99:	5d                   	pop    %rbp
		ret = z_swap(&sched_spinlock, key);
  112a9a:	e9 20 df ff ff       	jmpq   1109bf <z_swap>
		ret = 0;
  112a9f:	45 31 e4             	xor    %r12d,%r12d
  112aa2:	eb 0e                	jmp    112ab2 <z_impl_k_thread_join+0x130>
		ret = -EBUSY;
  112aa4:	41 bc f0 ff ff ff    	mov    $0xfffffff0,%r12d
  112aaa:	eb 06                	jmp    112ab2 <z_impl_k_thread_join+0x130>
		ret = -EDEADLK;
  112aac:	41 bc d3 ff ff ff    	mov    $0xffffffd3,%r12d
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  112ab2:	bf c8 cd 1b 00       	mov    $0x1bcdc8,%edi
  112ab7:	e8 dd ad ff ff       	callq  10d899 <z_spin_unlock_valid>
  112abc:	84 c0                	test   %al,%al
  112abe:	75 39                	jne    112af9 <z_impl_k_thread_join+0x177>
  112ac0:	b9 b9 00 00 00       	mov    $0xb9,%ecx
  112ac5:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  112aca:	be 41 d2 11 00       	mov    $0x11d241,%esi
  112acf:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  112ad4:	e8 1f db fe ff       	callq  1005f8 <printk>
  112ad9:	be c8 cd 1b 00       	mov    $0x1bcdc8,%esi
  112ade:	bf 58 d2 11 00       	mov    $0x11d258,%edi
  112ae3:	31 c0                	xor    %eax,%eax
  112ae5:	e8 0e db fe ff       	callq  1005f8 <printk>
  112aea:	be b9 00 00 00       	mov    $0xb9,%esi
  112aef:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  112af4:	e8 9f 00 ff ff       	callq  102b98 <assert_post_action>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  112af9:	41 0f ba e5 09       	bt     $0x9,%r13d
  112afe:	73 01                	jae    112b01 <z_impl_k_thread_join+0x17f>
		__asm__ volatile ("sti" ::: "memory");
  112b00:	fb                   	sti    
}
  112b01:	5a                   	pop    %rdx
  112b02:	44 89 e0             	mov    %r12d,%eax
  112b05:	5b                   	pop    %rbx
  112b06:	41 5c                	pop    %r12
  112b08:	41 5d                	pop    %r13
  112b0a:	5d                   	pop    %rbp
  112b0b:	c3                   	retq   

0000000000112b0c <z_mrsh_k_thread_join>:
#include <syscalls/kernel.h>

extern int z_vrfy_k_thread_join(struct k_thread * thread, k_timeout_t timeout);
uintptr_t z_mrsh_k_thread_join(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
  112b0c:	55                   	push   %rbp
  112b0d:	48 89 e5             	mov    %rsp,%rbp
  112b10:	41 55                	push   %r13
  112b12:	49 89 f5             	mov    %rsi,%r13
  112b15:	48 83 ec 18          	sub    $0x18,%rsp
	_current->syscall_frame = ssf;
  112b19:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  112b1d:	48 8b 05 2c 5c 01 00 	mov    0x15c2c(%rip),%rax        # 128750 <_kernel+0x10>
{
  112b24:	48 89 75 e8          	mov    %rsi,-0x18(%rbp)

static inline int z_vrfy_k_thread_join(struct k_thread *thread,
				       k_timeout_t timeout)
{
	if (thread_obj_validate(thread)) {
  112b28:	48 89 7d e0          	mov    %rdi,-0x20(%rbp)
	_current->syscall_frame = ssf;
  112b2c:	48 89 90 40 01 00 00 	mov    %rdx,0x140(%rax)
  112b33:	e8 1c dc ff ff       	callq  110754 <thread_obj_validate>
  112b38:	41 89 c0             	mov    %eax,%r8d
  112b3b:	31 c0                	xor    %eax,%eax
  112b3d:	45 84 c0             	test   %r8b,%r8b
  112b40:	75 0c                	jne    112b4e <z_mrsh_k_thread_join+0x42>
		return 0;
	}

	return z_impl_k_thread_join(thread, timeout);
  112b42:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
  112b46:	4c 89 ee             	mov    %r13,%rsi
  112b49:	e8 34 fe ff ff       	callq  112982 <z_impl_k_thread_join>
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	int ret = z_vrfy_k_thread_join(*(struct k_thread **)&arg0, *(k_timeout_t*)&arg1)
;
	_current->syscall_frame = NULL;
  112b4e:	48 8b 15 fb 5b 01 00 	mov    0x15bfb(%rip),%rdx        # 128750 <_kernel+0x10>
	return (uintptr_t) ret;
  112b55:	48 98                	cltq   
	_current->syscall_frame = NULL;
  112b57:	48 c7 82 40 01 00 00 	movq   $0x0,0x140(%rdx)
  112b5e:	00 00 00 00 
}
  112b62:	48 83 c4 18          	add    $0x18,%rsp
  112b66:	41 5d                	pop    %r13
  112b68:	5d                   	pop    %rbp
  112b69:	c3                   	retq   

0000000000112b6a <z_mrsh_k_thread_abort>:
#include <syscalls/kernel.h>

extern void z_vrfy_k_thread_abort(k_tid_t thread);
uintptr_t z_mrsh_k_thread_abort(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
  112b6a:	55                   	push   %rbp
  112b6b:	48 89 e5             	mov    %rsp,%rbp
  112b6e:	41 54                	push   %r12
  112b70:	49 89 fc             	mov    %rdi,%r12
  112b73:	51                   	push   %rcx
	_current->syscall_frame = ssf;
  112b74:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  112b78:	48 8b 05 d1 5b 01 00 	mov    0x15bd1(%rip),%rax        # 128750 <_kernel+0x10>
  112b7f:	48 89 90 40 01 00 00 	mov    %rdx,0x140(%rax)
}
#include <syscalls/k_thread_join_mrsh.c>

static inline void z_vrfy_k_thread_abort(k_tid_t thread)
{
	if (thread_obj_validate(thread)) {
  112b86:	e8 c9 db ff ff       	callq  110754 <thread_obj_validate>
  112b8b:	84 c0                	test   %al,%al
  112b8d:	75 3a                	jne    112bc9 <z_mrsh_k_thread_abort+0x5f>
		return;
	}

	Z_OOPS(Z_SYSCALL_VERIFY_MSG(!(thread->base.user_options & K_ESSENTIAL),
  112b8f:	41 f6 44 24 18 01    	testb  $0x1,0x18(%r12)
  112b95:	74 2a                	je     112bc1 <z_mrsh_k_thread_abort+0x57>
  112b97:	bf 83 ff 11 00       	mov    $0x11ff83,%edi
  112b9c:	4c 89 e1             	mov    %r12,%rcx
  112b9f:	ba b0 c4 11 00       	mov    $0x11c4b0,%edx
  112ba4:	be 45 00 00 00       	mov    $0x45,%esi
  112ba9:	e8 18 05 ff ff       	callq  1030c6 <z_log_minimal_printk>
  112bae:	48 8b 05 9b 5b 01 00 	mov    0x15b9b(%rip),%rax        # 128750 <_kernel+0x10>
  112bb5:	48 8b b8 40 01 00 00 	mov    0x140(%rax),%rdi
  112bbc:	e8 4c 70 ff ff       	callq  109c0d <arch_syscall_oops>
	z_thread_abort(thread);
  112bc1:	4c 89 e7             	mov    %r12,%rdi
  112bc4:	e8 e8 fb ff ff       	callq  1127b1 <z_thread_abort>
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	z_vrfy_k_thread_abort(*(k_tid_t*)&arg0)
;
	_current->syscall_frame = NULL;
  112bc9:	48 8b 05 80 5b 01 00 	mov    0x15b80(%rip),%rax        # 128750 <_kernel+0x10>
  112bd0:	48 c7 80 40 01 00 00 	movq   $0x0,0x140(%rax)
  112bd7:	00 00 00 00 
	return 0;
}
  112bdb:	31 c0                	xor    %eax,%eax
  112bdd:	5a                   	pop    %rdx
  112bde:	41 5c                	pop    %r12
  112be0:	5d                   	pop    %rbp
  112be1:	c3                   	retq   

0000000000112be2 <z_sched_wake>:

/*
 * future scheduler.h API implementations
 */
bool z_sched_wake(_wait_q_t *wait_q, int swap_retval, void *swap_data)
{
  112be2:	55                   	push   %rbp
  112be3:	48 89 e5             	mov    %rsp,%rbp
  112be6:	41 57                	push   %r15
  112be8:	41 56                	push   %r14
  112bea:	41 55                	push   %r13
  112bec:	41 89 f5             	mov    %esi,%r13d
  112bef:	41 54                	push   %r12
  112bf1:	49 89 fc             	mov    %rdi,%r12
  112bf4:	53                   	push   %rbx
  112bf5:	48 89 d3             	mov    %rdx,%rbx
  112bf8:	51                   	push   %rcx
  112bf9:	9c                   	pushfq 
  112bfa:	fa                   	cli    
  112bfb:	41 5e                	pop    %r14
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  112bfd:	bf c8 cd 1b 00       	mov    $0x1bcdc8,%edi
  112c02:	e8 72 ac ff ff       	callq  10d879 <z_spin_lock_valid>
  112c07:	84 c0                	test   %al,%al
  112c09:	75 39                	jne    112c44 <z_sched_wake+0x62>
  112c0b:	b9 8e 00 00 00       	mov    $0x8e,%ecx
  112c10:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  112c15:	be fd d1 11 00       	mov    $0x11d1fd,%esi
  112c1a:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  112c1f:	e8 d4 d9 fe ff       	callq  1005f8 <printk>
  112c24:	be c8 cd 1b 00       	mov    $0x1bcdc8,%esi
  112c29:	bf 12 d2 11 00       	mov    $0x11d212,%edi
  112c2e:	31 c0                	xor    %eax,%eax
  112c30:	e8 c3 d9 fe ff       	callq  1005f8 <printk>
  112c35:	be 8e 00 00 00       	mov    $0x8e,%esi
  112c3a:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  112c3f:	e8 54 ff fe ff       	callq  102b98 <assert_post_action>
	z_spin_lock_set_owner(l);
  112c44:	bf c8 cd 1b 00       	mov    $0x1bcdc8,%edi
	struct k_thread *thread;
	bool ret = false;
  112c49:	45 31 ff             	xor    %r15d,%r15d
  112c4c:	e8 6c ac ff ff       	callq  10d8bd <z_spin_lock_set_owner>

	LOCKED(&sched_spinlock) {
		thread = _priq_wait_best(&wait_q->waitq);
  112c51:	4c 89 e7             	mov    %r12,%rdi
  112c54:	e8 94 e4 ff ff       	callq  1110ed <z_priq_dumb_best>
  112c59:	49 89 c4             	mov    %rax,%r12

		if (thread != NULL) {
  112c5c:	48 85 c0             	test   %rax,%rax
  112c5f:	74 28                	je     112c89 <z_sched_wake+0xa7>
  112c61:	44 89 a8 48 01 00 00 	mov    %r13d,0x148(%rax)
			z_thread_return_value_set_with_data(thread,
							    swap_retval,
							    swap_data);
			unpend_thread_no_timeout(thread);
  112c68:	48 89 c7             	mov    %rax,%rdi
			(void)z_abort_thread_timeout(thread);
			ready_thread(thread);
			ret = true;
  112c6b:	41 b7 01             	mov    $0x1,%r15b
	thread->base.swap_data = data;
  112c6e:	48 89 58 20          	mov    %rbx,0x20(%rax)
			unpend_thread_no_timeout(thread);
  112c72:	e8 5d e3 ff ff       	callq  110fd4 <unpend_thread_no_timeout>
	return z_abort_timeout(&thread->base.timeout);
  112c77:	49 8d 7c 24 28       	lea    0x28(%r12),%rdi
  112c7c:	e8 59 03 00 00       	callq  112fda <z_abort_timeout>
			ready_thread(thread);
  112c81:	4c 89 e7             	mov    %r12,%rdi
  112c84:	e8 ef e6 ff ff       	callq  111378 <ready_thread>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  112c89:	bf c8 cd 1b 00       	mov    $0x1bcdc8,%edi
  112c8e:	e8 06 ac ff ff       	callq  10d899 <z_spin_unlock_valid>
  112c93:	84 c0                	test   %al,%al
  112c95:	75 39                	jne    112cd0 <z_sched_wake+0xee>
  112c97:	b9 b9 00 00 00       	mov    $0xb9,%ecx
  112c9c:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  112ca1:	be 41 d2 11 00       	mov    $0x11d241,%esi
  112ca6:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  112cab:	e8 48 d9 fe ff       	callq  1005f8 <printk>
  112cb0:	be c8 cd 1b 00       	mov    $0x1bcdc8,%esi
  112cb5:	bf 58 d2 11 00       	mov    $0x11d258,%edi
  112cba:	31 c0                	xor    %eax,%eax
  112cbc:	e8 37 d9 fe ff       	callq  1005f8 <printk>
  112cc1:	be b9 00 00 00       	mov    $0xb9,%esi
  112cc6:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  112ccb:	e8 c8 fe fe ff       	callq  102b98 <assert_post_action>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  112cd0:	41 0f ba e6 09       	bt     $0x9,%r14d
  112cd5:	73 01                	jae    112cd8 <z_sched_wake+0xf6>
		__asm__ volatile ("sti" ::: "memory");
  112cd7:	fb                   	sti    
		}
	}

	return ret;
}
  112cd8:	5a                   	pop    %rdx
  112cd9:	44 89 f8             	mov    %r15d,%eax
  112cdc:	5b                   	pop    %rbx
  112cdd:	41 5c                	pop    %r12
  112cdf:	41 5d                	pop    %r13
  112ce1:	41 5e                	pop    %r14
  112ce3:	41 5f                	pop    %r15
  112ce5:	5d                   	pop    %rbp
  112ce6:	c3                   	retq   

0000000000112ce7 <z_sched_wait>:

int z_sched_wait(struct k_spinlock *lock, k_spinlock_key_t key,
		 _wait_q_t *wait_q, k_timeout_t timeout, void **data)
{
  112ce7:	55                   	push   %rbp
  112ce8:	48 89 e5             	mov    %rsp,%rbp
  112ceb:	53                   	push   %rbx
  112cec:	4c 89 c3             	mov    %r8,%rbx
  112cef:	41 51                	push   %r9
	int ret = z_pend_curr(lock, key, wait_q, timeout);
  112cf1:	e8 f2 ec ff ff       	callq  1119e8 <z_pend_curr>

	if (data != NULL) {
  112cf6:	48 85 db             	test   %rbx,%rbx
  112cf9:	74 0e                	je     112d09 <z_sched_wait+0x22>
		*data = _current->base.swap_data;
  112cfb:	48 8b 15 4e 5a 01 00 	mov    0x15a4e(%rip),%rdx        # 128750 <_kernel+0x10>
  112d02:	48 8b 52 20          	mov    0x20(%rdx),%rdx
  112d06:	48 89 13             	mov    %rdx,(%rbx)
	}
	return ret;
}
  112d09:	5a                   	pop    %rdx
  112d0a:	5b                   	pop    %rbx
  112d0b:	5d                   	pop    %rbp
  112d0c:	c3                   	retq   

0000000000112d0d <elapsed>:
	sys_dlist_remove(&t->node);
}

static int32_t elapsed(void)
{
	return announce_remaining == 0 ? sys_clock_elapsed() : 0U;
  112d0d:	83 3d 2c a1 0a 00 00 	cmpl   $0x0,0xaa12c(%rip)        # 1bce40 <announce_remaining>
  112d14:	75 05                	jne    112d1b <elapsed+0xe>
  112d16:	e9 6c 9e ff ff       	jmpq   10cb87 <sys_clock_elapsed>
}
  112d1b:	31 c0                	xor    %eax,%eax
  112d1d:	c3                   	retq   

0000000000112d1e <next_timeout>:

static int32_t next_timeout(void)
{
  112d1e:	55                   	push   %rbp
  112d1f:	48 89 e5             	mov    %rsp,%rbp
  112d22:	53                   	push   %rbx
  112d23:	51                   	push   %rcx
  112d24:	48 8b 1d 85 e6 4c 00 	mov    0x4ce685(%rip),%rbx        # 5e13b0 <timeout_list>
	return sys_dlist_is_empty(list) ? NULL : list->head;
  112d2b:	48 81 fb b0 13 5e 00 	cmp    $0x5e13b0,%rbx
  112d32:	75 02                	jne    112d36 <next_timeout+0x18>
  112d34:	31 db                	xor    %ebx,%ebx
	struct _timeout *to = first();
	int32_t ticks_elapsed = elapsed();
  112d36:	e8 d2 ff ff ff       	callq  112d0d <elapsed>
  112d3b:	89 c2                	mov    %eax,%edx
	int32_t ret = to == NULL ? MAX_WAIT
  112d3d:	b8 ff ff ff 7f       	mov    $0x7fffffff,%eax
  112d42:	48 85 db             	test   %rbx,%rbx
  112d45:	74 21                	je     112d68 <next_timeout+0x4a>
		: CLAMP(to->dticks - ticks_elapsed, 0, MAX_WAIT);
  112d47:	48 63 c2             	movslq %edx,%rax
  112d4a:	48 8b 53 18          	mov    0x18(%rbx),%rdx
  112d4e:	48 29 c2             	sub    %rax,%rdx
	int32_t ret = to == NULL ? MAX_WAIT
  112d51:	31 c0                	xor    %eax,%eax
  112d53:	48 85 d2             	test   %rdx,%rdx
  112d56:	7e 10                	jle    112d68 <next_timeout+0x4a>
		: CLAMP(to->dticks - ticks_elapsed, 0, MAX_WAIT);
  112d58:	48 81 fa ff ff ff 7f 	cmp    $0x7fffffff,%rdx
	int32_t ret = to == NULL ? MAX_WAIT
  112d5f:	b8 ff ff ff 7f       	mov    $0x7fffffff,%eax
  112d64:	48 0f 4e c2          	cmovle %rdx,%rax

#ifdef CONFIG_TIMESLICING
	if (_current_cpu->slice_ticks && _current_cpu->slice_ticks < ret) {
  112d68:	8b 15 f2 59 01 00    	mov    0x159f2(%rip),%edx        # 128760 <_kernel+0x20>
  112d6e:	85 d2                	test   %edx,%edx
  112d70:	74 05                	je     112d77 <next_timeout+0x59>
  112d72:	39 d0                	cmp    %edx,%eax
  112d74:	0f 4f c2             	cmovg  %edx,%eax
		ret = _current_cpu->slice_ticks;
	}
#endif
	return ret;
}
  112d77:	5a                   	pop    %rdx
  112d78:	5b                   	pop    %rbx
  112d79:	5d                   	pop    %rbp
  112d7a:	c3                   	retq   

0000000000112d7b <remove_timeout>:
	return (node == list->tail) ? NULL : node->next;
  112d7b:	48 8b 07             	mov    (%rdi),%rax
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
  112d7e:	48 85 ff             	test   %rdi,%rdi
  112d81:	74 16                	je     112d99 <remove_timeout+0x1e>
	return (node == list->tail) ? NULL : node->next;
  112d83:	48 3b 3d 2e e6 4c 00 	cmp    0x4ce62e(%rip),%rdi        # 5e13b8 <timeout_list+0x8>
  112d8a:	74 0d                	je     112d99 <remove_timeout+0x1e>
	if (next(t) != NULL) {
  112d8c:	48 85 c0             	test   %rax,%rax
  112d8f:	74 08                	je     112d99 <remove_timeout+0x1e>
		next(t)->dticks += t->dticks;
  112d91:	48 8b 57 18          	mov    0x18(%rdi),%rdx
  112d95:	48 01 50 18          	add    %rdx,0x18(%rax)
	sys_dnode_t *const prev = node->prev;
  112d99:	48 8b 57 08          	mov    0x8(%rdi),%rdx
	prev->next = next;
  112d9d:	48 89 02             	mov    %rax,(%rdx)
	next->prev = prev;
  112da0:	48 89 50 08          	mov    %rdx,0x8(%rax)
	node->next = NULL;
  112da4:	48 c7 07 00 00 00 00 	movq   $0x0,(%rdi)
	node->prev = NULL;
  112dab:	48 c7 47 08 00 00 00 	movq   $0x0,0x8(%rdi)
  112db2:	00 
}
  112db3:	c3                   	retq   

0000000000112db4 <timeout_rem>:
/* must be locked */
static k_ticks_t timeout_rem(const struct _timeout *timeout)
{
	k_ticks_t ticks = 0;

	if (z_is_inactive_timeout(timeout)) {
  112db4:	48 83 3f 00          	cmpq   $0x0,(%rdi)
  112db8:	74 48                	je     112e02 <timeout_rem+0x4e>
{
  112dba:	55                   	push   %rbp
  112dbb:	48 89 e5             	mov    %rsp,%rbp
  112dbe:	53                   	push   %rbx
  112dbf:	31 db                	xor    %ebx,%ebx
  112dc1:	51                   	push   %rcx
	return list->head == list;
  112dc2:	48 8b 05 e7 e5 4c 00 	mov    0x4ce5e7(%rip),%rax        # 5e13b0 <timeout_list>
	return (node == list->tail) ? NULL : node->next;
  112dc9:	48 8b 15 e8 e5 4c 00 	mov    0x4ce5e8(%rip),%rdx        # 5e13b8 <timeout_list+0x8>
	return sys_dlist_is_empty(list) ? NULL : list->head;
  112dd0:	48 3d b0 13 5e 00    	cmp    $0x5e13b0,%rax
  112dd6:	74 18                	je     112df0 <timeout_rem+0x3c>
		return 0;
	}

	for (struct _timeout *t = first(); t != NULL; t = next(t)) {
  112dd8:	48 85 c0             	test   %rax,%rax
  112ddb:	74 13                	je     112df0 <timeout_rem+0x3c>
		ticks += t->dticks;
  112ddd:	48 03 58 18          	add    0x18(%rax),%rbx
		if (timeout == t) {
  112de1:	48 39 f8             	cmp    %rdi,%rax
  112de4:	74 0a                	je     112df0 <timeout_rem+0x3c>
	return (node == list->tail) ? NULL : node->next;
  112de6:	48 39 d0             	cmp    %rdx,%rax
  112de9:	74 05                	je     112df0 <timeout_rem+0x3c>
  112deb:	48 8b 00             	mov    (%rax),%rax
  112dee:	eb e8                	jmp    112dd8 <timeout_rem+0x24>
			break;
		}
	}

	return ticks - elapsed();
  112df0:	e8 18 ff ff ff       	callq  112d0d <elapsed>
  112df5:	48 63 d0             	movslq %eax,%rdx
  112df8:	48 89 d8             	mov    %rbx,%rax
  112dfb:	48 29 d0             	sub    %rdx,%rax
}
  112dfe:	5a                   	pop    %rdx
  112dff:	5b                   	pop    %rbx
  112e00:	5d                   	pop    %rbp
  112e01:	c3                   	retq   
  112e02:	31 c0                	xor    %eax,%eax
  112e04:	c3                   	retq   

0000000000112e05 <z_add_timeout>:
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
  112e05:	48 83 fa ff          	cmp    $0xffffffffffffffff,%rdx
  112e09:	0f 84 ca 01 00 00    	je     112fd9 <z_add_timeout+0x1d4>
{
  112e0f:	55                   	push   %rbp
  112e10:	48 89 e5             	mov    %rsp,%rbp
  112e13:	41 55                	push   %r13
  112e15:	49 89 d5             	mov    %rdx,%r13
  112e18:	41 54                	push   %r12
  112e1a:	49 89 f4             	mov    %rsi,%r12
  112e1d:	53                   	push   %rbx
  112e1e:	48 89 fb             	mov    %rdi,%rbx
  112e21:	51                   	push   %rcx
	__ASSERT(!sys_dnode_is_linked(&to->node), "");
  112e22:	48 83 3f 00          	cmpq   $0x0,(%rdi)
  112e26:	74 36                	je     112e5e <z_add_timeout+0x59>
  112e28:	be e2 ff 11 00       	mov    $0x11ffe2,%esi
  112e2d:	b9 5d 00 00 00       	mov    $0x5d,%ecx
  112e32:	ba be ff 11 00       	mov    $0x11ffbe,%edx
  112e37:	31 c0                	xor    %eax,%eax
  112e39:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  112e3e:	e8 b5 d7 fe ff       	callq  1005f8 <printk>
  112e43:	bf 22 fc 11 00       	mov    $0x11fc22,%edi
  112e48:	31 c0                	xor    %eax,%eax
  112e4a:	e8 a9 d7 fe ff       	callq  1005f8 <printk>
  112e4f:	be 5d 00 00 00       	mov    $0x5d,%esi
  112e54:	bf be ff 11 00       	mov    $0x11ffbe,%edi
  112e59:	e8 3a fd fe ff       	callq  102b98 <assert_post_action>
	to->fn = fn;
  112e5e:	4c 89 63 10          	mov    %r12,0x10(%rbx)
  112e62:	9c                   	pushfq 
  112e63:	fa                   	cli    
  112e64:	41 5c                	pop    %r12
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  112e66:	bf d0 cd 1b 00       	mov    $0x1bcdd0,%edi
  112e6b:	e8 09 aa ff ff       	callq  10d879 <z_spin_lock_valid>
  112e70:	84 c0                	test   %al,%al
  112e72:	75 39                	jne    112ead <z_add_timeout+0xa8>
  112e74:	b9 8e 00 00 00       	mov    $0x8e,%ecx
  112e79:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  112e7e:	be fd d1 11 00       	mov    $0x11d1fd,%esi
  112e83:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  112e88:	e8 6b d7 fe ff       	callq  1005f8 <printk>
  112e8d:	be d0 cd 1b 00       	mov    $0x1bcdd0,%esi
  112e92:	bf 12 d2 11 00       	mov    $0x11d212,%edi
  112e97:	31 c0                	xor    %eax,%eax
  112e99:	e8 5a d7 fe ff       	callq  1005f8 <printk>
  112e9e:	be 8e 00 00 00       	mov    $0x8e,%esi
  112ea3:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  112ea8:	e8 eb fc fe ff       	callq  102b98 <assert_post_action>
	z_spin_lock_set_owner(l);
  112ead:	bf d0 cd 1b 00       	mov    $0x1bcdd0,%edi
  112eb2:	e8 06 aa ff ff       	callq  10d8bd <z_spin_lock_set_owner>
		    Z_TICK_ABS(timeout.ticks) >= 0) {
  112eb7:	48 c7 c0 fe ff ff ff 	mov    $0xfffffffffffffffe,%rax
		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) &&
  112ebe:	4c 39 e8             	cmp    %r13,%rax
  112ec1:	78 18                	js     112edb <z_add_timeout+0xd6>
			k_ticks_t ticks = Z_TICK_ABS(timeout.ticks) - curr_tick;
  112ec3:	48 2b 05 0e 9f 0a 00 	sub    0xa9f0e(%rip),%rax        # 1bcdd8 <curr_tick>
			to->dticks = MAX(1, ticks);
  112eca:	ba 01 00 00 00       	mov    $0x1,%edx
			k_ticks_t ticks = Z_TICK_ABS(timeout.ticks) - curr_tick;
  112ecf:	4c 29 e8             	sub    %r13,%rax
			to->dticks = MAX(1, ticks);
  112ed2:	48 85 c0             	test   %rax,%rax
  112ed5:	48 0f 4e c2          	cmovle %rdx,%rax
  112ed9:	eb 0c                	jmp    112ee7 <z_add_timeout+0xe2>
			to->dticks = timeout.ticks + 1 + elapsed();
  112edb:	e8 2d fe ff ff       	callq  112d0d <elapsed>
  112ee0:	48 98                	cltq   
  112ee2:	49 8d 44 05 01       	lea    0x1(%r13,%rax,1),%rax
  112ee7:	48 89 43 18          	mov    %rax,0x18(%rbx)
	return list->head == list;
  112eeb:	48 8b 05 be e4 4c 00 	mov    0x4ce4be(%rip),%rax        # 5e13b0 <timeout_list>
	sys_dnode_t *const tail = list->tail;
  112ef2:	48 8b 35 bf e4 4c 00 	mov    0x4ce4bf(%rip),%rsi        # 5e13b8 <timeout_list+0x8>
	return sys_dlist_is_empty(list) ? NULL : list->head;
  112ef9:	48 3d b0 13 5e 00    	cmp    $0x5e13b0,%rax
  112eff:	74 3e                	je     112f3f <z_add_timeout+0x13a>
		for (t = first(); t != NULL; t = next(t)) {
  112f01:	48 85 c0             	test   %rax,%rax
  112f04:	74 39                	je     112f3f <z_add_timeout+0x13a>
			if (t->dticks > to->dticks) {
  112f06:	48 8b 48 18          	mov    0x18(%rax),%rcx
  112f0a:	48 8b 53 18          	mov    0x18(%rbx),%rdx
  112f0e:	48 39 d1             	cmp    %rdx,%rcx
  112f11:	7e 1b                	jle    112f2e <z_add_timeout+0x129>
				t->dticks -= to->dticks;
  112f13:	48 29 d1             	sub    %rdx,%rcx
	sys_dnode_t *const prev = successor->prev;
  112f16:	48 8b 50 08          	mov    0x8(%rax),%rdx
  112f1a:	48 89 48 18          	mov    %rcx,0x18(%rax)
	node->prev = prev;
  112f1e:	48 89 53 08          	mov    %rdx,0x8(%rbx)
	node->next = successor;
  112f22:	48 89 03             	mov    %rax,(%rbx)
	prev->next = node;
  112f25:	48 89 1a             	mov    %rbx,(%rdx)
	successor->prev = node;
  112f28:	48 89 58 08          	mov    %rbx,0x8(%rax)
		if (t == NULL) {
  112f2c:	eb 26                	jmp    112f54 <z_add_timeout+0x14f>
			to->dticks -= t->dticks;
  112f2e:	48 29 ca             	sub    %rcx,%rdx
  112f31:	48 89 53 18          	mov    %rdx,0x18(%rbx)
	return (node == list->tail) ? NULL : node->next;
  112f35:	48 39 c6             	cmp    %rax,%rsi
  112f38:	74 05                	je     112f3f <z_add_timeout+0x13a>
  112f3a:	48 8b 00             	mov    (%rax),%rax
  112f3d:	eb c2                	jmp    112f01 <z_add_timeout+0xfc>
	node->next = list;
  112f3f:	48 c7 03 b0 13 5e 00 	movq   $0x5e13b0,(%rbx)
	node->prev = tail;
  112f46:	48 89 73 08          	mov    %rsi,0x8(%rbx)
	tail->next = node;
  112f4a:	48 89 1e             	mov    %rbx,(%rsi)
	list->tail = node;
  112f4d:	48 89 1d 64 e4 4c 00 	mov    %rbx,0x4ce464(%rip)        # 5e13b8 <timeout_list+0x8>
	return list->head == list;
  112f54:	48 8b 05 55 e4 4c 00 	mov    0x4ce455(%rip),%rax        # 5e13b0 <timeout_list>
		if (to == first()) {
  112f5b:	48 39 c3             	cmp    %rax,%rbx
  112f5e:	75 22                	jne    112f82 <z_add_timeout+0x17d>
  112f60:	48 3d b0 13 5e 00    	cmp    $0x5e13b0,%rax
  112f66:	74 1a                	je     112f82 <z_add_timeout+0x17d>
			int32_t next_time = next_timeout();
  112f68:	e8 b1 fd ff ff       	callq  112d1e <next_timeout>
  112f6d:	89 c7                	mov    %eax,%edi
			if (next_time == 0 ||
  112f6f:	85 c0                	test   %eax,%eax
  112f71:	74 08                	je     112f7b <z_add_timeout+0x176>
  112f73:	39 05 e7 57 01 00    	cmp    %eax,0x157e7(%rip)        # 128760 <_kernel+0x20>
  112f79:	74 07                	je     112f82 <z_add_timeout+0x17d>
				sys_clock_set_timeout(next_time, false);
  112f7b:	31 f6                	xor    %esi,%esi
  112f7d:	e8 e9 9a ff ff       	callq  10ca6b <sys_clock_set_timeout>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  112f82:	bf d0 cd 1b 00       	mov    $0x1bcdd0,%edi
  112f87:	e8 0d a9 ff ff       	callq  10d899 <z_spin_unlock_valid>
  112f8c:	84 c0                	test   %al,%al
  112f8e:	75 39                	jne    112fc9 <z_add_timeout+0x1c4>
  112f90:	b9 b9 00 00 00       	mov    $0xb9,%ecx
  112f95:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  112f9a:	be 41 d2 11 00       	mov    $0x11d241,%esi
  112f9f:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  112fa4:	e8 4f d6 fe ff       	callq  1005f8 <printk>
  112fa9:	be d0 cd 1b 00       	mov    $0x1bcdd0,%esi
  112fae:	bf 58 d2 11 00       	mov    $0x11d258,%edi
  112fb3:	31 c0                	xor    %eax,%eax
  112fb5:	e8 3e d6 fe ff       	callq  1005f8 <printk>
  112fba:	be b9 00 00 00       	mov    $0xb9,%esi
  112fbf:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  112fc4:	e8 cf fb fe ff       	callq  102b98 <assert_post_action>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  112fc9:	41 0f ba e4 09       	bt     $0x9,%r12d
  112fce:	73 01                	jae    112fd1 <z_add_timeout+0x1cc>
		__asm__ volatile ("sti" ::: "memory");
  112fd0:	fb                   	sti    
}
  112fd1:	58                   	pop    %rax
  112fd2:	5b                   	pop    %rbx
  112fd3:	41 5c                	pop    %r12
  112fd5:	41 5d                	pop    %r13
  112fd7:	5d                   	pop    %rbp
  112fd8:	c3                   	retq   
  112fd9:	c3                   	retq   

0000000000112fda <z_abort_timeout>:
{
  112fda:	55                   	push   %rbp
  112fdb:	48 89 e5             	mov    %rsp,%rbp
  112fde:	41 55                	push   %r13
  112fe0:	41 54                	push   %r12
  112fe2:	49 89 fc             	mov    %rdi,%r12
  112fe5:	53                   	push   %rbx
  112fe6:	51                   	push   %rcx
  112fe7:	9c                   	pushfq 
  112fe8:	fa                   	cli    
  112fe9:	5b                   	pop    %rbx
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  112fea:	bf d0 cd 1b 00       	mov    $0x1bcdd0,%edi
  112fef:	e8 85 a8 ff ff       	callq  10d879 <z_spin_lock_valid>
  112ff4:	84 c0                	test   %al,%al
  112ff6:	75 39                	jne    113031 <z_abort_timeout+0x57>
  112ff8:	b9 8e 00 00 00       	mov    $0x8e,%ecx
  112ffd:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  113002:	be fd d1 11 00       	mov    $0x11d1fd,%esi
  113007:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  11300c:	e8 e7 d5 fe ff       	callq  1005f8 <printk>
  113011:	be d0 cd 1b 00       	mov    $0x1bcdd0,%esi
  113016:	bf 12 d2 11 00       	mov    $0x11d212,%edi
  11301b:	31 c0                	xor    %eax,%eax
  11301d:	e8 d6 d5 fe ff       	callq  1005f8 <printk>
  113022:	be 8e 00 00 00       	mov    $0x8e,%esi
  113027:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  11302c:	e8 67 fb fe ff       	callq  102b98 <assert_post_action>
	z_spin_lock_set_owner(l);
  113031:	bf d0 cd 1b 00       	mov    $0x1bcdd0,%edi
	int ret = -EINVAL;
  113036:	41 bd ea ff ff ff    	mov    $0xffffffea,%r13d
  11303c:	e8 7c a8 ff ff       	callq  10d8bd <z_spin_lock_set_owner>
		if (sys_dnode_is_linked(&to->node)) {
  113041:	49 83 3c 24 00       	cmpq   $0x0,(%r12)
  113046:	74 0b                	je     113053 <z_abort_timeout+0x79>
			remove_timeout(to);
  113048:	4c 89 e7             	mov    %r12,%rdi
			ret = 0;
  11304b:	45 31 ed             	xor    %r13d,%r13d
			remove_timeout(to);
  11304e:	e8 28 fd ff ff       	callq  112d7b <remove_timeout>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  113053:	bf d0 cd 1b 00       	mov    $0x1bcdd0,%edi
  113058:	e8 3c a8 ff ff       	callq  10d899 <z_spin_unlock_valid>
  11305d:	84 c0                	test   %al,%al
  11305f:	75 39                	jne    11309a <z_abort_timeout+0xc0>
  113061:	b9 b9 00 00 00       	mov    $0xb9,%ecx
  113066:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  11306b:	be 41 d2 11 00       	mov    $0x11d241,%esi
  113070:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  113075:	e8 7e d5 fe ff       	callq  1005f8 <printk>
  11307a:	be d0 cd 1b 00       	mov    $0x1bcdd0,%esi
  11307f:	bf 58 d2 11 00       	mov    $0x11d258,%edi
  113084:	31 c0                	xor    %eax,%eax
  113086:	e8 6d d5 fe ff       	callq  1005f8 <printk>
  11308b:	be b9 00 00 00       	mov    $0xb9,%esi
  113090:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  113095:	e8 fe fa fe ff       	callq  102b98 <assert_post_action>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  11309a:	0f ba e3 09          	bt     $0x9,%ebx
  11309e:	73 01                	jae    1130a1 <z_abort_timeout+0xc7>
		__asm__ volatile ("sti" ::: "memory");
  1130a0:	fb                   	sti    
}
  1130a1:	5a                   	pop    %rdx
  1130a2:	44 89 e8             	mov    %r13d,%eax
  1130a5:	5b                   	pop    %rbx
  1130a6:	41 5c                	pop    %r12
  1130a8:	41 5d                	pop    %r13
  1130aa:	5d                   	pop    %rbp
  1130ab:	c3                   	retq   

00000000001130ac <z_timeout_remaining>:

k_ticks_t z_timeout_remaining(const struct _timeout *timeout)
{
  1130ac:	55                   	push   %rbp
  1130ad:	48 89 e5             	mov    %rsp,%rbp
  1130b0:	41 54                	push   %r12
  1130b2:	49 89 fc             	mov    %rdi,%r12
  1130b5:	53                   	push   %rbx
  1130b6:	9c                   	pushfq 
  1130b7:	fa                   	cli    
  1130b8:	5b                   	pop    %rbx
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  1130b9:	bf d0 cd 1b 00       	mov    $0x1bcdd0,%edi
  1130be:	e8 b6 a7 ff ff       	callq  10d879 <z_spin_lock_valid>
  1130c3:	84 c0                	test   %al,%al
  1130c5:	75 39                	jne    113100 <z_timeout_remaining+0x54>
  1130c7:	b9 8e 00 00 00       	mov    $0x8e,%ecx
  1130cc:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  1130d1:	be fd d1 11 00       	mov    $0x11d1fd,%esi
  1130d6:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  1130db:	e8 18 d5 fe ff       	callq  1005f8 <printk>
  1130e0:	be d0 cd 1b 00       	mov    $0x1bcdd0,%esi
  1130e5:	bf 12 d2 11 00       	mov    $0x11d212,%edi
  1130ea:	31 c0                	xor    %eax,%eax
  1130ec:	e8 07 d5 fe ff       	callq  1005f8 <printk>
  1130f1:	be 8e 00 00 00       	mov    $0x8e,%esi
  1130f6:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  1130fb:	e8 98 fa fe ff       	callq  102b98 <assert_post_action>
	z_spin_lock_set_owner(l);
  113100:	bf d0 cd 1b 00       	mov    $0x1bcdd0,%edi
  113105:	e8 b3 a7 ff ff       	callq  10d8bd <z_spin_lock_set_owner>
	k_ticks_t ticks = 0;

	LOCKED(&timeout_lock) {
		ticks = timeout_rem(timeout);
  11310a:	4c 89 e7             	mov    %r12,%rdi
  11310d:	e8 a2 fc ff ff       	callq  112db4 <timeout_rem>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  113112:	bf d0 cd 1b 00       	mov    $0x1bcdd0,%edi
  113117:	49 89 c4             	mov    %rax,%r12
  11311a:	e8 7a a7 ff ff       	callq  10d899 <z_spin_unlock_valid>
  11311f:	84 c0                	test   %al,%al
  113121:	75 39                	jne    11315c <z_timeout_remaining+0xb0>
  113123:	b9 b9 00 00 00       	mov    $0xb9,%ecx
  113128:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  11312d:	be 41 d2 11 00       	mov    $0x11d241,%esi
  113132:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  113137:	e8 bc d4 fe ff       	callq  1005f8 <printk>
  11313c:	be d0 cd 1b 00       	mov    $0x1bcdd0,%esi
  113141:	bf 58 d2 11 00       	mov    $0x11d258,%edi
  113146:	31 c0                	xor    %eax,%eax
  113148:	e8 ab d4 fe ff       	callq  1005f8 <printk>
  11314d:	be b9 00 00 00       	mov    $0xb9,%esi
  113152:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  113157:	e8 3c fa fe ff       	callq  102b98 <assert_post_action>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  11315c:	0f ba e3 09          	bt     $0x9,%ebx
  113160:	73 01                	jae    113163 <z_timeout_remaining+0xb7>
		__asm__ volatile ("sti" ::: "memory");
  113162:	fb                   	sti    
	}

	return ticks;
}
  113163:	4c 89 e0             	mov    %r12,%rax
  113166:	5b                   	pop    %rbx
  113167:	41 5c                	pop    %r12
  113169:	5d                   	pop    %rbp
  11316a:	c3                   	retq   

000000000011316b <z_timeout_expires>:

k_ticks_t z_timeout_expires(const struct _timeout *timeout)
{
  11316b:	55                   	push   %rbp
  11316c:	48 89 e5             	mov    %rsp,%rbp
  11316f:	41 54                	push   %r12
  113171:	49 89 fc             	mov    %rdi,%r12
  113174:	53                   	push   %rbx
  113175:	9c                   	pushfq 
  113176:	fa                   	cli    
  113177:	5b                   	pop    %rbx
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  113178:	bf d0 cd 1b 00       	mov    $0x1bcdd0,%edi
  11317d:	e8 f7 a6 ff ff       	callq  10d879 <z_spin_lock_valid>
  113182:	84 c0                	test   %al,%al
  113184:	75 39                	jne    1131bf <z_timeout_expires+0x54>
  113186:	b9 8e 00 00 00       	mov    $0x8e,%ecx
  11318b:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  113190:	be fd d1 11 00       	mov    $0x11d1fd,%esi
  113195:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  11319a:	e8 59 d4 fe ff       	callq  1005f8 <printk>
  11319f:	be d0 cd 1b 00       	mov    $0x1bcdd0,%esi
  1131a4:	bf 12 d2 11 00       	mov    $0x11d212,%edi
  1131a9:	31 c0                	xor    %eax,%eax
  1131ab:	e8 48 d4 fe ff       	callq  1005f8 <printk>
  1131b0:	be 8e 00 00 00       	mov    $0x8e,%esi
  1131b5:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  1131ba:	e8 d9 f9 fe ff       	callq  102b98 <assert_post_action>
	z_spin_lock_set_owner(l);
  1131bf:	bf d0 cd 1b 00       	mov    $0x1bcdd0,%edi
  1131c4:	e8 f4 a6 ff ff       	callq  10d8bd <z_spin_lock_set_owner>
	k_ticks_t ticks = 0;

	LOCKED(&timeout_lock) {
		ticks = curr_tick + timeout_rem(timeout);
  1131c9:	4c 89 e7             	mov    %r12,%rdi
  1131cc:	e8 e3 fb ff ff       	callq  112db4 <timeout_rem>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  1131d1:	bf d0 cd 1b 00       	mov    $0x1bcdd0,%edi
  1131d6:	48 03 05 fb 9b 0a 00 	add    0xa9bfb(%rip),%rax        # 1bcdd8 <curr_tick>
  1131dd:	49 89 c4             	mov    %rax,%r12
  1131e0:	e8 b4 a6 ff ff       	callq  10d899 <z_spin_unlock_valid>
  1131e5:	84 c0                	test   %al,%al
  1131e7:	75 39                	jne    113222 <z_timeout_expires+0xb7>
  1131e9:	b9 b9 00 00 00       	mov    $0xb9,%ecx
  1131ee:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  1131f3:	be 41 d2 11 00       	mov    $0x11d241,%esi
  1131f8:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  1131fd:	e8 f6 d3 fe ff       	callq  1005f8 <printk>
  113202:	be d0 cd 1b 00       	mov    $0x1bcdd0,%esi
  113207:	bf 58 d2 11 00       	mov    $0x11d258,%edi
  11320c:	31 c0                	xor    %eax,%eax
  11320e:	e8 e5 d3 fe ff       	callq  1005f8 <printk>
  113213:	be b9 00 00 00       	mov    $0xb9,%esi
  113218:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  11321d:	e8 76 f9 fe ff       	callq  102b98 <assert_post_action>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  113222:	0f ba e3 09          	bt     $0x9,%ebx
  113226:	73 01                	jae    113229 <z_timeout_expires+0xbe>
		__asm__ volatile ("sti" ::: "memory");
  113228:	fb                   	sti    
	}

	return ticks;
}
  113229:	4c 89 e0             	mov    %r12,%rax
  11322c:	5b                   	pop    %rbx
  11322d:	41 5c                	pop    %r12
  11322f:	5d                   	pop    %rbp
  113230:	c3                   	retq   

0000000000113231 <z_set_timeout_expiry>:
	}
	return ret;
}

void z_set_timeout_expiry(int32_t ticks, bool is_idle)
{
  113231:	55                   	push   %rbp
  113232:	48 89 e5             	mov    %rsp,%rbp
  113235:	41 55                	push   %r13
  113237:	41 89 fd             	mov    %edi,%r13d
  11323a:	41 54                	push   %r12
  11323c:	53                   	push   %rbx
  11323d:	89 f3                	mov    %esi,%ebx
  11323f:	52                   	push   %rdx
  113240:	9c                   	pushfq 
  113241:	fa                   	cli    
  113242:	41 5c                	pop    %r12
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  113244:	bf d0 cd 1b 00       	mov    $0x1bcdd0,%edi
  113249:	e8 2b a6 ff ff       	callq  10d879 <z_spin_lock_valid>
  11324e:	84 c0                	test   %al,%al
  113250:	75 39                	jne    11328b <z_set_timeout_expiry+0x5a>
  113252:	b9 8e 00 00 00       	mov    $0x8e,%ecx
  113257:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  11325c:	be fd d1 11 00       	mov    $0x11d1fd,%esi
  113261:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  113266:	e8 8d d3 fe ff       	callq  1005f8 <printk>
  11326b:	be d0 cd 1b 00       	mov    $0x1bcdd0,%esi
  113270:	bf 12 d2 11 00       	mov    $0x11d212,%edi
  113275:	31 c0                	xor    %eax,%eax
  113277:	e8 7c d3 fe ff       	callq  1005f8 <printk>
  11327c:	be 8e 00 00 00       	mov    $0x8e,%esi
  113281:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  113286:	e8 0d f9 fe ff       	callq  102b98 <assert_post_action>
	z_spin_lock_set_owner(l);
  11328b:	bf d0 cd 1b 00       	mov    $0x1bcdd0,%edi
  113290:	e8 28 a6 ff ff       	callq  10d8bd <z_spin_lock_set_owner>
	LOCKED(&timeout_lock) {
		int next_to = next_timeout();
  113295:	e8 84 fa ff ff       	callq  112d1e <next_timeout>
		bool sooner = (next_to == K_TICKS_FOREVER)
  11329a:	83 f8 ff             	cmp    $0xffffffff,%eax
  11329d:	0f 94 c1             	sete   %cl
			      || (ticks <= next_to);
  1132a0:	44 39 e8             	cmp    %r13d,%eax
  1132a3:	0f 9d c2             	setge  %dl
		 * SMP can't use this optimization though: we don't
		 * know when context switches happen until interrupt
		 * exit and so can't get the timeslicing clamp folded
		 * in.
		 */
		if (!imminent && (sooner || IS_ENABLED(CONFIG_SMP))) {
  1132a6:	08 d1                	or     %dl,%cl
  1132a8:	74 16                	je     1132c0 <z_set_timeout_expiry+0x8f>
  1132aa:	83 f8 01             	cmp    $0x1,%eax
  1132ad:	7e 11                	jle    1132c0 <z_set_timeout_expiry+0x8f>
			sys_clock_set_timeout(MIN(ticks, next_to), is_idle);
  1132af:	44 39 e8             	cmp    %r13d,%eax
  1132b2:	44 89 ef             	mov    %r13d,%edi
  1132b5:	0f b6 f3             	movzbl %bl,%esi
  1132b8:	0f 4e f8             	cmovle %eax,%edi
  1132bb:	e8 ab 97 ff ff       	callq  10ca6b <sys_clock_set_timeout>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  1132c0:	bf d0 cd 1b 00       	mov    $0x1bcdd0,%edi
  1132c5:	e8 cf a5 ff ff       	callq  10d899 <z_spin_unlock_valid>
  1132ca:	84 c0                	test   %al,%al
  1132cc:	75 39                	jne    113307 <z_set_timeout_expiry+0xd6>
  1132ce:	b9 b9 00 00 00       	mov    $0xb9,%ecx
  1132d3:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  1132d8:	be 41 d2 11 00       	mov    $0x11d241,%esi
  1132dd:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  1132e2:	e8 11 d3 fe ff       	callq  1005f8 <printk>
  1132e7:	be d0 cd 1b 00       	mov    $0x1bcdd0,%esi
  1132ec:	bf 58 d2 11 00       	mov    $0x11d258,%edi
  1132f1:	31 c0                	xor    %eax,%eax
  1132f3:	e8 00 d3 fe ff       	callq  1005f8 <printk>
  1132f8:	be b9 00 00 00       	mov    $0xb9,%esi
  1132fd:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  113302:	e8 91 f8 fe ff       	callq  102b98 <assert_post_action>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  113307:	41 0f ba e4 09       	bt     $0x9,%r12d
  11330c:	73 01                	jae    11330f <z_set_timeout_expiry+0xde>
		__asm__ volatile ("sti" ::: "memory");
  11330e:	fb                   	sti    
		}
	}
}
  11330f:	58                   	pop    %rax
  113310:	5b                   	pop    %rbx
  113311:	41 5c                	pop    %r12
  113313:	41 5d                	pop    %r13
  113315:	5d                   	pop    %rbp
  113316:	c3                   	retq   

0000000000113317 <sys_clock_announce>:

void sys_clock_announce(int32_t ticks)
{
  113317:	55                   	push   %rbp
  113318:	48 89 e5             	mov    %rsp,%rbp
  11331b:	41 54                	push   %r12
  11331d:	53                   	push   %rbx
  11331e:	89 fb                	mov    %edi,%ebx
#ifdef CONFIG_TIMESLICING
	z_time_slice(ticks);
  113320:	e8 45 df ff ff       	callq  11126a <z_time_slice>
  113325:	9c                   	pushfq 
  113326:	fa                   	cli    
  113327:	41 5c                	pop    %r12
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  113329:	bf d0 cd 1b 00       	mov    $0x1bcdd0,%edi
  11332e:	e8 46 a5 ff ff       	callq  10d879 <z_spin_lock_valid>
  113333:	84 c0                	test   %al,%al
  113335:	75 39                	jne    113370 <sys_clock_announce+0x59>
  113337:	b9 8e 00 00 00       	mov    $0x8e,%ecx
  11333c:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  113341:	be fd d1 11 00       	mov    $0x11d1fd,%esi
  113346:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  11334b:	e8 a8 d2 fe ff       	callq  1005f8 <printk>
  113350:	be d0 cd 1b 00       	mov    $0x1bcdd0,%esi
  113355:	bf 12 d2 11 00       	mov    $0x11d212,%edi
  11335a:	31 c0                	xor    %eax,%eax
  11335c:	e8 97 d2 fe ff       	callq  1005f8 <printk>
  113361:	be 8e 00 00 00       	mov    $0x8e,%esi
  113366:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  11336b:	e8 28 f8 fe ff       	callq  102b98 <assert_post_action>
	z_spin_lock_set_owner(l);
  113370:	bf d0 cd 1b 00       	mov    $0x1bcdd0,%edi
  113375:	e8 43 a5 ff ff       	callq  10d8bd <z_spin_lock_set_owner>
#endif

	k_spinlock_key_t key = k_spin_lock(&timeout_lock);

	announce_remaining = ticks;
  11337a:	89 1d c0 9a 0a 00    	mov    %ebx,0xa9ac0(%rip)        # 1bce40 <announce_remaining>

	while (first() != NULL && first()->dticks <= announce_remaining) {
  113380:	48 63 15 b9 9a 0a 00 	movslq 0xa9ab9(%rip),%rdx        # 1bce40 <announce_remaining>
  113387:	48 8b 1d 22 e0 4c 00 	mov    0x4ce022(%rip),%rbx        # 5e13b0 <timeout_list>
		struct _timeout *t = first();
		int dt = t->dticks;

		curr_tick += dt;
  11338e:	48 8b 35 43 9a 0a 00 	mov    0xa9a43(%rip),%rsi        # 1bcdd8 <curr_tick>
	while (first() != NULL && first()->dticks <= announce_remaining) {
  113395:	48 89 d1             	mov    %rdx,%rcx
  113398:	48 85 db             	test   %rbx,%rbx
  11339b:	0f 84 f5 00 00 00    	je     113496 <sys_clock_announce+0x17f>
  1133a1:	48 81 fb b0 13 5e 00 	cmp    $0x5e13b0,%rbx
  1133a8:	0f 84 e8 00 00 00    	je     113496 <sys_clock_announce+0x17f>
  1133ae:	48 8b 43 18          	mov    0x18(%rbx),%rax
  1133b2:	48 39 d0             	cmp    %rdx,%rax
  1133b5:	0f 8f d4 00 00 00    	jg     11348f <sys_clock_announce+0x178>
		announce_remaining -= dt;
		t->dticks = 0;
  1133bb:	48 c7 43 18 00 00 00 	movq   $0x0,0x18(%rbx)
  1133c2:	00 
		curr_tick += dt;
  1133c3:	48 63 d0             	movslq %eax,%rdx
		announce_remaining -= dt;
  1133c6:	29 c1                	sub    %eax,%ecx
		remove_timeout(t);
  1133c8:	48 89 df             	mov    %rbx,%rdi
		curr_tick += dt;
  1133cb:	48 01 f2             	add    %rsi,%rdx
		announce_remaining -= dt;
  1133ce:	89 0d 6c 9a 0a 00    	mov    %ecx,0xa9a6c(%rip)        # 1bce40 <announce_remaining>
		curr_tick += dt;
  1133d4:	48 89 15 fd 99 0a 00 	mov    %rdx,0xa99fd(%rip)        # 1bcdd8 <curr_tick>
		remove_timeout(t);
  1133db:	e8 9b f9 ff ff       	callq  112d7b <remove_timeout>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  1133e0:	bf d0 cd 1b 00       	mov    $0x1bcdd0,%edi
  1133e5:	e8 af a4 ff ff       	callq  10d899 <z_spin_unlock_valid>
  1133ea:	84 c0                	test   %al,%al
  1133ec:	75 39                	jne    113427 <sys_clock_announce+0x110>
  1133ee:	b9 b9 00 00 00       	mov    $0xb9,%ecx
  1133f3:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  1133f8:	be 41 d2 11 00       	mov    $0x11d241,%esi
  1133fd:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  113402:	e8 f1 d1 fe ff       	callq  1005f8 <printk>
  113407:	be d0 cd 1b 00       	mov    $0x1bcdd0,%esi
  11340c:	bf 58 d2 11 00       	mov    $0x11d258,%edi
  113411:	31 c0                	xor    %eax,%eax
  113413:	e8 e0 d1 fe ff       	callq  1005f8 <printk>
  113418:	be b9 00 00 00       	mov    $0xb9,%esi
  11341d:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  113422:	e8 71 f7 fe ff       	callq  102b98 <assert_post_action>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  113427:	41 0f ba e4 09       	bt     $0x9,%r12d
  11342c:	73 01                	jae    11342f <sys_clock_announce+0x118>
		__asm__ volatile ("sti" ::: "memory");
  11342e:	fb                   	sti    

		k_spin_unlock(&timeout_lock, key);
		t->fn(t);
  11342f:	48 89 df             	mov    %rbx,%rdi
  113432:	ff 53 10             	callq  *0x10(%rbx)
  113435:	9c                   	pushfq 
  113436:	fa                   	cli    
  113437:	41 5c                	pop    %r12
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  113439:	bf d0 cd 1b 00       	mov    $0x1bcdd0,%edi
  11343e:	e8 36 a4 ff ff       	callq  10d879 <z_spin_lock_valid>
  113443:	84 c0                	test   %al,%al
  113445:	75 39                	jne    113480 <sys_clock_announce+0x169>
  113447:	b9 8e 00 00 00       	mov    $0x8e,%ecx
  11344c:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  113451:	be fd d1 11 00       	mov    $0x11d1fd,%esi
  113456:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  11345b:	e8 98 d1 fe ff       	callq  1005f8 <printk>
  113460:	be d0 cd 1b 00       	mov    $0x1bcdd0,%esi
  113465:	bf 12 d2 11 00       	mov    $0x11d212,%edi
  11346a:	31 c0                	xor    %eax,%eax
  11346c:	e8 87 d1 fe ff       	callq  1005f8 <printk>
  113471:	be 8e 00 00 00       	mov    $0x8e,%esi
  113476:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  11347b:	e8 18 f7 fe ff       	callq  102b98 <assert_post_action>
	z_spin_lock_set_owner(l);
  113480:	bf d0 cd 1b 00       	mov    $0x1bcdd0,%edi
  113485:	e8 33 a4 ff ff       	callq  10d8bd <z_spin_lock_set_owner>
	return k;
  11348a:	e9 f1 fe ff ff       	jmpq   113380 <sys_clock_announce+0x69>
		key = k_spin_lock(&timeout_lock);
	}

	if (first() != NULL) {
		first()->dticks -= announce_remaining;
  11348f:	48 29 d0             	sub    %rdx,%rax
  113492:	48 89 43 18          	mov    %rax,0x18(%rbx)
	}

	curr_tick += announce_remaining;
	announce_remaining = 0;
  113496:	c7 05 a0 99 0a 00 00 	movl   $0x0,0xa99a0(%rip)        # 1bce40 <announce_remaining>
  11349d:	00 00 00 
	curr_tick += announce_remaining;
  1134a0:	48 01 f2             	add    %rsi,%rdx
  1134a3:	48 89 15 2e 99 0a 00 	mov    %rdx,0xa992e(%rip)        # 1bcdd8 <curr_tick>

	sys_clock_set_timeout(next_timeout(), false);
  1134aa:	e8 6f f8 ff ff       	callq  112d1e <next_timeout>
  1134af:	31 f6                	xor    %esi,%esi
  1134b1:	89 c7                	mov    %eax,%edi
  1134b3:	e8 b3 95 ff ff       	callq  10ca6b <sys_clock_set_timeout>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  1134b8:	bf d0 cd 1b 00       	mov    $0x1bcdd0,%edi
  1134bd:	e8 d7 a3 ff ff       	callq  10d899 <z_spin_unlock_valid>
  1134c2:	84 c0                	test   %al,%al
  1134c4:	75 39                	jne    1134ff <sys_clock_announce+0x1e8>
  1134c6:	b9 b9 00 00 00       	mov    $0xb9,%ecx
  1134cb:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  1134d0:	be 41 d2 11 00       	mov    $0x11d241,%esi
  1134d5:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  1134da:	e8 19 d1 fe ff       	callq  1005f8 <printk>
  1134df:	be d0 cd 1b 00       	mov    $0x1bcdd0,%esi
  1134e4:	bf 58 d2 11 00       	mov    $0x11d258,%edi
  1134e9:	31 c0                	xor    %eax,%eax
  1134eb:	e8 08 d1 fe ff       	callq  1005f8 <printk>
  1134f0:	be b9 00 00 00       	mov    $0xb9,%esi
  1134f5:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  1134fa:	e8 99 f6 fe ff       	callq  102b98 <assert_post_action>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  1134ff:	41 0f ba e4 09       	bt     $0x9,%r12d
  113504:	73 01                	jae    113507 <sys_clock_announce+0x1f0>
		__asm__ volatile ("sti" ::: "memory");
  113506:	fb                   	sti    

	k_spin_unlock(&timeout_lock, key);
}
  113507:	5b                   	pop    %rbx
  113508:	41 5c                	pop    %r12
  11350a:	5d                   	pop    %rbp
  11350b:	c3                   	retq   

000000000011350c <sys_clock_tick_get>:

int64_t sys_clock_tick_get(void)
{
  11350c:	55                   	push   %rbp
  11350d:	48 89 e5             	mov    %rsp,%rbp
  113510:	41 54                	push   %r12
  113512:	53                   	push   %rbx
  113513:	9c                   	pushfq 
  113514:	fa                   	cli    
  113515:	5b                   	pop    %rbx
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  113516:	bf d0 cd 1b 00       	mov    $0x1bcdd0,%edi
  11351b:	e8 59 a3 ff ff       	callq  10d879 <z_spin_lock_valid>
  113520:	84 c0                	test   %al,%al
  113522:	75 39                	jne    11355d <sys_clock_tick_get+0x51>
  113524:	b9 8e 00 00 00       	mov    $0x8e,%ecx
  113529:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  11352e:	be fd d1 11 00       	mov    $0x11d1fd,%esi
  113533:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  113538:	e8 bb d0 fe ff       	callq  1005f8 <printk>
  11353d:	be d0 cd 1b 00       	mov    $0x1bcdd0,%esi
  113542:	bf 12 d2 11 00       	mov    $0x11d212,%edi
  113547:	31 c0                	xor    %eax,%eax
  113549:	e8 aa d0 fe ff       	callq  1005f8 <printk>
  11354e:	be 8e 00 00 00       	mov    $0x8e,%esi
  113553:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  113558:	e8 3b f6 fe ff       	callq  102b98 <assert_post_action>
	z_spin_lock_set_owner(l);
  11355d:	bf d0 cd 1b 00       	mov    $0x1bcdd0,%edi
  113562:	e8 56 a3 ff ff       	callq  10d8bd <z_spin_lock_set_owner>
	uint64_t t = 0U;

	LOCKED(&timeout_lock) {
		t = curr_tick + sys_clock_elapsed();
  113567:	e8 1b 96 ff ff       	callq  10cb87 <sys_clock_elapsed>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  11356c:	bf d0 cd 1b 00       	mov    $0x1bcdd0,%edi
  113571:	41 89 c4             	mov    %eax,%r12d
  113574:	4c 03 25 5d 98 0a 00 	add    0xa985d(%rip),%r12        # 1bcdd8 <curr_tick>
  11357b:	e8 19 a3 ff ff       	callq  10d899 <z_spin_unlock_valid>
  113580:	84 c0                	test   %al,%al
  113582:	75 39                	jne    1135bd <sys_clock_tick_get+0xb1>
  113584:	b9 b9 00 00 00       	mov    $0xb9,%ecx
  113589:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  11358e:	be 41 d2 11 00       	mov    $0x11d241,%esi
  113593:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  113598:	e8 5b d0 fe ff       	callq  1005f8 <printk>
  11359d:	be d0 cd 1b 00       	mov    $0x1bcdd0,%esi
  1135a2:	bf 58 d2 11 00       	mov    $0x11d258,%edi
  1135a7:	31 c0                	xor    %eax,%eax
  1135a9:	e8 4a d0 fe ff       	callq  1005f8 <printk>
  1135ae:	be b9 00 00 00       	mov    $0xb9,%esi
  1135b3:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  1135b8:	e8 db f5 fe ff       	callq  102b98 <assert_post_action>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  1135bd:	0f ba e3 09          	bt     $0x9,%ebx
  1135c1:	73 01                	jae    1135c4 <sys_clock_tick_get+0xb8>
		__asm__ volatile ("sti" ::: "memory");
  1135c3:	fb                   	sti    
	}
	return t;
}
  1135c4:	4c 89 e0             	mov    %r12,%rax
  1135c7:	5b                   	pop    %rbx
  1135c8:	41 5c                	pop    %r12
  1135ca:	5d                   	pop    %rbp
  1135cb:	c3                   	retq   

00000000001135cc <sys_clock_tick_get_32>:

uint32_t sys_clock_tick_get_32(void)
{
  1135cc:	55                   	push   %rbp
  1135cd:	48 89 e5             	mov    %rsp,%rbp
#ifdef CONFIG_TICKLESS_KERNEL
	return (uint32_t)sys_clock_tick_get();
  1135d0:	e8 37 ff ff ff       	callq  11350c <sys_clock_tick_get>
#else
	return (uint32_t)curr_tick;
#endif
}
  1135d5:	5d                   	pop    %rbp
  1135d6:	c3                   	retq   

00000000001135d7 <z_impl_k_uptime_ticks>:

int64_t z_impl_k_uptime_ticks(void)
{
	return sys_clock_tick_get();
  1135d7:	e9 30 ff ff ff       	jmpq   11350c <sys_clock_tick_get>

00000000001135dc <z_mrsh_k_uptime_ticks>:
#include <syscalls/kernel.h>

extern int64_t z_vrfy_k_uptime_ticks();
uintptr_t z_mrsh_k_uptime_ticks(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
  1135dc:	55                   	push   %rbp
	_current->syscall_frame = ssf;
  1135dd:	48 8b 05 6c 51 01 00 	mov    0x1516c(%rip),%rax        # 128750 <_kernel+0x10>
{
  1135e4:	48 89 e5             	mov    %rsp,%rbp
	_current->syscall_frame = ssf;
  1135e7:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  1135eb:	48 89 90 40 01 00 00 	mov    %rdx,0x140(%rax)
  1135f2:	e8 15 ff ff ff       	callq  11350c <sys_clock_tick_get>
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	int64_t ret = z_vrfy_k_uptime_ticks()
;
	_current->syscall_frame = NULL;
  1135f7:	48 8b 15 52 51 01 00 	mov    0x15152(%rip),%rdx        # 128750 <_kernel+0x10>
  1135fe:	48 c7 82 40 01 00 00 	movq   $0x0,0x140(%rdx)
  113605:	00 00 00 00 
	return (uintptr_t) ret;
}
  113609:	5d                   	pop    %rbp
  11360a:	c3                   	retq   

000000000011360b <z_impl_k_busy_wait>:
#endif

void z_impl_k_busy_wait(uint32_t usec_to_wait)
{
	SYS_PORT_TRACING_FUNC_ENTER(k_thread, busy_wait, usec_to_wait);
	if (usec_to_wait == 0U) {
  11360b:	85 ff                	test   %edi,%edi
  11360d:	74 38                	je     113647 <z_impl_k_busy_wait+0x3c>
{
  11360f:	55                   	push   %rbp
  113610:	48 89 e5             	mov    %rsp,%rbp
  113613:	41 54                	push   %r12
  113615:	53                   	push   %rbx
  113616:	89 fb                	mov    %edi,%ebx
	return sys_clock_cycle_get_32();
  113618:	e8 3b 96 ff ff       	callq  10cc58 <sys_clock_cycle_get_32>
	uint32_t start_cycles = k_cycle_get_32();

	/* use 64-bit math to prevent overflow when multiplying */
	uint32_t cycles_to_wait = (uint32_t)(
		(uint64_t)usec_to_wait *
		(uint64_t)sys_clock_hw_cycles_per_sec() /
  11361d:	b9 40 42 0f 00       	mov    $0xf4240,%ecx
	uint32_t cycles_to_wait = (uint32_t)(
  113622:	31 d2                	xor    %edx,%edx
  113624:	41 89 c4             	mov    %eax,%r12d
		(uint64_t)usec_to_wait *
  113627:	89 d8                	mov    %ebx,%eax
  113629:	48 69 c0 00 b3 3f 71 	imul   $0x713fb300,%rax,%rax
	uint32_t cycles_to_wait = (uint32_t)(
  113630:	48 f7 f1             	div    %rcx
  113633:	48 89 c3             	mov    %rax,%rbx
  113636:	e8 1d 96 ff ff       	callq  10cc58 <sys_clock_cycle_get_32>

	for (;;) {
		uint32_t current_cycles = k_cycle_get_32();

		/* this handles the rollover on an unsigned 32-bit value */
		if ((current_cycles - start_cycles) >= cycles_to_wait) {
  11363b:	44 29 e0             	sub    %r12d,%eax
  11363e:	39 c3                	cmp    %eax,%ebx
  113640:	77 f4                	ja     113636 <z_impl_k_busy_wait+0x2b>
	}
#else
	arch_busy_wait(usec_to_wait);
#endif /* CONFIG_ARCH_HAS_CUSTOM_BUSY_WAIT */
	SYS_PORT_TRACING_FUNC_EXIT(k_thread, busy_wait, usec_to_wait);
}
  113642:	5b                   	pop    %rbx
  113643:	41 5c                	pop    %r12
  113645:	5d                   	pop    %rbp
  113646:	c3                   	retq   
  113647:	c3                   	retq   

0000000000113648 <z_mrsh_k_busy_wait>:
#include <syscalls/kernel.h>

extern void z_vrfy_k_busy_wait(uint32_t usec_to_wait);
uintptr_t z_mrsh_k_busy_wait(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
  113648:	55                   	push   %rbp
	_current->syscall_frame = ssf;
  113649:	48 8b 05 00 51 01 00 	mov    0x15100(%rip),%rax        # 128750 <_kernel+0x10>
{
  113650:	48 89 e5             	mov    %rsp,%rbp
	_current->syscall_frame = ssf;
  113653:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  113657:	48 89 90 40 01 00 00 	mov    %rdx,0x140(%rax)

#ifdef CONFIG_USERSPACE
static inline void z_vrfy_k_busy_wait(uint32_t usec_to_wait)
{
	z_impl_k_busy_wait(usec_to_wait);
  11365e:	e8 a8 ff ff ff       	callq  11360b <z_impl_k_busy_wait>
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	z_vrfy_k_busy_wait(*(uint32_t*)&arg0)
;
	_current->syscall_frame = NULL;
  113663:	48 8b 05 e6 50 01 00 	mov    0x150e6(%rip),%rax        # 128750 <_kernel+0x10>
  11366a:	48 c7 80 40 01 00 00 	movq   $0x0,0x140(%rax)
  113671:	00 00 00 00 
	return 0;
}
  113675:	31 c0                	xor    %eax,%eax
  113677:	5d                   	pop    %rbp
  113678:	c3                   	retq   

0000000000113679 <sys_clock_timeout_end_calc>:
 */
uint64_t sys_clock_timeout_end_calc(k_timeout_t timeout)
{
	k_ticks_t dt;

	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
  113679:	48 83 ff ff          	cmp    $0xffffffffffffffff,%rdi
  11367d:	74 38                	je     1136b7 <sys_clock_timeout_end_calc+0x3e>
{
  11367f:	55                   	push   %rbp
  113680:	48 89 e5             	mov    %rsp,%rbp
  113683:	53                   	push   %rbx
  113684:	48 89 fb             	mov    %rdi,%rbx
  113687:	56                   	push   %rsi
		return UINT64_MAX;
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
  113688:	48 85 ff             	test   %rdi,%rdi
  11368b:	75 08                	jne    113695 <sys_clock_timeout_end_calc+0x1c>
		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) && Z_TICK_ABS(dt) >= 0) {
			return Z_TICK_ABS(dt);
		}
		return sys_clock_tick_get() + MAX(1, dt);
	}
}
  11368d:	59                   	pop    %rcx
  11368e:	5b                   	pop    %rbx
  11368f:	5d                   	pop    %rbp
		return sys_clock_tick_get();
  113690:	e9 77 fe ff ff       	jmpq   11350c <sys_clock_tick_get>
		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) && Z_TICK_ABS(dt) >= 0) {
  113695:	48 c7 c0 fe ff ff ff 	mov    $0xfffffffffffffffe,%rax
  11369c:	48 29 f8             	sub    %rdi,%rax
  11369f:	79 1b                	jns    1136bc <sys_clock_timeout_end_calc+0x43>
		return sys_clock_tick_get() + MAX(1, dt);
  1136a1:	e8 66 fe ff ff       	callq  11350c <sys_clock_tick_get>
  1136a6:	48 85 db             	test   %rbx,%rbx
  1136a9:	bf 01 00 00 00       	mov    $0x1,%edi
  1136ae:	48 0f 4e df          	cmovle %rdi,%rbx
  1136b2:	48 01 d8             	add    %rbx,%rax
  1136b5:	eb 05                	jmp    1136bc <sys_clock_timeout_end_calc+0x43>
		return UINT64_MAX;
  1136b7:	48 83 c8 ff          	or     $0xffffffffffffffff,%rax
}
  1136bb:	c3                   	retq   
  1136bc:	5a                   	pop    %rdx
  1136bd:	5b                   	pop    %rbx
  1136be:	5d                   	pop    %rbp
  1136bf:	c3                   	retq   

00000000001136c0 <z_timer_expiration_handler>:
 * @param t  Timeout used by the timer.
 *
 * @return N/A
 */
void z_timer_expiration_handler(struct _timeout *t)
{
  1136c0:	55                   	push   %rbp
  1136c1:	48 89 e5             	mov    %rsp,%rbp
  1136c4:	41 55                	push   %r13
  1136c6:	41 54                	push   %r12
  1136c8:	53                   	push   %rbx
  1136c9:	48 89 fb             	mov    %rdi,%rbx
  1136cc:	51                   	push   %rcx
  1136cd:	9c                   	pushfq 
  1136ce:	fa                   	cli    
  1136cf:	41 5c                	pop    %r12
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  1136d1:	bf e0 cd 1b 00       	mov    $0x1bcde0,%edi
  1136d6:	e8 9e a1 ff ff       	callq  10d879 <z_spin_lock_valid>
  1136db:	84 c0                	test   %al,%al
  1136dd:	75 39                	jne    113718 <z_timer_expiration_handler+0x58>
  1136df:	b9 8e 00 00 00       	mov    $0x8e,%ecx
  1136e4:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  1136e9:	be fd d1 11 00       	mov    $0x11d1fd,%esi
  1136ee:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  1136f3:	e8 00 cf fe ff       	callq  1005f8 <printk>
  1136f8:	be e0 cd 1b 00       	mov    $0x1bcde0,%esi
  1136fd:	bf 12 d2 11 00       	mov    $0x11d212,%edi
  113702:	31 c0                	xor    %eax,%eax
  113704:	e8 ef ce fe ff       	callq  1005f8 <printk>
  113709:	be 8e 00 00 00       	mov    $0x8e,%esi
  11370e:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  113713:	e8 80 f4 fe ff       	callq  102b98 <assert_post_action>
	z_spin_lock_set_owner(l);
  113718:	bf e0 cd 1b 00       	mov    $0x1bcde0,%edi
  11371d:	e8 9b a1 ff ff       	callq  10d8bd <z_spin_lock_set_owner>

	/*
	 * if the timer is periodic, start it again; don't add _TICK_ALIGN
	 * since we're already aligned to a tick boundary
	 */
	if (!K_TIMEOUT_EQ(timer->period, K_NO_WAIT) &&
  113722:	48 8b 53 40          	mov    0x40(%rbx),%rdx
  113726:	48 8d 42 01          	lea    0x1(%rdx),%rax
  11372a:	48 83 f8 01          	cmp    $0x1,%rax
  11372e:	76 0d                	jbe    11373d <z_timer_expiration_handler+0x7d>
	    !K_TIMEOUT_EQ(timer->period, K_FOREVER)) {
		z_add_timeout(&timer->timeout, z_timer_expiration_handler,
  113730:	be c0 36 11 00       	mov    $0x1136c0,%esi
  113735:	48 89 df             	mov    %rbx,%rdi
  113738:	e8 c8 f6 ff ff       	callq  112e05 <z_add_timeout>
			     timer->period);
	}

	/* update timer's status */
	timer->status += 1U;
  11373d:	ff 43 48             	incl   0x48(%rbx)

	/* invoke timer expiry function */
	if (timer->expiry_fn != NULL) {
  113740:	48 83 7b 30 00       	cmpq   $0x0,0x30(%rbx)
  113745:	0f 84 aa 00 00 00    	je     1137f5 <z_timer_expiration_handler+0x135>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  11374b:	bf e0 cd 1b 00       	mov    $0x1bcde0,%edi
  113750:	e8 44 a1 ff ff       	callq  10d899 <z_spin_unlock_valid>
  113755:	84 c0                	test   %al,%al
  113757:	75 39                	jne    113792 <z_timer_expiration_handler+0xd2>
  113759:	b9 b9 00 00 00       	mov    $0xb9,%ecx
  11375e:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  113763:	be 41 d2 11 00       	mov    $0x11d241,%esi
  113768:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  11376d:	e8 86 ce fe ff       	callq  1005f8 <printk>
  113772:	be e0 cd 1b 00       	mov    $0x1bcde0,%esi
  113777:	bf 58 d2 11 00       	mov    $0x11d258,%edi
  11377c:	31 c0                	xor    %eax,%eax
  11377e:	e8 75 ce fe ff       	callq  1005f8 <printk>
  113783:	be b9 00 00 00       	mov    $0xb9,%esi
  113788:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  11378d:	e8 06 f4 fe ff       	callq  102b98 <assert_post_action>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  113792:	41 0f ba e4 09       	bt     $0x9,%r12d
  113797:	73 01                	jae    11379a <z_timer_expiration_handler+0xda>
		__asm__ volatile ("sti" ::: "memory");
  113799:	fb                   	sti    
		/* Unlock for user handler. */
		k_spin_unlock(&lock, key);
		timer->expiry_fn(timer);
  11379a:	48 89 df             	mov    %rbx,%rdi
  11379d:	ff 53 30             	callq  *0x30(%rbx)
  1137a0:	9c                   	pushfq 
  1137a1:	fa                   	cli    
  1137a2:	41 5c                	pop    %r12
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  1137a4:	bf e0 cd 1b 00       	mov    $0x1bcde0,%edi
  1137a9:	e8 cb a0 ff ff       	callq  10d879 <z_spin_lock_valid>
  1137ae:	84 c0                	test   %al,%al
  1137b0:	75 39                	jne    1137eb <z_timer_expiration_handler+0x12b>
  1137b2:	b9 8e 00 00 00       	mov    $0x8e,%ecx
  1137b7:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  1137bc:	be fd d1 11 00       	mov    $0x11d1fd,%esi
  1137c1:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  1137c6:	e8 2d ce fe ff       	callq  1005f8 <printk>
  1137cb:	be e0 cd 1b 00       	mov    $0x1bcde0,%esi
  1137d0:	bf 12 d2 11 00       	mov    $0x11d212,%edi
  1137d5:	31 c0                	xor    %eax,%eax
  1137d7:	e8 1c ce fe ff       	callq  1005f8 <printk>
  1137dc:	be 8e 00 00 00       	mov    $0x8e,%esi
  1137e1:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  1137e6:	e8 ad f3 fe ff       	callq  102b98 <assert_post_action>
	z_spin_lock_set_owner(l);
  1137eb:	bf e0 cd 1b 00       	mov    $0x1bcde0,%edi
  1137f0:	e8 c8 a0 ff ff       	callq  10d8bd <z_spin_lock_set_owner>
  1137f5:	4c 8b 6b 20          	mov    0x20(%rbx),%r13
  1137f9:	48 83 c3 20          	add    $0x20,%rbx
		return;
	}

	thread = z_waitq_head(&timer->wait_q);

	if (thread == NULL) {
  1137fd:	49 39 dd             	cmp    %rbx,%r13
  113800:	74 05                	je     113807 <z_timer_expiration_handler+0x147>
  113802:	4d 85 ed             	test   %r13,%r13
  113805:	75 51                	jne    113858 <z_timer_expiration_handler+0x198>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  113807:	bf e0 cd 1b 00       	mov    $0x1bcde0,%edi
  11380c:	e8 88 a0 ff ff       	callq  10d899 <z_spin_unlock_valid>
  113811:	84 c0                	test   %al,%al
  113813:	75 39                	jne    11384e <z_timer_expiration_handler+0x18e>
  113815:	b9 b9 00 00 00       	mov    $0xb9,%ecx
  11381a:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  11381f:	be 41 d2 11 00       	mov    $0x11d241,%esi
  113824:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  113829:	e8 ca cd fe ff       	callq  1005f8 <printk>
  11382e:	be e0 cd 1b 00       	mov    $0x1bcde0,%esi
  113833:	bf 58 d2 11 00       	mov    $0x11d258,%edi
  113838:	31 c0                	xor    %eax,%eax
  11383a:	e8 b9 cd fe ff       	callq  1005f8 <printk>
  11383f:	be b9 00 00 00       	mov    $0xb9,%esi
  113844:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  113849:	e8 4a f3 fe ff       	callq  102b98 <assert_post_action>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  11384e:	41 0f ba e4 09       	bt     $0x9,%r12d
  113853:	73 74                	jae    1138c9 <z_timer_expiration_handler+0x209>
		__asm__ volatile ("sti" ::: "memory");
  113855:	fb                   	sti    
  113856:	eb 71                	jmp    1138c9 <z_timer_expiration_handler+0x209>
		k_spin_unlock(&lock, key);
		return;
	}

	z_unpend_thread_no_timeout(thread);
  113858:	4c 89 ef             	mov    %r13,%rdi
  11385b:	e8 48 d4 ff ff       	callq  110ca8 <z_unpend_thread_no_timeout>
  113860:	bf e0 cd 1b 00       	mov    $0x1bcde0,%edi
	thread->swap_retval = value;
  113865:	41 c7 85 48 01 00 00 	movl   $0x0,0x148(%r13)
  11386c:	00 00 00 00 
  113870:	e8 24 a0 ff ff       	callq  10d899 <z_spin_unlock_valid>
  113875:	84 c0                	test   %al,%al
  113877:	75 39                	jne    1138b2 <z_timer_expiration_handler+0x1f2>
  113879:	b9 b9 00 00 00       	mov    $0xb9,%ecx
  11387e:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  113883:	be 41 d2 11 00       	mov    $0x11d241,%esi
  113888:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  11388d:	e8 66 cd fe ff       	callq  1005f8 <printk>
  113892:	be e0 cd 1b 00       	mov    $0x1bcde0,%esi
  113897:	bf 58 d2 11 00       	mov    $0x11d258,%edi
  11389c:	31 c0                	xor    %eax,%eax
  11389e:	e8 55 cd fe ff       	callq  1005f8 <printk>
  1138a3:	be b9 00 00 00       	mov    $0xb9,%esi
  1138a8:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  1138ad:	e8 e6 f2 fe ff       	callq  102b98 <assert_post_action>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  1138b2:	41 0f ba e4 09       	bt     $0x9,%r12d
  1138b7:	73 01                	jae    1138ba <z_timer_expiration_handler+0x1fa>
		__asm__ volatile ("sti" ::: "memory");
  1138b9:	fb                   	sti    
	arch_thread_return_value_set(thread, 0);

	k_spin_unlock(&lock, key);

	z_ready_thread(thread);
}
  1138ba:	5a                   	pop    %rdx
	z_ready_thread(thread);
  1138bb:	4c 89 ef             	mov    %r13,%rdi
}
  1138be:	5b                   	pop    %rbx
  1138bf:	41 5c                	pop    %r12
  1138c1:	41 5d                	pop    %r13
  1138c3:	5d                   	pop    %rbp
	z_ready_thread(thread);
  1138c4:	e9 81 db ff ff       	jmpq   11144a <z_ready_thread>
}
  1138c9:	58                   	pop    %rax
  1138ca:	5b                   	pop    %rbx
  1138cb:	41 5c                	pop    %r12
  1138cd:	41 5d                	pop    %r13
  1138cf:	5d                   	pop    %rbp
  1138d0:	c3                   	retq   

00000000001138d1 <z_obj_validation_check.constprop.0>:
static inline int z_obj_validation_check(struct z_object *ko,
  1138d1:	55                   	push   %rbp
	ret = z_object_validate(ko, otype, init);
  1138d2:	31 d2                	xor    %edx,%edx
static inline int z_obj_validation_check(struct z_object *ko,
  1138d4:	48 89 e5             	mov    %rsp,%rbp
  1138d7:	41 56                	push   %r14
  1138d9:	49 89 f6             	mov    %rsi,%r14
	ret = z_object_validate(ko, otype, init);
  1138dc:	be 0a 00 00 00       	mov    $0xa,%esi
static inline int z_obj_validation_check(struct z_object *ko,
  1138e1:	41 55                	push   %r13
  1138e3:	49 89 fd             	mov    %rdi,%r13
  1138e6:	48 83 ec 10          	sub    $0x10,%rsp
	ret = z_object_validate(ko, otype, init);
  1138ea:	e8 7d 36 00 00       	callq  116f6c <z_object_validate>
	if (ret != 0) {
  1138ef:	85 c0                	test   %eax,%eax
  1138f1:	74 18                	je     11390b <z_obj_validation_check.constprop.0+0x3a>
		z_dump_object_error(ret, obj, ko, otype);
  1138f3:	89 c7                	mov    %eax,%edi
  1138f5:	b9 0a 00 00 00       	mov    $0xa,%ecx
  1138fa:	4c 89 ea             	mov    %r13,%rdx
  1138fd:	4c 89 f6             	mov    %r14,%rsi
  113900:	89 45 ec             	mov    %eax,-0x14(%rbp)
  113903:	e8 19 35 00 00       	callq  116e21 <z_dump_object_error>
  113908:	8b 45 ec             	mov    -0x14(%rbp),%eax
}
  11390b:	5a                   	pop    %rdx
  11390c:	59                   	pop    %rcx
  11390d:	41 5d                	pop    %r13
  11390f:	41 5e                	pop    %r14
  113911:	5d                   	pop    %rbp
  113912:	c3                   	retq   

0000000000113913 <k_timer_init>:
	sys_dlist_init(&w->waitq);
  113913:	48 8d 47 20          	lea    0x20(%rdi),%rax

void k_timer_init(struct k_timer *timer,
			 k_timer_expiry_t expiry_fn,
			 k_timer_stop_t stop_fn)
{
	timer->expiry_fn = expiry_fn;
  113917:	48 89 77 30          	mov    %rsi,0x30(%rdi)
	timer->stop_fn = stop_fn;
  11391b:	48 89 57 38          	mov    %rdx,0x38(%rdi)
	timer->status = 0U;
  11391f:	c7 47 48 00 00 00 00 	movl   $0x0,0x48(%rdi)
	list->head = (sys_dnode_t *)list;
  113926:	48 89 47 20          	mov    %rax,0x20(%rdi)
	list->tail = (sys_dnode_t *)list;
  11392a:	48 89 47 28          	mov    %rax,0x28(%rdi)
	node->next = NULL;
  11392e:	48 c7 07 00 00 00 00 	movq   $0x0,(%rdi)
	node->prev = NULL;
  113935:	48 c7 47 08 00 00 00 	movq   $0x0,0x8(%rdi)
  11393c:	00 

	z_init_timeout(&timer->timeout);

	SYS_PORT_TRACING_OBJ_INIT(k_timer, timer);

	timer->user_data = NULL;
  11393d:	48 c7 47 50 00 00 00 	movq   $0x0,0x50(%rdi)
  113944:	00 

	z_object_init(timer);
  113945:	e9 a7 36 00 00       	jmpq   116ff1 <z_object_init>

000000000011394a <z_impl_k_timer_start>:
void z_impl_k_timer_start(struct k_timer *timer, k_timeout_t duration,
			  k_timeout_t period)
{
	SYS_PORT_TRACING_OBJ_FUNC(k_timer, start, timer);

	if (K_TIMEOUT_EQ(duration, K_FOREVER)) {
  11394a:	48 83 fe ff          	cmp    $0xffffffffffffffff,%rsi
  11394e:	74 7d                	je     1139cd <z_impl_k_timer_start+0x83>
{
  113950:	55                   	push   %rbp
  113951:	48 89 e5             	mov    %rsp,%rbp
  113954:	41 55                	push   %r13
  113956:	49 89 f5             	mov    %rsi,%r13
  113959:	53                   	push   %rbx
  11395a:	48 89 d3             	mov    %rdx,%rbx
  11395d:	48 83 ec 10          	sub    $0x10,%rsp
	 * for backwards compatibility.  This is unfortunate
	 * (i.e. k_timer_start() doesn't treat its initial sleep
	 * argument the same way k_sleep() does), but historical.  The
	 * timer_api test relies on this behavior.
	 */
	if (!K_TIMEOUT_EQ(period, K_FOREVER) && period.ticks != 0 &&
  113961:	48 83 fa ff          	cmp    $0xffffffffffffffff,%rdx
  113965:	74 20                	je     113987 <z_impl_k_timer_start+0x3d>
  113967:	48 85 d2             	test   %rdx,%rdx
  11396a:	74 1b                	je     113987 <z_impl_k_timer_start+0x3d>
  11396c:	48 c7 c0 fe ff ff ff 	mov    $0xfffffffffffffffe,%rax
  113973:	48 39 d0             	cmp    %rdx,%rax
  113976:	79 0f                	jns    113987 <z_impl_k_timer_start+0x3d>
	    Z_TICK_ABS(period.ticks) < 0) {
		period.ticks = MAX(period.ticks - 1, 1);
  113978:	48 ff cb             	dec    %rbx
  11397b:	b8 01 00 00 00       	mov    $0x1,%eax
  113980:	48 85 db             	test   %rbx,%rbx
  113983:	48 0f 4e d8          	cmovle %rax,%rbx
	}
	if (Z_TICK_ABS(duration.ticks) < 0) {
  113987:	48 c7 c0 fe ff ff ff 	mov    $0xfffffffffffffffe,%rax
  11398e:	48 39 f0             	cmp    %rsi,%rax
  113991:	79 0f                	jns    1139a2 <z_impl_k_timer_start+0x58>
		duration.ticks = MAX(duration.ticks - 1, 0);
  113993:	48 ff ce             	dec    %rsi
  113996:	b8 00 00 00 00       	mov    $0x0,%eax
  11399b:	49 89 f5             	mov    %rsi,%r13
  11399e:	4c 0f 48 e8          	cmovs  %rax,%r13
	}

	(void)z_abort_timeout(&timer->timeout);
  1139a2:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  1139a6:	e8 2f f6 ff ff       	callq  112fda <z_abort_timeout>
	timer->period = period;
  1139ab:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
	timer->status = 0U;

	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
  1139af:	4c 89 ea             	mov    %r13,%rdx
  1139b2:	be c0 36 11 00       	mov    $0x1136c0,%esi
	timer->period = period;
  1139b7:	48 89 5f 40          	mov    %rbx,0x40(%rdi)
	timer->status = 0U;
  1139bb:	c7 47 48 00 00 00 00 	movl   $0x0,0x48(%rdi)
		     duration);
}
  1139c2:	58                   	pop    %rax
  1139c3:	59                   	pop    %rcx
  1139c4:	5b                   	pop    %rbx
  1139c5:	41 5d                	pop    %r13
  1139c7:	5d                   	pop    %rbp
	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
  1139c8:	e9 38 f4 ff ff       	jmpq   112e05 <z_add_timeout>
  1139cd:	c3                   	retq   

00000000001139ce <z_mrsh_k_timer_start>:
#include <syscalls/kernel.h>

extern void z_vrfy_k_timer_start(struct k_timer * timer, k_timeout_t duration, k_timeout_t period);
uintptr_t z_mrsh_k_timer_start(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
  1139ce:	55                   	push   %rbp
  1139cf:	48 89 e5             	mov    %rsp,%rbp
  1139d2:	41 56                	push   %r14
  1139d4:	49 89 d6             	mov    %rdx,%r14
  1139d7:	41 55                	push   %r13
  1139d9:	49 89 f5             	mov    %rsi,%r13
  1139dc:	41 54                	push   %r12
  1139de:	49 89 fc             	mov    %rdi,%r12
  1139e1:	48 83 ec 18          	sub    $0x18,%rsp
  1139e5:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
	_current->syscall_frame = ssf;
  1139e9:	48 8b 05 60 4d 01 00 	mov    0x14d60(%rip),%rax        # 128750 <_kernel+0x10>
  1139f0:	48 8b 55 10          	mov    0x10(%rbp),%rdx
{
  1139f4:	48 89 75 d8          	mov    %rsi,-0x28(%rbp)
	_current->syscall_frame = ssf;
  1139f8:	48 89 90 40 01 00 00 	mov    %rdx,0x140(%rax)
#ifdef CONFIG_USERSPACE
static inline void z_vrfy_k_timer_start(struct k_timer *timer,
					k_timeout_t duration,
					k_timeout_t period)
{
	Z_OOPS(Z_SYSCALL_OBJ(timer, K_OBJ_TIMER));
  1139ff:	e8 d0 30 00 00       	callq  116ad4 <z_object_find>
  113a04:	4c 89 e6             	mov    %r12,%rsi
  113a07:	48 89 c7             	mov    %rax,%rdi
  113a0a:	e8 c2 fe ff ff       	callq  1138d1 <z_obj_validation_check.constprop.0>
  113a0f:	85 c0                	test   %eax,%eax
  113a11:	74 29                	je     113a3c <z_mrsh_k_timer_start+0x6e>
  113a13:	bf 23 f3 11 00       	mov    $0x11f323,%edi
  113a18:	31 c0                	xor    %eax,%eax
  113a1a:	ba 40 c6 11 00       	mov    $0x11c640,%edx
  113a1f:	be 45 00 00 00       	mov    $0x45,%esi
  113a24:	e8 9d f6 fe ff       	callq  1030c6 <z_log_minimal_printk>
  113a29:	48 8b 05 20 4d 01 00 	mov    0x14d20(%rip),%rax        # 128750 <_kernel+0x10>
  113a30:	48 8b b8 40 01 00 00 	mov    0x140(%rax),%rdi
  113a37:	e8 d1 61 ff ff       	callq  109c0d <arch_syscall_oops>
	z_impl_k_timer_start(timer, duration, period);
  113a3c:	4c 89 f2             	mov    %r14,%rdx
  113a3f:	4c 89 ee             	mov    %r13,%rsi
  113a42:	4c 89 e7             	mov    %r12,%rdi
  113a45:	e8 00 ff ff ff       	callq  11394a <z_impl_k_timer_start>
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	z_vrfy_k_timer_start(*(struct k_timer **)&arg0, *(k_timeout_t*)&arg1, *(k_timeout_t*)&arg2)
;
	_current->syscall_frame = NULL;
  113a4a:	48 8b 05 ff 4c 01 00 	mov    0x14cff(%rip),%rax        # 128750 <_kernel+0x10>
  113a51:	48 c7 80 40 01 00 00 	movq   $0x0,0x140(%rax)
  113a58:	00 00 00 00 
	return 0;
}
  113a5c:	48 83 c4 18          	add    $0x18,%rsp
  113a60:	31 c0                	xor    %eax,%eax
  113a62:	41 5c                	pop    %r12
  113a64:	41 5d                	pop    %r13
  113a66:	41 5e                	pop    %r14
  113a68:	5d                   	pop    %rbp
  113a69:	c3                   	retq   

0000000000113a6a <z_impl_k_timer_stop>:
}
#include <syscalls/k_timer_start_mrsh.c>
#endif

void z_impl_k_timer_stop(struct k_timer *timer)
{
  113a6a:	55                   	push   %rbp
  113a6b:	48 89 e5             	mov    %rsp,%rbp
  113a6e:	53                   	push   %rbx
  113a6f:	48 89 fb             	mov    %rdi,%rbx
  113a72:	51                   	push   %rcx
	SYS_PORT_TRACING_OBJ_FUNC(k_timer, stop, timer);

	int inactive = z_abort_timeout(&timer->timeout) != 0;
  113a73:	e8 62 f5 ff ff       	callq  112fda <z_abort_timeout>

	if (inactive) {
  113a78:	85 c0                	test   %eax,%eax
  113a7a:	75 2f                	jne    113aab <z_impl_k_timer_stop+0x41>
		return;
	}

	if (timer->stop_fn != NULL) {
  113a7c:	48 8b 43 38          	mov    0x38(%rbx),%rax
  113a80:	48 85 c0             	test   %rax,%rax
  113a83:	74 05                	je     113a8a <z_impl_k_timer_stop+0x20>
		timer->stop_fn(timer);
  113a85:	48 89 df             	mov    %rbx,%rdi
  113a88:	ff d0                	callq  *%rax
	}

	if (IS_ENABLED(CONFIG_MULTITHREADING)) {
		struct k_thread *pending_thread = z_unpend1_no_timeout(&timer->wait_q);
  113a8a:	48 8d 7b 20          	lea    0x20(%rbx),%rdi
  113a8e:	e8 fe e3 ff ff       	callq  111e91 <z_unpend1_no_timeout>
  113a93:	48 89 c7             	mov    %rax,%rdi

		if (pending_thread != NULL) {
  113a96:	48 85 c0             	test   %rax,%rax
  113a99:	74 10                	je     113aab <z_impl_k_timer_stop+0x41>
			z_ready_thread(pending_thread);
  113a9b:	e8 aa d9 ff ff       	callq  11144a <z_ready_thread>
  113aa0:	9c                   	pushfq 
  113aa1:	fa                   	cli    
  113aa2:	5f                   	pop    %rdi
			z_reschedule_unlocked();
		}
	}
}
  113aa3:	5a                   	pop    %rdx
  113aa4:	5b                   	pop    %rbx
  113aa5:	5d                   	pop    %rbp
	(void) z_reschedule_irqlock(arch_irq_lock());
  113aa6:	e9 3c d3 ff ff       	jmpq   110de7 <z_reschedule_irqlock>
  113aab:	58                   	pop    %rax
  113aac:	5b                   	pop    %rbx
  113aad:	5d                   	pop    %rbp
  113aae:	c3                   	retq   

0000000000113aaf <z_mrsh_k_timer_stop>:
#include <syscalls/kernel.h>

extern void z_vrfy_k_timer_stop(struct k_timer * timer);
uintptr_t z_mrsh_k_timer_stop(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
  113aaf:	55                   	push   %rbp
  113ab0:	48 89 e5             	mov    %rsp,%rbp
  113ab3:	41 54                	push   %r12
  113ab5:	49 89 fc             	mov    %rdi,%r12
  113ab8:	51                   	push   %rcx
	_current->syscall_frame = ssf;
  113ab9:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  113abd:	48 8b 05 8c 4c 01 00 	mov    0x14c8c(%rip),%rax        # 128750 <_kernel+0x10>
  113ac4:	48 89 90 40 01 00 00 	mov    %rdx,0x140(%rax)

#ifdef CONFIG_USERSPACE
static inline void z_vrfy_k_timer_stop(struct k_timer *timer)
{
	Z_OOPS(Z_SYSCALL_OBJ(timer, K_OBJ_TIMER));
  113acb:	e8 04 30 00 00       	callq  116ad4 <z_object_find>
  113ad0:	4c 89 e6             	mov    %r12,%rsi
  113ad3:	48 89 c7             	mov    %rax,%rdi
  113ad6:	e8 f6 fd ff ff       	callq  1138d1 <z_obj_validation_check.constprop.0>
  113adb:	85 c0                	test   %eax,%eax
  113add:	74 29                	je     113b08 <z_mrsh_k_timer_stop+0x59>
  113adf:	bf 23 f3 11 00       	mov    $0x11f323,%edi
  113ae4:	31 c0                	xor    %eax,%eax
  113ae6:	ba 20 c6 11 00       	mov    $0x11c620,%edx
  113aeb:	be 45 00 00 00       	mov    $0x45,%esi
  113af0:	e8 d1 f5 fe ff       	callq  1030c6 <z_log_minimal_printk>
  113af5:	48 8b 05 54 4c 01 00 	mov    0x14c54(%rip),%rax        # 128750 <_kernel+0x10>
  113afc:	48 8b b8 40 01 00 00 	mov    0x140(%rax),%rdi
  113b03:	e8 05 61 ff ff       	callq  109c0d <arch_syscall_oops>
	z_impl_k_timer_stop(timer);
  113b08:	4c 89 e7             	mov    %r12,%rdi
  113b0b:	e8 5a ff ff ff       	callq  113a6a <z_impl_k_timer_stop>
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	z_vrfy_k_timer_stop(*(struct k_timer **)&arg0)
;
	_current->syscall_frame = NULL;
  113b10:	48 8b 05 39 4c 01 00 	mov    0x14c39(%rip),%rax        # 128750 <_kernel+0x10>
  113b17:	48 c7 80 40 01 00 00 	movq   $0x0,0x140(%rax)
  113b1e:	00 00 00 00 
	return 0;
}
  113b22:	31 c0                	xor    %eax,%eax
  113b24:	5a                   	pop    %rdx
  113b25:	41 5c                	pop    %r12
  113b27:	5d                   	pop    %rbp
  113b28:	c3                   	retq   

0000000000113b29 <z_impl_k_timer_status_get>:
}
#include <syscalls/k_timer_stop_mrsh.c>
#endif

uint32_t z_impl_k_timer_status_get(struct k_timer *timer)
{
  113b29:	55                   	push   %rbp
  113b2a:	48 89 e5             	mov    %rsp,%rbp
  113b2d:	41 55                	push   %r13
  113b2f:	41 54                	push   %r12
  113b31:	53                   	push   %rbx
  113b32:	48 89 fb             	mov    %rdi,%rbx
  113b35:	51                   	push   %rcx
  113b36:	9c                   	pushfq 
  113b37:	fa                   	cli    
  113b38:	41 5d                	pop    %r13
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  113b3a:	bf e0 cd 1b 00       	mov    $0x1bcde0,%edi
  113b3f:	e8 35 9d ff ff       	callq  10d879 <z_spin_lock_valid>
  113b44:	84 c0                	test   %al,%al
  113b46:	75 39                	jne    113b81 <z_impl_k_timer_status_get+0x58>
  113b48:	b9 8e 00 00 00       	mov    $0x8e,%ecx
  113b4d:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  113b52:	be fd d1 11 00       	mov    $0x11d1fd,%esi
  113b57:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  113b5c:	e8 97 ca fe ff       	callq  1005f8 <printk>
  113b61:	be e0 cd 1b 00       	mov    $0x1bcde0,%esi
  113b66:	bf 12 d2 11 00       	mov    $0x11d212,%edi
  113b6b:	31 c0                	xor    %eax,%eax
  113b6d:	e8 86 ca fe ff       	callq  1005f8 <printk>
  113b72:	be 8e 00 00 00       	mov    $0x8e,%esi
  113b77:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  113b7c:	e8 17 f0 fe ff       	callq  102b98 <assert_post_action>
	z_spin_lock_set_owner(l);
  113b81:	bf e0 cd 1b 00       	mov    $0x1bcde0,%edi
  113b86:	e8 32 9d ff ff       	callq  10d8bd <z_spin_lock_set_owner>
	k_spinlock_key_t key = k_spin_lock(&lock);
	uint32_t result = timer->status;
  113b8b:	44 8b 63 48          	mov    0x48(%rbx),%r12d

	timer->status = 0U;
  113b8f:	c7 43 48 00 00 00 00 	movl   $0x0,0x48(%rbx)
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  113b96:	bf e0 cd 1b 00       	mov    $0x1bcde0,%edi
  113b9b:	e8 f9 9c ff ff       	callq  10d899 <z_spin_unlock_valid>
  113ba0:	84 c0                	test   %al,%al
  113ba2:	75 39                	jne    113bdd <z_impl_k_timer_status_get+0xb4>
  113ba4:	b9 b9 00 00 00       	mov    $0xb9,%ecx
  113ba9:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  113bae:	be 41 d2 11 00       	mov    $0x11d241,%esi
  113bb3:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  113bb8:	e8 3b ca fe ff       	callq  1005f8 <printk>
  113bbd:	be e0 cd 1b 00       	mov    $0x1bcde0,%esi
  113bc2:	bf 58 d2 11 00       	mov    $0x11d258,%edi
  113bc7:	31 c0                	xor    %eax,%eax
  113bc9:	e8 2a ca fe ff       	callq  1005f8 <printk>
  113bce:	be b9 00 00 00       	mov    $0xb9,%esi
  113bd3:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  113bd8:	e8 bb ef fe ff       	callq  102b98 <assert_post_action>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  113bdd:	41 0f ba e5 09       	bt     $0x9,%r13d
  113be2:	73 01                	jae    113be5 <z_impl_k_timer_status_get+0xbc>
		__asm__ volatile ("sti" ::: "memory");
  113be4:	fb                   	sti    
	k_spin_unlock(&lock, key);

	return result;
}
  113be5:	5a                   	pop    %rdx
  113be6:	44 89 e0             	mov    %r12d,%eax
  113be9:	5b                   	pop    %rbx
  113bea:	41 5c                	pop    %r12
  113bec:	41 5d                	pop    %r13
  113bee:	5d                   	pop    %rbp
  113bef:	c3                   	retq   

0000000000113bf0 <z_mrsh_k_timer_status_get>:
#include <syscalls/kernel.h>

extern uint32_t z_vrfy_k_timer_status_get(struct k_timer * timer);
uintptr_t z_mrsh_k_timer_status_get(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
  113bf0:	55                   	push   %rbp
  113bf1:	48 89 e5             	mov    %rsp,%rbp
  113bf4:	41 54                	push   %r12
  113bf6:	49 89 fc             	mov    %rdi,%r12
  113bf9:	51                   	push   %rcx
	_current->syscall_frame = ssf;
  113bfa:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  113bfe:	48 8b 05 4b 4b 01 00 	mov    0x14b4b(%rip),%rax        # 128750 <_kernel+0x10>
  113c05:	48 89 90 40 01 00 00 	mov    %rdx,0x140(%rax)

#ifdef CONFIG_USERSPACE
static inline uint32_t z_vrfy_k_timer_status_get(struct k_timer *timer)
{
	Z_OOPS(Z_SYSCALL_OBJ(timer, K_OBJ_TIMER));
  113c0c:	e8 c3 2e 00 00       	callq  116ad4 <z_object_find>
  113c11:	4c 89 e6             	mov    %r12,%rsi
  113c14:	48 89 c7             	mov    %rax,%rdi
  113c17:	e8 b5 fc ff ff       	callq  1138d1 <z_obj_validation_check.constprop.0>
  113c1c:	85 c0                	test   %eax,%eax
  113c1e:	74 29                	je     113c49 <z_mrsh_k_timer_status_get+0x59>
  113c20:	bf 23 f3 11 00       	mov    $0x11f323,%edi
  113c25:	31 c0                	xor    %eax,%eax
  113c27:	ba 00 c6 11 00       	mov    $0x11c600,%edx
  113c2c:	be 45 00 00 00       	mov    $0x45,%esi
  113c31:	e8 90 f4 fe ff       	callq  1030c6 <z_log_minimal_printk>
  113c36:	48 8b 05 13 4b 01 00 	mov    0x14b13(%rip),%rax        # 128750 <_kernel+0x10>
  113c3d:	48 8b b8 40 01 00 00 	mov    0x140(%rax),%rdi
  113c44:	e8 c4 5f ff ff       	callq  109c0d <arch_syscall_oops>
	return z_impl_k_timer_status_get(timer);
  113c49:	4c 89 e7             	mov    %r12,%rdi
  113c4c:	e8 d8 fe ff ff       	callq  113b29 <z_impl_k_timer_status_get>
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	uint32_t ret = z_vrfy_k_timer_status_get(*(struct k_timer **)&arg0)
;
	_current->syscall_frame = NULL;
  113c51:	48 8b 15 f8 4a 01 00 	mov    0x14af8(%rip),%rdx        # 128750 <_kernel+0x10>
	return (uintptr_t) ret;
  113c58:	89 c0                	mov    %eax,%eax
	_current->syscall_frame = NULL;
  113c5a:	48 c7 82 40 01 00 00 	movq   $0x0,0x140(%rdx)
  113c61:	00 00 00 00 
}
  113c65:	5a                   	pop    %rdx
  113c66:	41 5c                	pop    %r12
  113c68:	5d                   	pop    %rbp
  113c69:	c3                   	retq   

0000000000113c6a <z_impl_k_timer_status_sync>:
}
#include <syscalls/k_timer_status_get_mrsh.c>
#endif

uint32_t z_impl_k_timer_status_sync(struct k_timer *timer)
{
  113c6a:	55                   	push   %rbp
	__ASSERT(!arch_is_in_isr(), "");
  113c6b:	83 3d ce 4a 01 00 00 	cmpl   $0x0,0x14ace(%rip)        # 128740 <_kernel>
{
  113c72:	48 89 e5             	mov    %rsp,%rbp
  113c75:	41 56                	push   %r14
  113c77:	41 55                	push   %r13
  113c79:	41 54                	push   %r12
  113c7b:	53                   	push   %rbx
  113c7c:	48 89 fb             	mov    %rdi,%rbx
	__ASSERT(!arch_is_in_isr(), "");
  113c7f:	74 36                	je     113cb7 <z_impl_k_timer_status_sync+0x4d>
  113c81:	be 49 f9 11 00       	mov    $0x11f949,%esi
  113c86:	b9 c8 00 00 00       	mov    $0xc8,%ecx
  113c8b:	ba 02 00 12 00       	mov    $0x120002,%edx
  113c90:	31 c0                	xor    %eax,%eax
  113c92:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  113c97:	e8 5c c9 fe ff       	callq  1005f8 <printk>
  113c9c:	bf 22 fc 11 00       	mov    $0x11fc22,%edi
  113ca1:	31 c0                	xor    %eax,%eax
  113ca3:	e8 50 c9 fe ff       	callq  1005f8 <printk>
  113ca8:	be c8 00 00 00       	mov    $0xc8,%esi
  113cad:	bf 02 00 12 00       	mov    $0x120002,%edi
  113cb2:	e8 e1 ee fe ff       	callq  102b98 <assert_post_action>
  113cb7:	9c                   	pushfq 
  113cb8:	fa                   	cli    
  113cb9:	41 5e                	pop    %r14
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  113cbb:	bf e0 cd 1b 00       	mov    $0x1bcde0,%edi
	k.key = arch_irq_lock();
  113cc0:	45 89 f4             	mov    %r14d,%r12d
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  113cc3:	e8 b1 9b ff ff       	callq  10d879 <z_spin_lock_valid>
  113cc8:	84 c0                	test   %al,%al
  113cca:	75 39                	jne    113d05 <z_impl_k_timer_status_sync+0x9b>
  113ccc:	b9 8e 00 00 00       	mov    $0x8e,%ecx
  113cd1:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  113cd6:	be fd d1 11 00       	mov    $0x11d1fd,%esi
  113cdb:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  113ce0:	e8 13 c9 fe ff       	callq  1005f8 <printk>
  113ce5:	be e0 cd 1b 00       	mov    $0x1bcde0,%esi
  113cea:	bf 12 d2 11 00       	mov    $0x11d212,%edi
  113cef:	31 c0                	xor    %eax,%eax
  113cf1:	e8 02 c9 fe ff       	callq  1005f8 <printk>
  113cf6:	be 8e 00 00 00       	mov    $0x8e,%esi
  113cfb:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  113d00:	e8 93 ee fe ff       	callq  102b98 <assert_post_action>
	z_spin_lock_set_owner(l);
  113d05:	bf e0 cd 1b 00       	mov    $0x1bcde0,%edi
  113d0a:	e8 ae 9b ff ff       	callq  10d8bd <z_spin_lock_set_owner>

		return result;
	}

	k_spinlock_key_t key = k_spin_lock(&lock);
	uint32_t result = timer->status;
  113d0f:	44 8b 6b 48          	mov    0x48(%rbx),%r13d

	if (result == 0U) {
  113d13:	45 85 ed             	test   %r13d,%r13d
  113d16:	75 74                	jne    113d8c <z_impl_k_timer_status_sync+0x122>
		if (!z_is_inactive_timeout(&timer->timeout)) {
  113d18:	48 83 3b 00          	cmpq   $0x0,(%rbx)
  113d1c:	74 6e                	je     113d8c <z_impl_k_timer_status_sync+0x122>
			SYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_timer, status_sync, timer, K_FOREVER);

			/* wait for timer to expire or stop */
			(void)z_pend_curr(&lock, key, &timer->wait_q, K_FOREVER);
  113d1e:	48 8d 53 20          	lea    0x20(%rbx),%rdx
  113d22:	48 83 c9 ff          	or     $0xffffffffffffffff,%rcx
  113d26:	44 89 f6             	mov    %r14d,%esi
  113d29:	bf e0 cd 1b 00       	mov    $0x1bcde0,%edi
  113d2e:	e8 b5 dc ff ff       	callq  1119e8 <z_pend_curr>
  113d33:	9c                   	pushfq 
  113d34:	fa                   	cli    
  113d35:	41 5c                	pop    %r12
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  113d37:	bf e0 cd 1b 00       	mov    $0x1bcde0,%edi
  113d3c:	e8 38 9b ff ff       	callq  10d879 <z_spin_lock_valid>
  113d41:	84 c0                	test   %al,%al
  113d43:	75 39                	jne    113d7e <z_impl_k_timer_status_sync+0x114>
  113d45:	b9 8e 00 00 00       	mov    $0x8e,%ecx
  113d4a:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  113d4f:	be fd d1 11 00       	mov    $0x11d1fd,%esi
  113d54:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  113d59:	e8 9a c8 fe ff       	callq  1005f8 <printk>
  113d5e:	be e0 cd 1b 00       	mov    $0x1bcde0,%esi
  113d63:	bf 12 d2 11 00       	mov    $0x11d212,%edi
  113d68:	31 c0                	xor    %eax,%eax
  113d6a:	e8 89 c8 fe ff       	callq  1005f8 <printk>
  113d6f:	be 8e 00 00 00       	mov    $0x8e,%esi
  113d74:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  113d79:	e8 1a ee fe ff       	callq  102b98 <assert_post_action>
	z_spin_lock_set_owner(l);
  113d7e:	bf e0 cd 1b 00       	mov    $0x1bcde0,%edi
  113d83:	e8 35 9b ff ff       	callq  10d8bd <z_spin_lock_set_owner>

			/* get updated timer status */
			key = k_spin_lock(&lock);
			result = timer->status;
  113d88:	44 8b 6b 48          	mov    0x48(%rbx),%r13d
		}
	} else {
		/* timer has already expired at least once */
	}

	timer->status = 0U;
  113d8c:	c7 43 48 00 00 00 00 	movl   $0x0,0x48(%rbx)
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  113d93:	bf e0 cd 1b 00       	mov    $0x1bcde0,%edi
  113d98:	e8 fc 9a ff ff       	callq  10d899 <z_spin_unlock_valid>
  113d9d:	84 c0                	test   %al,%al
  113d9f:	75 39                	jne    113dda <z_impl_k_timer_status_sync+0x170>
  113da1:	b9 b9 00 00 00       	mov    $0xb9,%ecx
  113da6:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  113dab:	be 41 d2 11 00       	mov    $0x11d241,%esi
  113db0:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  113db5:	e8 3e c8 fe ff       	callq  1005f8 <printk>
  113dba:	be e0 cd 1b 00       	mov    $0x1bcde0,%esi
  113dbf:	bf 58 d2 11 00       	mov    $0x11d258,%edi
  113dc4:	31 c0                	xor    %eax,%eax
  113dc6:	e8 2d c8 fe ff       	callq  1005f8 <printk>
  113dcb:	be b9 00 00 00       	mov    $0xb9,%esi
  113dd0:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  113dd5:	e8 be ed fe ff       	callq  102b98 <assert_post_action>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  113dda:	41 0f ba e4 09       	bt     $0x9,%r12d
  113ddf:	73 01                	jae    113de2 <z_impl_k_timer_status_sync+0x178>
		__asm__ volatile ("sti" ::: "memory");
  113de1:	fb                   	sti    
	 * @note	New tracing hook
	 */
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_timer, status_sync, timer, result);

	return result;
}
  113de2:	5b                   	pop    %rbx
  113de3:	44 89 e8             	mov    %r13d,%eax
  113de6:	41 5c                	pop    %r12
  113de8:	41 5d                	pop    %r13
  113dea:	41 5e                	pop    %r14
  113dec:	5d                   	pop    %rbp
  113ded:	c3                   	retq   

0000000000113dee <z_mrsh_k_timer_status_sync>:
#include <syscalls/kernel.h>

extern uint32_t z_vrfy_k_timer_status_sync(struct k_timer * timer);
uintptr_t z_mrsh_k_timer_status_sync(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
  113dee:	55                   	push   %rbp
  113def:	48 89 e5             	mov    %rsp,%rbp
  113df2:	41 54                	push   %r12
  113df4:	49 89 fc             	mov    %rdi,%r12
  113df7:	51                   	push   %rcx
	_current->syscall_frame = ssf;
  113df8:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  113dfc:	48 8b 05 4d 49 01 00 	mov    0x1494d(%rip),%rax        # 128750 <_kernel+0x10>
  113e03:	48 89 90 40 01 00 00 	mov    %rdx,0x140(%rax)

#ifdef CONFIG_USERSPACE
static inline uint32_t z_vrfy_k_timer_status_sync(struct k_timer *timer)
{
	Z_OOPS(Z_SYSCALL_OBJ(timer, K_OBJ_TIMER));
  113e0a:	e8 c5 2c 00 00       	callq  116ad4 <z_object_find>
  113e0f:	4c 89 e6             	mov    %r12,%rsi
  113e12:	48 89 c7             	mov    %rax,%rdi
  113e15:	e8 b7 fa ff ff       	callq  1138d1 <z_obj_validation_check.constprop.0>
  113e1a:	85 c0                	test   %eax,%eax
  113e1c:	74 29                	je     113e47 <z_mrsh_k_timer_status_sync+0x59>
  113e1e:	bf 23 f3 11 00       	mov    $0x11f323,%edi
  113e23:	31 c0                	xor    %eax,%eax
  113e25:	ba e0 c5 11 00       	mov    $0x11c5e0,%edx
  113e2a:	be 45 00 00 00       	mov    $0x45,%esi
  113e2f:	e8 92 f2 fe ff       	callq  1030c6 <z_log_minimal_printk>
  113e34:	48 8b 05 15 49 01 00 	mov    0x14915(%rip),%rax        # 128750 <_kernel+0x10>
  113e3b:	48 8b b8 40 01 00 00 	mov    0x140(%rax),%rdi
  113e42:	e8 c6 5d ff ff       	callq  109c0d <arch_syscall_oops>
	return z_impl_k_timer_status_sync(timer);
  113e47:	4c 89 e7             	mov    %r12,%rdi
  113e4a:	e8 1b fe ff ff       	callq  113c6a <z_impl_k_timer_status_sync>
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	uint32_t ret = z_vrfy_k_timer_status_sync(*(struct k_timer **)&arg0)
;
	_current->syscall_frame = NULL;
  113e4f:	48 8b 15 fa 48 01 00 	mov    0x148fa(%rip),%rdx        # 128750 <_kernel+0x10>
	return (uintptr_t) ret;
  113e56:	89 c0                	mov    %eax,%eax
	_current->syscall_frame = NULL;
  113e58:	48 c7 82 40 01 00 00 	movq   $0x0,0x140(%rdx)
  113e5f:	00 00 00 00 
}
  113e63:	5a                   	pop    %rdx
  113e64:	41 5c                	pop    %r12
  113e66:	5d                   	pop    %rbp
  113e67:	c3                   	retq   

0000000000113e68 <z_mrsh_k_timer_remaining_ticks>:
#include <syscalls/kernel.h>

extern k_ticks_t z_vrfy_k_timer_remaining_ticks(const struct k_timer * timer);
uintptr_t z_mrsh_k_timer_remaining_ticks(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
  113e68:	55                   	push   %rbp
  113e69:	48 89 e5             	mov    %rsp,%rbp
  113e6c:	41 54                	push   %r12
  113e6e:	49 89 fc             	mov    %rdi,%r12
  113e71:	51                   	push   %rcx
	_current->syscall_frame = ssf;
  113e72:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  113e76:	48 8b 05 d3 48 01 00 	mov    0x148d3(%rip),%rax        # 128750 <_kernel+0x10>
  113e7d:	48 89 90 40 01 00 00 	mov    %rdx,0x140(%rax)
#include <syscalls/k_timer_status_sync_mrsh.c>

static inline k_ticks_t z_vrfy_k_timer_remaining_ticks(
						const struct k_timer *timer)
{
	Z_OOPS(Z_SYSCALL_OBJ(timer, K_OBJ_TIMER));
  113e84:	e8 4b 2c 00 00       	callq  116ad4 <z_object_find>
  113e89:	4c 89 e6             	mov    %r12,%rsi
  113e8c:	48 89 c7             	mov    %rax,%rdi
  113e8f:	e8 3d fa ff ff       	callq  1138d1 <z_obj_validation_check.constprop.0>
  113e94:	85 c0                	test   %eax,%eax
  113e96:	74 29                	je     113ec1 <z_mrsh_k_timer_remaining_ticks+0x59>
  113e98:	bf 23 f3 11 00       	mov    $0x11f323,%edi
  113e9d:	31 c0                	xor    %eax,%eax
  113e9f:	ba c0 c5 11 00       	mov    $0x11c5c0,%edx
  113ea4:	be 45 00 00 00       	mov    $0x45,%esi
  113ea9:	e8 18 f2 fe ff       	callq  1030c6 <z_log_minimal_printk>
  113eae:	48 8b 05 9b 48 01 00 	mov    0x1489b(%rip),%rax        # 128750 <_kernel+0x10>
  113eb5:	48 8b b8 40 01 00 00 	mov    0x140(%rax),%rdi
  113ebc:	e8 4c 5d ff ff       	callq  109c0d <arch_syscall_oops>
	return z_timeout_remaining(&timer->timeout);
  113ec1:	4c 89 e7             	mov    %r12,%rdi
  113ec4:	e8 e3 f1 ff ff       	callq  1130ac <z_timeout_remaining>
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	k_ticks_t ret = z_vrfy_k_timer_remaining_ticks(*(const struct k_timer **)&arg0)
;
	_current->syscall_frame = NULL;
  113ec9:	48 8b 15 80 48 01 00 	mov    0x14880(%rip),%rdx        # 128750 <_kernel+0x10>
  113ed0:	48 c7 82 40 01 00 00 	movq   $0x0,0x140(%rdx)
  113ed7:	00 00 00 00 
	return (uintptr_t) ret;
}
  113edb:	5a                   	pop    %rdx
  113edc:	41 5c                	pop    %r12
  113ede:	5d                   	pop    %rbp
  113edf:	c3                   	retq   

0000000000113ee0 <z_mrsh_k_timer_expires_ticks>:
#include <syscalls/kernel.h>

extern k_ticks_t z_vrfy_k_timer_expires_ticks(const struct k_timer * timer);
uintptr_t z_mrsh_k_timer_expires_ticks(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
  113ee0:	55                   	push   %rbp
  113ee1:	48 89 e5             	mov    %rsp,%rbp
  113ee4:	41 54                	push   %r12
  113ee6:	49 89 fc             	mov    %rdi,%r12
  113ee9:	51                   	push   %rcx
	_current->syscall_frame = ssf;
  113eea:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  113eee:	48 8b 05 5b 48 01 00 	mov    0x1485b(%rip),%rax        # 128750 <_kernel+0x10>
  113ef5:	48 89 90 40 01 00 00 	mov    %rdx,0x140(%rax)
#include <syscalls/k_timer_remaining_ticks_mrsh.c>

static inline k_ticks_t z_vrfy_k_timer_expires_ticks(
						const struct k_timer *timer)
{
	Z_OOPS(Z_SYSCALL_OBJ(timer, K_OBJ_TIMER));
  113efc:	e8 d3 2b 00 00       	callq  116ad4 <z_object_find>
  113f01:	4c 89 e6             	mov    %r12,%rsi
  113f04:	48 89 c7             	mov    %rax,%rdi
  113f07:	e8 c5 f9 ff ff       	callq  1138d1 <z_obj_validation_check.constprop.0>
  113f0c:	85 c0                	test   %eax,%eax
  113f0e:	74 29                	je     113f39 <z_mrsh_k_timer_expires_ticks+0x59>
  113f10:	bf 23 f3 11 00       	mov    $0x11f323,%edi
  113f15:	31 c0                	xor    %eax,%eax
  113f17:	ba a0 c5 11 00       	mov    $0x11c5a0,%edx
  113f1c:	be 45 00 00 00       	mov    $0x45,%esi
  113f21:	e8 a0 f1 fe ff       	callq  1030c6 <z_log_minimal_printk>
  113f26:	48 8b 05 23 48 01 00 	mov    0x14823(%rip),%rax        # 128750 <_kernel+0x10>
  113f2d:	48 8b b8 40 01 00 00 	mov    0x140(%rax),%rdi
  113f34:	e8 d4 5c ff ff       	callq  109c0d <arch_syscall_oops>
	return z_timeout_expires(&timer->timeout);
  113f39:	4c 89 e7             	mov    %r12,%rdi
  113f3c:	e8 2a f2 ff ff       	callq  11316b <z_timeout_expires>
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	k_ticks_t ret = z_vrfy_k_timer_expires_ticks(*(const struct k_timer **)&arg0)
;
	_current->syscall_frame = NULL;
  113f41:	48 8b 15 08 48 01 00 	mov    0x14808(%rip),%rdx        # 128750 <_kernel+0x10>
  113f48:	48 c7 82 40 01 00 00 	movq   $0x0,0x140(%rdx)
  113f4f:	00 00 00 00 
	return (uintptr_t) ret;
}
  113f53:	5a                   	pop    %rdx
  113f54:	41 5c                	pop    %r12
  113f56:	5d                   	pop    %rbp
  113f57:	c3                   	retq   

0000000000113f58 <z_mrsh_k_timer_user_data_get>:
#include <syscalls/kernel.h>

extern void * z_vrfy_k_timer_user_data_get(const struct k_timer * timer);
uintptr_t z_mrsh_k_timer_user_data_get(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
  113f58:	55                   	push   %rbp
  113f59:	48 89 e5             	mov    %rsp,%rbp
  113f5c:	53                   	push   %rbx
  113f5d:	48 89 fb             	mov    %rdi,%rbx
  113f60:	51                   	push   %rcx
	_current->syscall_frame = ssf;
  113f61:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  113f65:	48 8b 05 e4 47 01 00 	mov    0x147e4(%rip),%rax        # 128750 <_kernel+0x10>
  113f6c:	48 89 90 40 01 00 00 	mov    %rdx,0x140(%rax)
}
#include <syscalls/k_timer_expires_ticks_mrsh.c>

static inline void *z_vrfy_k_timer_user_data_get(const struct k_timer *timer)
{
	Z_OOPS(Z_SYSCALL_OBJ(timer, K_OBJ_TIMER));
  113f73:	e8 5c 2b 00 00       	callq  116ad4 <z_object_find>
  113f78:	48 89 de             	mov    %rbx,%rsi
  113f7b:	48 89 c7             	mov    %rax,%rdi
  113f7e:	e8 4e f9 ff ff       	callq  1138d1 <z_obj_validation_check.constprop.0>
  113f83:	85 c0                	test   %eax,%eax
  113f85:	74 29                	je     113fb0 <z_mrsh_k_timer_user_data_get+0x58>
  113f87:	bf 23 f3 11 00       	mov    $0x11f323,%edi
  113f8c:	31 c0                	xor    %eax,%eax
  113f8e:	ba 80 c5 11 00       	mov    $0x11c580,%edx
  113f93:	be 45 00 00 00       	mov    $0x45,%esi
  113f98:	e8 29 f1 fe ff       	callq  1030c6 <z_log_minimal_printk>
  113f9d:	48 8b 05 ac 47 01 00 	mov    0x147ac(%rip),%rax        # 128750 <_kernel+0x10>
  113fa4:	48 8b b8 40 01 00 00 	mov    0x140(%rax),%rdi
  113fab:	e8 5d 5c ff ff       	callq  109c0d <arch_syscall_oops>
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	void * ret = z_vrfy_k_timer_user_data_get(*(const struct k_timer **)&arg0)
;
	_current->syscall_frame = NULL;
  113fb0:	48 8b 15 99 47 01 00 	mov    0x14799(%rip),%rdx        # 128750 <_kernel+0x10>
	return timer->user_data;
  113fb7:	48 8b 43 50          	mov    0x50(%rbx),%rax
  113fbb:	48 c7 82 40 01 00 00 	movq   $0x0,0x140(%rdx)
  113fc2:	00 00 00 00 
	return (uintptr_t) ret;
}
  113fc6:	5a                   	pop    %rdx
  113fc7:	5b                   	pop    %rbx
  113fc8:	5d                   	pop    %rbp
  113fc9:	c3                   	retq   

0000000000113fca <z_mrsh_k_timer_user_data_set>:
#include <syscalls/kernel.h>

extern void z_vrfy_k_timer_user_data_set(struct k_timer * timer, void * user_data);
uintptr_t z_mrsh_k_timer_user_data_set(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
  113fca:	55                   	push   %rbp
	_current->syscall_frame = ssf;
  113fcb:	48 8b 05 7e 47 01 00 	mov    0x1477e(%rip),%rax        # 128750 <_kernel+0x10>
{
  113fd2:	48 89 e5             	mov    %rsp,%rbp
  113fd5:	41 54                	push   %r12
  113fd7:	49 89 f4             	mov    %rsi,%r12
	_current->syscall_frame = ssf;
  113fda:	48 8b 55 10          	mov    0x10(%rbp),%rdx
{
  113fde:	53                   	push   %rbx
  113fdf:	48 89 fb             	mov    %rdi,%rbx
	_current->syscall_frame = ssf;
  113fe2:	48 89 90 40 01 00 00 	mov    %rdx,0x140(%rax)
#include <syscalls/k_timer_user_data_get_mrsh.c>

static inline void z_vrfy_k_timer_user_data_set(struct k_timer *timer,
						void *user_data)
{
	Z_OOPS(Z_SYSCALL_OBJ(timer, K_OBJ_TIMER));
  113fe9:	e8 e6 2a 00 00       	callq  116ad4 <z_object_find>
  113fee:	48 89 de             	mov    %rbx,%rsi
  113ff1:	48 89 c7             	mov    %rax,%rdi
  113ff4:	e8 d8 f8 ff ff       	callq  1138d1 <z_obj_validation_check.constprop.0>
  113ff9:	85 c0                	test   %eax,%eax
  113ffb:	74 29                	je     114026 <z_mrsh_k_timer_user_data_set+0x5c>
  113ffd:	bf 23 f3 11 00       	mov    $0x11f323,%edi
  114002:	31 c0                	xor    %eax,%eax
  114004:	ba 60 c5 11 00       	mov    $0x11c560,%edx
  114009:	be 45 00 00 00       	mov    $0x45,%esi
  11400e:	e8 b3 f0 fe ff       	callq  1030c6 <z_log_minimal_printk>
  114013:	48 8b 05 36 47 01 00 	mov    0x14736(%rip),%rax        # 128750 <_kernel+0x10>
  11401a:	48 8b b8 40 01 00 00 	mov    0x140(%rax),%rdi
  114021:	e8 e7 5b ff ff       	callq  109c0d <arch_syscall_oops>
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	z_vrfy_k_timer_user_data_set(*(struct k_timer **)&arg0, *(void **)&arg1)
;
	_current->syscall_frame = NULL;
  114026:	48 8b 05 23 47 01 00 	mov    0x14723(%rip),%rax        # 128750 <_kernel+0x10>
	timer->user_data = user_data;
  11402d:	4c 89 63 50          	mov    %r12,0x50(%rbx)
  114031:	48 c7 80 40 01 00 00 	movq   $0x0,0x140(%rax)
  114038:	00 00 00 00 
	return 0;
}
  11403c:	31 c0                	xor    %eax,%eax
  11403e:	5b                   	pop    %rbx
  11403f:	41 5c                	pop    %r12
  114041:	5d                   	pop    %rbp
  114042:	c3                   	retq   

0000000000114043 <frame_mapped_set>:

/* Called after the frame is mapped in the arch layer, to update our
 * local ontology (and do some assertions while we're at it)
 */
static void frame_mapped_set(struct z_page_frame *pf, void *addr)
{
  114043:	55                   	push   %rbp
  114044:	48 89 e5             	mov    %rsp,%rbp
  114047:	41 54                	push   %r12
  114049:	49 89 f4             	mov    %rsi,%r12
  11404c:	53                   	push   %rbx
  11404d:	48 89 fb             	mov    %rdi,%rbx
	PF_ASSERT(pf, !z_page_frame_is_reserved(pf),
  114050:	f6 47 08 02          	testb  $0x2,0x8(%rdi)
  114054:	74 52                	je     1140a8 <frame_mapped_set+0x65>
  114056:	b9 65 01 00 00       	mov    $0x165,%ecx
  11405b:	ba 24 00 12 00       	mov    $0x120024,%edx
  114060:	be 44 00 12 00       	mov    $0x120044,%esi
  114065:	31 c0                	xor    %eax,%eax
  114067:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  11406c:	e8 87 c5 fe ff       	callq  1005f8 <printk>
	return (uintptr_t)((pf - z_page_frames) * CONFIG_MMU_PAGE_SIZE) +
  114071:	48 89 de             	mov    %rbx,%rsi
  114074:	bf 62 00 12 00       	mov    $0x120062,%edi
  114079:	48 b8 39 8e e3 38 8e 	movabs $0x8e38e38e38e38e39,%rax
  114080:	e3 38 8e 
  114083:	48 81 ee a0 c7 12 00 	sub    $0x12c7a0,%rsi
  11408a:	48 0f af f0          	imul   %rax,%rsi
  11408e:	31 c0                	xor    %eax,%eax
  114090:	48 c1 e6 0c          	shl    $0xc,%rsi
  114094:	e8 5f c5 fe ff       	callq  1005f8 <printk>
  114099:	be 65 01 00 00       	mov    $0x165,%esi
  11409e:	bf 24 00 12 00       	mov    $0x120024,%edi
  1140a3:	e8 f0 ea fe ff       	callq  102b98 <assert_post_action>
	return (pf->flags & Z_PAGE_FRAME_MAPPED) != 0U;
  1140a8:	8a 43 08             	mov    0x8(%rbx),%al
	/* We do allow multiple mappings for pinned page frames
	 * since we will never need to reverse map them.
	 * This is uncommon, use-cases are for things like the
	 * Zephyr equivalent of VSDOs
	 */
	PF_ASSERT(pf, !z_page_frame_is_mapped(pf) || z_page_frame_is_pinned(pf),
  1140ab:	a8 04                	test   $0x4,%al
  1140ad:	74 59                	je     114108 <frame_mapped_set+0xc5>
  1140af:	a8 01                	test   $0x1,%al
  1140b1:	75 55                	jne    114108 <frame_mapped_set+0xc5>
  1140b3:	b9 6d 01 00 00       	mov    $0x16d,%ecx
  1140b8:	ba 24 00 12 00       	mov    $0x120024,%edx
  1140bd:	be 9d 00 12 00       	mov    $0x12009d,%esi
  1140c2:	31 c0                	xor    %eax,%eax
  1140c4:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  1140c9:	e8 2a c5 fe ff       	callq  1005f8 <printk>
	return (uintptr_t)((pf - z_page_frames) * CONFIG_MMU_PAGE_SIZE) +
  1140ce:	48 89 de             	mov    %rbx,%rsi
  1140d1:	48 8b 13             	mov    (%rbx),%rdx
  1140d4:	bf d7 00 12 00       	mov    $0x1200d7,%edi
  1140d9:	48 b8 39 8e e3 38 8e 	movabs $0x8e38e38e38e38e39,%rax
  1140e0:	e3 38 8e 
  1140e3:	48 81 ee a0 c7 12 00 	sub    $0x12c7a0,%rsi
  1140ea:	48 0f af f0          	imul   %rax,%rsi
  1140ee:	31 c0                	xor    %eax,%eax
  1140f0:	48 c1 e6 0c          	shl    $0xc,%rsi
  1140f4:	e8 ff c4 fe ff       	callq  1005f8 <printk>
  1140f9:	be 6d 01 00 00       	mov    $0x16d,%esi
  1140fe:	bf 24 00 12 00       	mov    $0x120024,%edi
  114103:	e8 90 ea fe ff       	callq  102b98 <assert_post_action>
		 "non-pinned and already mapped to %p", pf->addr);

	pf->flags |= Z_PAGE_FRAME_MAPPED;
	pf->addr = addr;
  114108:	4c 89 23             	mov    %r12,(%rbx)
	pf->flags |= Z_PAGE_FRAME_MAPPED;
  11410b:	80 4b 08 04          	orb    $0x4,0x8(%rbx)
}
  11410f:	5b                   	pop    %rbx
  114110:	41 5c                	pop    %r12
  114112:	5d                   	pop    %rbp
  114113:	c3                   	retq   

0000000000114114 <z_assert_phys_aligned>:
	__ASSERT(phys % CONFIG_MMU_PAGE_SIZE == 0U,
  114114:	f7 c7 ff 0f 00 00    	test   $0xfff,%edi
  11411a:	74 47                	je     114163 <z_assert_phys_aligned+0x4f>
{
  11411c:	55                   	push   %rbp
	__ASSERT(phys % CONFIG_MMU_PAGE_SIZE == 0U,
  11411d:	ba 0f 01 12 00       	mov    $0x12010f,%edx
  114122:	b9 a0 00 00 00       	mov    $0xa0,%ecx
  114127:	be 37 01 12 00       	mov    $0x120137,%esi
{
  11412c:	48 89 e5             	mov    %rsp,%rbp
  11412f:	41 54                	push   %r12
  114131:	49 89 fc             	mov    %rdi,%r12
	__ASSERT(phys % CONFIG_MMU_PAGE_SIZE == 0U,
  114134:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
{
  114139:	50                   	push   %rax
	__ASSERT(phys % CONFIG_MMU_PAGE_SIZE == 0U,
  11413a:	31 c0                	xor    %eax,%eax
  11413c:	e8 b7 c4 fe ff       	callq  1005f8 <printk>
  114141:	4c 89 e6             	mov    %r12,%rsi
  114144:	bf 4b 01 12 00       	mov    $0x12014b,%edi
  114149:	31 c0                	xor    %eax,%eax
  11414b:	e8 a8 c4 fe ff       	callq  1005f8 <printk>
}
  114150:	5a                   	pop    %rdx
	__ASSERT(phys % CONFIG_MMU_PAGE_SIZE == 0U,
  114151:	be a0 00 00 00       	mov    $0xa0,%esi
}
  114156:	41 5c                	pop    %r12
	__ASSERT(phys % CONFIG_MMU_PAGE_SIZE == 0U,
  114158:	bf 0f 01 12 00       	mov    $0x12010f,%edi
}
  11415d:	5d                   	pop    %rbp
	__ASSERT(phys % CONFIG_MMU_PAGE_SIZE == 0U,
  11415e:	e9 35 ea fe ff       	jmpq   102b98 <assert_post_action>
  114163:	c3                   	retq   

0000000000114164 <z_phys_to_page_frame>:
{
  114164:	55                   	push   %rbp
  114165:	48 89 e5             	mov    %rsp,%rbp
  114168:	53                   	push   %rbx
  114169:	48 89 fb             	mov    %rdi,%rbx
  11416c:	51                   	push   %rcx
	z_assert_phys_aligned(phys);
  11416d:	e8 a2 ff ff ff       	callq  114114 <z_assert_phys_aligned>
	__ASSERT(z_is_page_frame(phys),
  114172:	48 81 fb ff ff ff 0f 	cmp    $0xfffffff,%rbx
  114179:	76 39                	jbe    1141b4 <z_phys_to_page_frame+0x50>
  11417b:	b9 bb 00 00 00       	mov    $0xbb,%ecx
  114180:	ba 0f 01 12 00       	mov    $0x12010f,%edx
  114185:	be 78 01 12 00       	mov    $0x120178,%esi
  11418a:	31 c0                	xor    %eax,%eax
  11418c:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  114191:	e8 62 c4 fe ff       	callq  1005f8 <printk>
  114196:	48 89 de             	mov    %rbx,%rsi
  114199:	bf 8e 01 12 00       	mov    $0x12018e,%edi
  11419e:	31 c0                	xor    %eax,%eax
  1141a0:	e8 53 c4 fe ff       	callq  1005f8 <printk>
  1141a5:	be bb 00 00 00       	mov    $0xbb,%esi
  1141aa:	bf 0f 01 12 00       	mov    $0x12010f,%edi
  1141af:	e8 e4 e9 fe ff       	callq  102b98 <assert_post_action>
	return &z_page_frames[(phys - Z_PHYS_RAM_START) /
  1141b4:	48 c1 eb 0c          	shr    $0xc,%rbx
			      CONFIG_MMU_PAGE_SIZE];
}
  1141b8:	5a                   	pop    %rdx
	return &z_page_frames[(phys - Z_PHYS_RAM_START) /
  1141b9:	48 8d 04 db          	lea    (%rbx,%rbx,8),%rax
}
  1141bd:	5b                   	pop    %rbx
  1141be:	5d                   	pop    %rbp
	return &z_page_frames[(phys - Z_PHYS_RAM_START) /
  1141bf:	48 05 a0 c7 12 00    	add    $0x12c7a0,%rax
}
  1141c5:	c3                   	retq   

00000000001141c6 <virt_region_alloc>:
{
  1141c6:	55                   	push   %rbp
  1141c7:	48 89 e5             	mov    %rsp,%rbp
  1141ca:	41 54                	push   %r12
  1141cc:	49 89 fc             	mov    %rdi,%r12
  1141cf:	48 83 ec 18          	sub    $0x18,%rsp
	if (unlikely(!virt_region_inited)) {
  1141d3:	80 3d 73 8c 0a 00 00 	cmpb   $0x0,0xa8c73(%rip)        # 1bce4d <virt_region_inited>
  1141da:	75 2a                	jne    114206 <virt_region_alloc+0x40>
		- POINTER_TO_UINT(vaddr) - size) / CONFIG_MMU_PAGE_SIZE;
  1141dc:	ba 00 00 00 20       	mov    $0x20000000,%edx
	num_bits /= CONFIG_MMU_PAGE_SIZE;
  1141e1:	be 00 60 6e 00       	mov    $0x6e6000,%esi
	(void)sys_bitarray_set_region(&virt_region_bitmap,
  1141e6:	bf c0 13 5e 00       	mov    $0x5e13c0,%edi
		- POINTER_TO_UINT(vaddr) - size) / CONFIG_MMU_PAGE_SIZE;
  1141eb:	48 81 ea 00 60 6e 00 	sub    $0x6e6000,%rdx
	num_bits /= CONFIG_MMU_PAGE_SIZE;
  1141f2:	48 c1 ee 0c          	shr    $0xc,%rsi
		- POINTER_TO_UINT(vaddr) - size) / CONFIG_MMU_PAGE_SIZE;
  1141f6:	48 c1 ea 0c          	shr    $0xc,%rdx
	(void)sys_bitarray_set_region(&virt_region_bitmap,
  1141fa:	e8 1e dc fe ff       	callq  101e1d <sys_bitarray_set_region>
	virt_region_inited = true;
  1141ff:	c6 05 47 8c 0a 00 01 	movb   $0x1,0xa8c47(%rip)        # 1bce4d <virt_region_inited>
	num_bits = size / CONFIG_MMU_PAGE_SIZE;
  114206:	4c 89 e6             	mov    %r12,%rsi
	ret = sys_bitarray_alloc(&virt_region_bitmap, num_bits, &offset);
  114209:	48 8d 55 e8          	lea    -0x18(%rbp),%rdx
  11420d:	bf c0 13 5e 00       	mov    $0x5e13c0,%edi
	num_bits = size / CONFIG_MMU_PAGE_SIZE;
  114212:	48 c1 ee 0c          	shr    $0xc,%rsi
	ret = sys_bitarray_alloc(&virt_region_bitmap, num_bits, &offset);
  114216:	e8 e0 d8 fe ff       	callq  101afb <sys_bitarray_alloc>
	if (ret != 0) {
  11421b:	85 c0                	test   %eax,%eax
  11421d:	74 16                	je     114235 <virt_region_alloc+0x6f>
		LOG_ERR("insufficient virtual address space (requested %zu)",
  11421f:	4c 89 e2             	mov    %r12,%rdx
  114222:	be 45 00 00 00       	mov    $0x45,%esi
  114227:	bf b3 01 12 00       	mov    $0x1201b3,%edi
  11422c:	31 c0                	xor    %eax,%eax
  11422e:	e8 93 ee fe ff       	callq  1030c6 <z_log_minimal_printk>
		return NULL;
  114233:	eb 28                	jmp    11425d <virt_region_alloc+0x97>
	dest_addr = virt_from_bitmap_offset(offset, size);
  114235:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
	       - (offset * CONFIG_MMU_PAGE_SIZE) - size;
  114239:	b8 00 00 02 00       	mov    $0x20000,%eax
  11423e:	48 29 d0             	sub    %rdx,%rax
  114241:	48 c1 e0 0c          	shl    $0xc,%rax
	return UINT_TO_POINTER(dest_addr);
  114245:	4c 29 e0             	sub    %r12,%rax
	if (dest_addr < POINTER_TO_UINT(Z_VIRT_REGION_START_ADDR)) {
  114248:	48 3d 00 60 6e 00    	cmp    $0x6e6000,%rax
  11424e:	73 0f                	jae    11425f <virt_region_alloc+0x99>
		(void)sys_bitarray_free(&virt_region_bitmap, size, offset);
  114250:	4c 89 e6             	mov    %r12,%rsi
  114253:	bf c0 13 5e 00       	mov    $0x5e13c0,%edi
  114258:	e8 58 da fe ff       	callq  101cb5 <sys_bitarray_free>
		return NULL;
  11425d:	31 c0                	xor    %eax,%eax
}
  11425f:	48 83 c4 18          	add    $0x18,%rsp
  114263:	41 5c                	pop    %r12
  114265:	5d                   	pop    %rbp
  114266:	c3                   	retq   

0000000000114267 <free_page_frame_list_put>:
{
  114267:	55                   	push   %rbp
  114268:	48 89 e5             	mov    %rsp,%rbp
  11426b:	53                   	push   %rbx
  11426c:	48 89 fb             	mov    %rdi,%rbx
  11426f:	52                   	push   %rdx
	PF_ASSERT(pf, z_page_frame_is_available(pf),
  114270:	80 7f 08 00          	cmpb   $0x0,0x8(%rdi)
  114274:	74 52                	je     1142c8 <free_page_frame_list_put+0x61>
  114276:	b9 4b 01 00 00       	mov    $0x14b,%ecx
  11427b:	ba 24 00 12 00       	mov    $0x120024,%edx
  114280:	be eb 01 12 00       	mov    $0x1201eb,%esi
  114285:	31 c0                	xor    %eax,%eax
  114287:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  11428c:	e8 67 c3 fe ff       	callq  1005f8 <printk>
	return (uintptr_t)((pf - z_page_frames) * CONFIG_MMU_PAGE_SIZE) +
  114291:	48 89 de             	mov    %rbx,%rsi
  114294:	bf 09 02 12 00       	mov    $0x120209,%edi
  114299:	48 b8 39 8e e3 38 8e 	movabs $0x8e38e38e38e38e39,%rax
  1142a0:	e3 38 8e 
  1142a3:	48 81 ee a0 c7 12 00 	sub    $0x12c7a0,%rsi
  1142aa:	48 0f af f0          	imul   %rax,%rsi
  1142ae:	31 c0                	xor    %eax,%eax
  1142b0:	48 c1 e6 0c          	shl    $0xc,%rsi
  1142b4:	e8 3f c3 fe ff       	callq  1005f8 <printk>
  1142b9:	be 4b 01 00 00       	mov    $0x14b,%esi
  1142be:	bf 24 00 12 00       	mov    $0x120024,%edi
  1142c3:	e8 d0 e8 fe ff       	callq  102b98 <assert_post_action>
	return list->tail;
  1142c8:	48 8b 05 69 8a 0a 00 	mov    0xa8a69(%rip),%rax        # 1bcd38 <free_page_frame_list+0x8>
	parent->next = child;
  1142cf:	48 c7 03 00 00 00 00 	movq   $0x0,(%rbx)
Z_GENLIST_APPEND(slist, snode)
  1142d6:	48 85 c0             	test   %rax,%rax
  1142d9:	75 10                	jne    1142eb <free_page_frame_list_put+0x84>
	list->tail = node;
  1142db:	48 89 1d 56 8a 0a 00 	mov    %rbx,0xa8a56(%rip)        # 1bcd38 <free_page_frame_list+0x8>
	list->head = node;
  1142e2:	48 89 1d 47 8a 0a 00 	mov    %rbx,0xa8a47(%rip)        # 1bcd30 <free_page_frame_list>
}
  1142e9:	eb 0a                	jmp    1142f5 <free_page_frame_list_put+0x8e>
	parent->next = child;
  1142eb:	48 89 18             	mov    %rbx,(%rax)
	list->tail = node;
  1142ee:	48 89 1d 43 8a 0a 00 	mov    %rbx,0xa8a43(%rip)        # 1bcd38 <free_page_frame_list+0x8>
	z_free_page_count++;
  1142f5:	48 ff 05 ec 8a 0a 00 	incq   0xa8aec(%rip)        # 1bcde8 <z_free_page_count>
}
  1142fc:	58                   	pop    %rax
  1142fd:	5b                   	pop    %rbx
  1142fe:	5d                   	pop    %rbp
  1142ff:	c3                   	retq   

0000000000114300 <z_phys_map>:
/* This may be called from arch early boot code before z_cstart() is invoked.
 * Data will be copied and BSS zeroed, but this must not rely on any
 * initialization functions being called prior to work correctly.
 */
void z_phys_map(uint8_t **virt_ptr, uintptr_t phys, size_t size, uint32_t flags)
{
  114300:	55                   	push   %rbp

	/* The actual mapped region must be page-aligned. Round down the
	 * physical address and pad the region size appropriately
	 */
	*aligned_addr = ROUND_DOWN(addr, align);
	addr_offset = addr - *aligned_addr;
  114301:	48 89 f0             	mov    %rsi,%rax
  114304:	25 ff 0f 00 00       	and    $0xfff,%eax
{
  114309:	48 89 e5             	mov    %rsp,%rbp
  11430c:	41 57                	push   %r15
  11430e:	49 89 f7             	mov    %rsi,%r15
  114311:	41 56                	push   %r14
	*aligned_addr = ROUND_DOWN(addr, align);
  114313:	49 89 f6             	mov    %rsi,%r14
{
  114316:	41 55                	push   %r13
	*aligned_addr = ROUND_DOWN(addr, align);
  114318:	49 81 e6 00 f0 ff ff 	and    $0xfffffffffffff000,%r14
{
  11431f:	49 89 d5             	mov    %rdx,%r13
  114322:	41 54                	push   %r12
	*aligned_size = ROUND_UP(size + addr_offset, align);
  114324:	4c 8d a4 10 ff 0f 00 	lea    0xfff(%rax,%rdx,1),%r12
  11432b:	00 
{
  11432c:	53                   	push   %rbx
  11432d:	48 83 ec 28          	sub    $0x28,%rsp
  114331:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  114335:	89 4d c4             	mov    %ecx,-0x3c(%rbp)
	addr_offset = addr - *aligned_addr;
  114338:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	__ASSERT(aligned_size != 0U, "0-length mapping at 0x%lx", aligned_phys);
  11433c:	49 81 e4 00 f0 ff ff 	and    $0xfffffffffffff000,%r12
  114343:	75 39                	jne    11437e <z_phys_map+0x7e>
  114345:	b9 8f 02 00 00       	mov    $0x28f,%ecx
  11434a:	ba 24 00 12 00       	mov    $0x120024,%edx
  11434f:	be a6 03 12 00       	mov    $0x1203a6,%esi
  114354:	31 c0                	xor    %eax,%eax
  114356:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  11435b:	e8 98 c2 fe ff       	callq  1005f8 <printk>
  114360:	4c 89 f6             	mov    %r14,%rsi
  114363:	bf b9 03 12 00       	mov    $0x1203b9,%edi
  114368:	31 c0                	xor    %eax,%eax
  11436a:	e8 89 c2 fe ff       	callq  1005f8 <printk>
  11436f:	be 8f 02 00 00       	mov    $0x28f,%esi
  114374:	bf 24 00 12 00       	mov    $0x120024,%edi
  114379:	e8 1a e8 fe ff       	callq  102b98 <assert_post_action>
	__ASSERT(aligned_phys < (aligned_phys + (aligned_size - 1)),
  11437e:	4b 8d 44 34 ff       	lea    -0x1(%r12,%r14,1),%rax
  114383:	4c 39 f0             	cmp    %r14,%rax
  114386:	77 3c                	ja     1143c4 <z_phys_map+0xc4>
  114388:	b9 90 02 00 00       	mov    $0x290,%ecx
  11438d:	ba 24 00 12 00       	mov    $0x120024,%edx
  114392:	be d5 03 12 00       	mov    $0x1203d5,%esi
  114397:	31 c0                	xor    %eax,%eax
  114399:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  11439e:	e8 55 c2 fe ff       	callq  1005f8 <printk>
  1143a3:	4c 89 f6             	mov    %r14,%rsi
  1143a6:	bf 08 04 12 00       	mov    $0x120408,%edi
  1143ab:	4c 89 e2             	mov    %r12,%rdx
  1143ae:	31 c0                	xor    %eax,%eax
  1143b0:	e8 43 c2 fe ff       	callq  1005f8 <printk>
  1143b5:	be 90 02 00 00       	mov    $0x290,%esi
  1143ba:	bf 24 00 12 00       	mov    $0x120024,%edi
  1143bf:	e8 d4 e7 fe ff       	callq  102b98 <assert_post_action>
  1143c4:	9c                   	pushfq 
  1143c5:	fa                   	cli    
  1143c6:	8f 45 b0             	popq   -0x50(%rbp)
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  1143c9:	bf f0 cd 1b 00       	mov    $0x1bcdf0,%edi
  1143ce:	e8 a6 94 ff ff       	callq  10d879 <z_spin_lock_valid>
  1143d3:	84 c0                	test   %al,%al
  1143d5:	75 39                	jne    114410 <z_phys_map+0x110>
  1143d7:	b9 8e 00 00 00       	mov    $0x8e,%ecx
  1143dc:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  1143e1:	be fd d1 11 00       	mov    $0x11d1fd,%esi
  1143e6:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  1143eb:	e8 08 c2 fe ff       	callq  1005f8 <printk>
  1143f0:	be f0 cd 1b 00       	mov    $0x1bcdf0,%esi
  1143f5:	bf 12 d2 11 00       	mov    $0x11d212,%edi
  1143fa:	31 c0                	xor    %eax,%eax
  1143fc:	e8 f7 c1 fe ff       	callq  1005f8 <printk>
  114401:	be 8e 00 00 00       	mov    $0x8e,%esi
  114406:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  11440b:	e8 88 e7 fe ff       	callq  102b98 <assert_post_action>
	z_spin_lock_set_owner(l);
  114410:	bf f0 cd 1b 00       	mov    $0x1bcdf0,%edi
  114415:	e8 a3 94 ff ff       	callq  10d8bd <z_spin_lock_set_owner>
	dest_addr = virt_region_alloc(aligned_size);
  11441a:	4c 89 e7             	mov    %r12,%rdi
  11441d:	e8 a4 fd ff ff       	callq  1141c6 <virt_region_alloc>
  114422:	48 89 c3             	mov    %rax,%rbx
	if (!dest_addr) {
  114425:	48 85 c0             	test   %rax,%rax
  114428:	75 24                	jne    11444e <z_phys_map+0x14e>
	LOG_ERR("memory mapping 0x%lx (size %zu, flags 0x%x) failed",
  11442a:	44 8b 45 c4          	mov    -0x3c(%rbp),%r8d
  11442e:	4c 89 e9             	mov    %r13,%rcx
  114431:	4c 89 fa             	mov    %r15,%rdx
  114434:	be 45 00 00 00       	mov    $0x45,%esi
  114439:	bf 3b 04 12 00       	mov    $0x12043b,%edi
  11443e:	31 c0                	xor    %eax,%eax
  114440:	e8 81 ec fe ff       	callq  1030c6 <z_log_minimal_printk>
	k_panic();
  114445:	48 c7 c0 04 00 00 00 	mov    $0x4,%rax
  11444c:	cd 20                	int    $0x20
	__ASSERT((uintptr_t)dest_addr <
  11444e:	4a 8d 44 28 ff       	lea    -0x1(%rax,%r13,1),%rax
  114453:	48 39 c3             	cmp    %rax,%rbx
  114456:	72 3c                	jb     114494 <z_phys_map+0x194>
  114458:	b9 9c 02 00 00       	mov    $0x29c,%ecx
  11445d:	ba 24 00 12 00       	mov    $0x120024,%edx
  114462:	be 73 04 12 00       	mov    $0x120473,%esi
  114467:	31 c0                	xor    %eax,%eax
  114469:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  11446e:	e8 85 c1 fe ff       	callq  1005f8 <printk>
  114473:	48 89 de             	mov    %rbx,%rsi
  114476:	bf ae 04 12 00       	mov    $0x1204ae,%edi
  11447b:	4c 89 ea             	mov    %r13,%rdx
  11447e:	31 c0                	xor    %eax,%eax
  114480:	e8 73 c1 fe ff       	callq  1005f8 <printk>
  114485:	be 9c 02 00 00       	mov    $0x29c,%esi
  11448a:	bf 24 00 12 00       	mov    $0x120024,%edi
  11448f:	e8 04 e7 fe ff       	callq  102b98 <assert_post_action>
	arch_mem_map(dest_addr, aligned_phys, aligned_size, flags);
  114494:	8b 4d c4             	mov    -0x3c(%rbp),%ecx
  114497:	48 89 df             	mov    %rbx,%rdi
  11449a:	4c 89 e2             	mov    %r12,%rdx
  11449d:	4c 89 f6             	mov    %r14,%rsi
  1144a0:	e8 42 4e ff ff       	callq  1092e7 <arch_mem_map>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  1144a5:	bf f0 cd 1b 00       	mov    $0x1bcdf0,%edi
  1144aa:	e8 ea 93 ff ff       	callq  10d899 <z_spin_unlock_valid>
  1144af:	84 c0                	test   %al,%al
  1144b1:	75 39                	jne    1144ec <z_phys_map+0x1ec>
  1144b3:	b9 b9 00 00 00       	mov    $0xb9,%ecx
  1144b8:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  1144bd:	be 41 d2 11 00       	mov    $0x11d241,%esi
  1144c2:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  1144c7:	e8 2c c1 fe ff       	callq  1005f8 <printk>
  1144cc:	be f0 cd 1b 00       	mov    $0x1bcdf0,%esi
  1144d1:	bf 58 d2 11 00       	mov    $0x11d258,%edi
  1144d6:	31 c0                	xor    %eax,%eax
  1144d8:	e8 1b c1 fe ff       	callq  1005f8 <printk>
  1144dd:	be b9 00 00 00       	mov    $0xb9,%esi
  1144e2:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  1144e7:	e8 ac e6 fe ff       	callq  102b98 <assert_post_action>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  1144ec:	0f ba 65 b0 09       	btl    $0x9,-0x50(%rbp)
  1144f1:	73 01                	jae    1144f4 <z_phys_map+0x1f4>
		__asm__ volatile ("sti" ::: "memory");
  1144f3:	fb                   	sti    
	*virt_ptr = dest_addr + addr_offset;
  1144f4:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  1144f8:	48 03 5d c8          	add    -0x38(%rbp),%rbx
  1144fc:	48 89 18             	mov    %rbx,(%rax)
}
  1144ff:	48 83 c4 28          	add    $0x28,%rsp
  114503:	5b                   	pop    %rbx
  114504:	41 5c                	pop    %r12
  114506:	41 5d                	pop    %r13
  114508:	41 5e                	pop    %r14
  11450a:	41 5f                	pop    %r15
  11450c:	5d                   	pop    %rbp
  11450d:	c3                   	retq   

000000000011450e <k_mem_region_align>:
{
  11450e:	49 89 c9             	mov    %rcx,%r9
	*aligned_addr = ROUND_DOWN(addr, align);
  114511:	4c 89 c1             	mov    %r8,%rcx
{
  114514:	48 89 d0             	mov    %rdx,%rax
	*aligned_addr = ROUND_DOWN(addr, align);
  114517:	48 f7 d9             	neg    %rcx
  11451a:	48 89 ca             	mov    %rcx,%rdx
  11451d:	48 21 c2             	and    %rax,%rdx
  114520:	48 89 17             	mov    %rdx,(%rdi)
	addr_offset = addr - *aligned_addr;
  114523:	48 29 d0             	sub    %rdx,%rax
	*aligned_size = ROUND_UP(size + addr_offset, align);
  114526:	4b 8d 54 08 ff       	lea    -0x1(%r8,%r9,1),%rdx
  11452b:	48 01 c2             	add    %rax,%rdx
  11452e:	48 21 ca             	and    %rcx,%rdx
  114531:	48 89 16             	mov    %rdx,(%rsi)

	return addr_offset;
}
  114534:	c3                   	retq   

0000000000114535 <z_mem_manage_init>:
	}
}
#endif /* CONFIG_LINKER_USE_BOOT_SECTION) || CONFIG_LINKER_USE_PINNED_SECTION */

void z_mem_manage_init(void)
{
  114535:	55                   	push   %rbp
  114536:	48 89 e5             	mov    %rsp,%rbp
  114539:	41 55                	push   %r13
  11453b:	41 54                	push   %r12
  11453d:	53                   	push   %rbx
  11453e:	52                   	push   %rdx
  11453f:	9c                   	pushfq 
  114540:	fa                   	cli    
  114541:	41 5d                	pop    %r13
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  114543:	bf f0 cd 1b 00       	mov    $0x1bcdf0,%edi
  114548:	e8 2c 93 ff ff       	callq  10d879 <z_spin_lock_valid>
  11454d:	84 c0                	test   %al,%al
  11454f:	75 39                	jne    11458a <z_mem_manage_init+0x55>
  114551:	b9 8e 00 00 00       	mov    $0x8e,%ecx
  114556:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  11455b:	be fd d1 11 00       	mov    $0x11d1fd,%esi
  114560:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  114565:	e8 8e c0 fe ff       	callq  1005f8 <printk>
  11456a:	be f0 cd 1b 00       	mov    $0x1bcdf0,%esi
  11456f:	bf 12 d2 11 00       	mov    $0x11d212,%edi
  114574:	31 c0                	xor    %eax,%eax
  114576:	e8 7d c0 fe ff       	callq  1005f8 <printk>
  11457b:	be 8e 00 00 00       	mov    $0x8e,%esi
  114580:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  114585:	e8 0e e6 fe ff       	callq  102b98 <assert_post_action>
	z_spin_lock_set_owner(l);
  11458a:	bf f0 cd 1b 00       	mov    $0x1bcdf0,%edi

#ifdef CONFIG_LINKER_GENERIC_SECTIONS_PRESENT_AT_BOOT
	/* All pages composing the Zephyr image are mapped at boot in a
	 * predictable way. This can change at runtime.
	 */
	VIRT_FOREACH(Z_KERNEL_VIRT_START, Z_KERNEL_VIRT_SIZE, addr)
  11458f:	bb 00 00 10 00       	mov    $0x100000,%ebx
  114594:	e8 24 93 ff ff       	callq  10d8bd <z_spin_lock_set_owner>
	list->head = NULL;
  114599:	48 c7 05 8c 87 0a 00 	movq   $0x0,0xa878c(%rip)        # 1bcd30 <free_page_frame_list>
  1145a0:	00 00 00 00 
	list->tail = NULL;
  1145a4:	48 c7 05 89 87 0a 00 	movq   $0x0,0xa8789(%rip)        # 1bcd38 <free_page_frame_list+0x8>
  1145ab:	00 00 00 00 
	arch_reserved_pages_update();
  1145af:	e8 33 52 ff ff       	callq  1097e7 <arch_reserved_pages_update>
	VIRT_FOREACH(Z_KERNEL_VIRT_START, Z_KERNEL_VIRT_SIZE, addr)
  1145b4:	48 81 fb 00 60 6e 00 	cmp    $0x6e6000,%rbx
  1145bb:	73 25                	jae    1145e2 <z_mem_manage_init+0xad>
	{
		pf = z_phys_to_page_frame(Z_BOOT_VIRT_TO_PHYS(addr));
  1145bd:	48 89 df             	mov    %rbx,%rdi
  1145c0:	e8 9f fb ff ff       	callq  114164 <z_phys_to_page_frame>
		frame_mapped_set(pf, addr);
  1145c5:	48 89 de             	mov    %rbx,%rsi
	VIRT_FOREACH(Z_KERNEL_VIRT_START, Z_KERNEL_VIRT_SIZE, addr)
  1145c8:	48 81 c3 00 10 00 00 	add    $0x1000,%rbx
		pf = z_phys_to_page_frame(Z_BOOT_VIRT_TO_PHYS(addr));
  1145cf:	49 89 c4             	mov    %rax,%r12
		frame_mapped_set(pf, addr);
  1145d2:	48 89 c7             	mov    %rax,%rdi
  1145d5:	e8 69 fa ff ff       	callq  114043 <frame_mapped_set>
		 * code/data pages which are pinned in memory and
		 * may not be evicted. This will contain critical CPU data
		 * structures, and any code used to perform page fault
		 * handling, page-ins, etc.
		 */
		pf->flags |= Z_PAGE_FRAME_PINNED;
  1145da:	41 80 4c 24 08 01    	orb    $0x1,0x8(%r12)
	VIRT_FOREACH(Z_KERNEL_VIRT_START, Z_KERNEL_VIRT_SIZE, addr)
  1145e0:	eb d2                	jmp    1145b4 <z_mem_manage_init+0x7f>
#endif

	/* Any remaining pages that aren't mapped, reserved, or pinned get
	 * added to the free pages list
	 */
	Z_PAGE_FRAME_FOREACH(phys, pf) {
  1145e2:	bb a0 c7 12 00       	mov    $0x12c7a0,%ebx
		if (z_page_frame_is_available(pf)) {
  1145e7:	80 7b 08 00          	cmpb   $0x0,0x8(%rbx)
  1145eb:	75 08                	jne    1145f5 <z_mem_manage_init+0xc0>
			free_page_frame_list_put(pf);
  1145ed:	48 89 df             	mov    %rbx,%rdi
  1145f0:	e8 72 fc ff ff       	callq  114267 <free_page_frame_list_put>
	Z_PAGE_FRAME_FOREACH(phys, pf) {
  1145f5:	48 83 c3 09          	add    $0x9,%rbx
  1145f9:	48 81 fb a0 c7 1b 00 	cmp    $0x1bc7a0,%rbx
  114600:	75 e5                	jne    1145e7 <z_mem_manage_init+0xb2>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  114602:	bf f0 cd 1b 00       	mov    $0x1bcdf0,%edi
#endif
	k_mem_paging_backing_store_init();
	k_mem_paging_eviction_init();
#endif
#if __ASSERT_ON
	page_frames_initialized = true;
  114607:	c6 05 40 88 0a 00 01 	movb   $0x1,0xa8840(%rip)        # 1bce4e <page_frames_initialized>
  11460e:	e8 86 92 ff ff       	callq  10d899 <z_spin_unlock_valid>
  114613:	84 c0                	test   %al,%al
  114615:	75 39                	jne    114650 <z_mem_manage_init+0x11b>
  114617:	b9 b9 00 00 00       	mov    $0xb9,%ecx
  11461c:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  114621:	be 41 d2 11 00       	mov    $0x11d241,%esi
  114626:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  11462b:	e8 c8 bf fe ff       	callq  1005f8 <printk>
  114630:	be f0 cd 1b 00       	mov    $0x1bcdf0,%esi
  114635:	bf 58 d2 11 00       	mov    $0x11d258,%edi
  11463a:	31 c0                	xor    %eax,%eax
  11463c:	e8 b7 bf fe ff       	callq  1005f8 <printk>
  114641:	be b9 00 00 00       	mov    $0xb9,%esi
  114646:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  11464b:	e8 48 e5 fe ff       	callq  102b98 <assert_post_action>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  114650:	41 0f ba e5 09       	bt     $0x9,%r13d
  114655:	73 01                	jae    114658 <z_mem_manage_init+0x123>
		__asm__ volatile ("sti" ::: "memory");
  114657:	fb                   	sti    
	 * and the BSS pages can be brought into physical
	 * memory to be cleared.
	 */
	z_bss_zero();
#endif
}
  114658:	58                   	pop    %rax
  114659:	5b                   	pop    %rbx
  11465a:	41 5c                	pop    %r12
  11465c:	41 5d                	pop    %r13
  11465e:	5d                   	pop    %rbp
  11465f:	c3                   	retq   

0000000000114660 <z_mem_manage_boot_finish>:
	/* At the end of boot process, unpin the boot sections
	 * as they don't need to be in memory all the time anymore.
	 */
	mark_linker_section_pinned(lnkr_boot_start, lnkr_boot_end, false);
#endif
}
  114660:	c3                   	retq   

0000000000114661 <z_obj_validation_check>:
{
  114661:	55                   	push   %rbp
  114662:	48 89 e5             	mov    %rsp,%rbp
  114665:	41 57                	push   %r15
  114667:	49 89 f7             	mov    %rsi,%r15
  11466a:	41 56                	push   %r14
  11466c:	41 89 d6             	mov    %edx,%r14d
  11466f:	89 ca                	mov    %ecx,%edx
  114671:	41 55                	push   %r13
	ret = z_object_validate(ko, otype, init);
  114673:	44 89 f6             	mov    %r14d,%esi
{
  114676:	49 89 fd             	mov    %rdi,%r13
  114679:	48 83 ec 18          	sub    $0x18,%rsp
	ret = z_object_validate(ko, otype, init);
  11467d:	e8 ea 28 00 00       	callq  116f6c <z_object_validate>
	if (ret != 0) {
  114682:	85 c0                	test   %eax,%eax
  114684:	74 16                	je     11469c <z_obj_validation_check+0x3b>
		z_dump_object_error(ret, obj, ko, otype);
  114686:	89 c7                	mov    %eax,%edi
  114688:	44 89 f1             	mov    %r14d,%ecx
  11468b:	4c 89 ea             	mov    %r13,%rdx
  11468e:	4c 89 fe             	mov    %r15,%rsi
  114691:	89 45 dc             	mov    %eax,-0x24(%rbp)
  114694:	e8 88 27 00 00       	callq  116e21 <z_dump_object_error>
  114699:	8b 45 dc             	mov    -0x24(%rbp),%eax
}
  11469c:	48 83 c4 18          	add    $0x18,%rsp
  1146a0:	41 5d                	pop    %r13
  1146a2:	41 5e                	pop    %r14
  1146a4:	41 5f                	pop    %r15
  1146a6:	5d                   	pop    %rbp
  1146a7:	c3                   	retq   

00000000001146a8 <add_event>:
	return p ? CONTAINER_OF(p, struct k_thread, poller) : NULL;
}

static inline void add_event(sys_dlist_t *events, struct k_poll_event *event,
			     struct z_poller *poller)
{
  1146a8:	55                   	push   %rbp
  1146a9:	48 89 e5             	mov    %rsp,%rbp
  1146ac:	41 56                	push   %r14
  1146ae:	41 55                	push   %r13
  1146b0:	41 54                	push   %r12
  1146b2:	49 89 f4             	mov    %rsi,%r12
  1146b5:	53                   	push   %rbx
  1146b6:	48 89 fb             	mov    %rdi,%rbx
	return sys_dlist_is_empty(list) ? NULL : list->tail;
  1146b9:	48 8b 47 08          	mov    0x8(%rdi),%rax
  1146bd:	48 3b 3f             	cmp    (%rdi),%rdi
  1146c0:	74 3d                	je     1146ff <add_event+0x57>
	struct k_poll_event *pending;

	pending = (struct k_poll_event *)sys_dlist_peek_tail(events);
	if ((pending == NULL) ||
  1146c2:	48 85 c0             	test   %rax,%rax
  1146c5:	74 38                	je     1146ff <add_event+0x57>
  1146c7:	49 89 d6             	mov    %rdx,%r14
	return p ? CONTAINER_OF(p, struct k_thread, poller) : NULL;
  1146ca:	48 85 d2             	test   %rdx,%rdx
  1146cd:	74 07                	je     1146d6 <add_event+0x2e>
  1146cf:	49 81 ee a8 00 00 00 	sub    $0xa8,%r14
	    (z_sched_prio_cmp(poller_thread(pending->poller), poller_thread(poller)) > 0)) {
  1146d6:	48 8b 78 10          	mov    0x10(%rax),%rdi
	return p ? CONTAINER_OF(p, struct k_thread, poller) : NULL;
  1146da:	48 85 ff             	test   %rdi,%rdi
  1146dd:	74 07                	je     1146e6 <add_event+0x3e>
  1146df:	48 81 ef a8 00 00 00 	sub    $0xa8,%rdi
	    (z_sched_prio_cmp(poller_thread(pending->poller), poller_thread(poller)) > 0)) {
  1146e6:	4c 89 f6             	mov    %r14,%rsi
  1146e9:	e8 ef c0 ff ff       	callq  1107dd <z_sched_prio_cmp>
	if ((pending == NULL) ||
  1146ee:	85 c0                	test   %eax,%eax
  1146f0:	7f 0d                	jg     1146ff <add_event+0x57>
	return list->head == list;
  1146f2:	4c 8b 2b             	mov    (%rbx),%r13
		sys_dlist_append(events, &event->_node);
		return;
	}

	SYS_DLIST_FOR_EACH_CONTAINER (events, pending, _node) {
  1146f5:	4d 85 ed             	test   %r13,%r13
  1146f8:	74 05                	je     1146ff <add_event+0x57>
  1146fa:	4c 39 eb             	cmp    %r13,%rbx
  1146fd:	75 16                	jne    114715 <add_event+0x6d>
	sys_dnode_t *const tail = list->tail;
  1146ff:	48 8b 43 08          	mov    0x8(%rbx),%rax
	node->next = list;
  114703:	49 89 1c 24          	mov    %rbx,(%r12)
	node->prev = tail;
  114707:	49 89 44 24 08       	mov    %rax,0x8(%r12)
	tail->next = node;
  11470c:	4c 89 20             	mov    %r12,(%rax)
	list->tail = node;
  11470f:	4c 89 63 08          	mov    %r12,0x8(%rbx)
}
  114713:	eb 41                	jmp    114756 <add_event+0xae>
		if (z_sched_prio_cmp(poller_thread(poller), poller_thread(pending->poller)) > 0) {
  114715:	49 8b 75 10          	mov    0x10(%r13),%rsi
	return p ? CONTAINER_OF(p, struct k_thread, poller) : NULL;
  114719:	48 85 f6             	test   %rsi,%rsi
  11471c:	74 07                	je     114725 <add_event+0x7d>
  11471e:	48 81 ee a8 00 00 00 	sub    $0xa8,%rsi
		if (z_sched_prio_cmp(poller_thread(poller), poller_thread(pending->poller)) > 0) {
  114725:	4c 89 f7             	mov    %r14,%rdi
  114728:	e8 b0 c0 ff ff       	callq  1107dd <z_sched_prio_cmp>
  11472d:	85 c0                	test   %eax,%eax
  11472f:	7e 16                	jle    114747 <add_event+0x9f>
	sys_dnode_t *const prev = successor->prev;
  114731:	49 8b 45 08          	mov    0x8(%r13),%rax
	node->next = successor;
  114735:	4d 89 2c 24          	mov    %r13,(%r12)
	node->prev = prev;
  114739:	49 89 44 24 08       	mov    %rax,0x8(%r12)
	prev->next = node;
  11473e:	4c 89 20             	mov    %r12,(%rax)
	successor->prev = node;
  114741:	4d 89 65 08          	mov    %r12,0x8(%r13)
			sys_dlist_insert(&pending->_node, &event->_node);
			return;
  114745:	eb 0f                	jmp    114756 <add_event+0xae>
	return (node == list->tail) ? NULL : node->next;
  114747:	4c 3b 6b 08          	cmp    0x8(%rbx),%r13
  11474b:	74 b2                	je     1146ff <add_event+0x57>
  11474d:	4d 8b 6d 00          	mov    0x0(%r13),%r13
	SYS_DLIST_FOR_EACH_CONTAINER (events, pending, _node) {
  114751:	4d 85 ed             	test   %r13,%r13
  114754:	eb a7                	jmp    1146fd <add_event+0x55>
		}
	}

	sys_dlist_append(events, &event->_node);
}
  114756:	5b                   	pop    %rbx
  114757:	41 5c                	pop    %r12
  114759:	41 5d                	pop    %r13
  11475b:	41 5e                	pop    %r14
  11475d:	5d                   	pop    %rbp
  11475e:	c3                   	retq   

000000000011475f <register_events>:
	event->state |= state;
}

static inline int register_events(struct k_poll_event *events, int num_events,
				  struct z_poller *poller, bool just_check)
{
  11475f:	55                   	push   %rbp
  114760:	48 89 e5             	mov    %rsp,%rbp
  114763:	41 57                	push   %r15
  114765:	49 89 ff             	mov    %rdi,%r15
  114768:	41 56                	push   %r14
  11476a:	41 89 ce             	mov    %ecx,%r14d
  11476d:	41 55                	push   %r13
	int events_registered = 0;

	for (int ii = 0; ii < num_events; ii++) {
  11476f:	45 31 ed             	xor    %r13d,%r13d
{
  114772:	41 54                	push   %r12
	int events_registered = 0;
  114774:	45 31 e4             	xor    %r12d,%r12d
{
  114777:	53                   	push   %rbx
  114778:	48 89 d3             	mov    %rdx,%rbx
  11477b:	48 83 ec 18          	sub    $0x18,%rsp
  11477f:	89 75 cc             	mov    %esi,-0x34(%rbp)
	for (int ii = 0; ii < num_events; ii++) {
  114782:	44 3b 6d cc          	cmp    -0x34(%rbp),%r13d
  114786:	0f 8d 12 03 00 00    	jge    114a9e <register_events+0x33f>
  11478c:	9c                   	pushfq 
  11478d:	fa                   	cli    
  11478e:	8f 45 c0             	popq   -0x40(%rbp)
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  114791:	bf f8 cd 1b 00       	mov    $0x1bcdf8,%edi
  114796:	e8 de 90 ff ff       	callq  10d879 <z_spin_lock_valid>
  11479b:	84 c0                	test   %al,%al
  11479d:	75 39                	jne    1147d8 <register_events+0x79>
  11479f:	b9 8e 00 00 00       	mov    $0x8e,%ecx
  1147a4:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  1147a9:	be fd d1 11 00       	mov    $0x11d1fd,%esi
  1147ae:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  1147b3:	e8 40 be fe ff       	callq  1005f8 <printk>
  1147b8:	be f8 cd 1b 00       	mov    $0x1bcdf8,%esi
  1147bd:	bf 12 d2 11 00       	mov    $0x11d212,%edi
  1147c2:	31 c0                	xor    %eax,%eax
  1147c4:	e8 2f be fe ff       	callq  1005f8 <printk>
  1147c9:	be 8e 00 00 00       	mov    $0x8e,%esi
  1147ce:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  1147d3:	e8 c0 e3 fe ff       	callq  102b98 <assert_post_action>
	z_spin_lock_set_owner(l);
  1147d8:	bf f8 cd 1b 00       	mov    $0x1bcdf8,%edi
  1147dd:	e8 db 90 ff ff       	callq  10d8bd <z_spin_lock_set_owner>
	switch (event->type) {
  1147e2:	41 8a 47 19          	mov    0x19(%r15),%al
  1147e6:	83 e0 1f             	and    $0x1f,%eax
  1147e9:	3c 08                	cmp    $0x8,%al
  1147eb:	77 59                	ja     114846 <register_events+0xe7>
  1147ed:	0f b6 c0             	movzbl %al,%eax
  1147f0:	ff 24 c5 80 cd 11 00 	jmpq   *0x11cd80(,%rax,8)
		if (k_sem_count_get(event->sem) > 0U) {
  1147f7:	49 8b 47 20          	mov    0x20(%r15),%rax
  1147fb:	83 78 10 00          	cmpl   $0x0,0x10(%rax)
  1147ff:	0f 84 ad 00 00 00    	je     1148b2 <register_events+0x153>
			*state = K_POLL_STATE_SEM_AVAILABLE;
  114805:	b9 02 00 00 00       	mov    $0x2,%ecx
  11480a:	eb 79                	jmp    114885 <register_events+0x126>
		if (!k_queue_is_empty(event->queue)) {
  11480c:	49 8b 47 20          	mov    0x20(%r15),%rax
  114810:	48 83 38 00          	cmpq   $0x0,(%rax)
			*state = K_POLL_STATE_FIFO_DATA_AVAILABLE;
  114814:	b9 04 00 00 00       	mov    $0x4,%ecx
		if (!k_queue_is_empty(event->queue)) {
  114819:	75 6a                	jne    114885 <register_events+0x126>
  11481b:	e9 92 00 00 00       	jmpq   1148b2 <register_events+0x153>
		if (event->signal->signaled != 0U) {
  114820:	49 8b 47 20          	mov    0x20(%r15),%rax
  114824:	83 78 10 00          	cmpl   $0x0,0x10(%rax)
  114828:	0f 84 84 00 00 00    	je     1148b2 <register_events+0x153>
			*state = K_POLL_STATE_SIGNALED;
  11482e:	b9 01 00 00 00       	mov    $0x1,%ecx
  114833:	eb 50                	jmp    114885 <register_events+0x126>
		if (event->msgq->used_msgs > 0) {
  114835:	49 8b 47 20          	mov    0x20(%r15),%rax
  114839:	83 78 48 00          	cmpl   $0x0,0x48(%rax)
  11483d:	74 73                	je     1148b2 <register_events+0x153>
			*state = K_POLL_STATE_MSGQ_DATA_AVAILABLE;
  11483f:	b9 10 00 00 00       	mov    $0x10,%ecx
  114844:	eb 3f                	jmp    114885 <register_events+0x126>
		__ASSERT(false, "invalid event type (0x%x)\n", event->type);
  114846:	b9 5a 00 00 00       	mov    $0x5a,%ecx
  11484b:	ba dd 04 12 00       	mov    $0x1204dd,%edx
  114850:	31 c0                	xor    %eax,%eax
  114852:	be cb f4 11 00       	mov    $0x11f4cb,%esi
  114857:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  11485c:	e8 97 bd fe ff       	callq  1005f8 <printk>
  114861:	41 8a 77 19          	mov    0x19(%r15),%sil
  114865:	bf fe 04 12 00       	mov    $0x1204fe,%edi
  11486a:	31 c0                	xor    %eax,%eax
  11486c:	83 e6 1f             	and    $0x1f,%esi
  11486f:	e8 84 bd fe ff       	callq  1005f8 <printk>
  114874:	be 5a 00 00 00       	mov    $0x5a,%esi
  114879:	bf dd 04 12 00       	mov    $0x1204dd,%edi
  11487e:	e8 15 e3 fe ff       	callq  102b98 <assert_post_action>
		break;
  114883:	eb 2d                	jmp    1148b2 <register_events+0x153>
	event->state |= state;
  114885:	41 8b 57 18          	mov    0x18(%r15),%edx
	event->poller = NULL;
  114889:	49 c7 47 10 00 00 00 	movq   $0x0,0x10(%r15)
  114890:	00 
	event->state |= state;
  114891:	89 d0                	mov    %edx,%eax
  114893:	81 e2 ff 1f f8 ff    	and    $0xfff81fff,%edx
  114899:	c1 e8 0d             	shr    $0xd,%eax
  11489c:	83 e0 3f             	and    $0x3f,%eax
  11489f:	09 c8                	or     %ecx,%eax
  1148a1:	c1 e0 0d             	shl    $0xd,%eax
  1148a4:	09 d0                	or     %edx,%eax
  1148a6:	41 89 47 18          	mov    %eax,0x18(%r15)
		uint32_t state;

		key = k_spin_lock(&lock);
		if (is_condition_met(&events[ii], &state)) {
			set_event_ready(&events[ii], state);
			poller->is_polling = false;
  1148aa:	c6 03 00             	movb   $0x0,(%rbx)
  1148ad:	e9 91 01 00 00       	jmpq   114a43 <register_events+0x2e4>
		} else if (!just_check && poller->is_polling) {
  1148b2:	45 84 f6             	test   %r14b,%r14b
  1148b5:	0f 85 88 01 00 00    	jne    114a43 <register_events+0x2e4>
  1148bb:	80 3b 00             	cmpb   $0x0,(%rbx)
  1148be:	0f 84 7f 01 00 00    	je     114a43 <register_events+0x2e4>
	switch (event->type) {
  1148c4:	41 8a 47 19          	mov    0x19(%r15),%al
  1148c8:	83 e0 1f             	and    $0x1f,%eax
  1148cb:	3c 08                	cmp    $0x8,%al
  1148cd:	0f 87 33 01 00 00    	ja     114a06 <register_events+0x2a7>
  1148d3:	0f b6 c0             	movzbl %al,%eax
  1148d6:	ff 24 c5 c8 cd 11 00 	jmpq   *0x11cdc8(,%rax,8)
		__ASSERT(event->sem != NULL, "invalid semaphore\n");
  1148dd:	49 83 7f 20 00       	cmpq   $0x0,0x20(%r15)
  1148e2:	75 36                	jne    11491a <register_events+0x1bb>
  1148e4:	be 1b 05 12 00       	mov    $0x12051b,%esi
  1148e9:	b9 81 00 00 00       	mov    $0x81,%ecx
  1148ee:	ba dd 04 12 00       	mov    $0x1204dd,%edx
  1148f3:	31 c0                	xor    %eax,%eax
  1148f5:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  1148fa:	e8 f9 bc fe ff       	callq  1005f8 <printk>
  1148ff:	bf 35 05 12 00       	mov    $0x120535,%edi
  114904:	31 c0                	xor    %eax,%eax
  114906:	e8 ed bc fe ff       	callq  1005f8 <printk>
  11490b:	be 81 00 00 00       	mov    $0x81,%esi
  114910:	bf dd 04 12 00       	mov    $0x1204dd,%edi
  114915:	e8 7e e2 fe ff       	callq  102b98 <assert_post_action>
		add_event(&event->sem->poll_events, event, poller);
  11491a:	49 8b 47 20          	mov    0x20(%r15),%rax
  11491e:	48 8d 78 18          	lea    0x18(%rax),%rdi
  114922:	eb 45                	jmp    114969 <register_events+0x20a>
		__ASSERT(event->queue != NULL, "invalid queue\n");
  114924:	49 83 7f 20 00       	cmpq   $0x0,0x20(%r15)
  114929:	75 36                	jne    114961 <register_events+0x202>
  11492b:	be 4a 05 12 00       	mov    $0x12054a,%esi
  114930:	b9 85 00 00 00       	mov    $0x85,%ecx
  114935:	ba dd 04 12 00       	mov    $0x1204dd,%edx
  11493a:	31 c0                	xor    %eax,%eax
  11493c:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  114941:	e8 b2 bc fe ff       	callq  1005f8 <printk>
  114946:	bf 66 05 12 00       	mov    $0x120566,%edi
  11494b:	31 c0                	xor    %eax,%eax
  11494d:	e8 a6 bc fe ff       	callq  1005f8 <printk>
  114952:	be 85 00 00 00       	mov    $0x85,%esi
  114957:	bf dd 04 12 00       	mov    $0x1204dd,%edi
  11495c:	e8 37 e2 fe ff       	callq  102b98 <assert_post_action>
		add_event(&event->queue->poll_events, event, poller);
  114961:	49 8b 47 20          	mov    0x20(%r15),%rax
  114965:	48 8d 78 28          	lea    0x28(%rax),%rdi
  114969:	48 89 da             	mov    %rbx,%rdx
  11496c:	4c 89 fe             	mov    %r15,%rsi
  11496f:	e8 34 fd ff ff       	callq  1146a8 <add_event>
		break;
  114974:	e9 c3 00 00 00       	jmpq   114a3c <register_events+0x2dd>
		__ASSERT(event->signal != NULL, "invalid poll signal\n");
  114979:	49 83 7f 20 00       	cmpq   $0x0,0x20(%r15)
  11497e:	75 36                	jne    1149b6 <register_events+0x257>
  114980:	be 77 05 12 00       	mov    $0x120577,%esi
  114985:	b9 89 00 00 00       	mov    $0x89,%ecx
  11498a:	ba dd 04 12 00       	mov    $0x1204dd,%edx
  11498f:	31 c0                	xor    %eax,%eax
  114991:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  114996:	e8 5d bc fe ff       	callq  1005f8 <printk>
  11499b:	bf 94 05 12 00       	mov    $0x120594,%edi
  1149a0:	31 c0                	xor    %eax,%eax
  1149a2:	e8 51 bc fe ff       	callq  1005f8 <printk>
  1149a7:	be 89 00 00 00       	mov    $0x89,%esi
  1149ac:	bf dd 04 12 00       	mov    $0x1204dd,%edi
  1149b1:	e8 e2 e1 fe ff       	callq  102b98 <assert_post_action>
		add_event(&event->signal->poll_events, event, poller);
  1149b6:	49 8b 7f 20          	mov    0x20(%r15),%rdi
  1149ba:	eb ad                	jmp    114969 <register_events+0x20a>
		__ASSERT(event->msgq != NULL, "invalid message queue\n");
  1149bc:	49 83 7f 20 00       	cmpq   $0x0,0x20(%r15)
  1149c1:	75 36                	jne    1149f9 <register_events+0x29a>
  1149c3:	be ab 05 12 00       	mov    $0x1205ab,%esi
  1149c8:	b9 8d 00 00 00       	mov    $0x8d,%ecx
  1149cd:	ba dd 04 12 00       	mov    $0x1204dd,%edx
  1149d2:	31 c0                	xor    %eax,%eax
  1149d4:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  1149d9:	e8 1a bc fe ff       	callq  1005f8 <printk>
  1149de:	bf c6 05 12 00       	mov    $0x1205c6,%edi
  1149e3:	31 c0                	xor    %eax,%eax
  1149e5:	e8 0e bc fe ff       	callq  1005f8 <printk>
  1149ea:	be 8d 00 00 00       	mov    $0x8d,%esi
  1149ef:	bf dd 04 12 00       	mov    $0x1204dd,%edi
  1149f4:	e8 9f e1 fe ff       	callq  102b98 <assert_post_action>
		add_event(&event->msgq->poll_events, event, poller);
  1149f9:	49 8b 47 20          	mov    0x20(%r15),%rax
  1149fd:	48 8d 78 50          	lea    0x50(%rax),%rdi
  114a01:	e9 63 ff ff ff       	jmpq   114969 <register_events+0x20a>
		__ASSERT(false, "invalid event type\n");
  114a06:	be cb f4 11 00       	mov    $0x11f4cb,%esi
  114a0b:	b9 94 00 00 00       	mov    $0x94,%ecx
  114a10:	ba dd 04 12 00       	mov    $0x1204dd,%edx
  114a15:	31 c0                	xor    %eax,%eax
  114a17:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  114a1c:	e8 d7 bb fe ff       	callq  1005f8 <printk>
  114a21:	bf df 05 12 00       	mov    $0x1205df,%edi
  114a26:	31 c0                	xor    %eax,%eax
  114a28:	e8 cb bb fe ff       	callq  1005f8 <printk>
  114a2d:	be 94 00 00 00       	mov    $0x94,%esi
  114a32:	bf dd 04 12 00       	mov    $0x1204dd,%edi
  114a37:	e8 5c e1 fe ff       	callq  102b98 <assert_post_action>
	event->poller = poller;
  114a3c:	49 89 5f 10          	mov    %rbx,0x10(%r15)
			register_event(&events[ii], poller);
			events_registered += 1;
  114a40:	41 ff c4             	inc    %r12d
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  114a43:	bf f8 cd 1b 00       	mov    $0x1bcdf8,%edi
  114a48:	e8 4c 8e ff ff       	callq  10d899 <z_spin_unlock_valid>
  114a4d:	84 c0                	test   %al,%al
  114a4f:	75 39                	jne    114a8a <register_events+0x32b>
  114a51:	b9 b9 00 00 00       	mov    $0xb9,%ecx
  114a56:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  114a5b:	be 41 d2 11 00       	mov    $0x11d241,%esi
  114a60:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  114a65:	e8 8e bb fe ff       	callq  1005f8 <printk>
  114a6a:	be f8 cd 1b 00       	mov    $0x1bcdf8,%esi
  114a6f:	bf 58 d2 11 00       	mov    $0x11d258,%edi
  114a74:	31 c0                	xor    %eax,%eax
  114a76:	e8 7d bb fe ff       	callq  1005f8 <printk>
  114a7b:	be b9 00 00 00       	mov    $0xb9,%esi
  114a80:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  114a85:	e8 0e e1 fe ff       	callq  102b98 <assert_post_action>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  114a8a:	0f ba 65 c0 09       	btl    $0x9,-0x40(%rbp)
  114a8f:	73 01                	jae    114a92 <register_events+0x333>
		__asm__ volatile ("sti" ::: "memory");
  114a91:	fb                   	sti    
	for (int ii = 0; ii < num_events; ii++) {
  114a92:	41 ff c5             	inc    %r13d
  114a95:	49 83 c7 28          	add    $0x28,%r15
  114a99:	e9 e4 fc ff ff       	jmpq   114782 <register_events+0x23>
		}
		k_spin_unlock(&lock, key);
	}

	return events_registered;
}
  114a9e:	48 83 c4 18          	add    $0x18,%rsp
  114aa2:	44 89 e0             	mov    %r12d,%eax
  114aa5:	5b                   	pop    %rbx
  114aa6:	41 5c                	pop    %r12
  114aa8:	41 5d                	pop    %r13
  114aaa:	41 5e                	pop    %r14
  114aac:	41 5f                	pop    %r15
  114aae:	5d                   	pop    %rbp
  114aaf:	c3                   	retq   

0000000000114ab0 <signal_poll_event>:
#include <syscalls/k_poll_mrsh.c>
#endif

/* must be called with interrupts locked */
static int signal_poll_event(struct k_poll_event *event, uint32_t state)
{
  114ab0:	55                   	push   %rbp
  114ab1:	48 89 e5             	mov    %rsp,%rbp
  114ab4:	41 57                	push   %r15
  114ab6:	41 56                	push   %r14
  114ab8:	41 55                	push   %r13
  114aba:	41 89 f5             	mov    %esi,%r13d
  114abd:	41 54                	push   %r12
  114abf:	49 89 fc             	mov    %rdi,%r12
  114ac2:	53                   	push   %rbx
  114ac3:	51                   	push   %rcx
	struct z_poller *poller = event->poller;
  114ac4:	48 8b 5f 10          	mov    0x10(%rdi),%rbx
	int retcode = 0;

	if (poller != NULL) {
  114ac8:	48 85 db             	test   %rbx,%rbx
  114acb:	0f 84 df 00 00 00    	je     114bb0 <signal_poll_event+0x100>
		if (poller->mode == MODE_POLL) {
  114ad1:	8a 43 01             	mov    0x1(%rbx),%al
  114ad4:	3c 01                	cmp    $0x1,%al
  114ad6:	0f 85 a0 00 00 00    	jne    114b7c <signal_poll_event+0xcc>
	__ASSERT(thread != NULL, "poller should have a thread\n");
  114adc:	49 89 de             	mov    %rbx,%r14
  114adf:	49 81 ee a8 00 00 00 	sub    $0xa8,%r14
  114ae6:	75 3f                	jne    114b27 <signal_poll_event+0x77>
  114ae8:	b9 f1 00 00 00       	mov    $0xf1,%ecx
  114aed:	ba dd 04 12 00       	mov    $0x1204dd,%edx
  114af2:	be f5 05 12 00       	mov    $0x1205f5,%esi
  114af7:	31 c0                	xor    %eax,%eax
  114af9:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  114afe:	e8 f5 ba fe ff       	callq  1005f8 <printk>
  114b03:	31 c0                	xor    %eax,%eax
  114b05:	bf 0b 06 12 00       	mov    $0x12060b,%edi
  114b0a:	e8 e9 ba fe ff       	callq  1005f8 <printk>
  114b0f:	be f1 00 00 00       	mov    $0xf1,%esi
  114b14:	bf dd 04 12 00       	mov    $0x1204dd,%edi
  114b19:	e8 7a e0 fe ff       	callq  102b98 <assert_post_action>
	return (thread->base.thread_state & _THREAD_PENDING) != 0U;
  114b1e:	8a 04 25 19 00 00 00 	mov    0x19,%al
  114b25:	0f 0b                	ud2    
	if (!z_is_thread_pending(thread)) {
  114b27:	f6 83 71 ff ff ff 02 	testb  $0x2,-0x8f(%rbx)
  114b2e:	74 7d                	je     114bad <signal_poll_event+0xfd>
	if (z_is_thread_timeout_expired(thread)) {
  114b30:	48 83 7b 98 fe       	cmpq   $0xfffffffffffffffe,-0x68(%rbx)
  114b35:	75 0d                	jne    114b44 <signal_poll_event+0x94>
		} else {
			/* Poller is not poll or triggered mode. No action needed.*/
			;
		}

		poller->is_polling = false;
  114b37:	c6 03 00             	movb   $0x0,(%rbx)
		return -EAGAIN;
  114b3a:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  114b3f:	e9 96 00 00 00       	jmpq   114bda <signal_poll_event+0x12a>
	z_unpend_thread(thread);
  114b44:	4c 89 f7             	mov    %r14,%rdi
  114b47:	e8 de c4 ff ff       	callq  11102a <z_unpend_thread>
	arch_thread_return_value_set(thread, state == K_POLL_STATE_CANCELLED ? -EINTR : 0);
  114b4c:	31 c0                	xor    %eax,%eax
  114b4e:	41 83 fd 08          	cmp    $0x8,%r13d
  114b52:	0f 95 c0             	setne  %al
  114b55:	8d 04 85 fc ff ff ff 	lea    -0x4(,%rax,4),%eax
  114b5c:	89 83 a0 00 00 00    	mov    %eax,0xa0(%rbx)
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
  114b62:	f6 83 71 ff ff ff 1f 	testb  $0x1f,-0x8f(%rbx)
  114b69:	75 42                	jne    114bad <signal_poll_event+0xfd>
	if (!z_is_thread_ready(thread)) {
  114b6b:	48 83 7b 80 00       	cmpq   $0x0,-0x80(%rbx)
  114b70:	75 3b                	jne    114bad <signal_poll_event+0xfd>
	z_ready_thread(thread);
  114b72:	4c 89 f7             	mov    %r14,%rdi
  114b75:	e8 d0 c8 ff ff       	callq  11144a <z_ready_thread>
		poller->is_polling = false;
  114b7a:	eb 31                	jmp    114bad <signal_poll_event+0xfd>
		} else if (poller->mode == MODE_TRIGGERED) {
  114b7c:	3c 02                	cmp    $0x2,%al
  114b7e:	75 2d                	jne    114bad <signal_poll_event+0xfd>
static int signal_triggered_work(struct k_poll_event *event, uint32_t status)
{
	struct z_poller *poller = event->poller;
	struct k_work_poll *twork = CONTAINER_OF(poller, struct k_work_poll, poller);

	if (poller->is_polling && twork->workq != NULL) {
  114b80:	80 3b 00             	cmpb   $0x0,(%rbx)
  114b83:	74 2b                	je     114bb0 <signal_poll_event+0x100>
  114b85:	4c 8b 73 f8          	mov    -0x8(%rbx),%r14
  114b89:	4d 85 f6             	test   %r14,%r14
  114b8c:	74 1f                	je     114bad <signal_poll_event+0xfd>
		struct k_work_q *work_q = twork->workq;

		z_abort_timeout(&twork->timeout);
  114b8e:	48 8d 7b 20          	lea    0x20(%rbx),%rdi
  114b92:	4c 8d 7b d8          	lea    -0x28(%rbx),%r15
  114b96:	e8 3f e4 ff ff       	callq  112fda <z_abort_timeout>
		twork->poll_result = 0;
  114b9b:	c7 43 40 00 00 00 00 	movl   $0x0,0x40(%rbx)
		k_work_submit_to_queue(work_q, &twork->work);
  114ba2:	4c 89 fe             	mov    %r15,%rsi
  114ba5:	4c 89 f7             	mov    %r14,%rdi
  114ba8:	e8 89 43 00 00       	callq  118f36 <k_work_submit_to_queue>
		poller->is_polling = false;
  114bad:	c6 03 00             	movb   $0x0,(%rbx)
	event->poller = NULL;
  114bb0:	49 c7 44 24 10 00 00 	movq   $0x0,0x10(%r12)
  114bb7:	00 00 
	event->state |= state;
  114bb9:	41 8b 44 24 18       	mov    0x18(%r12),%eax
  114bbe:	89 c6                	mov    %eax,%esi
  114bc0:	25 ff 1f f8 ff       	and    $0xfff81fff,%eax
  114bc5:	c1 ee 0d             	shr    $0xd,%esi
  114bc8:	44 09 ee             	or     %r13d,%esi
  114bcb:	83 e6 3f             	and    $0x3f,%esi
  114bce:	c1 e6 0d             	shl    $0xd,%esi
  114bd1:	09 c6                	or     %eax,%esi
	return retcode;
  114bd3:	31 c0                	xor    %eax,%eax
	event->state |= state;
  114bd5:	41 89 74 24 18       	mov    %esi,0x18(%r12)
}
  114bda:	5a                   	pop    %rdx
  114bdb:	5b                   	pop    %rbx
  114bdc:	41 5c                	pop    %r12
  114bde:	41 5d                	pop    %r13
  114be0:	41 5e                	pop    %r14
  114be2:	41 5f                	pop    %r15
  114be4:	5d                   	pop    %rbp
  114be5:	c3                   	retq   

0000000000114be6 <clear_event_registrations>:
{
  114be6:	55                   	push   %rbp
  114be7:	48 89 e5             	mov    %rsp,%rbp
  114bea:	41 56                	push   %r14
  114bec:	49 89 fe             	mov    %rdi,%r14
  114bef:	41 55                	push   %r13
  114bf1:	41 89 d5             	mov    %edx,%r13d
  114bf4:	41 54                	push   %r12
  114bf6:	44 8d 66 ff          	lea    -0x1(%rsi),%r12d
  114bfa:	53                   	push   %rbx
	while (num_events--) {
  114bfb:	41 83 fc ff          	cmp    $0xffffffff,%r12d
  114bff:	0f 84 1d 02 00 00    	je     114e22 <clear_event_registrations+0x23c>
		clear_event_registration(&events[num_events]);
  114c05:	49 63 dc             	movslq %r12d,%rbx
  114c08:	48 6b db 28          	imul   $0x28,%rbx,%rbx
  114c0c:	4c 01 f3             	add    %r14,%rbx
	switch (event->type) {
  114c0f:	8a 43 19             	mov    0x19(%rbx),%al
	event->poller = NULL;
  114c12:	48 c7 43 10 00 00 00 	movq   $0x0,0x10(%rbx)
  114c19:	00 
	switch (event->type) {
  114c1a:	83 e0 1f             	and    $0x1f,%eax
  114c1d:	3c 08                	cmp    $0x8,%al
  114c1f:	0f 87 f7 00 00 00    	ja     114d1c <clear_event_registrations+0x136>
  114c25:	0f b6 c0             	movzbl %al,%eax
  114c28:	ff 24 c5 10 ce 11 00 	jmpq   *0x11ce10(,%rax,8)
		__ASSERT(event->sem != NULL, "invalid semaphore\n");
  114c2f:	48 83 7b 20 00       	cmpq   $0x0,0x20(%rbx)
  114c34:	0f 85 1a 01 00 00    	jne    114d54 <clear_event_registrations+0x16e>
  114c3a:	be 1b 05 12 00       	mov    $0x12051b,%esi
  114c3f:	b9 a4 00 00 00       	mov    $0xa4,%ecx
  114c44:	ba dd 04 12 00       	mov    $0x1204dd,%edx
  114c49:	31 c0                	xor    %eax,%eax
  114c4b:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  114c50:	e8 a3 b9 fe ff       	callq  1005f8 <printk>
  114c55:	bf 35 05 12 00       	mov    $0x120535,%edi
  114c5a:	31 c0                	xor    %eax,%eax
  114c5c:	e8 97 b9 fe ff       	callq  1005f8 <printk>
  114c61:	be a4 00 00 00       	mov    $0xa4,%esi
  114c66:	e9 a5 00 00 00       	jmpq   114d10 <clear_event_registrations+0x12a>
		__ASSERT(event->queue != NULL, "invalid queue\n");
  114c6b:	48 83 7b 20 00       	cmpq   $0x0,0x20(%rbx)
  114c70:	0f 85 de 00 00 00    	jne    114d54 <clear_event_registrations+0x16e>
  114c76:	be 4a 05 12 00       	mov    $0x12054a,%esi
  114c7b:	b9 a8 00 00 00       	mov    $0xa8,%ecx
  114c80:	ba dd 04 12 00       	mov    $0x1204dd,%edx
  114c85:	31 c0                	xor    %eax,%eax
  114c87:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  114c8c:	e8 67 b9 fe ff       	callq  1005f8 <printk>
  114c91:	bf 66 05 12 00       	mov    $0x120566,%edi
  114c96:	31 c0                	xor    %eax,%eax
  114c98:	e8 5b b9 fe ff       	callq  1005f8 <printk>
  114c9d:	be a8 00 00 00       	mov    $0xa8,%esi
  114ca2:	eb 6c                	jmp    114d10 <clear_event_registrations+0x12a>
		__ASSERT(event->signal != NULL, "invalid poll signal\n");
  114ca4:	48 83 7b 20 00       	cmpq   $0x0,0x20(%rbx)
  114ca9:	0f 85 a5 00 00 00    	jne    114d54 <clear_event_registrations+0x16e>
  114caf:	be 77 05 12 00       	mov    $0x120577,%esi
  114cb4:	b9 ac 00 00 00       	mov    $0xac,%ecx
  114cb9:	ba dd 04 12 00       	mov    $0x1204dd,%edx
  114cbe:	31 c0                	xor    %eax,%eax
  114cc0:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  114cc5:	e8 2e b9 fe ff       	callq  1005f8 <printk>
  114cca:	bf 94 05 12 00       	mov    $0x120594,%edi
  114ccf:	31 c0                	xor    %eax,%eax
  114cd1:	e8 22 b9 fe ff       	callq  1005f8 <printk>
  114cd6:	be ac 00 00 00       	mov    $0xac,%esi
  114cdb:	eb 33                	jmp    114d10 <clear_event_registrations+0x12a>
		__ASSERT(event->msgq != NULL, "invalid message queue\n");
  114cdd:	48 83 7b 20 00       	cmpq   $0x0,0x20(%rbx)
  114ce2:	75 70                	jne    114d54 <clear_event_registrations+0x16e>
  114ce4:	be ab 05 12 00       	mov    $0x1205ab,%esi
  114ce9:	b9 b0 00 00 00       	mov    $0xb0,%ecx
  114cee:	ba dd 04 12 00       	mov    $0x1204dd,%edx
  114cf3:	31 c0                	xor    %eax,%eax
  114cf5:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  114cfa:	e8 f9 b8 fe ff       	callq  1005f8 <printk>
  114cff:	bf c6 05 12 00       	mov    $0x1205c6,%edi
  114d04:	31 c0                	xor    %eax,%eax
  114d06:	e8 ed b8 fe ff       	callq  1005f8 <printk>
  114d0b:	be b0 00 00 00       	mov    $0xb0,%esi
  114d10:	bf dd 04 12 00       	mov    $0x1204dd,%edi
  114d15:	e8 7e de fe ff       	callq  102b98 <assert_post_action>
  114d1a:	eb 38                	jmp    114d54 <clear_event_registrations+0x16e>
		__ASSERT(false, "invalid event type\n");
  114d1c:	b9 b7 00 00 00       	mov    $0xb7,%ecx
  114d21:	ba dd 04 12 00       	mov    $0x1204dd,%edx
  114d26:	be cb f4 11 00       	mov    $0x11f4cb,%esi
  114d2b:	31 c0                	xor    %eax,%eax
  114d2d:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  114d32:	e8 c1 b8 fe ff       	callq  1005f8 <printk>
  114d37:	bf df 05 12 00       	mov    $0x1205df,%edi
  114d3c:	31 c0                	xor    %eax,%eax
  114d3e:	e8 b5 b8 fe ff       	callq  1005f8 <printk>
  114d43:	be b7 00 00 00       	mov    $0xb7,%esi
  114d48:	bf dd 04 12 00       	mov    $0x1204dd,%edi
  114d4d:	e8 46 de fe ff       	callq  102b98 <assert_post_action>
	if (remove_event && sys_dnode_is_linked(&event->_node)) {
  114d52:	eb 22                	jmp    114d76 <clear_event_registrations+0x190>
	return node->next != NULL;
  114d54:	48 8b 03             	mov    (%rbx),%rax
  114d57:	48 85 c0             	test   %rax,%rax
  114d5a:	74 1a                	je     114d76 <clear_event_registrations+0x190>
	sys_dnode_t *const prev = node->prev;
  114d5c:	48 8b 53 08          	mov    0x8(%rbx),%rdx
	prev->next = next;
  114d60:	48 89 02             	mov    %rax,(%rdx)
	next->prev = prev;
  114d63:	48 89 50 08          	mov    %rdx,0x8(%rax)
	node->next = NULL;
  114d67:	48 c7 03 00 00 00 00 	movq   $0x0,(%rbx)
	node->prev = NULL;
  114d6e:	48 c7 43 08 00 00 00 	movq   $0x0,0x8(%rbx)
  114d75:	00 
  114d76:	bf f8 cd 1b 00       	mov    $0x1bcdf8,%edi
  114d7b:	e8 19 8b ff ff       	callq  10d899 <z_spin_unlock_valid>
  114d80:	84 c0                	test   %al,%al
  114d82:	75 39                	jne    114dbd <clear_event_registrations+0x1d7>
  114d84:	b9 b9 00 00 00       	mov    $0xb9,%ecx
  114d89:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  114d8e:	be 41 d2 11 00       	mov    $0x11d241,%esi
  114d93:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  114d98:	e8 5b b8 fe ff       	callq  1005f8 <printk>
  114d9d:	be f8 cd 1b 00       	mov    $0x1bcdf8,%esi
  114da2:	bf 58 d2 11 00       	mov    $0x11d258,%edi
  114da7:	31 c0                	xor    %eax,%eax
  114da9:	e8 4a b8 fe ff       	callq  1005f8 <printk>
  114dae:	be b9 00 00 00       	mov    $0xb9,%esi
  114db3:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  114db8:	e8 db dd fe ff       	callq  102b98 <assert_post_action>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  114dbd:	41 0f ba e5 09       	bt     $0x9,%r13d
  114dc2:	73 01                	jae    114dc5 <clear_event_registrations+0x1df>
		__asm__ volatile ("sti" ::: "memory");
  114dc4:	fb                   	sti    
  114dc5:	9c                   	pushfq 
  114dc6:	fa                   	cli    
  114dc7:	41 5d                	pop    %r13
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  114dc9:	bf f8 cd 1b 00       	mov    $0x1bcdf8,%edi
  114dce:	e8 a6 8a ff ff       	callq  10d879 <z_spin_lock_valid>
  114dd3:	84 c0                	test   %al,%al
  114dd5:	75 39                	jne    114e10 <clear_event_registrations+0x22a>
  114dd7:	b9 8e 00 00 00       	mov    $0x8e,%ecx
  114ddc:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  114de1:	be fd d1 11 00       	mov    $0x11d1fd,%esi
  114de6:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  114deb:	e8 08 b8 fe ff       	callq  1005f8 <printk>
  114df0:	be f8 cd 1b 00       	mov    $0x1bcdf8,%esi
  114df5:	bf 12 d2 11 00       	mov    $0x11d212,%edi
  114dfa:	31 c0                	xor    %eax,%eax
  114dfc:	e8 f7 b7 fe ff       	callq  1005f8 <printk>
  114e01:	be 8e 00 00 00       	mov    $0x8e,%esi
  114e06:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  114e0b:	e8 88 dd fe ff       	callq  102b98 <assert_post_action>
	z_spin_lock_set_owner(l);
  114e10:	bf f8 cd 1b 00       	mov    $0x1bcdf8,%edi
  114e15:	41 ff cc             	dec    %r12d
  114e18:	e8 a0 8a ff ff       	callq  10d8bd <z_spin_lock_set_owner>
	return k;
  114e1d:	e9 d9 fd ff ff       	jmpq   114bfb <clear_event_registrations+0x15>
}
  114e22:	5b                   	pop    %rbx
  114e23:	41 5c                	pop    %r12
  114e25:	41 5d                	pop    %r13
  114e27:	41 5e                	pop    %r14
  114e29:	5d                   	pop    %rbp
  114e2a:	c3                   	retq   

0000000000114e2b <k_poll_event_init>:
{
  114e2b:	55                   	push   %rbp
  114e2c:	48 89 e5             	mov    %rsp,%rbp
  114e2f:	41 56                	push   %r14
  114e31:	41 89 f6             	mov    %esi,%r14d
  114e34:	41 55                	push   %r13
  114e36:	49 89 cd             	mov    %rcx,%r13
  114e39:	41 54                	push   %r12
  114e3b:	49 89 fc             	mov    %rdi,%r12
  114e3e:	53                   	push   %rbx
  114e3f:	89 d3                	mov    %edx,%ebx
	__ASSERT(mode == K_POLL_MODE_NOTIFY_ONLY, "only NOTIFY_ONLY mode is supported\n");
  114e41:	85 d2                	test   %edx,%edx
  114e43:	74 36                	je     114e7b <k_poll_event_init+0x50>
  114e45:	be 2a 06 12 00       	mov    $0x12062a,%esi
  114e4a:	b9 2c 00 00 00       	mov    $0x2c,%ecx
  114e4f:	ba dd 04 12 00       	mov    $0x1204dd,%edx
  114e54:	31 c0                	xor    %eax,%eax
  114e56:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  114e5b:	e8 98 b7 fe ff       	callq  1005f8 <printk>
  114e60:	bf 4a 06 12 00       	mov    $0x12064a,%edi
  114e65:	31 c0                	xor    %eax,%eax
  114e67:	e8 8c b7 fe ff       	callq  1005f8 <printk>
  114e6c:	be 2c 00 00 00       	mov    $0x2c,%esi
  114e71:	bf dd 04 12 00       	mov    $0x1204dd,%edi
  114e76:	e8 1d dd fe ff       	callq  102b98 <assert_post_action>
	__ASSERT(type < (BIT(_POLL_NUM_TYPES)), "invalid type\n");
  114e7b:	41 83 fe 1f          	cmp    $0x1f,%r14d
  114e7f:	76 36                	jbe    114eb7 <k_poll_event_init+0x8c>
  114e81:	be 70 06 12 00       	mov    $0x120670,%esi
  114e86:	b9 2d 00 00 00       	mov    $0x2d,%ecx
  114e8b:	ba dd 04 12 00       	mov    $0x1204dd,%edx
  114e90:	31 c0                	xor    %eax,%eax
  114e92:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  114e97:	e8 5c b7 fe ff       	callq  1005f8 <printk>
  114e9c:	bf 94 06 12 00       	mov    $0x120694,%edi
  114ea1:	31 c0                	xor    %eax,%eax
  114ea3:	e8 50 b7 fe ff       	callq  1005f8 <printk>
  114ea8:	be 2d 00 00 00       	mov    $0x2d,%esi
  114ead:	bf dd 04 12 00       	mov    $0x1204dd,%edi
  114eb2:	e8 e1 dc fe ff       	callq  102b98 <assert_post_action>
	__ASSERT(obj != NULL, "must provide an object\n");
  114eb7:	4d 85 ed             	test   %r13,%r13
  114eba:	75 36                	jne    114ef2 <k_poll_event_init+0xc7>
  114ebc:	be a4 06 12 00       	mov    $0x1206a4,%esi
  114ec1:	b9 2e 00 00 00       	mov    $0x2e,%ecx
  114ec6:	ba dd 04 12 00       	mov    $0x1204dd,%edx
  114ecb:	31 c0                	xor    %eax,%eax
  114ecd:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  114ed2:	e8 21 b7 fe ff       	callq  1005f8 <printk>
  114ed7:	bf b7 06 12 00       	mov    $0x1206b7,%edi
  114edc:	31 c0                	xor    %eax,%eax
  114ede:	e8 15 b7 fe ff       	callq  1005f8 <printk>
  114ee3:	be 2e 00 00 00       	mov    $0x2e,%esi
  114ee8:	bf dd 04 12 00       	mov    $0x1204dd,%edi
  114eed:	e8 a6 dc fe ff       	callq  102b98 <assert_post_action>
	event->type = type;
  114ef2:	c1 e3 13             	shl    $0x13,%ebx
  114ef5:	41 c1 e6 08          	shl    $0x8,%r14d
  114ef9:	41 0f b6 54 24 18    	movzbl 0x18(%r12),%edx
	event->obj = obj;
  114eff:	4d 89 6c 24 20       	mov    %r13,0x20(%r12)
	event->type = type;
  114f04:	41 81 e6 00 1f 00 00 	and    $0x1f00,%r14d
  114f0b:	81 e3 00 00 08 00    	and    $0x80000,%ebx
	event->poller = NULL;
  114f11:	49 c7 44 24 10 00 00 	movq   $0x0,0x10(%r12)
  114f18:	00 00 
	event->type = type;
  114f1a:	44 09 f3             	or     %r14d,%ebx
  114f1d:	09 d3                	or     %edx,%ebx
  114f1f:	41 89 5c 24 18       	mov    %ebx,0x18(%r12)
}
  114f24:	5b                   	pop    %rbx
  114f25:	41 5c                	pop    %r12
  114f27:	41 5d                	pop    %r13
  114f29:	41 5e                	pop    %r14
  114f2b:	5d                   	pop    %rbp
  114f2c:	c3                   	retq   

0000000000114f2d <z_impl_k_poll>:
{
  114f2d:	55                   	push   %rbp
  114f2e:	48 89 e5             	mov    %rsp,%rbp
  114f31:	41 57                	push   %r15
  114f33:	41 56                	push   %r14
  114f35:	41 89 f6             	mov    %esi,%r14d
  114f38:	41 55                	push   %r13
  114f3a:	49 89 d5             	mov    %rdx,%r13
  114f3d:	41 54                	push   %r12
  114f3f:	49 89 fc             	mov    %rdi,%r12
  114f42:	53                   	push   %rbx
  114f43:	51                   	push   %rcx
	struct z_poller *poller = &_current->poller;
  114f44:	4c 8b 3d 05 38 01 00 	mov    0x13805(%rip),%r15        # 128750 <_kernel+0x10>
	__ASSERT(!arch_is_in_isr(), "");
  114f4b:	83 3d ee 37 01 00 00 	cmpl   $0x0,0x137ee(%rip)        # 128740 <_kernel>
	poller->is_polling = true;
  114f52:	66 41 c7 87 a8 00 00 	movw   $0x101,0xa8(%r15)
  114f59:	00 01 01 
	struct z_poller *poller = &_current->poller;
  114f5c:	49 8d 9f a8 00 00 00 	lea    0xa8(%r15),%rbx
	__ASSERT(!arch_is_in_isr(), "");
  114f63:	74 36                	je     114f9b <z_impl_k_poll+0x6e>
  114f65:	be 49 f9 11 00       	mov    $0x11f949,%esi
  114f6a:	b9 10 01 00 00       	mov    $0x110,%ecx
  114f6f:	ba dd 04 12 00       	mov    $0x1204dd,%edx
  114f74:	31 c0                	xor    %eax,%eax
  114f76:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  114f7b:	e8 78 b6 fe ff       	callq  1005f8 <printk>
  114f80:	bf 22 fc 11 00       	mov    $0x11fc22,%edi
  114f85:	31 c0                	xor    %eax,%eax
  114f87:	e8 6c b6 fe ff       	callq  1005f8 <printk>
  114f8c:	be 10 01 00 00       	mov    $0x110,%esi
  114f91:	bf dd 04 12 00       	mov    $0x1204dd,%edi
  114f96:	e8 fd db fe ff       	callq  102b98 <assert_post_action>
	__ASSERT(events != NULL, "NULL events\n");
  114f9b:	4d 85 e4             	test   %r12,%r12
  114f9e:	75 36                	jne    114fd6 <z_impl_k_poll+0xa9>
  114fa0:	be d1 06 12 00       	mov    $0x1206d1,%esi
  114fa5:	b9 11 01 00 00       	mov    $0x111,%ecx
  114faa:	ba dd 04 12 00       	mov    $0x1204dd,%edx
  114faf:	31 c0                	xor    %eax,%eax
  114fb1:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  114fb6:	e8 3d b6 fe ff       	callq  1005f8 <printk>
  114fbb:	bf e7 06 12 00       	mov    $0x1206e7,%edi
  114fc0:	31 c0                	xor    %eax,%eax
  114fc2:	e8 31 b6 fe ff       	callq  1005f8 <printk>
  114fc7:	be 11 01 00 00       	mov    $0x111,%esi
  114fcc:	bf dd 04 12 00       	mov    $0x1204dd,%edi
  114fd1:	e8 c2 db fe ff       	callq  102b98 <assert_post_action>
	__ASSERT(num_events >= 0, "<0 events\n");
  114fd6:	45 85 f6             	test   %r14d,%r14d
  114fd9:	79 36                	jns    115011 <z_impl_k_poll+0xe4>
  114fdb:	be f6 06 12 00       	mov    $0x1206f6,%esi
  114fe0:	b9 12 01 00 00       	mov    $0x112,%ecx
  114fe5:	ba dd 04 12 00       	mov    $0x1204dd,%edx
  114fea:	31 c0                	xor    %eax,%eax
  114fec:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  114ff1:	e8 02 b6 fe ff       	callq  1005f8 <printk>
  114ff6:	bf 06 07 12 00       	mov    $0x120706,%edi
  114ffb:	31 c0                	xor    %eax,%eax
  114ffd:	e8 f6 b5 fe ff       	callq  1005f8 <printk>
  115002:	be 12 01 00 00       	mov    $0x112,%esi
  115007:	bf dd 04 12 00       	mov    $0x1204dd,%edi
  11500c:	e8 87 db fe ff       	callq  102b98 <assert_post_action>
		register_events(events, num_events, poller, K_TIMEOUT_EQ(timeout, K_NO_WAIT));
  115011:	31 c9                	xor    %ecx,%ecx
  115013:	4d 85 ed             	test   %r13,%r13
  115016:	44 89 f6             	mov    %r14d,%esi
  115019:	48 89 da             	mov    %rbx,%rdx
  11501c:	0f 94 c1             	sete   %cl
  11501f:	4c 89 e7             	mov    %r12,%rdi
  115022:	e8 38 f7 ff ff       	callq  11475f <register_events>
  115027:	41 89 c6             	mov    %eax,%r14d
  11502a:	9c                   	pushfq 
  11502b:	fa                   	cli    
  11502c:	5b                   	pop    %rbx
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  11502d:	bf f8 cd 1b 00       	mov    $0x1bcdf8,%edi
  115032:	e8 42 88 ff ff       	callq  10d879 <z_spin_lock_valid>
  115037:	84 c0                	test   %al,%al
  115039:	75 39                	jne    115074 <z_impl_k_poll+0x147>
  11503b:	b9 8e 00 00 00       	mov    $0x8e,%ecx
  115040:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  115045:	be fd d1 11 00       	mov    $0x11d1fd,%esi
  11504a:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  11504f:	e8 a4 b5 fe ff       	callq  1005f8 <printk>
  115054:	be f8 cd 1b 00       	mov    $0x1bcdf8,%esi
  115059:	bf 12 d2 11 00       	mov    $0x11d212,%edi
  11505e:	31 c0                	xor    %eax,%eax
  115060:	e8 93 b5 fe ff       	callq  1005f8 <printk>
  115065:	be 8e 00 00 00       	mov    $0x8e,%esi
  11506a:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  11506f:	e8 24 db fe ff       	callq  102b98 <assert_post_action>
	z_spin_lock_set_owner(l);
  115074:	bf f8 cd 1b 00       	mov    $0x1bcdf8,%edi
  115079:	e8 3f 88 ff ff       	callq  10d8bd <z_spin_lock_set_owner>
	if (!poller->is_polling) {
  11507e:	41 80 bf a8 00 00 00 	cmpb   $0x0,0xa8(%r15)
  115085:	00 
  115086:	75 5c                	jne    1150e4 <z_impl_k_poll+0x1b7>
		clear_event_registrations(events, events_registered, key);
  115088:	4c 89 e7             	mov    %r12,%rdi
  11508b:	89 da                	mov    %ebx,%edx
  11508d:	44 89 f6             	mov    %r14d,%esi
  115090:	e8 51 fb ff ff       	callq  114be6 <clear_event_registrations>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  115095:	bf f8 cd 1b 00       	mov    $0x1bcdf8,%edi
  11509a:	e8 fa 87 ff ff       	callq  10d899 <z_spin_unlock_valid>
  11509f:	84 c0                	test   %al,%al
  1150a1:	75 39                	jne    1150dc <z_impl_k_poll+0x1af>
  1150a3:	b9 b9 00 00 00       	mov    $0xb9,%ecx
  1150a8:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  1150ad:	be 41 d2 11 00       	mov    $0x11d241,%esi
  1150b2:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  1150b7:	e8 3c b5 fe ff       	callq  1005f8 <printk>
  1150bc:	be f8 cd 1b 00       	mov    $0x1bcdf8,%esi
  1150c1:	bf 58 d2 11 00       	mov    $0x11d258,%edi
  1150c6:	31 c0                	xor    %eax,%eax
  1150c8:	e8 2b b5 fe ff       	callq  1005f8 <printk>
  1150cd:	be b9 00 00 00       	mov    $0xb9,%esi
  1150d2:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  1150d7:	e8 bc da fe ff       	callq  102b98 <assert_post_action>
		return 0;
  1150dc:	45 31 ed             	xor    %r13d,%r13d
  1150df:	e9 1e 01 00 00       	jmpq   115202 <z_impl_k_poll+0x2d5>
	poller->is_polling = false;
  1150e4:	41 c6 87 a8 00 00 00 	movb   $0x0,0xa8(%r15)
  1150eb:	00 
	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
  1150ec:	4d 85 ed             	test   %r13,%r13
  1150ef:	75 52                	jne    115143 <z_impl_k_poll+0x216>
  1150f1:	bf f8 cd 1b 00       	mov    $0x1bcdf8,%edi
  1150f6:	e8 9e 87 ff ff       	callq  10d899 <z_spin_unlock_valid>
  1150fb:	84 c0                	test   %al,%al
  1150fd:	75 39                	jne    115138 <z_impl_k_poll+0x20b>
  1150ff:	b9 b9 00 00 00       	mov    $0xb9,%ecx
  115104:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  115109:	be 41 d2 11 00       	mov    $0x11d241,%esi
  11510e:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  115113:	e8 e0 b4 fe ff       	callq  1005f8 <printk>
  115118:	be f8 cd 1b 00       	mov    $0x1bcdf8,%esi
  11511d:	bf 58 d2 11 00       	mov    $0x11d258,%edi
  115122:	31 c0                	xor    %eax,%eax
  115124:	e8 cf b4 fe ff       	callq  1005f8 <printk>
  115129:	be b9 00 00 00       	mov    $0xb9,%esi
  11512e:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  115133:	e8 60 da fe ff       	callq  102b98 <assert_post_action>
		return -EAGAIN;
  115138:	41 bd f5 ff ff ff    	mov    $0xfffffff5,%r13d
  11513e:	e9 bf 00 00 00       	jmpq   115202 <z_impl_k_poll+0x2d5>
	int swap_rc = z_pend_curr(&lock, key, &wait_q, timeout);
  115143:	4c 89 e9             	mov    %r13,%rcx
  115146:	ba e0 13 5e 00       	mov    $0x5e13e0,%edx
  11514b:	89 de                	mov    %ebx,%esi
  11514d:	bf f8 cd 1b 00       	mov    $0x1bcdf8,%edi
  115152:	e8 91 c8 ff ff       	callq  1119e8 <z_pend_curr>
  115157:	41 89 c5             	mov    %eax,%r13d
  11515a:	9c                   	pushfq 
  11515b:	fa                   	cli    
  11515c:	5b                   	pop    %rbx
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  11515d:	bf f8 cd 1b 00       	mov    $0x1bcdf8,%edi
  115162:	e8 12 87 ff ff       	callq  10d879 <z_spin_lock_valid>
  115167:	84 c0                	test   %al,%al
  115169:	75 39                	jne    1151a4 <z_impl_k_poll+0x277>
  11516b:	b9 8e 00 00 00       	mov    $0x8e,%ecx
  115170:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  115175:	be fd d1 11 00       	mov    $0x11d1fd,%esi
  11517a:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  11517f:	e8 74 b4 fe ff       	callq  1005f8 <printk>
  115184:	be f8 cd 1b 00       	mov    $0x1bcdf8,%esi
  115189:	bf 12 d2 11 00       	mov    $0x11d212,%edi
  11518e:	31 c0                	xor    %eax,%eax
  115190:	e8 63 b4 fe ff       	callq  1005f8 <printk>
  115195:	be 8e 00 00 00       	mov    $0x8e,%esi
  11519a:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  11519f:	e8 f4 d9 fe ff       	callq  102b98 <assert_post_action>
	z_spin_lock_set_owner(l);
  1151a4:	bf f8 cd 1b 00       	mov    $0x1bcdf8,%edi
  1151a9:	e8 0f 87 ff ff       	callq  10d8bd <z_spin_lock_set_owner>
	clear_event_registrations(events, events_registered, key);
  1151ae:	4c 89 e7             	mov    %r12,%rdi
  1151b1:	89 da                	mov    %ebx,%edx
  1151b3:	44 89 f6             	mov    %r14d,%esi
  1151b6:	e8 2b fa ff ff       	callq  114be6 <clear_event_registrations>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  1151bb:	bf f8 cd 1b 00       	mov    $0x1bcdf8,%edi
  1151c0:	e8 d4 86 ff ff       	callq  10d899 <z_spin_unlock_valid>
  1151c5:	84 c0                	test   %al,%al
  1151c7:	75 39                	jne    115202 <z_impl_k_poll+0x2d5>
  1151c9:	b9 b9 00 00 00       	mov    $0xb9,%ecx
  1151ce:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  1151d3:	be 41 d2 11 00       	mov    $0x11d241,%esi
  1151d8:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  1151dd:	e8 16 b4 fe ff       	callq  1005f8 <printk>
  1151e2:	be f8 cd 1b 00       	mov    $0x1bcdf8,%esi
  1151e7:	bf 58 d2 11 00       	mov    $0x11d258,%edi
  1151ec:	31 c0                	xor    %eax,%eax
  1151ee:	e8 05 b4 fe ff       	callq  1005f8 <printk>
  1151f3:	be b9 00 00 00       	mov    $0xb9,%esi
  1151f8:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  1151fd:	e8 96 d9 fe ff       	callq  102b98 <assert_post_action>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  115202:	0f ba e3 09          	bt     $0x9,%ebx
  115206:	73 01                	jae    115209 <z_impl_k_poll+0x2dc>
		__asm__ volatile ("sti" ::: "memory");
  115208:	fb                   	sti    
}
  115209:	5a                   	pop    %rdx
  11520a:	44 89 e8             	mov    %r13d,%eax
  11520d:	5b                   	pop    %rbx
  11520e:	41 5c                	pop    %r12
  115210:	41 5d                	pop    %r13
  115212:	41 5e                	pop    %r14
  115214:	41 5f                	pop    %r15
  115216:	5d                   	pop    %rbp
  115217:	c3                   	retq   

0000000000115218 <z_mrsh_k_poll>:
#include <syscalls/kernel.h>

extern int z_vrfy_k_poll(struct k_poll_event * events, int num_events, k_timeout_t timeout);
uintptr_t z_mrsh_k_poll(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
  115218:	55                   	push   %rbp
  115219:	48 89 e5             	mov    %rsp,%rbp
  11521c:	41 57                	push   %r15
  11521e:	49 89 ff             	mov    %rdi,%r15
	printk("\ntest1\n");
  115221:	bf 13 07 12 00       	mov    $0x120713,%edi
  115226:	41 56                	push   %r14
  115228:	49 89 f6             	mov    %rsi,%r14
  11522b:	41 55                	push   %r13
  11522d:	41 54                	push   %r12
  11522f:	53                   	push   %rbx
  115230:	48 83 ec 28          	sub    $0x28,%rsp
  115234:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
	_current->syscall_frame = ssf;
  115238:	48 8b 05 11 35 01 00 	mov    0x13511(%rip),%rax        # 128750 <_kernel+0x10>
{
  11523f:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
	_current->syscall_frame = ssf;
  115243:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  115247:	48 89 90 40 01 00 00 	mov    %rdx,0x140(%rax)
  11524e:	31 c0                	xor    %eax,%eax
  115250:	e8 a3 b3 fe ff       	callq  1005f8 <printk>
	if (Z_SYSCALL_VERIFY(num_events >= 0)) {
  115255:	45 85 f6             	test   %r14d,%r14d
  115258:	79 14                	jns    11526e <z_mrsh_k_poll+0x56>
  11525a:	ba a0 ce 11 00       	mov    $0x11cea0,%edx
  11525f:	be 45 00 00 00       	mov    $0x45,%esi
  115264:	bf 1b 07 12 00       	mov    $0x12071b,%edi
  115269:	e9 47 03 00 00       	jmpq   1155b5 <z_mrsh_k_poll+0x39d>
	printk("\ntest2\n");
  11526e:	31 c0                	xor    %eax,%eax
	return __builtin_mul_overflow(a, b, result);
  115270:	41 bc 28 00 00 00    	mov    $0x28,%r12d
  115276:	bf 27 08 12 00       	mov    $0x120827,%edi
  11527b:	e8 78 b3 fe ff       	callq  1005f8 <printk>
  115280:	44 89 e0             	mov    %r12d,%eax
  115283:	41 f7 e6             	mul    %r14d
  115286:	41 89 c4             	mov    %eax,%r12d
  115289:	0f 80 17 03 00 00    	jo     1155a6 <z_mrsh_k_poll+0x38e>
	printk("\ntest3\n");
  11528f:	bf 1f 08 12 00       	mov    $0x12081f,%edi
  115294:	31 c0                	xor    %eax,%eax
  115296:	e8 5d b3 fe ff       	callq  1005f8 <printk>
	return z_thread_aligned_alloc(0, size);
  11529b:	4c 89 e6             	mov    %r12,%rsi
  11529e:	31 ff                	xor    %edi,%edi
  1152a0:	e8 cb 07 00 00       	callq  115a70 <z_thread_aligned_alloc>
  1152a5:	49 89 c5             	mov    %rax,%r13
	if (!events_copy) {
  1152a8:	48 85 c0             	test   %rax,%rax
  1152ab:	0f 84 52 01 00 00    	je     115403 <z_mrsh_k_poll+0x1eb>
	printk("\ntest4\n");
  1152b1:	bf 7c 07 12 00       	mov    $0x12077c,%edi
  1152b6:	31 c0                	xor    %eax,%eax
  1152b8:	e8 3b b3 fe ff       	callq  1005f8 <printk>
  1152bd:	9c                   	pushfq 
  1152be:	fa                   	cli    
  1152bf:	5b                   	pop    %rbx
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  1152c0:	bf f8 cd 1b 00       	mov    $0x1bcdf8,%edi
  1152c5:	e8 af 85 ff ff       	callq  10d879 <z_spin_lock_valid>
  1152ca:	84 c0                	test   %al,%al
  1152cc:	75 39                	jne    115307 <z_mrsh_k_poll+0xef>
  1152ce:	b9 8e 00 00 00       	mov    $0x8e,%ecx
  1152d3:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  1152d8:	be fd d1 11 00       	mov    $0x11d1fd,%esi
  1152dd:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  1152e2:	e8 11 b3 fe ff       	callq  1005f8 <printk>
  1152e7:	be f8 cd 1b 00       	mov    $0x1bcdf8,%esi
  1152ec:	bf 12 d2 11 00       	mov    $0x11d212,%edi
  1152f1:	31 c0                	xor    %eax,%eax
  1152f3:	e8 00 b3 fe ff       	callq  1005f8 <printk>
  1152f8:	be 8e 00 00 00       	mov    $0x8e,%esi
  1152fd:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  115302:	e8 91 d8 fe ff       	callq  102b98 <assert_post_action>
	z_spin_lock_set_owner(l);
  115307:	bf f8 cd 1b 00       	mov    $0x1bcdf8,%edi
  11530c:	e8 ac 85 ff ff       	callq  10d8bd <z_spin_lock_set_owner>
	if (Z_SYSCALL_MEMORY_WRITE(events, bounds)) {
  115311:	ba 01 00 00 00       	mov    $0x1,%edx
  115316:	4c 89 e6             	mov    %r12,%rsi
  115319:	4c 89 ff             	mov    %r15,%rdi
  11531c:	e8 9b 40 ff ff       	callq  1093bc <arch_buffer_validate>
  115321:	85 c0                	test   %eax,%eax
  115323:	0f 84 e4 00 00 00    	je     11540d <z_mrsh_k_poll+0x1f5>
  115329:	bf 1e cf 11 00       	mov    $0x11cf1e,%edi
  11532e:	31 c0                	xor    %eax,%eax
  115330:	41 b9 a4 d2 11 00    	mov    $0x11d2a4,%r9d
  115336:	4d 89 e0             	mov    %r12,%r8
  115339:	4c 89 f9             	mov    %r15,%rcx
  11533c:	ba a0 ce 11 00       	mov    $0x11cea0,%edx
  115341:	be 45 00 00 00       	mov    $0x45,%esi
  115346:	e8 7b dd fe ff       	callq  1030c6 <z_log_minimal_printk>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  11534b:	bf f8 cd 1b 00       	mov    $0x1bcdf8,%edi
  115350:	e8 44 85 ff ff       	callq  10d899 <z_spin_unlock_valid>
  115355:	84 c0                	test   %al,%al
  115357:	75 39                	jne    115392 <z_mrsh_k_poll+0x17a>
  115359:	b9 b9 00 00 00       	mov    $0xb9,%ecx
  11535e:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  115363:	be 41 d2 11 00       	mov    $0x11d241,%esi
  115368:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  11536d:	e8 86 b2 fe ff       	callq  1005f8 <printk>
  115372:	be f8 cd 1b 00       	mov    $0x1bcdf8,%esi
  115377:	bf 58 d2 11 00       	mov    $0x11d258,%edi
  11537c:	31 c0                	xor    %eax,%eax
  11537e:	e8 75 b2 fe ff       	callq  1005f8 <printk>
  115383:	be b9 00 00 00       	mov    $0xb9,%esi
  115388:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  11538d:	e8 06 d8 fe ff       	callq  102b98 <assert_post_action>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  115392:	0f ba e3 09          	bt     $0x9,%ebx
  115396:	73 01                	jae    115399 <z_mrsh_k_poll+0x181>
		__asm__ volatile ("sti" ::: "memory");
  115398:	fb                   	sti    
	k_free(events_copy);
  115399:	4c 89 ef             	mov    %r13,%rdi
  11539c:	e8 bc 06 00 00       	callq  115a5d <k_free>
	Z_OOPS(1);
  1153a1:	eb 4d                	jmp    1153f0 <z_mrsh_k_poll+0x1d8>
			printk("\ntest 6.2\n");
  1153a3:	bf d8 07 12 00       	mov    $0x1207d8,%edi
  1153a8:	31 c0                	xor    %eax,%eax
  1153aa:	e8 49 b2 fe ff       	callq  1005f8 <printk>
			Z_OOPS(Z_SYSCALL_OBJ(e->signal, K_OBJ_POLL_SIGNAL));
  1153af:	48 8b 73 20          	mov    0x20(%rbx),%rsi
  1153b3:	48 89 f7             	mov    %rsi,%rdi
  1153b6:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  1153ba:	e8 15 17 00 00       	callq  116ad4 <z_object_find>
  1153bf:	31 c9                	xor    %ecx,%ecx
  1153c1:	ba 06 00 00 00       	mov    $0x6,%edx
  1153c6:	48 89 c7             	mov    %rax,%rdi
  1153c9:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  1153cd:	e8 8f f2 ff ff       	callq  114661 <z_obj_validation_check>
  1153d2:	85 c0                	test   %eax,%eax
  1153d4:	0f 84 c3 01 00 00    	je     11559d <z_mrsh_k_poll+0x385>
  1153da:	ba a0 ce 11 00       	mov    $0x11cea0,%edx
  1153df:	be 45 00 00 00       	mov    $0x45,%esi
  1153e4:	bf 23 f3 11 00       	mov    $0x11f323,%edi
  1153e9:	31 c0                	xor    %eax,%eax
  1153eb:	e8 d6 dc fe ff       	callq  1030c6 <z_log_minimal_printk>
  1153f0:	48 8b 05 59 33 01 00 	mov    0x13359(%rip),%rax        # 128750 <_kernel+0x10>
  1153f7:	48 8b b8 40 01 00 00 	mov    0x140(%rax),%rdi
  1153fe:	e8 0a 48 ff ff       	callq  109c0d <arch_syscall_oops>
		ret = -ENOMEM;
  115403:	bb f4 ff ff ff       	mov    $0xfffffff4,%ebx
  115408:	e9 b4 01 00 00       	jmpq   1155c1 <z_mrsh_k_poll+0x3a9>
	printk("\ntest5\n");
  11540d:	31 c0                	xor    %eax,%eax
  11540f:	bf 17 08 12 00       	mov    $0x120817,%edi
  115414:	e8 df b1 fe ff       	callq  1005f8 <printk>
	(void)memcpy(events_copy, events, bounds);
  115419:	4c 89 ef             	mov    %r13,%rdi
  11541c:	4c 89 e2             	mov    %r12,%rdx
  11541f:	4c 89 fe             	mov    %r15,%rsi
  115422:	e8 71 4c ff ff       	callq  10a098 <memcpy>
  115427:	bf f8 cd 1b 00       	mov    $0x1bcdf8,%edi
  11542c:	e8 68 84 ff ff       	callq  10d899 <z_spin_unlock_valid>
  115431:	84 c0                	test   %al,%al
  115433:	75 3b                	jne    115470 <z_mrsh_k_poll+0x258>
  115435:	b9 b9 00 00 00       	mov    $0xb9,%ecx
  11543a:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  11543f:	be 41 d2 11 00       	mov    $0x11d241,%esi
  115444:	31 c0                	xor    %eax,%eax
  115446:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  11544b:	e8 a8 b1 fe ff       	callq  1005f8 <printk>
  115450:	be f8 cd 1b 00       	mov    $0x1bcdf8,%esi
  115455:	bf 58 d2 11 00       	mov    $0x11d258,%edi
  11545a:	31 c0                	xor    %eax,%eax
  11545c:	e8 97 b1 fe ff       	callq  1005f8 <printk>
  115461:	be b9 00 00 00       	mov    $0xb9,%esi
  115466:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  11546b:	e8 28 d7 fe ff       	callq  102b98 <assert_post_action>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  115470:	0f ba e3 09          	bt     $0x9,%ebx
  115474:	73 01                	jae    115477 <z_mrsh_k_poll+0x25f>
		__asm__ volatile ("sti" ::: "memory");
  115476:	fb                   	sti    
	printk("\ntest6\n");
  115477:	31 c0                	xor    %eax,%eax
  115479:	bf 84 07 12 00       	mov    $0x120784,%edi
  11547e:	4c 89 eb             	mov    %r13,%rbx
  115481:	e8 72 b1 fe ff       	callq  1005f8 <printk>
	for (int i = 0; i < num_events; i++) {
  115486:	44 89 f0             	mov    %r14d,%eax
  115489:	48 6b c0 28          	imul   $0x28,%rax,%rax
  11548d:	4c 01 e8             	add    %r13,%rax
  115490:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  115494:	48 3b 5d c0          	cmp    -0x40(%rbp),%rbx
  115498:	74 40                	je     1154da <z_mrsh_k_poll+0x2c2>
		if (Z_SYSCALL_VERIFY(e->mode == K_POLL_MODE_NOTIFY_ONLY)) {
  11549a:	f6 43 1a 08          	testb  $0x8,0x1a(%rbx)
  11549e:	74 1d                	je     1154bd <z_mrsh_k_poll+0x2a5>
  1154a0:	bf 8c 07 12 00       	mov    $0x12078c,%edi
  1154a5:	ba a0 ce 11 00       	mov    $0x11cea0,%edx
  1154aa:	be 45 00 00 00       	mov    $0x45,%esi
  1154af:	31 c0                	xor    %eax,%eax
  1154b1:	e8 10 dc fe ff       	callq  1030c6 <z_log_minimal_printk>
			printk("\ntest 6.1\n");
  1154b6:	bf cd 07 12 00       	mov    $0x1207cd,%edi
  1154bb:	eb 0f                	jmp    1154cc <z_mrsh_k_poll+0x2b4>
		switch (e->type) {
  1154bd:	8a 43 19             	mov    0x19(%rbx),%al
  1154c0:	83 e0 1f             	and    $0x1f,%eax
  1154c3:	3c 08                	cmp    $0x8,%al
  1154c5:	76 4b                	jbe    115512 <z_mrsh_k_poll+0x2fa>
			printk("\ntest 6.6\n");
  1154c7:	bf 04 08 12 00       	mov    $0x120804,%edi
  1154cc:	31 c0                	xor    %eax,%eax
			ret = -EINVAL;
  1154ce:	bb ea ff ff ff       	mov    $0xffffffea,%ebx
			printk("\ntest 6.6\n");
  1154d3:	e8 20 b1 fe ff       	callq  1005f8 <printk>
			goto out_free;
  1154d8:	eb 2b                	jmp    115505 <z_mrsh_k_poll+0x2ed>
	printk("\ntest7\n");
  1154da:	bf 0f 08 12 00       	mov    $0x12080f,%edi
  1154df:	31 c0                	xor    %eax,%eax
  1154e1:	e8 12 b1 fe ff       	callq  1005f8 <printk>
	return z_impl_k_poll(events, num_events, timeout);
  1154e6:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  1154ea:	44 89 f6             	mov    %r14d,%esi
  1154ed:	4c 89 ef             	mov    %r13,%rdi
  1154f0:	e8 38 fa ff ff       	callq  114f2d <z_impl_k_poll>
	(void)memcpy((void *)events, events_copy, bounds);
  1154f5:	4c 89 e2             	mov    %r12,%rdx
  1154f8:	4c 89 ee             	mov    %r13,%rsi
  1154fb:	4c 89 ff             	mov    %r15,%rdi
  1154fe:	89 c3                	mov    %eax,%ebx
  115500:	e8 93 4b ff ff       	callq  10a098 <memcpy>
	k_free(events_copy);
  115505:	4c 89 ef             	mov    %r13,%rdi
  115508:	e8 50 05 00 00       	callq  115a5d <k_free>
  11550d:	e9 af 00 00 00       	jmpq   1155c1 <z_mrsh_k_poll+0x3a9>
		switch (e->type) {
  115512:	0f b6 c0             	movzbl %al,%eax
  115515:	ff 24 c5 58 ce 11 00 	jmpq   *0x11ce58(,%rax,8)
			printk("\ntest 6.3\n");
  11551c:	bf e3 07 12 00       	mov    $0x1207e3,%edi
  115521:	31 c0                	xor    %eax,%eax
  115523:	e8 d0 b0 fe ff       	callq  1005f8 <printk>
			Z_OOPS(Z_SYSCALL_OBJ(e->sem, K_OBJ_SEM));
  115528:	48 8b 73 20          	mov    0x20(%rbx),%rsi
  11552c:	48 89 f7             	mov    %rsi,%rdi
  11552f:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  115533:	e8 9c 15 00 00       	callq  116ad4 <z_object_find>
  115538:	31 c9                	xor    %ecx,%ecx
  11553a:	ba 07 00 00 00       	mov    $0x7,%edx
  11553f:	48 89 c7             	mov    %rax,%rdi
  115542:	e9 82 fe ff ff       	jmpq   1153c9 <z_mrsh_k_poll+0x1b1>
			printk("\ntest 6.4\n");
  115547:	bf ee 07 12 00       	mov    $0x1207ee,%edi
  11554c:	31 c0                	xor    %eax,%eax
  11554e:	e8 a5 b0 fe ff       	callq  1005f8 <printk>
			Z_OOPS(Z_SYSCALL_OBJ(e->queue, K_OBJ_QUEUE));
  115553:	48 8b 73 20          	mov    0x20(%rbx),%rsi
  115557:	48 89 f7             	mov    %rsi,%rdi
  11555a:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  11555e:	e8 71 15 00 00       	callq  116ad4 <z_object_find>
  115563:	31 c9                	xor    %ecx,%ecx
  115565:	ba 05 00 00 00       	mov    $0x5,%edx
  11556a:	48 89 c7             	mov    %rax,%rdi
  11556d:	e9 57 fe ff ff       	jmpq   1153c9 <z_mrsh_k_poll+0x1b1>
			printk("\ntest 6.5\n");
  115572:	bf f9 07 12 00       	mov    $0x1207f9,%edi
  115577:	31 c0                	xor    %eax,%eax
  115579:	e8 7a b0 fe ff       	callq  1005f8 <printk>
			Z_OOPS(Z_SYSCALL_OBJ(e->msgq, K_OBJ_MSGQ));
  11557e:	48 8b 73 20          	mov    0x20(%rbx),%rsi
  115582:	48 89 f7             	mov    %rsi,%rdi
  115585:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  115589:	e8 46 15 00 00       	callq  116ad4 <z_object_find>
  11558e:	31 c9                	xor    %ecx,%ecx
  115590:	ba 02 00 00 00       	mov    $0x2,%edx
  115595:	48 89 c7             	mov    %rax,%rdi
  115598:	e9 2c fe ff ff       	jmpq   1153c9 <z_mrsh_k_poll+0x1b1>
	for (int i = 0; i < num_events; i++) {
  11559d:	48 83 c3 28          	add    $0x28,%rbx
  1155a1:	e9 ee fe ff ff       	jmpq   115494 <z_mrsh_k_poll+0x27c>
	if (Z_SYSCALL_VERIFY_MSG(!u32_mul_overflow(num_events, sizeof(struct k_poll_event),
  1155a6:	ba a0 ce 11 00       	mov    $0x11cea0,%edx
  1155ab:	be 45 00 00 00       	mov    $0x45,%esi
  1155b0:	bf 49 07 12 00       	mov    $0x120749,%edi
  1155b5:	31 c0                	xor    %eax,%eax
		ret = -EINVAL;
  1155b7:	bb ea ff ff ff       	mov    $0xffffffea,%ebx
	if (Z_SYSCALL_VERIFY_MSG(!u32_mul_overflow(num_events, sizeof(struct k_poll_event),
  1155bc:	e8 05 db fe ff       	callq  1030c6 <z_log_minimal_printk>
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	int ret = z_vrfy_k_poll(*(struct k_poll_event **)&arg0, *(int*)&arg1, *(k_timeout_t*)&arg2)
;
	_current->syscall_frame = NULL;
  1155c1:	48 8b 05 88 31 01 00 	mov    0x13188(%rip),%rax        # 128750 <_kernel+0x10>
  1155c8:	48 c7 80 40 01 00 00 	movq   $0x0,0x140(%rax)
  1155cf:	00 00 00 00 
	return (uintptr_t) ret;
}
  1155d3:	48 83 c4 28          	add    $0x28,%rsp
	return (uintptr_t) ret;
  1155d7:	48 63 c3             	movslq %ebx,%rax
}
  1155da:	5b                   	pop    %rbx
  1155db:	41 5c                	pop    %r12
  1155dd:	41 5d                	pop    %r13
  1155df:	41 5e                	pop    %r14
  1155e1:	41 5f                	pop    %r15
  1155e3:	5d                   	pop    %rbp
  1155e4:	c3                   	retq   

00000000001155e5 <z_handle_obj_poll_events>:
{
  1155e5:	49 89 f8             	mov    %rdi,%r8
	return list->head == list;
  1155e8:	48 8b 3f             	mov    (%rdi),%rdi

static inline sys_dnode_t *sys_dlist_get(sys_dlist_t *list)
{
	sys_dnode_t *node = NULL;

	if (!sys_dlist_is_empty(list)) {
  1155eb:	4c 39 c7             	cmp    %r8,%rdi
  1155ee:	74 22                	je     115612 <z_handle_obj_poll_events+0x2d>
	sys_dnode_t *const prev = node->prev;
  1155f0:	48 8b 57 08          	mov    0x8(%rdi),%rdx
	sys_dnode_t *const next = node->next;
  1155f4:	48 8b 07             	mov    (%rdi),%rax
	prev->next = next;
  1155f7:	48 89 02             	mov    %rax,(%rdx)
	next->prev = prev;
  1155fa:	48 89 50 08          	mov    %rdx,0x8(%rax)
	node->next = NULL;
  1155fe:	48 c7 07 00 00 00 00 	movq   $0x0,(%rdi)
	node->prev = NULL;
  115605:	48 c7 47 08 00 00 00 	movq   $0x0,0x8(%rdi)
  11560c:	00 
		(void)signal_poll_event(poll_event, state);
  11560d:	e9 9e f4 ff ff       	jmpq   114ab0 <signal_poll_event>
}
  115612:	c3                   	retq   

0000000000115613 <z_impl_k_poll_signal_init>:
	list->head = (sys_dnode_t *)list;
  115613:	48 89 3f             	mov    %rdi,(%rdi)
	list->tail = (sys_dnode_t *)list;
  115616:	48 89 7f 08          	mov    %rdi,0x8(%rdi)
	sig->signaled = 0U;
  11561a:	c7 47 10 00 00 00 00 	movl   $0x0,0x10(%rdi)
	z_object_init(sig);
  115621:	e9 cb 19 00 00       	jmpq   116ff1 <z_object_init>

0000000000115626 <z_mrsh_k_poll_signal_init>:
#include <syscalls/kernel.h>

extern void z_vrfy_k_poll_signal_init(struct k_poll_signal * sig);
uintptr_t z_mrsh_k_poll_signal_init(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
  115626:	55                   	push   %rbp
  115627:	48 89 e5             	mov    %rsp,%rbp
  11562a:	41 54                	push   %r12
  11562c:	49 89 fc             	mov    %rdi,%r12
  11562f:	51                   	push   %rcx
	_current->syscall_frame = ssf;
  115630:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  115634:	48 8b 05 15 31 01 00 	mov    0x13115(%rip),%rax        # 128750 <_kernel+0x10>
  11563b:	48 89 90 40 01 00 00 	mov    %rdx,0x140(%rax)
	Z_OOPS(Z_SYSCALL_OBJ_INIT(sig, K_OBJ_POLL_SIGNAL));
  115642:	e8 8d 14 00 00       	callq  116ad4 <z_object_find>
  115647:	b9 01 00 00 00       	mov    $0x1,%ecx
  11564c:	ba 06 00 00 00       	mov    $0x6,%edx
  115651:	4c 89 e6             	mov    %r12,%rsi
  115654:	48 89 c7             	mov    %rax,%rdi
  115657:	e8 05 f0 ff ff       	callq  114661 <z_obj_validation_check>
  11565c:	85 c0                	test   %eax,%eax
  11565e:	74 29                	je     115689 <z_mrsh_k_poll_signal_init+0x63>
  115660:	bf 23 f3 11 00       	mov    $0x11f323,%edi
  115665:	31 c0                	xor    %eax,%eax
  115667:	ba c0 c6 11 00       	mov    $0x11c6c0,%edx
  11566c:	be 45 00 00 00       	mov    $0x45,%esi
  115671:	e8 50 da fe ff       	callq  1030c6 <z_log_minimal_printk>
  115676:	48 8b 05 d3 30 01 00 	mov    0x130d3(%rip),%rax        # 128750 <_kernel+0x10>
  11567d:	48 8b b8 40 01 00 00 	mov    0x140(%rax),%rdi
  115684:	e8 84 45 ff ff       	callq  109c0d <arch_syscall_oops>
	z_impl_k_poll_signal_init(sig);
  115689:	4c 89 e7             	mov    %r12,%rdi
  11568c:	e8 82 ff ff ff       	callq  115613 <z_impl_k_poll_signal_init>
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	z_vrfy_k_poll_signal_init(*(struct k_poll_signal **)&arg0)
;
	_current->syscall_frame = NULL;
  115691:	48 8b 05 b8 30 01 00 	mov    0x130b8(%rip),%rax        # 128750 <_kernel+0x10>
  115698:	48 c7 80 40 01 00 00 	movq   $0x0,0x140(%rax)
  11569f:	00 00 00 00 
	return 0;
}
  1156a3:	31 c0                	xor    %eax,%eax
  1156a5:	5a                   	pop    %rdx
  1156a6:	41 5c                	pop    %r12
  1156a8:	5d                   	pop    %rbp
  1156a9:	c3                   	retq   

00000000001156aa <z_impl_k_poll_signal_reset>:
	sig->signaled = 0U;
  1156aa:	c7 47 10 00 00 00 00 	movl   $0x0,0x10(%rdi)
}
  1156b1:	c3                   	retq   

00000000001156b2 <z_impl_k_poll_signal_check>:
	*signaled = sig->signaled;
  1156b2:	8b 47 10             	mov    0x10(%rdi),%eax
  1156b5:	89 06                	mov    %eax,(%rsi)
	*result = sig->result;
  1156b7:	8b 47 14             	mov    0x14(%rdi),%eax
  1156ba:	89 02                	mov    %eax,(%rdx)
}
  1156bc:	c3                   	retq   

00000000001156bd <z_vrfy_k_poll_signal_check>:
{
  1156bd:	55                   	push   %rbp
  1156be:	48 89 e5             	mov    %rsp,%rbp
  1156c1:	41 55                	push   %r13
  1156c3:	49 89 d5             	mov    %rdx,%r13
  1156c6:	41 54                	push   %r12
  1156c8:	49 89 f4             	mov    %rsi,%r12
  1156cb:	53                   	push   %rbx
  1156cc:	48 89 fb             	mov    %rdi,%rbx
  1156cf:	51                   	push   %rcx
	Z_OOPS(Z_SYSCALL_OBJ(sig, K_OBJ_POLL_SIGNAL));
  1156d0:	e8 ff 13 00 00       	callq  116ad4 <z_object_find>
  1156d5:	31 c9                	xor    %ecx,%ecx
  1156d7:	ba 06 00 00 00       	mov    $0x6,%edx
  1156dc:	48 89 de             	mov    %rbx,%rsi
  1156df:	48 89 c7             	mov    %rax,%rdi
  1156e2:	e8 7a ef ff ff       	callq  114661 <z_obj_validation_check>
  1156e7:	85 c0                	test   %eax,%eax
  1156e9:	74 18                	je     115703 <z_vrfy_k_poll_signal_check+0x46>
  1156eb:	ba a0 c6 11 00       	mov    $0x11c6a0,%edx
  1156f0:	be 45 00 00 00       	mov    $0x45,%esi
  1156f5:	bf 23 f3 11 00       	mov    $0x11f323,%edi
  1156fa:	31 c0                	xor    %eax,%eax
  1156fc:	e8 c5 d9 fe ff       	callq  1030c6 <z_log_minimal_printk>
  115701:	eb 3b                	jmp    11573e <z_vrfy_k_poll_signal_check+0x81>
	Z_OOPS(Z_SYSCALL_MEMORY_WRITE(signaled, sizeof(unsigned int)));
  115703:	ba 01 00 00 00       	mov    $0x1,%edx
  115708:	be 04 00 00 00       	mov    $0x4,%esi
  11570d:	4c 89 e7             	mov    %r12,%rdi
  115710:	e8 a7 3c ff ff       	callq  1093bc <arch_buffer_validate>
  115715:	85 c0                	test   %eax,%eax
  115717:	74 38                	je     115751 <z_vrfy_k_poll_signal_check+0x94>
  115719:	41 b9 a4 d2 11 00    	mov    $0x11d2a4,%r9d
  11571f:	41 b8 04 00 00 00    	mov    $0x4,%r8d
  115725:	4c 89 e1             	mov    %r12,%rcx
  115728:	ba a0 c6 11 00       	mov    $0x11c6a0,%edx
  11572d:	be 45 00 00 00       	mov    $0x45,%esi
  115732:	bf 1e cf 11 00       	mov    $0x11cf1e,%edi
  115737:	31 c0                	xor    %eax,%eax
  115739:	e8 88 d9 fe ff       	callq  1030c6 <z_log_minimal_printk>
  11573e:	48 8b 05 0b 30 01 00 	mov    0x1300b(%rip),%rax        # 128750 <_kernel+0x10>
  115745:	48 8b b8 40 01 00 00 	mov    0x140(%rax),%rdi
  11574c:	e8 bc 44 ff ff       	callq  109c0d <arch_syscall_oops>
	Z_OOPS(Z_SYSCALL_MEMORY_WRITE(result, sizeof(int)));
  115751:	ba 01 00 00 00       	mov    $0x1,%edx
  115756:	be 04 00 00 00       	mov    $0x4,%esi
  11575b:	4c 89 ef             	mov    %r13,%rdi
  11575e:	e8 59 3c ff ff       	callq  1093bc <arch_buffer_validate>
  115763:	85 c0                	test   %eax,%eax
  115765:	74 11                	je     115778 <z_vrfy_k_poll_signal_check+0xbb>
  115767:	41 b9 a4 d2 11 00    	mov    $0x11d2a4,%r9d
  11576d:	41 b8 04 00 00 00    	mov    $0x4,%r8d
  115773:	4c 89 e9             	mov    %r13,%rcx
  115776:	eb b0                	jmp    115728 <z_vrfy_k_poll_signal_check+0x6b>
	*signaled = sig->signaled;
  115778:	8b 43 10             	mov    0x10(%rbx),%eax
  11577b:	41 89 04 24          	mov    %eax,(%r12)
	*result = sig->result;
  11577f:	8b 43 14             	mov    0x14(%rbx),%eax
  115782:	41 89 45 00          	mov    %eax,0x0(%r13)
}
  115786:	58                   	pop    %rax
  115787:	5b                   	pop    %rbx
  115788:	41 5c                	pop    %r12
  11578a:	41 5d                	pop    %r13
  11578c:	5d                   	pop    %rbp
  11578d:	c3                   	retq   

000000000011578e <z_mrsh_k_poll_signal_check>:
#include <syscalls/kernel.h>

extern void z_vrfy_k_poll_signal_check(struct k_poll_signal * sig, unsigned int * signaled, int * result);
uintptr_t z_mrsh_k_poll_signal_check(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
  11578e:	55                   	push   %rbp
	_current->syscall_frame = ssf;
  11578f:	48 8b 05 ba 2f 01 00 	mov    0x12fba(%rip),%rax        # 128750 <_kernel+0x10>
{
  115796:	48 89 e5             	mov    %rsp,%rbp
	_current->syscall_frame = ssf;
  115799:	48 8b 4d 10          	mov    0x10(%rbp),%rcx
  11579d:	48 89 88 40 01 00 00 	mov    %rcx,0x140(%rax)
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	z_vrfy_k_poll_signal_check(*(struct k_poll_signal **)&arg0, *(unsigned int **)&arg1, *(int **)&arg2)
  1157a4:	e8 14 ff ff ff       	callq  1156bd <z_vrfy_k_poll_signal_check>
;
	_current->syscall_frame = NULL;
  1157a9:	48 8b 05 a0 2f 01 00 	mov    0x12fa0(%rip),%rax        # 128750 <_kernel+0x10>
  1157b0:	48 c7 80 40 01 00 00 	movq   $0x0,0x140(%rax)
  1157b7:	00 00 00 00 
	return 0;
}
  1157bb:	31 c0                	xor    %eax,%eax
  1157bd:	5d                   	pop    %rbp
  1157be:	c3                   	retq   

00000000001157bf <z_impl_k_poll_signal_raise>:
{
  1157bf:	55                   	push   %rbp
  1157c0:	48 89 e5             	mov    %rsp,%rbp
  1157c3:	41 55                	push   %r13
  1157c5:	41 54                	push   %r12
  1157c7:	41 89 f4             	mov    %esi,%r12d
  1157ca:	53                   	push   %rbx
  1157cb:	48 89 fb             	mov    %rdi,%rbx
  1157ce:	48 83 ec 18          	sub    $0x18,%rsp
  1157d2:	9c                   	pushfq 
  1157d3:	fa                   	cli    
  1157d4:	41 5d                	pop    %r13
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  1157d6:	bf f8 cd 1b 00       	mov    $0x1bcdf8,%edi
  1157db:	e8 99 80 ff ff       	callq  10d879 <z_spin_lock_valid>
  1157e0:	84 c0                	test   %al,%al
  1157e2:	75 39                	jne    11581d <z_impl_k_poll_signal_raise+0x5e>
  1157e4:	b9 8e 00 00 00       	mov    $0x8e,%ecx
  1157e9:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  1157ee:	be fd d1 11 00       	mov    $0x11d1fd,%esi
  1157f3:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  1157f8:	e8 fb ad fe ff       	callq  1005f8 <printk>
  1157fd:	be f8 cd 1b 00       	mov    $0x1bcdf8,%esi
  115802:	bf 12 d2 11 00       	mov    $0x11d212,%edi
  115807:	31 c0                	xor    %eax,%eax
  115809:	e8 ea ad fe ff       	callq  1005f8 <printk>
  11580e:	be 8e 00 00 00       	mov    $0x8e,%esi
  115813:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  115818:	e8 7b d3 fe ff       	callq  102b98 <assert_post_action>
	z_spin_lock_set_owner(l);
  11581d:	bf f8 cd 1b 00       	mov    $0x1bcdf8,%edi
  115822:	e8 96 80 ff ff       	callq  10d8bd <z_spin_lock_set_owner>
	return list->head == list;
  115827:	48 8b 3b             	mov    (%rbx),%rdi
	sig->result = result;
  11582a:	44 89 63 14          	mov    %r12d,0x14(%rbx)
	sig->signaled = 1U;
  11582e:	c7 43 10 01 00 00 00 	movl   $0x1,0x10(%rbx)
	if (!sys_dlist_is_empty(list)) {
  115835:	48 39 fb             	cmp    %rdi,%rbx
  115838:	75 4b                	jne    115885 <z_impl_k_poll_signal_raise+0xc6>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  11583a:	bf f8 cd 1b 00       	mov    $0x1bcdf8,%edi
  11583f:	e8 55 80 ff ff       	callq  10d899 <z_spin_unlock_valid>
  115844:	84 c0                	test   %al,%al
  115846:	75 79                	jne    1158c1 <z_impl_k_poll_signal_raise+0x102>
  115848:	b9 b9 00 00 00       	mov    $0xb9,%ecx
  11584d:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  115852:	31 c0                	xor    %eax,%eax
  115854:	be 41 d2 11 00       	mov    $0x11d241,%esi
  115859:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  11585e:	e8 95 ad fe ff       	callq  1005f8 <printk>
  115863:	be f8 cd 1b 00       	mov    $0x1bcdf8,%esi
  115868:	bf 58 d2 11 00       	mov    $0x11d258,%edi
  11586d:	31 c0                	xor    %eax,%eax
  11586f:	e8 84 ad fe ff       	callq  1005f8 <printk>
  115874:	be b9 00 00 00       	mov    $0xb9,%esi
  115879:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  11587e:	e8 15 d3 fe ff       	callq  102b98 <assert_post_action>
  115883:	eb 3c                	jmp    1158c1 <z_impl_k_poll_signal_raise+0x102>
	sys_dnode_t *const prev = node->prev;
  115885:	48 8b 57 08          	mov    0x8(%rdi),%rdx
	sys_dnode_t *const next = node->next;
  115889:	48 8b 07             	mov    (%rdi),%rax
	int rc = signal_poll_event(poll_event, K_POLL_STATE_SIGNALED);
  11588c:	be 01 00 00 00       	mov    $0x1,%esi
	prev->next = next;
  115891:	48 89 02             	mov    %rax,(%rdx)
	next->prev = prev;
  115894:	48 89 50 08          	mov    %rdx,0x8(%rax)
	node->next = NULL;
  115898:	48 c7 07 00 00 00 00 	movq   $0x0,(%rdi)
	node->prev = NULL;
  11589f:	48 c7 47 08 00 00 00 	movq   $0x0,0x8(%rdi)
  1158a6:	00 
  1158a7:	e8 04 f2 ff ff       	callq  114ab0 <signal_poll_event>
	z_reschedule(&lock, key);
  1158ac:	44 89 ee             	mov    %r13d,%esi
  1158af:	bf f8 cd 1b 00       	mov    $0x1bcdf8,%edi
	int rc = signal_poll_event(poll_event, K_POLL_STATE_SIGNALED);
  1158b4:	89 45 dc             	mov    %eax,-0x24(%rbp)
	z_reschedule(&lock, key);
  1158b7:	e8 a5 b4 ff ff       	callq  110d61 <z_reschedule>
	return rc;
  1158bc:	8b 45 dc             	mov    -0x24(%rbp),%eax
  1158bf:	eb 0a                	jmp    1158cb <z_impl_k_poll_signal_raise+0x10c>
		return 0;
  1158c1:	31 c0                	xor    %eax,%eax
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  1158c3:	41 0f ba e5 09       	bt     $0x9,%r13d
  1158c8:	73 01                	jae    1158cb <z_impl_k_poll_signal_raise+0x10c>
		__asm__ volatile ("sti" ::: "memory");
  1158ca:	fb                   	sti    
}
  1158cb:	48 83 c4 18          	add    $0x18,%rsp
  1158cf:	5b                   	pop    %rbx
  1158d0:	41 5c                	pop    %r12
  1158d2:	41 5d                	pop    %r13
  1158d4:	5d                   	pop    %rbp
  1158d5:	c3                   	retq   

00000000001158d6 <z_mrsh_k_poll_signal_raise>:
#include <syscalls/kernel.h>

extern int z_vrfy_k_poll_signal_raise(struct k_poll_signal * sig, int result);
uintptr_t z_mrsh_k_poll_signal_raise(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
  1158d6:	55                   	push   %rbp
	_current->syscall_frame = ssf;
  1158d7:	48 8b 05 72 2e 01 00 	mov    0x12e72(%rip),%rax        # 128750 <_kernel+0x10>
{
  1158de:	48 89 e5             	mov    %rsp,%rbp
  1158e1:	41 54                	push   %r12
  1158e3:	49 89 fc             	mov    %rdi,%r12
	_current->syscall_frame = ssf;
  1158e6:	48 8b 55 10          	mov    0x10(%rbp),%rdx
{
  1158ea:	53                   	push   %rbx
  1158eb:	48 89 f3             	mov    %rsi,%rbx
	_current->syscall_frame = ssf;
  1158ee:	48 89 90 40 01 00 00 	mov    %rdx,0x140(%rax)
	Z_OOPS(Z_SYSCALL_OBJ(sig, K_OBJ_POLL_SIGNAL));
  1158f5:	e8 da 11 00 00       	callq  116ad4 <z_object_find>
  1158fa:	31 c9                	xor    %ecx,%ecx
  1158fc:	ba 06 00 00 00       	mov    $0x6,%edx
  115901:	4c 89 e6             	mov    %r12,%rsi
  115904:	48 89 c7             	mov    %rax,%rdi
  115907:	e8 55 ed ff ff       	callq  114661 <z_obj_validation_check>
  11590c:	85 c0                	test   %eax,%eax
  11590e:	74 29                	je     115939 <z_mrsh_k_poll_signal_raise+0x63>
  115910:	bf 23 f3 11 00       	mov    $0x11f323,%edi
  115915:	31 c0                	xor    %eax,%eax
  115917:	ba 80 c6 11 00       	mov    $0x11c680,%edx
  11591c:	be 45 00 00 00       	mov    $0x45,%esi
  115921:	e8 a0 d7 fe ff       	callq  1030c6 <z_log_minimal_printk>
  115926:	48 8b 05 23 2e 01 00 	mov    0x12e23(%rip),%rax        # 128750 <_kernel+0x10>
  11592d:	48 8b b8 40 01 00 00 	mov    0x140(%rax),%rdi
  115934:	e8 d4 42 ff ff       	callq  109c0d <arch_syscall_oops>
	return z_impl_k_poll_signal_raise(sig, result);
  115939:	89 de                	mov    %ebx,%esi
  11593b:	4c 89 e7             	mov    %r12,%rdi
  11593e:	e8 7c fe ff ff       	callq  1157bf <z_impl_k_poll_signal_raise>
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	int ret = z_vrfy_k_poll_signal_raise(*(struct k_poll_signal **)&arg0, *(int*)&arg1)
;
	_current->syscall_frame = NULL;
  115943:	48 8b 15 06 2e 01 00 	mov    0x12e06(%rip),%rdx        # 128750 <_kernel+0x10>
	return (uintptr_t) ret;
  11594a:	48 98                	cltq   
	_current->syscall_frame = NULL;
  11594c:	48 c7 82 40 01 00 00 	movq   $0x0,0x140(%rdx)
  115953:	00 00 00 00 
}
  115957:	5b                   	pop    %rbx
  115958:	41 5c                	pop    %r12
  11595a:	5d                   	pop    %rbp
  11595b:	c3                   	retq   

000000000011595c <z_mrsh_k_poll_signal_reset>:
#include <syscalls/kernel.h>

extern void z_vrfy_k_poll_signal_reset(struct k_poll_signal * sig);
uintptr_t z_mrsh_k_poll_signal_reset(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
  11595c:	55                   	push   %rbp
  11595d:	48 89 e5             	mov    %rsp,%rbp
  115960:	53                   	push   %rbx
  115961:	48 89 fb             	mov    %rdi,%rbx
  115964:	51                   	push   %rcx
	_current->syscall_frame = ssf;
  115965:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  115969:	48 8b 05 e0 2d 01 00 	mov    0x12de0(%rip),%rax        # 128750 <_kernel+0x10>
  115970:	48 89 90 40 01 00 00 	mov    %rdx,0x140(%rax)
	Z_OOPS(Z_SYSCALL_OBJ(sig, K_OBJ_POLL_SIGNAL));
  115977:	e8 58 11 00 00       	callq  116ad4 <z_object_find>
  11597c:	31 c9                	xor    %ecx,%ecx
  11597e:	ba 06 00 00 00       	mov    $0x6,%edx
  115983:	48 89 de             	mov    %rbx,%rsi
  115986:	48 89 c7             	mov    %rax,%rdi
  115989:	e8 d3 ec ff ff       	callq  114661 <z_obj_validation_check>
  11598e:	85 c0                	test   %eax,%eax
  115990:	74 29                	je     1159bb <z_mrsh_k_poll_signal_reset+0x5f>
  115992:	bf 23 f3 11 00       	mov    $0x11f323,%edi
  115997:	31 c0                	xor    %eax,%eax
  115999:	ba 60 c6 11 00       	mov    $0x11c660,%edx
  11599e:	be 45 00 00 00       	mov    $0x45,%esi
  1159a3:	e8 1e d7 fe ff       	callq  1030c6 <z_log_minimal_printk>
  1159a8:	48 8b 05 a1 2d 01 00 	mov    0x12da1(%rip),%rax        # 128750 <_kernel+0x10>
  1159af:	48 8b b8 40 01 00 00 	mov    0x140(%rax),%rdi
  1159b6:	e8 52 42 ff ff       	callq  109c0d <arch_syscall_oops>
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	z_vrfy_k_poll_signal_reset(*(struct k_poll_signal **)&arg0)
;
	_current->syscall_frame = NULL;
  1159bb:	48 8b 05 8e 2d 01 00 	mov    0x12d8e(%rip),%rax        # 128750 <_kernel+0x10>
	sig->signaled = 0U;
  1159c2:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%rbx)
  1159c9:	48 c7 80 40 01 00 00 	movq   $0x0,0x140(%rax)
  1159d0:	00 00 00 00 
	return 0;
}
  1159d4:	31 c0                	xor    %eax,%eax
  1159d6:	5a                   	pop    %rdx
  1159d7:	5b                   	pop    %rbx
  1159d8:	5d                   	pop    %rbp
  1159d9:	c3                   	retq   

00000000001159da <z_heap_aligned_alloc>:
#include <string.h>
#include <sys/math_extras.h>
#include <sys/util.h>

static void *z_heap_aligned_alloc(struct k_heap *heap, size_t align, size_t size)
{
  1159da:	55                   	push   %rbp
  1159db:	48 89 e5             	mov    %rsp,%rbp
  1159de:	41 55                	push   %r13
  1159e0:	41 54                	push   %r12
	return __builtin_add_overflow(a, b, result);
  1159e2:	48 83 c2 08          	add    $0x8,%rdx
  1159e6:	72 16                	jb     1159fe <z_heap_aligned_alloc+0x24>
  1159e8:	49 89 f5             	mov    %rsi,%r13
	if (size_add_overflow(size, sizeof(heap_ref), &size)) {
		return NULL;
	}
	__align = align | sizeof(heap_ref);

	mem = k_heap_aligned_alloc(heap, __align, size, K_NO_WAIT);
  1159eb:	31 c9                	xor    %ecx,%ecx
	__align = align | sizeof(heap_ref);
  1159ed:	48 83 ce 08          	or     $0x8,%rsi
  1159f1:	49 89 fc             	mov    %rdi,%r12
	mem = k_heap_aligned_alloc(heap, __align, size, K_NO_WAIT);
  1159f4:	e8 55 17 00 00       	callq  11714e <k_heap_aligned_alloc>
	if (mem == NULL) {
  1159f9:	48 85 c0             	test   %rax,%rax
  1159fc:	75 05                	jne    115a03 <z_heap_aligned_alloc+0x29>
		return NULL;
  1159fe:	45 31 e4             	xor    %r12d,%r12d
  115a01:	eb 51                	jmp    115a54 <z_heap_aligned_alloc+0x7a>
		return NULL;
	}

	heap_ref = mem;
	*heap_ref = heap;
  115a03:	4c 89 20             	mov    %r12,(%rax)
	mem = ++heap_ref;
  115a06:	4c 8d 60 08          	lea    0x8(%rax),%r12
	__ASSERT(align == 0 || ((uintptr_t)mem & (align - 1)) == 0,
  115a0a:	4d 85 ed             	test   %r13,%r13
  115a0d:	74 45                	je     115a54 <z_heap_aligned_alloc+0x7a>
  115a0f:	49 8d 45 ff          	lea    -0x1(%r13),%rax
  115a13:	49 85 c4             	test   %rax,%r12
  115a16:	74 3c                	je     115a54 <z_heap_aligned_alloc+0x7a>
  115a18:	b9 25 00 00 00       	mov    $0x25,%ecx
  115a1d:	ba 2f 08 12 00       	mov    $0x12082f,%edx
  115a22:	be 53 08 12 00       	mov    $0x120853,%esi
  115a27:	31 c0                	xor    %eax,%eax
  115a29:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  115a2e:	e8 c5 ab fe ff       	callq  1005f8 <printk>
  115a33:	4c 89 e6             	mov    %r12,%rsi
  115a36:	bf 85 08 12 00       	mov    $0x120885,%edi
  115a3b:	4c 89 ea             	mov    %r13,%rdx
  115a3e:	31 c0                	xor    %eax,%eax
  115a40:	e8 b3 ab fe ff       	callq  1005f8 <printk>
  115a45:	be 25 00 00 00       	mov    $0x25,%esi
  115a4a:	bf 2f 08 12 00       	mov    $0x12082f,%edi
  115a4f:	e8 44 d1 fe ff       	callq  102b98 <assert_post_action>
		 "misaligned memory at %p (align = %zu)", mem, align);

	return mem;
}
  115a54:	4c 89 e0             	mov    %r12,%rax
  115a57:	41 5c                	pop    %r12
  115a59:	41 5d                	pop    %r13
  115a5b:	5d                   	pop    %rbp
  115a5c:	c3                   	retq   

0000000000115a5d <k_free>:

void k_free(void *ptr)
{
	struct k_heap **heap_ref;

	if (ptr != NULL) {
  115a5d:	48 85 ff             	test   %rdi,%rdi
  115a60:	74 0d                	je     115a6f <k_free+0x12>
		heap_ref = ptr;
		ptr = --heap_ref;
  115a62:	48 8d 77 f8          	lea    -0x8(%rdi),%rsi

		SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_heap_sys, k_free, *heap_ref);

		k_heap_free(*heap_ref, ptr);
  115a66:	48 8b 7f f8          	mov    -0x8(%rdi),%rdi
  115a6a:	e9 8f 18 00 00       	jmpq   1172fe <k_heap_free>

		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_heap_sys, k_free, *heap_ref);
	}
}
  115a6f:	c3                   	retq   

0000000000115a70 <z_thread_aligned_alloc>:
#else
#define _SYSTEM_HEAP	NULL
#endif

void *z_thread_aligned_alloc(size_t align, size_t size)
{
  115a70:	55                   	push   %rbp
  115a71:	48 89 e5             	mov    %rsp,%rbp
  115a74:	41 55                	push   %r13
  115a76:	49 89 f5             	mov    %rsi,%r13
  115a79:	41 54                	push   %r12
  115a7b:	49 89 fc             	mov    %rdi,%r12
	void *ret;
	struct k_heap *heap;

	if (k_is_in_isr()) {
  115a7e:	e8 1e 7b ff ff       	callq  10d5a1 <k_is_in_isr>
  115a83:	84 c0                	test   %al,%al
  115a85:	75 15                	jne    115a9c <z_thread_aligned_alloc+0x2c>
		heap = _SYSTEM_HEAP;
	} else {
		heap = _current->resource_pool;
  115a87:	48 8b 05 c2 2c 01 00 	mov    0x12cc2(%rip),%rax        # 128750 <_kernel+0x10>
  115a8e:	48 8b b8 58 01 00 00 	mov    0x158(%rax),%rdi
	}

	if (heap != NULL) {
  115a95:	48 85 ff             	test   %rdi,%rdi
  115a98:	74 17                	je     115ab1 <z_thread_aligned_alloc+0x41>
  115a9a:	eb 05                	jmp    115aa1 <z_thread_aligned_alloc+0x31>
		heap = _SYSTEM_HEAP;
  115a9c:	bf 70 14 5e 00       	mov    $0x5e1470,%edi
		ret = z_heap_aligned_alloc(heap, align, size);
  115aa1:	4c 89 ea             	mov    %r13,%rdx
  115aa4:	4c 89 e6             	mov    %r12,%rsi
	} else {
		ret = NULL;
	}

	return ret;
}
  115aa7:	41 5c                	pop    %r12
  115aa9:	41 5d                	pop    %r13
  115aab:	5d                   	pop    %rbp
		ret = z_heap_aligned_alloc(heap, align, size);
  115aac:	e9 29 ff ff ff       	jmpq   1159da <z_heap_aligned_alloc>
}
  115ab1:	41 5c                	pop    %r12
  115ab3:	31 c0                	xor    %eax,%eax
  115ab5:	41 5d                	pop    %r13
  115ab7:	5d                   	pop    %rbp
  115ab8:	c3                   	retq   

0000000000115ab9 <z_impl_k_futex_wake>:

	return obj->data.futex_data;
}

int z_impl_k_futex_wake(struct k_futex *futex, bool wake_all)
{
  115ab9:	55                   	push   %rbp
  115aba:	48 89 e5             	mov    %rsp,%rbp
  115abd:	41 57                	push   %r15
  115abf:	41 56                	push   %r14
  115ac1:	41 55                	push   %r13
  115ac3:	41 89 f5             	mov    %esi,%r13d
  115ac6:	41 54                	push   %r12
  115ac8:	53                   	push   %rbx
  115ac9:	51                   	push   %rcx
	obj = z_object_find(futex);
  115aca:	e8 05 10 00 00       	callq  116ad4 <z_object_find>
  115acf:	48 89 c2             	mov    %rax,%rdx
	struct k_thread *thread;
	struct z_futex_data *futex_data;

	futex_data = k_futex_find_data(futex);
	if (futex_data == NULL) {
		return -EINVAL;
  115ad2:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
	if (obj == NULL || obj->type != K_OBJ_FUTEX) {
  115ad7:	48 85 d2             	test   %rdx,%rdx
  115ada:	0f 84 9f 00 00 00    	je     115b7f <z_impl_k_futex_wake+0xc6>
  115ae0:	80 7a 0c 0f          	cmpb   $0xf,0xc(%rdx)
  115ae4:	0f 85 95 00 00 00    	jne    115b7f <z_impl_k_futex_wake+0xc6>
	return obj->data.futex_data;
  115aea:	4c 8b 72 0e          	mov    0xe(%rdx),%r14
	if (futex_data == NULL) {
  115aee:	4d 85 f6             	test   %r14,%r14
  115af1:	0f 84 88 00 00 00    	je     115b7f <z_impl_k_futex_wake+0xc6>
	}

	key = k_spin_lock(&futex_data->lock);
  115af7:	4d 8d 66 10          	lea    0x10(%r14),%r12
  115afb:	9c                   	pushfq 
  115afc:	fa                   	cli    
  115afd:	41 5f                	pop    %r15
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  115aff:	4c 89 e7             	mov    %r12,%rdi
  115b02:	e8 72 7d ff ff       	callq  10d879 <z_spin_lock_valid>
  115b07:	84 c0                	test   %al,%al
  115b09:	75 37                	jne    115b42 <z_impl_k_futex_wake+0x89>
  115b0b:	b9 8e 00 00 00       	mov    $0x8e,%ecx
  115b10:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  115b15:	be fd d1 11 00       	mov    $0x11d1fd,%esi
  115b1a:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  115b1f:	e8 d4 aa fe ff       	callq  1005f8 <printk>
  115b24:	4c 89 e6             	mov    %r12,%rsi
  115b27:	bf 12 d2 11 00       	mov    $0x11d212,%edi
  115b2c:	31 c0                	xor    %eax,%eax
  115b2e:	e8 c5 aa fe ff       	callq  1005f8 <printk>
  115b33:	be 8e 00 00 00       	mov    $0x8e,%esi
  115b38:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  115b3d:	e8 56 d0 fe ff       	callq  102b98 <assert_post_action>
	z_spin_lock_set_owner(l);
  115b42:	4c 89 e7             	mov    %r12,%rdi
	unsigned int woken = 0U;
  115b45:	31 db                	xor    %ebx,%ebx
  115b47:	e8 71 7d ff ff       	callq  10d8bd <z_spin_lock_set_owner>

	do {
		thread = z_unpend_first_thread(&futex_data->wait_q);
  115b4c:	4c 89 f7             	mov    %r14,%rdi
  115b4f:	e8 09 c4 ff ff       	callq  111f5d <z_unpend_first_thread>
  115b54:	48 89 c7             	mov    %rax,%rdi
		if (thread != NULL) {
  115b57:	48 85 c0             	test   %rax,%rax
  115b5a:	74 16                	je     115b72 <z_impl_k_futex_wake+0xb9>
	thread->swap_retval = value;
  115b5c:	c7 80 48 01 00 00 00 	movl   $0x0,0x148(%rax)
  115b63:	00 00 00 
			woken++;
  115b66:	ff c3                	inc    %ebx
			arch_thread_return_value_set(thread, 0);
			z_ready_thread(thread);
  115b68:	e8 dd b8 ff ff       	callq  11144a <z_ready_thread>
		}
	} while (thread && wake_all);
  115b6d:	45 84 ed             	test   %r13b,%r13b
  115b70:	75 da                	jne    115b4c <z_impl_k_futex_wake+0x93>

	z_reschedule(&futex_data->lock, key);
  115b72:	44 89 fe             	mov    %r15d,%esi
  115b75:	4c 89 e7             	mov    %r12,%rdi
  115b78:	e8 e4 b1 ff ff       	callq  110d61 <z_reschedule>

	return woken;
  115b7d:	89 d8                	mov    %ebx,%eax
}
  115b7f:	5a                   	pop    %rdx
  115b80:	5b                   	pop    %rbx
  115b81:	41 5c                	pop    %r12
  115b83:	41 5d                	pop    %r13
  115b85:	41 5e                	pop    %r14
  115b87:	41 5f                	pop    %r15
  115b89:	5d                   	pop    %rbp
  115b8a:	c3                   	retq   

0000000000115b8b <z_mrsh_k_futex_wake>:
#include <syscalls/kernel.h>

extern int z_vrfy_k_futex_wake(struct k_futex * futex, bool wake_all);
uintptr_t z_mrsh_k_futex_wake(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
  115b8b:	55                   	push   %rbp
  115b8c:	48 89 e5             	mov    %rsp,%rbp
  115b8f:	41 55                	push   %r13
  115b91:	44 0f b6 ee          	movzbl %sil,%r13d
  115b95:	41 54                	push   %r12
  115b97:	49 89 fc             	mov    %rdi,%r12
  115b9a:	48 83 ec 10          	sub    $0x10,%rsp
	_current->syscall_frame = ssf;
  115b9e:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  115ba2:	48 8b 05 a7 2b 01 00 	mov    0x12ba7(%rip),%rax        # 128750 <_kernel+0x10>
{
  115ba9:	48 89 75 e8          	mov    %rsi,-0x18(%rbp)

static inline int z_vrfy_k_futex_wake(struct k_futex *futex, bool wake_all)
{
	if (Z_SYSCALL_MEMORY_WRITE(futex, sizeof(struct k_futex)) != 0) {
  115bad:	be 04 00 00 00       	mov    $0x4,%esi
	_current->syscall_frame = ssf;
  115bb2:	48 89 90 40 01 00 00 	mov    %rdx,0x140(%rax)
  115bb9:	ba 01 00 00 00       	mov    $0x1,%edx
  115bbe:	e8 f9 37 ff ff       	callq  1093bc <arch_buffer_validate>
  115bc3:	85 c0                	test   %eax,%eax
  115bc5:	74 2c                	je     115bf3 <z_mrsh_k_futex_wake+0x68>
  115bc7:	31 c0                	xor    %eax,%eax
  115bc9:	41 b9 a4 d2 11 00    	mov    $0x11d2a4,%r9d
  115bcf:	4c 89 e1             	mov    %r12,%rcx
  115bd2:	ba 00 c7 11 00       	mov    $0x11c700,%edx
  115bd7:	41 b8 04 00 00 00    	mov    $0x4,%r8d
  115bdd:	be 45 00 00 00       	mov    $0x45,%esi
  115be2:	bf 1e cf 11 00       	mov    $0x11cf1e,%edi
  115be7:	e8 da d4 fe ff       	callq  1030c6 <z_log_minimal_printk>
		return -EACCES;
  115bec:	b8 f3 ff ff ff       	mov    $0xfffffff3,%eax
  115bf1:	eb 0b                	jmp    115bfe <z_mrsh_k_futex_wake+0x73>
	}

	return z_impl_k_futex_wake(futex, wake_all);
  115bf3:	44 89 ee             	mov    %r13d,%esi
  115bf6:	4c 89 e7             	mov    %r12,%rdi
  115bf9:	e8 bb fe ff ff       	callq  115ab9 <z_impl_k_futex_wake>
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	int ret = z_vrfy_k_futex_wake(*(struct k_futex **)&arg0, *(bool*)&arg1)
;
	_current->syscall_frame = NULL;
  115bfe:	48 8b 15 4b 2b 01 00 	mov    0x12b4b(%rip),%rdx        # 128750 <_kernel+0x10>
	return (uintptr_t) ret;
  115c05:	48 98                	cltq   
	_current->syscall_frame = NULL;
  115c07:	48 c7 82 40 01 00 00 	movq   $0x0,0x140(%rdx)
  115c0e:	00 00 00 00 
}
  115c12:	5a                   	pop    %rdx
  115c13:	59                   	pop    %rcx
  115c14:	41 5c                	pop    %r12
  115c16:	41 5d                	pop    %r13
  115c18:	5d                   	pop    %rbp
  115c19:	c3                   	retq   

0000000000115c1a <z_impl_k_futex_wait>:
}
#include <syscalls/k_futex_wake_mrsh.c>

int z_impl_k_futex_wait(struct k_futex *futex, int expected,
			k_timeout_t timeout)
{
  115c1a:	55                   	push   %rbp
  115c1b:	48 89 e5             	mov    %rsp,%rbp
  115c1e:	41 56                	push   %r14
  115c20:	41 55                	push   %r13
  115c22:	49 89 d5             	mov    %rdx,%r13
  115c25:	41 54                	push   %r12
  115c27:	41 89 f4             	mov    %esi,%r12d
  115c2a:	53                   	push   %rbx
  115c2b:	48 89 fb             	mov    %rdi,%rbx
	obj = z_object_find(futex);
  115c2e:	e8 a1 0e 00 00       	callq  116ad4 <z_object_find>
  115c33:	48 89 c2             	mov    %rax,%rdx
	k_spinlock_key_t key;
	struct z_futex_data *futex_data;

	futex_data = k_futex_find_data(futex);
	if (futex_data == NULL) {
		return -EINVAL;
  115c36:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
	if (obj == NULL || obj->type != K_OBJ_FUTEX) {
  115c3b:	48 85 d2             	test   %rdx,%rdx
  115c3e:	0f 84 8b 00 00 00    	je     115ccf <z_impl_k_futex_wait+0xb5>
  115c44:	80 7a 0c 0f          	cmpb   $0xf,0xc(%rdx)
  115c48:	0f 85 81 00 00 00    	jne    115ccf <z_impl_k_futex_wait+0xb5>
	return obj->data.futex_data;
  115c4e:	4c 8b 72 0e          	mov    0xe(%rdx),%r14
	if (futex_data == NULL) {
  115c52:	4d 85 f6             	test   %r14,%r14
  115c55:	74 78                	je     115ccf <z_impl_k_futex_wait+0xb5>
	}

	if (atomic_get(&futex->val) != (atomic_val_t)expected) {
		return -EAGAIN;
  115c57:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
  115c5c:	8b 13                	mov    (%rbx),%edx
	if (atomic_get(&futex->val) != (atomic_val_t)expected) {
  115c5e:	41 39 d4             	cmp    %edx,%r12d
  115c61:	75 6c                	jne    115ccf <z_impl_k_futex_wait+0xb5>
	}

	key = k_spin_lock(&futex_data->lock);
  115c63:	4d 8d 66 10          	lea    0x10(%r14),%r12
  115c67:	9c                   	pushfq 
  115c68:	fa                   	cli    
  115c69:	5b                   	pop    %rbx
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  115c6a:	4c 89 e7             	mov    %r12,%rdi
  115c6d:	e8 07 7c ff ff       	callq  10d879 <z_spin_lock_valid>
  115c72:	84 c0                	test   %al,%al
  115c74:	75 37                	jne    115cad <z_impl_k_futex_wait+0x93>
  115c76:	b9 8e 00 00 00       	mov    $0x8e,%ecx
  115c7b:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  115c80:	be fd d1 11 00       	mov    $0x11d1fd,%esi
  115c85:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  115c8a:	e8 69 a9 fe ff       	callq  1005f8 <printk>
  115c8f:	4c 89 e6             	mov    %r12,%rsi
  115c92:	bf 12 d2 11 00       	mov    $0x11d212,%edi
  115c97:	31 c0                	xor    %eax,%eax
  115c99:	e8 5a a9 fe ff       	callq  1005f8 <printk>
  115c9e:	be 8e 00 00 00       	mov    $0x8e,%esi
  115ca3:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  115ca8:	e8 eb ce fe ff       	callq  102b98 <assert_post_action>
	z_spin_lock_set_owner(l);
  115cad:	4c 89 e7             	mov    %r12,%rdi
  115cb0:	e8 08 7c ff ff       	callq  10d8bd <z_spin_lock_set_owner>

	ret = z_pend_curr(&futex_data->lock,
  115cb5:	4c 89 e9             	mov    %r13,%rcx
  115cb8:	4c 89 f2             	mov    %r14,%rdx
  115cbb:	89 de                	mov    %ebx,%esi
  115cbd:	4c 89 e7             	mov    %r12,%rdi
  115cc0:	e8 23 bd ff ff       	callq  1119e8 <z_pend_curr>
			key, &futex_data->wait_q, timeout);
	if (ret == -EAGAIN) {
  115cc5:	83 f8 f5             	cmp    $0xfffffff5,%eax
  115cc8:	75 05                	jne    115ccf <z_impl_k_futex_wait+0xb5>
		ret = -ETIMEDOUT;
  115cca:	b8 8c ff ff ff       	mov    $0xffffff8c,%eax
	}

	return ret;
}
  115ccf:	5b                   	pop    %rbx
  115cd0:	41 5c                	pop    %r12
  115cd2:	41 5d                	pop    %r13
  115cd4:	41 5e                	pop    %r14
  115cd6:	5d                   	pop    %rbp
  115cd7:	c3                   	retq   

0000000000115cd8 <z_mrsh_k_futex_wait>:
#include <syscalls/kernel.h>

extern int z_vrfy_k_futex_wait(struct k_futex * futex, int expected, k_timeout_t timeout);
uintptr_t z_mrsh_k_futex_wait(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
  115cd8:	55                   	push   %rbp
  115cd9:	48 89 e5             	mov    %rsp,%rbp
  115cdc:	41 55                	push   %r13
  115cde:	49 89 d5             	mov    %rdx,%r13
  115ce1:	41 54                	push   %r12
  115ce3:	49 89 fc             	mov    %rdi,%r12
  115ce6:	53                   	push   %rbx
  115ce7:	48 89 f3             	mov    %rsi,%rbx

static inline int z_vrfy_k_futex_wait(struct k_futex *futex, int expected,
				      k_timeout_t timeout)
{
	if (Z_SYSCALL_MEMORY_WRITE(futex, sizeof(struct k_futex)) != 0) {
  115cea:	be 04 00 00 00       	mov    $0x4,%esi
  115cef:	48 83 ec 18          	sub    $0x18,%rsp
  115cf3:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	_current->syscall_frame = ssf;
  115cf7:	48 8b 05 52 2a 01 00 	mov    0x12a52(%rip),%rax        # 128750 <_kernel+0x10>
  115cfe:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  115d02:	48 89 90 40 01 00 00 	mov    %rdx,0x140(%rax)
  115d09:	ba 01 00 00 00       	mov    $0x1,%edx
  115d0e:	e8 a9 36 ff ff       	callq  1093bc <arch_buffer_validate>
  115d13:	85 c0                	test   %eax,%eax
  115d15:	74 2c                	je     115d43 <z_mrsh_k_futex_wait+0x6b>
  115d17:	31 c0                	xor    %eax,%eax
  115d19:	41 b9 a4 d2 11 00    	mov    $0x11d2a4,%r9d
  115d1f:	4c 89 e1             	mov    %r12,%rcx
  115d22:	ba e0 c6 11 00       	mov    $0x11c6e0,%edx
  115d27:	41 b8 04 00 00 00    	mov    $0x4,%r8d
  115d2d:	be 45 00 00 00       	mov    $0x45,%esi
  115d32:	bf 1e cf 11 00       	mov    $0x11cf1e,%edi
  115d37:	e8 8a d3 fe ff       	callq  1030c6 <z_log_minimal_printk>
		return -EACCES;
  115d3c:	b8 f3 ff ff ff       	mov    $0xfffffff3,%eax
  115d41:	eb 0d                	jmp    115d50 <z_mrsh_k_futex_wait+0x78>
	}

	return z_impl_k_futex_wait(futex, expected, timeout);
  115d43:	4c 89 ea             	mov    %r13,%rdx
  115d46:	89 de                	mov    %ebx,%esi
  115d48:	4c 89 e7             	mov    %r12,%rdi
  115d4b:	e8 ca fe ff ff       	callq  115c1a <z_impl_k_futex_wait>
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	int ret = z_vrfy_k_futex_wait(*(struct k_futex **)&arg0, *(int*)&arg1, *(k_timeout_t*)&arg2)
;
	_current->syscall_frame = NULL;
  115d50:	48 8b 15 f9 29 01 00 	mov    0x129f9(%rip),%rdx        # 128750 <_kernel+0x10>
	return (uintptr_t) ret;
  115d57:	48 98                	cltq   
	_current->syscall_frame = NULL;
  115d59:	48 c7 82 40 01 00 00 	movq   $0x0,0x140(%rdx)
  115d60:	00 00 00 00 
}
  115d64:	48 83 c4 18          	add    $0x18,%rsp
  115d68:	5b                   	pop    %rbx
  115d69:	41 5c                	pop    %r12
  115d6b:	41 5d                	pop    %r13
  115d6d:	5d                   	pop    %rbp
  115d6e:	c3                   	retq   

0000000000115d6f <check_add_partition>:
struct k_mem_domain k_mem_domain_default;

#if __ASSERT_ON
static bool check_add_partition(struct k_mem_domain *domain,
				struct k_mem_partition *part)
{
  115d6f:	55                   	push   %rbp
  115d70:	48 89 e5             	mov    %rsp,%rbp
  115d73:	53                   	push   %rbx
  115d74:	41 50                	push   %r8

	int i;
	uintptr_t pstart, pend, dstart, dend;

	if (part == NULL) {
  115d76:	48 85 f6             	test   %rsi,%rsi
  115d79:	75 16                	jne    115d91 <check_add_partition+0x22>
		LOG_ERR("NULL k_mem_partition provided");
  115d7b:	be 45 00 00 00       	mov    $0x45,%esi
  115d80:	bf ad 08 12 00       	mov    $0x1208ad,%edi
  115d85:	31 c0                	xor    %eax,%eax
  115d87:	e8 3a d3 fe ff       	callq  1030c6 <z_log_minimal_printk>
		return false;
  115d8c:	e9 88 00 00 00       	jmpq   115e19 <check_add_partition+0xaa>
			part->start);
		return false;
	}
#endif

	if (part->size == 0U) {
  115d91:	4c 8b 46 08          	mov    0x8(%rsi),%r8
		LOG_ERR("zero sized partition at %p with base 0x%lx",
  115d95:	48 8b 0e             	mov    (%rsi),%rcx
  115d98:	48 89 f2             	mov    %rsi,%rdx
	if (part->size == 0U) {
  115d9b:	4d 85 c0             	test   %r8,%r8
  115d9e:	75 13                	jne    115db3 <check_add_partition+0x44>
		LOG_ERR("zero sized partition at %p with base 0x%lx",
  115da0:	be 45 00 00 00       	mov    $0x45,%esi
  115da5:	bf d0 08 12 00       	mov    $0x1208d0,%edi
  115daa:	31 c0                	xor    %eax,%eax
  115dac:	e8 15 d3 fe ff       	callq  1030c6 <z_log_minimal_printk>
			part, part->start);
		return false;
  115db1:	eb 66                	jmp    115e19 <check_add_partition+0xaa>
	}

	pstart = part->start;
	pend = part->start + part->size;
  115db3:	4d 8d 14 08          	lea    (%r8,%rcx,1),%r10

	if (pend <= pstart) {
  115db7:	4c 39 d1             	cmp    %r10,%rcx
  115dba:	73 10                	jae    115dcc <check_add_partition+0x5d>
	}

	/* Check that this partition doesn't overlap any existing ones already
	 * in the domain
	 */
	for (i = 0; i < domain->num_partitions; i++) {
  115dbc:	44 0f b6 9f 10 01 00 	movzbl 0x110(%rdi),%r11d
  115dc3:	00 
  115dc4:	31 c0                	xor    %eax,%eax
  115dc6:	48 83 c7 10          	add    $0x10,%rdi
  115dca:	eb 19                	jmp    115de5 <check_add_partition+0x76>
		LOG_ERR("invalid partition %p, wraparound detected. base 0x%lx size %zu",
  115dcc:	be 45 00 00 00       	mov    $0x45,%esi
  115dd1:	bf 00 09 12 00       	mov    $0x120900,%edi
  115dd6:	31 c0                	xor    %eax,%eax
  115dd8:	e8 e9 d2 fe ff       	callq  1030c6 <z_log_minimal_printk>
		return false;
  115ddd:	eb 3a                	jmp    115e19 <check_add_partition+0xaa>
	for (i = 0; i < domain->num_partitions; i++) {
  115ddf:	ff c0                	inc    %eax
  115de1:	48 83 c7 18          	add    $0x18,%rdi
  115de5:	44 39 d8             	cmp    %r11d,%eax
  115de8:	7d 33                	jge    115e1d <check_add_partition+0xae>
		struct k_mem_partition *dpart = &domain->partitions[i];

		if (dpart->size == 0U) {
  115dea:	48 8b 77 08          	mov    0x8(%rdi),%rsi
  115dee:	48 85 f6             	test   %rsi,%rsi
  115df1:	74 ec                	je     115ddf <check_add_partition+0x70>
			/* Unused slot */
			continue;
		}

		dstart = dpart->start;
  115df3:	4c 8b 0f             	mov    (%rdi),%r9
		dend = dstart + dpart->size;
  115df6:	4a 8d 1c 0e          	lea    (%rsi,%r9,1),%rbx

		if (pend > dstart && dend > pstart) {
  115dfa:	48 39 d9             	cmp    %rbx,%rcx
  115dfd:	73 e0                	jae    115ddf <check_add_partition+0x70>
  115dff:	4d 39 d1             	cmp    %r10,%r9
  115e02:	73 db                	jae    115ddf <check_add_partition+0x70>
			LOG_ERR("partition %p base %lx (size %zu) overlaps existing base %lx (size %zu)",
  115e04:	50                   	push   %rax
  115e05:	bf 44 09 12 00       	mov    $0x120944,%edi
  115e0a:	31 c0                	xor    %eax,%eax
  115e0c:	56                   	push   %rsi
  115e0d:	be 45 00 00 00       	mov    $0x45,%esi
  115e12:	e8 af d2 fe ff       	callq  1030c6 <z_log_minimal_printk>
  115e17:	5a                   	pop    %rdx
  115e18:	59                   	pop    %rcx
				part, part->start, part->size,
				dpart->start, dpart->size);
			return false;
  115e19:	31 c0                	xor    %eax,%eax
  115e1b:	eb 02                	jmp    115e1f <check_add_partition+0xb0>
		}
	}

	return true;
  115e1d:	b0 01                	mov    $0x1,%al
}
  115e1f:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
  115e23:	c9                   	leaveq 
  115e24:	c3                   	retq   

0000000000115e25 <add_thread_locked>:
	k_spin_unlock(&z_mem_domain_lock, key);
}

static void add_thread_locked(struct k_mem_domain *domain,
			      k_tid_t thread)
{
  115e25:	55                   	push   %rbp
  115e26:	48 89 e5             	mov    %rsp,%rbp
  115e29:	41 54                	push   %r12
  115e2b:	49 89 f4             	mov    %rsi,%r12
  115e2e:	53                   	push   %rbx
  115e2f:	48 89 fb             	mov    %rdi,%rbx
	__ASSERT_NO_MSG(domain != NULL);
  115e32:	48 85 ff             	test   %rdi,%rdi
  115e35:	75 2a                	jne    115e61 <add_thread_locked+0x3c>
  115e37:	be b7 09 12 00       	mov    $0x1209b7,%esi
  115e3c:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  115e41:	b9 d7 00 00 00       	mov    $0xd7,%ecx
  115e46:	31 c0                	xor    %eax,%eax
  115e48:	ba 90 09 12 00       	mov    $0x120990,%edx
  115e4d:	e8 a6 a7 fe ff       	callq  1005f8 <printk>
  115e52:	be d7 00 00 00       	mov    $0xd7,%esi
  115e57:	bf 90 09 12 00       	mov    $0x120990,%edi
  115e5c:	e8 37 cd fe ff       	callq  102b98 <assert_post_action>
	__ASSERT_NO_MSG(thread != NULL);
  115e61:	4d 85 e4             	test   %r12,%r12
  115e64:	75 2a                	jne    115e90 <add_thread_locked+0x6b>
  115e66:	be f5 05 12 00       	mov    $0x1205f5,%esi
  115e6b:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  115e70:	b9 d8 00 00 00       	mov    $0xd8,%ecx
  115e75:	31 c0                	xor    %eax,%eax
  115e77:	ba 90 09 12 00       	mov    $0x120990,%edx
  115e7c:	e8 77 a7 fe ff       	callq  1005f8 <printk>
  115e81:	be d8 00 00 00       	mov    $0xd8,%esi
  115e86:	bf 90 09 12 00       	mov    $0x120990,%edi
  115e8b:	e8 08 cd fe ff       	callq  102b98 <assert_post_action>
	sys_dnode_t *const tail = list->tail;
  115e90:	48 8b 93 08 01 00 00 	mov    0x108(%rbx),%rdx

	LOG_DBG("add thread %p to domain %p\n", thread, domain);
	sys_dlist_append(&domain->mem_domain_q,
  115e97:	49 8d 84 24 20 01 00 	lea    0x120(%r12),%rax
  115e9e:	00 
  115e9f:	48 8d 8b 00 01 00 00 	lea    0x100(%rbx),%rcx
			 &thread->mem_domain_info.mem_domain_q_node);
	thread->mem_domain_info.mem_domain = domain;

#ifdef CONFIG_ARCH_MEM_DOMAIN_SYNCHRONOUS_API
	arch_mem_domain_thread_add(thread);
  115ea6:	4c 89 e7             	mov    %r12,%rdi
	sys_dlist_append(&domain->mem_domain_q,
  115ea9:	49 89 8c 24 20 01 00 	mov    %rcx,0x120(%r12)
  115eb0:	00 
	node->prev = tail;
  115eb1:	49 89 94 24 28 01 00 	mov    %rdx,0x128(%r12)
  115eb8:	00 
	tail->next = node;
  115eb9:	48 89 02             	mov    %rax,(%rdx)
	list->tail = node;
  115ebc:	48 89 83 08 01 00 00 	mov    %rax,0x108(%rbx)
	thread->mem_domain_info.mem_domain = domain;
  115ec3:	49 89 9c 24 30 01 00 	mov    %rbx,0x130(%r12)
  115eca:	00 
#endif
}
  115ecb:	5b                   	pop    %rbx
  115ecc:	41 5c                	pop    %r12
  115ece:	5d                   	pop    %rbp
	arch_mem_domain_thread_add(thread);
  115ecf:	e9 f9 37 ff ff       	jmpq   1096cd <arch_mem_domain_thread_add>

0000000000115ed4 <remove_thread_locked>:

static void remove_thread_locked(struct k_thread *thread)
{
  115ed4:	55                   	push   %rbp
  115ed5:	48 89 e5             	mov    %rsp,%rbp
  115ed8:	41 54                	push   %r12
  115eda:	49 89 fc             	mov    %rdi,%r12
  115edd:	52                   	push   %rdx
	__ASSERT_NO_MSG(thread != NULL);
  115ede:	48 85 ff             	test   %rdi,%rdi
  115ee1:	75 2a                	jne    115f0d <remove_thread_locked+0x39>
  115ee3:	be f5 05 12 00       	mov    $0x1205f5,%esi
  115ee8:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  115eed:	b9 e6 00 00 00       	mov    $0xe6,%ecx
  115ef2:	31 c0                	xor    %eax,%eax
  115ef4:	ba 90 09 12 00       	mov    $0x120990,%edx
  115ef9:	e8 fa a6 fe ff       	callq  1005f8 <printk>
  115efe:	be e6 00 00 00       	mov    $0xe6,%esi
  115f03:	bf 90 09 12 00       	mov    $0x120990,%edi
  115f08:	e8 8b cc fe ff       	callq  102b98 <assert_post_action>
	sys_dnode_t *const prev = node->prev;
  115f0d:	49 8b 94 24 28 01 00 	mov    0x128(%r12),%rdx
  115f14:	00 
	sys_dnode_t *const next = node->next;
  115f15:	49 8b 84 24 20 01 00 	mov    0x120(%r12),%rax
  115f1c:	00 
	LOG_DBG("remove thread %p from memory domain %p\n",
		thread, thread->mem_domain_info.mem_domain);
	sys_dlist_remove(&thread->mem_domain_info.mem_domain_q_node);

#ifdef CONFIG_ARCH_MEM_DOMAIN_SYNCHRONOUS_API
	arch_mem_domain_thread_remove(thread);
  115f1d:	4c 89 e7             	mov    %r12,%rdi
	prev->next = next;
  115f20:	48 89 02             	mov    %rax,(%rdx)
	next->prev = prev;
  115f23:	48 89 50 08          	mov    %rdx,0x8(%rax)
	node->next = NULL;
  115f27:	49 c7 84 24 20 01 00 	movq   $0x0,0x120(%r12)
  115f2e:	00 00 00 00 00 
	node->prev = NULL;
  115f33:	49 c7 84 24 28 01 00 	movq   $0x0,0x128(%r12)
  115f3a:	00 00 00 00 00 
#endif
}
  115f3f:	58                   	pop    %rax
  115f40:	41 5c                	pop    %r12
  115f42:	5d                   	pop    %rbp
	arch_mem_domain_thread_remove(thread);
  115f43:	e9 2f 37 ff ff       	jmpq   109677 <arch_mem_domain_thread_remove>

0000000000115f48 <k_mem_domain_init>:
{
  115f48:	55                   	push   %rbp
  115f49:	48 89 e5             	mov    %rsp,%rbp
  115f4c:	41 57                	push   %r15
  115f4e:	41 89 f7             	mov    %esi,%r15d
  115f51:	41 56                	push   %r14
  115f53:	41 55                	push   %r13
  115f55:	44 0f b6 ee          	movzbl %sil,%r13d
  115f59:	41 54                	push   %r12
  115f5b:	49 89 fc             	mov    %rdi,%r12
  115f5e:	53                   	push   %rbx
  115f5f:	48 89 d3             	mov    %rdx,%rbx
  115f62:	48 83 ec 18          	sub    $0x18,%rsp
	__ASSERT_NO_MSG(domain != NULL);
  115f66:	48 85 ff             	test   %rdi,%rdi
  115f69:	75 2a                	jne    115f95 <k_mem_domain_init+0x4d>
  115f6b:	be b7 09 12 00       	mov    $0x1209b7,%esi
  115f70:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  115f75:	b9 5e 00 00 00       	mov    $0x5e,%ecx
  115f7a:	31 c0                	xor    %eax,%eax
  115f7c:	ba 90 09 12 00       	mov    $0x120990,%edx
  115f81:	e8 72 a6 fe ff       	callq  1005f8 <printk>
  115f86:	be 5e 00 00 00       	mov    $0x5e,%esi
  115f8b:	bf 90 09 12 00       	mov    $0x120990,%edi
  115f90:	e8 03 cc fe ff       	callq  102b98 <assert_post_action>
	__ASSERT(num_parts == 0U || parts != NULL,
  115f95:	45 84 ff             	test   %r15b,%r15b
  115f98:	74 3b                	je     115fd5 <k_mem_domain_init+0x8d>
  115f9a:	48 85 db             	test   %rbx,%rbx
  115f9d:	75 36                	jne    115fd5 <k_mem_domain_init+0x8d>
  115f9f:	be cd 09 12 00       	mov    $0x1209cd,%esi
  115fa4:	b9 5f 00 00 00       	mov    $0x5f,%ecx
  115fa9:	ba 90 09 12 00       	mov    $0x120990,%edx
  115fae:	31 c0                	xor    %eax,%eax
  115fb0:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  115fb5:	e8 3e a6 fe ff       	callq  1005f8 <printk>
  115fba:	bf f5 09 12 00       	mov    $0x1209f5,%edi
  115fbf:	31 c0                	xor    %eax,%eax
  115fc1:	e8 32 a6 fe ff       	callq  1005f8 <printk>
  115fc6:	be 5f 00 00 00       	mov    $0x5f,%esi
  115fcb:	bf 90 09 12 00       	mov    $0x120990,%edi
  115fd0:	e8 c3 cb fe ff       	callq  102b98 <assert_post_action>
	__ASSERT(num_parts <= max_partitions,
  115fd5:	44 38 3d 73 6e 0a 00 	cmp    %r15b,0xa6e73(%rip)        # 1bce4f <max_partitions>
  115fdc:	73 41                	jae    11601f <k_mem_domain_init+0xd7>
  115fde:	b9 61 00 00 00       	mov    $0x61,%ecx
  115fe3:	ba 90 09 12 00       	mov    $0x120990,%edx
  115fe8:	be 24 0a 12 00       	mov    $0x120a24,%esi
  115fed:	31 c0                	xor    %eax,%eax
  115fef:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  115ff4:	e8 ff a5 fe ff       	callq  1005f8 <printk>
  115ff9:	41 0f b6 f7          	movzbl %r15b,%esi
  115ffd:	bf 40 0a 12 00       	mov    $0x120a40,%edi
  116002:	31 c0                	xor    %eax,%eax
  116004:	0f b6 15 44 6e 0a 00 	movzbl 0xa6e44(%rip),%edx        # 1bce4f <max_partitions>
  11600b:	e8 e8 a5 fe ff       	callq  1005f8 <printk>
  116010:	be 61 00 00 00       	mov    $0x61,%esi
  116015:	bf 90 09 12 00       	mov    $0x120990,%edi
  11601a:	e8 79 cb fe ff       	callq  102b98 <assert_post_action>
  11601f:	9c                   	pushfq 
  116020:	fa                   	cli    
  116021:	8f 45 c8             	popq   -0x38(%rbp)
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  116024:	bf 00 ce 1b 00       	mov    $0x1bce00,%edi
  116029:	e8 4b 78 ff ff       	callq  10d879 <z_spin_lock_valid>
  11602e:	84 c0                	test   %al,%al
  116030:	75 39                	jne    11606b <k_mem_domain_init+0x123>
  116032:	b9 8e 00 00 00       	mov    $0x8e,%ecx
  116037:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  11603c:	be fd d1 11 00       	mov    $0x11d1fd,%esi
  116041:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  116046:	e8 ad a5 fe ff       	callq  1005f8 <printk>
  11604b:	be 00 ce 1b 00       	mov    $0x1bce00,%esi
  116050:	bf 12 d2 11 00       	mov    $0x11d212,%edi
  116055:	31 c0                	xor    %eax,%eax
  116057:	e8 9c a5 fe ff       	callq  1005f8 <printk>
  11605c:	be 8e 00 00 00       	mov    $0x8e,%esi
  116061:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  116066:	e8 2d cb fe ff       	callq  102b98 <assert_post_action>
	z_spin_lock_set_owner(l);
  11606b:	bf 00 ce 1b 00       	mov    $0x1bce00,%edi
  116070:	e8 48 78 ff ff       	callq  10d8bd <z_spin_lock_set_owner>
	(void)memset(domain->partitions, 0, sizeof(domain->partitions));
  116075:	49 8d 7c 24 10       	lea    0x10(%r12),%rdi
  11607a:	ba f0 00 00 00       	mov    $0xf0,%edx
  11607f:	31 f6                	xor    %esi,%esi
	domain->num_partitions = 0U;
  116081:	41 c6 84 24 10 01 00 	movb   $0x0,0x110(%r12)
  116088:	00 00 
	(void)memset(domain->partitions, 0, sizeof(domain->partitions));
  11608a:	e8 23 40 ff ff       	callq  10a0b2 <memset>
	sys_dlist_init(&domain->mem_domain_q);
  11608f:	49 8d 84 24 00 01 00 	lea    0x100(%r12),%rax
  116096:	00 
	int ret = arch_mem_domain_init(domain);
  116097:	4c 89 e7             	mov    %r12,%rdi
	list->head = (sys_dnode_t *)list;
  11609a:	49 89 84 24 00 01 00 	mov    %rax,0x100(%r12)
  1160a1:	00 
	list->tail = (sys_dnode_t *)list;
  1160a2:	49 89 84 24 08 01 00 	mov    %rax,0x108(%r12)
  1160a9:	00 
  1160aa:	e8 0b 34 ff ff       	callq  1094ba <arch_mem_domain_init>
  1160af:	89 c1                	mov    %eax,%ecx
	if (ret != 0) {
  1160b1:	85 c0                	test   %eax,%eax
  1160b3:	74 1d                	je     1160d2 <k_mem_domain_init+0x18a>
		LOG_ERR("architecture-specific initialization failed for domain %p with %d",
  1160b5:	4c 89 e2             	mov    %r12,%rdx
  1160b8:	be 45 00 00 00       	mov    $0x45,%esi
  1160bd:	bf 7c 0a 12 00       	mov    $0x120a7c,%edi
  1160c2:	31 c0                	xor    %eax,%eax
  1160c4:	e8 fd cf fe ff       	callq  1030c6 <z_log_minimal_printk>
		k_panic();
  1160c9:	48 c7 c0 04 00 00 00 	mov    $0x4,%rax
  1160d0:	cd 20                	int    $0x20
	if (num_parts != 0U) {
  1160d2:	45 84 ff             	test   %r15b,%r15b
  1160d5:	0f 84 8a 00 00 00    	je     116165 <k_mem_domain_init+0x21d>
  1160db:	45 31 f6             	xor    %r14d,%r14d
			__ASSERT(check_add_partition(domain, parts[i]),
  1160de:	4a 8b 34 f3          	mov    (%rbx,%r14,8),%rsi
  1160e2:	4c 89 e7             	mov    %r12,%rdi
  1160e5:	45 89 f7             	mov    %r14d,%r15d
  1160e8:	e8 82 fc ff ff       	callq  115d6f <check_add_partition>
  1160ed:	84 c0                	test   %al,%al
  1160ef:	75 3b                	jne    11612c <k_mem_domain_init+0x1e4>
  1160f1:	b9 7c 00 00 00       	mov    $0x7c,%ecx
  1160f6:	ba 90 09 12 00       	mov    $0x120990,%edx
  1160fb:	be c3 0a 12 00       	mov    $0x120ac3,%esi
  116100:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  116105:	e8 ee a4 fe ff       	callq  1005f8 <printk>
  11610a:	4a 8b 14 f3          	mov    (%rbx,%r14,8),%rdx
  11610e:	44 89 f6             	mov    %r14d,%esi
  116111:	31 c0                	xor    %eax,%eax
  116113:	bf e9 0a 12 00       	mov    $0x120ae9,%edi
  116118:	e8 db a4 fe ff       	callq  1005f8 <printk>
  11611d:	be 7c 00 00 00       	mov    $0x7c,%esi
  116122:	bf 90 09 12 00       	mov    $0x120990,%edi
  116127:	e8 6c ca fe ff       	callq  102b98 <assert_post_action>
			domain->partitions[i] = *parts[i];
  11612c:	4a 8b 14 f3          	mov    (%rbx,%r14,8),%rdx
  116130:	49 6b c6 18          	imul   $0x18,%r14,%rax
			arch_mem_domain_partition_add(domain, i);
  116134:	44 89 fe             	mov    %r15d,%esi
  116137:	4c 89 e7             	mov    %r12,%rdi
		for (i = 0U; i < num_parts; i++) {
  11613a:	49 ff c6             	inc    %r14
			domain->partitions[i] = *parts[i];
  11613d:	0f 10 02             	movups (%rdx),%xmm0
  116140:	41 0f 11 44 04 10    	movups %xmm0,0x10(%r12,%rax,1)
  116146:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  11614a:	49 89 54 04 20       	mov    %rdx,0x20(%r12,%rax,1)
			domain->num_partitions++;
  11614f:	41 fe 84 24 10 01 00 	incb   0x110(%r12)
  116156:	00 
			arch_mem_domain_partition_add(domain, i);
  116157:	e8 4d 35 ff ff       	callq  1096a9 <arch_mem_domain_partition_add>
		for (i = 0U; i < num_parts; i++) {
  11615c:	45 39 f5             	cmp    %r14d,%r13d
  11615f:	0f 87 79 ff ff ff    	ja     1160de <k_mem_domain_init+0x196>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  116165:	bf 00 ce 1b 00       	mov    $0x1bce00,%edi
  11616a:	e8 2a 77 ff ff       	callq  10d899 <z_spin_unlock_valid>
  11616f:	84 c0                	test   %al,%al
  116171:	75 39                	jne    1161ac <k_mem_domain_init+0x264>
  116173:	b9 b9 00 00 00       	mov    $0xb9,%ecx
  116178:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  11617d:	be 41 d2 11 00       	mov    $0x11d241,%esi
  116182:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  116187:	e8 6c a4 fe ff       	callq  1005f8 <printk>
  11618c:	be 00 ce 1b 00       	mov    $0x1bce00,%esi
  116191:	bf 58 d2 11 00       	mov    $0x11d258,%edi
  116196:	31 c0                	xor    %eax,%eax
  116198:	e8 5b a4 fe ff       	callq  1005f8 <printk>
  11619d:	be b9 00 00 00       	mov    $0xb9,%esi
  1161a2:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  1161a7:	e8 ec c9 fe ff       	callq  102b98 <assert_post_action>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  1161ac:	0f ba 65 c8 09       	btl    $0x9,-0x38(%rbp)
  1161b1:	73 01                	jae    1161b4 <k_mem_domain_init+0x26c>
		__asm__ volatile ("sti" ::: "memory");
  1161b3:	fb                   	sti    
}
  1161b4:	48 83 c4 18          	add    $0x18,%rsp
  1161b8:	5b                   	pop    %rbx
  1161b9:	41 5c                	pop    %r12
  1161bb:	41 5d                	pop    %r13
  1161bd:	41 5e                	pop    %r14
  1161bf:	41 5f                	pop    %r15
  1161c1:	5d                   	pop    %rbp
  1161c2:	c3                   	retq   

00000000001161c3 <k_mem_domain_add_partition>:
{
  1161c3:	55                   	push   %rbp
  1161c4:	48 89 e5             	mov    %rsp,%rbp
  1161c7:	41 57                	push   %r15
  1161c9:	41 56                	push   %r14
  1161cb:	41 55                	push   %r13
  1161cd:	49 89 f5             	mov    %rsi,%r13
  1161d0:	41 54                	push   %r12
  1161d2:	49 89 fc             	mov    %rdi,%r12
  1161d5:	53                   	push   %rbx
  1161d6:	52                   	push   %rdx
	__ASSERT_NO_MSG(domain != NULL);
  1161d7:	48 85 ff             	test   %rdi,%rdi
  1161da:	75 2a                	jne    116206 <k_mem_domain_add_partition+0x43>
  1161dc:	be b7 09 12 00       	mov    $0x1209b7,%esi
  1161e1:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  1161e6:	b9 91 00 00 00       	mov    $0x91,%ecx
  1161eb:	31 c0                	xor    %eax,%eax
  1161ed:	ba 90 09 12 00       	mov    $0x120990,%edx
  1161f2:	e8 01 a4 fe ff       	callq  1005f8 <printk>
  1161f7:	be 91 00 00 00       	mov    $0x91,%esi
  1161fc:	bf 90 09 12 00       	mov    $0x120990,%edi
  116201:	e8 92 c9 fe ff       	callq  102b98 <assert_post_action>
	__ASSERT(check_add_partition(domain, part),
  116206:	4c 89 ee             	mov    %r13,%rsi
  116209:	4c 89 e7             	mov    %r12,%rdi
  11620c:	e8 5e fb ff ff       	callq  115d6f <check_add_partition>
  116211:	84 c0                	test   %al,%al
  116213:	75 37                	jne    11624c <k_mem_domain_add_partition+0x89>
  116215:	b9 92 00 00 00       	mov    $0x92,%ecx
  11621a:	ba 90 09 12 00       	mov    $0x120990,%edx
  11621f:	be 0b 0b 12 00       	mov    $0x120b0b,%esi
  116224:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  116229:	e8 ca a3 fe ff       	callq  1005f8 <printk>
  11622e:	4c 89 ee             	mov    %r13,%rsi
  116231:	bf 2d 0b 12 00       	mov    $0x120b2d,%edi
  116236:	31 c0                	xor    %eax,%eax
  116238:	e8 bb a3 fe ff       	callq  1005f8 <printk>
  11623d:	be 92 00 00 00       	mov    $0x92,%esi
  116242:	bf 90 09 12 00       	mov    $0x120990,%edi
  116247:	e8 4c c9 fe ff       	callq  102b98 <assert_post_action>
  11624c:	9c                   	pushfq 
  11624d:	fa                   	cli    
  11624e:	41 5e                	pop    %r14
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  116250:	bf 00 ce 1b 00       	mov    $0x1bce00,%edi
  116255:	e8 1f 76 ff ff       	callq  10d879 <z_spin_lock_valid>
  11625a:	84 c0                	test   %al,%al
  11625c:	75 39                	jne    116297 <k_mem_domain_add_partition+0xd4>
  11625e:	b9 8e 00 00 00       	mov    $0x8e,%ecx
  116263:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  116268:	be fd d1 11 00       	mov    $0x11d1fd,%esi
  11626d:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  116272:	e8 81 a3 fe ff       	callq  1005f8 <printk>
  116277:	be 00 ce 1b 00       	mov    $0x1bce00,%esi
  11627c:	bf 12 d2 11 00       	mov    $0x11d212,%edi
  116281:	31 c0                	xor    %eax,%eax
  116283:	e8 70 a3 fe ff       	callq  1005f8 <printk>
  116288:	be 8e 00 00 00       	mov    $0x8e,%esi
  11628d:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  116292:	e8 01 c9 fe ff       	callq  102b98 <assert_post_action>
	z_spin_lock_set_owner(l);
  116297:	bf 00 ce 1b 00       	mov    $0x1bce00,%edi
  11629c:	e8 1c 76 ff ff       	callq  10d8bd <z_spin_lock_set_owner>
	for (p_idx = 0; p_idx < max_partitions; p_idx++) {
  1162a1:	0f b6 15 a7 6b 0a 00 	movzbl 0xa6ba7(%rip),%edx        # 1bce4f <max_partitions>
  1162a8:	31 c0                	xor    %eax,%eax
  1162aa:	41 89 c7             	mov    %eax,%r15d
  1162ad:	89 c3                	mov    %eax,%ebx
  1162af:	39 c2                	cmp    %eax,%edx
  1162b1:	7e 10                	jle    1162c3 <k_mem_domain_add_partition+0x100>
		if (domain->partitions[p_idx].size == 0U) {
  1162b3:	48 ff c0             	inc    %rax
  1162b6:	48 6b c8 18          	imul   $0x18,%rax,%rcx
  1162ba:	49 83 3c 0c 00       	cmpq   $0x0,(%r12,%rcx,1)
  1162bf:	75 e9                	jne    1162aa <k_mem_domain_add_partition+0xe7>
  1162c1:	eb 36                	jmp    1162f9 <k_mem_domain_add_partition+0x136>
	__ASSERT(p_idx < max_partitions,
  1162c3:	be 44 0b 12 00       	mov    $0x120b44,%esi
  1162c8:	b9 9e 00 00 00       	mov    $0x9e,%ecx
  1162cd:	ba 90 09 12 00       	mov    $0x120990,%edx
  1162d2:	31 c0                	xor    %eax,%eax
  1162d4:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  1162d9:	e8 1a a3 fe ff       	callq  1005f8 <printk>
  1162de:	bf 5b 0b 12 00       	mov    $0x120b5b,%edi
  1162e3:	31 c0                	xor    %eax,%eax
  1162e5:	e8 0e a3 fe ff       	callq  1005f8 <printk>
  1162ea:	be 9e 00 00 00       	mov    $0x9e,%esi
  1162ef:	bf 90 09 12 00       	mov    $0x120990,%edi
  1162f4:	e8 9f c8 fe ff       	callq  102b98 <assert_post_action>
	domain->partitions[p_idx].start = part->start;
  1162f9:	48 63 c3             	movslq %ebx,%rax
  1162fc:	49 8b 55 00          	mov    0x0(%r13),%rdx
	arch_mem_domain_partition_add(domain, p_idx);
  116300:	4c 89 e7             	mov    %r12,%rdi
  116303:	44 89 fe             	mov    %r15d,%esi
	domain->partitions[p_idx].start = part->start;
  116306:	48 6b c0 18          	imul   $0x18,%rax,%rax
  11630a:	4c 01 e0             	add    %r12,%rax
  11630d:	48 89 50 10          	mov    %rdx,0x10(%rax)
	domain->partitions[p_idx].size = part->size;
  116311:	49 8b 55 08          	mov    0x8(%r13),%rdx
  116315:	48 89 50 18          	mov    %rdx,0x18(%rax)
	domain->partitions[p_idx].attr = part->attr;
  116319:	49 8b 55 10          	mov    0x10(%r13),%rdx
  11631d:	48 89 50 20          	mov    %rdx,0x20(%rax)
	domain->num_partitions++;
  116321:	41 fe 84 24 10 01 00 	incb   0x110(%r12)
  116328:	00 
	arch_mem_domain_partition_add(domain, p_idx);
  116329:	e8 7b 33 ff ff       	callq  1096a9 <arch_mem_domain_partition_add>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  11632e:	bf 00 ce 1b 00       	mov    $0x1bce00,%edi
  116333:	e8 61 75 ff ff       	callq  10d899 <z_spin_unlock_valid>
  116338:	84 c0                	test   %al,%al
  11633a:	75 39                	jne    116375 <k_mem_domain_add_partition+0x1b2>
  11633c:	b9 b9 00 00 00       	mov    $0xb9,%ecx
  116341:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  116346:	be 41 d2 11 00       	mov    $0x11d241,%esi
  11634b:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  116350:	e8 a3 a2 fe ff       	callq  1005f8 <printk>
  116355:	be 00 ce 1b 00       	mov    $0x1bce00,%esi
  11635a:	bf 58 d2 11 00       	mov    $0x11d258,%edi
  11635f:	31 c0                	xor    %eax,%eax
  116361:	e8 92 a2 fe ff       	callq  1005f8 <printk>
  116366:	be b9 00 00 00       	mov    $0xb9,%esi
  11636b:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  116370:	e8 23 c8 fe ff       	callq  102b98 <assert_post_action>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  116375:	41 0f ba e6 09       	bt     $0x9,%r14d
  11637a:	73 01                	jae    11637d <k_mem_domain_add_partition+0x1ba>
		__asm__ volatile ("sti" ::: "memory");
  11637c:	fb                   	sti    
}
  11637d:	58                   	pop    %rax
  11637e:	5b                   	pop    %rbx
  11637f:	41 5c                	pop    %r12
  116381:	41 5d                	pop    %r13
  116383:	41 5e                	pop    %r14
  116385:	41 5f                	pop    %r15
  116387:	5d                   	pop    %rbp
  116388:	c3                   	retq   

0000000000116389 <init_mem_domain_module>:
	}
	k_spin_unlock(&z_mem_domain_lock, key);
}

static int init_mem_domain_module(const struct device *arg)
{
  116389:	55                   	push   %rbp
  11638a:	48 89 e5             	mov    %rsp,%rbp
	ARG_UNUSED(arg);

	max_partitions = arch_mem_domain_max_partitions_get();
  11638d:	e8 dc 33 ff ff       	callq  10976e <arch_mem_domain_max_partitions_get>
  116392:	88 05 b7 6a 0a 00    	mov    %al,0xa6ab7(%rip)        # 1bce4f <max_partitions>
	/*
	 * max_partitions must be less than or equal to
	 * CONFIG_MAX_DOMAIN_PARTITIONS, or would encounter array index
	 * out of bounds error.
	 */
	__ASSERT(max_partitions <= CONFIG_MAX_DOMAIN_PARTITIONS, "");
  116398:	3c 0a                	cmp    $0xa,%al
  11639a:	76 36                	jbe    1163d2 <init_mem_domain_module+0x49>
  11639c:	be 7f 0b 12 00       	mov    $0x120b7f,%esi
  1163a1:	b9 18 01 00 00       	mov    $0x118,%ecx
  1163a6:	ba 90 09 12 00       	mov    $0x120990,%edx
  1163ab:	31 c0                	xor    %eax,%eax
  1163ad:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  1163b2:	e8 41 a2 fe ff       	callq  1005f8 <printk>
  1163b7:	bf 22 fc 11 00       	mov    $0x11fc22,%edi
  1163bc:	31 c0                	xor    %eax,%eax
  1163be:	e8 35 a2 fe ff       	callq  1005f8 <printk>
  1163c3:	be 18 01 00 00       	mov    $0x118,%esi
  1163c8:	bf 90 09 12 00       	mov    $0x120990,%edi
  1163cd:	e8 c6 c7 fe ff       	callq  102b98 <assert_post_action>

	k_mem_domain_init(&k_mem_domain_default, 0, NULL);
  1163d2:	31 d2                	xor    %edx,%edx
  1163d4:	31 f6                	xor    %esi,%esi
  1163d6:	bf a0 c7 1b 00       	mov    $0x1bc7a0,%edi
  1163db:	e8 68 fb ff ff       	callq  115f48 <k_mem_domain_init>
#ifdef Z_LIBC_PARTITION_EXISTS
	k_mem_domain_add_partition(&k_mem_domain_default, &z_libc_partition);
  1163e0:	be 20 14 5e 00       	mov    $0x5e1420,%esi
  1163e5:	bf a0 c7 1b 00       	mov    $0x1bc7a0,%edi
  1163ea:	e8 d4 fd ff ff       	callq  1161c3 <k_mem_domain_add_partition>
#endif /* Z_LIBC_PARTITION_EXISTS */

	return 0;
}
  1163ef:	31 c0                	xor    %eax,%eax
  1163f1:	5d                   	pop    %rbp
  1163f2:	c3                   	retq   

00000000001163f3 <z_mem_domain_init_thread>:
{
  1163f3:	55                   	push   %rbp
  1163f4:	48 89 e5             	mov    %rsp,%rbp
  1163f7:	41 54                	push   %r12
  1163f9:	49 89 fc             	mov    %rdi,%r12
  1163fc:	53                   	push   %rbx
  1163fd:	9c                   	pushfq 
  1163fe:	fa                   	cli    
  1163ff:	5b                   	pop    %rbx
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  116400:	bf 00 ce 1b 00       	mov    $0x1bce00,%edi
  116405:	e8 6f 74 ff ff       	callq  10d879 <z_spin_lock_valid>
  11640a:	84 c0                	test   %al,%al
  11640c:	75 39                	jne    116447 <z_mem_domain_init_thread+0x54>
  11640e:	b9 8e 00 00 00       	mov    $0x8e,%ecx
  116413:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  116418:	be fd d1 11 00       	mov    $0x11d1fd,%esi
  11641d:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  116422:	e8 d1 a1 fe ff       	callq  1005f8 <printk>
  116427:	be 00 ce 1b 00       	mov    $0x1bce00,%esi
  11642c:	bf 12 d2 11 00       	mov    $0x11d212,%edi
  116431:	31 c0                	xor    %eax,%eax
  116433:	e8 c0 a1 fe ff       	callq  1005f8 <printk>
  116438:	be 8e 00 00 00       	mov    $0x8e,%esi
  11643d:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  116442:	e8 51 c7 fe ff       	callq  102b98 <assert_post_action>
	z_spin_lock_set_owner(l);
  116447:	bf 00 ce 1b 00       	mov    $0x1bce00,%edi
  11644c:	e8 6c 74 ff ff       	callq  10d8bd <z_spin_lock_set_owner>
	add_thread_locked(_current->mem_domain_info.mem_domain, thread);
  116451:	48 8b 05 f8 22 01 00 	mov    0x122f8(%rip),%rax        # 128750 <_kernel+0x10>
  116458:	4c 89 e6             	mov    %r12,%rsi
  11645b:	48 8b b8 30 01 00 00 	mov    0x130(%rax),%rdi
  116462:	e8 be f9 ff ff       	callq  115e25 <add_thread_locked>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  116467:	bf 00 ce 1b 00       	mov    $0x1bce00,%edi
  11646c:	e8 28 74 ff ff       	callq  10d899 <z_spin_unlock_valid>
  116471:	84 c0                	test   %al,%al
  116473:	75 39                	jne    1164ae <z_mem_domain_init_thread+0xbb>
  116475:	b9 b9 00 00 00       	mov    $0xb9,%ecx
  11647a:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  11647f:	be 41 d2 11 00       	mov    $0x11d241,%esi
  116484:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  116489:	e8 6a a1 fe ff       	callq  1005f8 <printk>
  11648e:	be 00 ce 1b 00       	mov    $0x1bce00,%esi
  116493:	bf 58 d2 11 00       	mov    $0x11d258,%edi
  116498:	31 c0                	xor    %eax,%eax
  11649a:	e8 59 a1 fe ff       	callq  1005f8 <printk>
  11649f:	be b9 00 00 00       	mov    $0xb9,%esi
  1164a4:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  1164a9:	e8 ea c6 fe ff       	callq  102b98 <assert_post_action>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  1164ae:	0f ba e3 09          	bt     $0x9,%ebx
  1164b2:	73 01                	jae    1164b5 <z_mem_domain_init_thread+0xc2>
		__asm__ volatile ("sti" ::: "memory");
  1164b4:	fb                   	sti    
}
  1164b5:	5b                   	pop    %rbx
  1164b6:	41 5c                	pop    %r12
  1164b8:	5d                   	pop    %rbp
  1164b9:	c3                   	retq   

00000000001164ba <z_mem_domain_exit_thread>:
{
  1164ba:	55                   	push   %rbp
  1164bb:	48 89 e5             	mov    %rsp,%rbp
  1164be:	41 54                	push   %r12
  1164c0:	49 89 fc             	mov    %rdi,%r12
  1164c3:	53                   	push   %rbx
  1164c4:	9c                   	pushfq 
  1164c5:	fa                   	cli    
  1164c6:	5b                   	pop    %rbx
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  1164c7:	bf 00 ce 1b 00       	mov    $0x1bce00,%edi
  1164cc:	e8 a8 73 ff ff       	callq  10d879 <z_spin_lock_valid>
  1164d1:	84 c0                	test   %al,%al
  1164d3:	75 39                	jne    11650e <z_mem_domain_exit_thread+0x54>
  1164d5:	b9 8e 00 00 00       	mov    $0x8e,%ecx
  1164da:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  1164df:	be fd d1 11 00       	mov    $0x11d1fd,%esi
  1164e4:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  1164e9:	e8 0a a1 fe ff       	callq  1005f8 <printk>
  1164ee:	be 00 ce 1b 00       	mov    $0x1bce00,%esi
  1164f3:	bf 12 d2 11 00       	mov    $0x11d212,%edi
  1164f8:	31 c0                	xor    %eax,%eax
  1164fa:	e8 f9 a0 fe ff       	callq  1005f8 <printk>
  1164ff:	be 8e 00 00 00       	mov    $0x8e,%esi
  116504:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  116509:	e8 8a c6 fe ff       	callq  102b98 <assert_post_action>
	z_spin_lock_set_owner(l);
  11650e:	bf 00 ce 1b 00       	mov    $0x1bce00,%edi
  116513:	e8 a5 73 ff ff       	callq  10d8bd <z_spin_lock_set_owner>
	remove_thread_locked(thread);
  116518:	4c 89 e7             	mov    %r12,%rdi
  11651b:	e8 b4 f9 ff ff       	callq  115ed4 <remove_thread_locked>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  116520:	bf 00 ce 1b 00       	mov    $0x1bce00,%edi
  116525:	e8 6f 73 ff ff       	callq  10d899 <z_spin_unlock_valid>
  11652a:	84 c0                	test   %al,%al
  11652c:	75 39                	jne    116567 <z_mem_domain_exit_thread+0xad>
  11652e:	b9 b9 00 00 00       	mov    $0xb9,%ecx
  116533:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  116538:	be 41 d2 11 00       	mov    $0x11d241,%esi
  11653d:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  116542:	e8 b1 a0 fe ff       	callq  1005f8 <printk>
  116547:	be 00 ce 1b 00       	mov    $0x1bce00,%esi
  11654c:	bf 58 d2 11 00       	mov    $0x11d258,%edi
  116551:	31 c0                	xor    %eax,%eax
  116553:	e8 a0 a0 fe ff       	callq  1005f8 <printk>
  116558:	be b9 00 00 00       	mov    $0xb9,%esi
  11655d:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  116562:	e8 31 c6 fe ff       	callq  102b98 <assert_post_action>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  116567:	0f ba e3 09          	bt     $0x9,%ebx
  11656b:	73 01                	jae    11656e <z_mem_domain_exit_thread+0xb4>
		__asm__ volatile ("sti" ::: "memory");
  11656d:	fb                   	sti    
}
  11656e:	5b                   	pop    %rbx
  11656f:	41 5c                	pop    %r12
  116571:	5d                   	pop    %rbp
  116572:	c3                   	retq   

0000000000116573 <k_mem_domain_add_thread>:
{
  116573:	55                   	push   %rbp
  116574:	48 89 e5             	mov    %rsp,%rbp
  116577:	41 55                	push   %r13
  116579:	49 89 fd             	mov    %rdi,%r13
  11657c:	41 54                	push   %r12
  11657e:	49 89 f4             	mov    %rsi,%r12
  116581:	53                   	push   %rbx
  116582:	52                   	push   %rdx
  116583:	9c                   	pushfq 
  116584:	fa                   	cli    
  116585:	5b                   	pop    %rbx
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  116586:	bf 00 ce 1b 00       	mov    $0x1bce00,%edi
  11658b:	e8 e9 72 ff ff       	callq  10d879 <z_spin_lock_valid>
  116590:	84 c0                	test   %al,%al
  116592:	75 39                	jne    1165cd <k_mem_domain_add_thread+0x5a>
  116594:	b9 8e 00 00 00       	mov    $0x8e,%ecx
  116599:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  11659e:	be fd d1 11 00       	mov    $0x11d1fd,%esi
  1165a3:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  1165a8:	e8 4b a0 fe ff       	callq  1005f8 <printk>
  1165ad:	be 00 ce 1b 00       	mov    $0x1bce00,%esi
  1165b2:	bf 12 d2 11 00       	mov    $0x11d212,%edi
  1165b7:	31 c0                	xor    %eax,%eax
  1165b9:	e8 3a a0 fe ff       	callq  1005f8 <printk>
  1165be:	be 8e 00 00 00       	mov    $0x8e,%esi
  1165c3:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  1165c8:	e8 cb c5 fe ff       	callq  102b98 <assert_post_action>
	z_spin_lock_set_owner(l);
  1165cd:	bf 00 ce 1b 00       	mov    $0x1bce00,%edi
  1165d2:	e8 e6 72 ff ff       	callq  10d8bd <z_spin_lock_set_owner>
	if (thread->mem_domain_info.mem_domain != domain) {
  1165d7:	4d 39 ac 24 30 01 00 	cmp    %r13,0x130(%r12)
  1165de:	00 
  1165df:	74 13                	je     1165f4 <k_mem_domain_add_thread+0x81>
		remove_thread_locked(thread);
  1165e1:	4c 89 e7             	mov    %r12,%rdi
  1165e4:	e8 eb f8 ff ff       	callq  115ed4 <remove_thread_locked>
		add_thread_locked(domain, thread);
  1165e9:	4c 89 e6             	mov    %r12,%rsi
  1165ec:	4c 89 ef             	mov    %r13,%rdi
  1165ef:	e8 31 f8 ff ff       	callq  115e25 <add_thread_locked>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  1165f4:	bf 00 ce 1b 00       	mov    $0x1bce00,%edi
  1165f9:	e8 9b 72 ff ff       	callq  10d899 <z_spin_unlock_valid>
  1165fe:	84 c0                	test   %al,%al
  116600:	75 39                	jne    11663b <k_mem_domain_add_thread+0xc8>
  116602:	b9 b9 00 00 00       	mov    $0xb9,%ecx
  116607:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  11660c:	be 41 d2 11 00       	mov    $0x11d241,%esi
  116611:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  116616:	e8 dd 9f fe ff       	callq  1005f8 <printk>
  11661b:	be 00 ce 1b 00       	mov    $0x1bce00,%esi
  116620:	bf 58 d2 11 00       	mov    $0x11d258,%edi
  116625:	31 c0                	xor    %eax,%eax
  116627:	e8 cc 9f fe ff       	callq  1005f8 <printk>
  11662c:	be b9 00 00 00       	mov    $0xb9,%esi
  116631:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  116636:	e8 5d c5 fe ff       	callq  102b98 <assert_post_action>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  11663b:	0f ba e3 09          	bt     $0x9,%ebx
  11663f:	73 01                	jae    116642 <k_mem_domain_add_thread+0xcf>
		__asm__ volatile ("sti" ::: "memory");
  116641:	fb                   	sti    
}
  116642:	58                   	pop    %rax
  116643:	5b                   	pop    %rbx
  116644:	41 5c                	pop    %r12
  116646:	41 5d                	pop    %r13
  116648:	5d                   	pop    %rbp
  116649:	c3                   	retq   

000000000011664a <node_lessthan>:
	return ret;
}

static bool node_lessthan(struct rbnode *a, struct rbnode *b)
{
	return a < b;
  11664a:	48 39 fe             	cmp    %rdi,%rsi
  11664d:	0f 97 c0             	seta   %al
}
  116650:	c3                   	retq   

0000000000116651 <wordlist_cb>:

static void wordlist_cb(struct z_object *ko, void *ctx_ptr)
{
	struct perm_ctx *ctx = (struct perm_ctx *)ctx_ptr;

	if (sys_bitfield_test_bit((mem_addr_t)&ko->perms, ctx->parent_id) &&
  116651:	8b 06                	mov    (%rsi),%eax
	__asm__ volatile("btl %2, %1;"
  116653:	0f a3 47 08          	bt     %eax,0x8(%rdi)
  116657:	19 c0                	sbb    %eax,%eax
  116659:	85 c0                	test   %eax,%eax
  11665b:	74 10                	je     11666d <wordlist_cb+0x1c>
  11665d:	48 8b 46 08          	mov    0x8(%rsi),%rax
  116661:	48 39 07             	cmp    %rax,(%rdi)
  116664:	74 07                	je     11666d <wordlist_cb+0x1c>
				  (struct k_thread *)ko->name != ctx->parent) {
		sys_bitfield_set_bit((mem_addr_t)&ko->perms, ctx->child_id);
  116666:	8b 46 04             	mov    0x4(%rsi),%eax
	__asm__ volatile("btsl %1, %0"
  116669:	0f ab 47 08          	bts    %eax,0x8(%rdi)
	}
}
  11666d:	c3                   	retq   

000000000011666e <app_shmem_bss_zero>:

extern char __app_shmem_regions_start[];
extern char __app_shmem_regions_end[];

static int app_shmem_bss_zero(const struct device *unused)
{
  11666e:	55                   	push   %rbp
  11666f:	48 89 e5             	mov    %rsp,%rbp
  116672:	53                   	push   %rbx
	struct z_app_region *region, *end;

	ARG_UNUSED(unused);

	end = (struct z_app_region *)&__app_shmem_regions_end;
	region = (struct z_app_region *)&__app_shmem_regions_start;
  116673:	bb 70 a2 11 00       	mov    $0x11a270,%ebx
{
  116678:	51                   	push   %rcx

	for ( ; region < end; region++) {
  116679:	48 81 fb a0 a2 11 00 	cmp    $0x11a2a0,%rbx
  116680:	73 14                	jae    116696 <app_shmem_bss_zero+0x28>
		}

		if (do_clear)
#endif /* CONFIG_DEMAND_PAGING && !CONFIG_LINKER_GENERIC_SECTIONS_PRESENT_AT_BOOT */
		{
			(void)memset(region->bss_start, 0, region->bss_size);
  116682:	48 8b 53 08          	mov    0x8(%rbx),%rdx
  116686:	48 8b 3b             	mov    (%rbx),%rdi
  116689:	31 f6                	xor    %esi,%esi
	for ( ; region < end; region++) {
  11668b:	48 83 c3 10          	add    $0x10,%rbx
			(void)memset(region->bss_start, 0, region->bss_size);
  11668f:	e8 1e 3a ff ff       	callq  10a0b2 <memset>
	for ( ; region < end; region++) {
  116694:	eb e3                	jmp    116679 <app_shmem_bss_zero+0xb>
		}
	}

	return 0;
}
  116696:	5a                   	pop    %rdx
  116697:	31 c0                	xor    %eax,%eax
  116699:	5b                   	pop    %rbx
  11669a:	5d                   	pop    %rbp
  11669b:	c3                   	retq   

000000000011669c <unref_check>:
{
  11669c:	55                   	push   %rbp
  11669d:	48 89 e5             	mov    %rsp,%rbp
  1166a0:	41 55                	push   %r13
  1166a2:	41 54                	push   %r12
  1166a4:	49 89 fc             	mov    %rdi,%r12
  1166a7:	53                   	push   %rbx
  1166a8:	48 89 f3             	mov    %rsi,%rbx
  1166ab:	52                   	push   %rdx
  1166ac:	9c                   	pushfq 
  1166ad:	fa                   	cli    
  1166ae:	41 5d                	pop    %r13
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  1166b0:	bf 08 ce 1b 00       	mov    $0x1bce08,%edi
  1166b5:	e8 bf 71 ff ff       	callq  10d879 <z_spin_lock_valid>
  1166ba:	84 c0                	test   %al,%al
  1166bc:	75 39                	jne    1166f7 <unref_check+0x5b>
  1166be:	b9 8e 00 00 00       	mov    $0x8e,%ecx
  1166c3:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  1166c8:	be fd d1 11 00       	mov    $0x11d1fd,%esi
  1166cd:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  1166d2:	e8 21 9f fe ff       	callq  1005f8 <printk>
  1166d7:	be 08 ce 1b 00       	mov    $0x1bce08,%esi
  1166dc:	bf 12 d2 11 00       	mov    $0x11d212,%edi
  1166e1:	31 c0                	xor    %eax,%eax
  1166e3:	e8 10 9f fe ff       	callq  1005f8 <printk>
  1166e8:	be 8e 00 00 00       	mov    $0x8e,%esi
  1166ed:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  1166f2:	e8 a1 c4 fe ff       	callq  102b98 <assert_post_action>
	z_spin_lock_set_owner(l);
  1166f7:	bf 08 ce 1b 00       	mov    $0x1bce08,%edi
  1166fc:	e8 bc 71 ff ff       	callq  10d8bd <z_spin_lock_set_owner>
	__asm__ volatile("btrl %1, %0"
  116701:	41 0f b3 5c 24 08    	btr    %ebx,0x8(%r12)
	if ((ko->flags & K_OBJ_FLAG_ALLOC) == 0U) {
  116707:	41 f6 44 24 0d 04    	testb  $0x4,0xd(%r12)
  11670d:	74 7d                	je     11678c <unref_check+0xf0>
  11670f:	31 c0                	xor    %eax,%eax
		if (ko->perms[i] != 0U) {
  116711:	41 80 7c 04 08 00    	cmpb   $0x0,0x8(%r12,%rax,1)
  116717:	75 73                	jne    11678c <unref_check+0xf0>
	for (int i = 0; i < CONFIG_MAX_THREAD_BYTES; i++) {
  116719:	48 ff c0             	inc    %rax
  11671c:	48 83 f8 04          	cmp    $0x4,%rax
  116720:	75 ef                	jne    116711 <unref_check+0x75>
	switch (ko->type) {
  116722:	41 8a 44 24 0c       	mov    0xc(%r12),%al
  116727:	3c 04                	cmp    $0x4,%al
  116729:	74 13                	je     11673e <unref_check+0xa2>
  11672b:	3c 08                	cmp    $0x8,%al
  11672d:	74 1a                	je     116749 <unref_check+0xad>
  11672f:	3c 02                	cmp    $0x2,%al
  116731:	75 1f                	jne    116752 <unref_check+0xb6>
		k_msgq_cleanup((struct k_msgq *)ko->name);
  116733:	49 8b 3c 24          	mov    (%r12),%rdi
  116737:	e8 c5 80 ff ff       	callq  10e801 <k_msgq_cleanup>
		break;
  11673c:	eb 14                	jmp    116752 <unref_check+0xb6>
		k_pipe_cleanup((struct k_pipe *)ko->name);
  11673e:	49 8b 3c 24          	mov    (%r12),%rdi
  116742:	e8 49 10 00 00       	callq  117790 <k_pipe_cleanup>
		break;
  116747:	eb 09                	jmp    116752 <unref_check+0xb6>
		k_stack_cleanup((struct k_stack *)ko->name);
  116749:	49 8b 3c 24          	mov    (%r12),%rdi
  11674d:	e8 45 1f 00 00       	callq  118697 <k_stack_cleanup>
	rb_remove(&obj_rb_tree, &dyn->node);
  116752:	bf 00 14 5e 00       	mov    $0x5e1400,%edi
  116757:	49 8d 74 24 28       	lea    0x28(%r12),%rsi
  11675c:	e8 cf a2 fe ff       	callq  100a30 <rb_remove>
	sys_dnode_t *const prev = node->prev;
  116761:	49 8b 54 24 20       	mov    0x20(%r12),%rdx
	sys_dnode_t *const next = node->next;
  116766:	49 8b 44 24 18       	mov    0x18(%r12),%rax
	k_free(dyn);
  11676b:	4c 89 e7             	mov    %r12,%rdi
	prev->next = next;
  11676e:	48 89 02             	mov    %rax,(%rdx)
	next->prev = prev;
  116771:	48 89 50 08          	mov    %rdx,0x8(%rax)
	node->next = NULL;
  116775:	49 c7 44 24 18 00 00 	movq   $0x0,0x18(%r12)
  11677c:	00 00 
	node->prev = NULL;
  11677e:	49 c7 44 24 20 00 00 	movq   $0x0,0x20(%r12)
  116785:	00 00 
  116787:	e8 d1 f2 ff ff       	callq  115a5d <k_free>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  11678c:	bf 08 ce 1b 00       	mov    $0x1bce08,%edi
  116791:	e8 03 71 ff ff       	callq  10d899 <z_spin_unlock_valid>
  116796:	84 c0                	test   %al,%al
  116798:	75 39                	jne    1167d3 <unref_check+0x137>
  11679a:	b9 b9 00 00 00       	mov    $0xb9,%ecx
  11679f:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  1167a4:	be 41 d2 11 00       	mov    $0x11d241,%esi
  1167a9:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  1167ae:	e8 45 9e fe ff       	callq  1005f8 <printk>
  1167b3:	be 08 ce 1b 00       	mov    $0x1bce08,%esi
  1167b8:	bf 58 d2 11 00       	mov    $0x11d258,%edi
  1167bd:	31 c0                	xor    %eax,%eax
  1167bf:	e8 34 9e fe ff       	callq  1005f8 <printk>
  1167c4:	be b9 00 00 00       	mov    $0xb9,%esi
  1167c9:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  1167ce:	e8 c5 c3 fe ff       	callq  102b98 <assert_post_action>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  1167d3:	41 0f ba e5 09       	bt     $0x9,%r13d
  1167d8:	73 01                	jae    1167db <unref_check+0x13f>
		__asm__ volatile ("sti" ::: "memory");
  1167da:	fb                   	sti    
}
  1167db:	58                   	pop    %rax
  1167dc:	5b                   	pop    %rbx
  1167dd:	41 5c                	pop    %r12
  1167df:	41 5d                	pop    %r13
  1167e1:	5d                   	pop    %rbp
  1167e2:	c3                   	retq   

00000000001167e3 <clear_perms_cb>:
	unref_check(ko, id);
  1167e3:	e9 b4 fe ff ff       	jmpq   11669c <unref_check>

00000000001167e8 <dyn_object_find>:
{
  1167e8:	55                   	push   %rbp
  1167e9:	48 89 e5             	mov    %rsp,%rbp
  1167ec:	41 55                	push   %r13
  1167ee:	41 54                	push   %r12
	return &dobj->node;
  1167f0:	4c 8d 67 e8          	lea    -0x18(%rdi),%r12
{
  1167f4:	53                   	push   %rbx
  1167f5:	48 89 fb             	mov    %rdi,%rbx
  1167f8:	51                   	push   %rcx
  1167f9:	9c                   	pushfq 
  1167fa:	fa                   	cli    
  1167fb:	41 5d                	pop    %r13
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  1167fd:	bf 10 ce 1b 00       	mov    $0x1bce10,%edi
  116802:	e8 72 70 ff ff       	callq  10d879 <z_spin_lock_valid>
  116807:	84 c0                	test   %al,%al
  116809:	75 39                	jne    116844 <dyn_object_find+0x5c>
  11680b:	b9 8e 00 00 00       	mov    $0x8e,%ecx
  116810:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  116815:	be fd d1 11 00       	mov    $0x11d1fd,%esi
  11681a:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  11681f:	e8 d4 9d fe ff       	callq  1005f8 <printk>
  116824:	be 10 ce 1b 00       	mov    $0x1bce10,%esi
  116829:	bf 12 d2 11 00       	mov    $0x11d212,%edi
  11682e:	31 c0                	xor    %eax,%eax
  116830:	e8 c3 9d fe ff       	callq  1005f8 <printk>
  116835:	be 8e 00 00 00       	mov    $0x8e,%esi
  11683a:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  11683f:	e8 54 c3 fe ff       	callq  102b98 <assert_post_action>
	z_spin_lock_set_owner(l);
  116844:	bf 10 ce 1b 00       	mov    $0x1bce10,%edi
  116849:	e8 6f 70 ff ff       	callq  10d8bd <z_spin_lock_set_owner>
	if (rb_contains(&obj_rb_tree, node)) {
  11684e:	4c 89 e6             	mov    %r12,%rsi
  116851:	bf 00 14 5e 00       	mov    $0x5e1400,%edi
		ret = NULL;
  116856:	45 31 e4             	xor    %r12d,%r12d
	if (rb_contains(&obj_rb_tree, node)) {
  116859:	e8 08 a6 fe ff       	callq  100e66 <rb_contains>
  11685e:	84 c0                	test   %al,%al
  116860:	74 04                	je     116866 <dyn_object_find+0x7e>
	return CONTAINER_OF(node, struct dyn_obj, node);
  116862:	4c 8d 63 c0          	lea    -0x40(%rbx),%r12
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  116866:	bf 10 ce 1b 00       	mov    $0x1bce10,%edi
  11686b:	e8 29 70 ff ff       	callq  10d899 <z_spin_unlock_valid>
  116870:	84 c0                	test   %al,%al
  116872:	75 39                	jne    1168ad <dyn_object_find+0xc5>
  116874:	b9 b9 00 00 00       	mov    $0xb9,%ecx
  116879:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  11687e:	be 41 d2 11 00       	mov    $0x11d241,%esi
  116883:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  116888:	e8 6b 9d fe ff       	callq  1005f8 <printk>
  11688d:	be 10 ce 1b 00       	mov    $0x1bce10,%esi
  116892:	bf 58 d2 11 00       	mov    $0x11d258,%edi
  116897:	31 c0                	xor    %eax,%eax
  116899:	e8 5a 9d fe ff       	callq  1005f8 <printk>
  11689e:	be b9 00 00 00       	mov    $0xb9,%esi
  1168a3:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  1168a8:	e8 eb c2 fe ff       	callq  102b98 <assert_post_action>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  1168ad:	41 0f ba e5 09       	bt     $0x9,%r13d
  1168b2:	73 01                	jae    1168b5 <dyn_object_find+0xcd>
		__asm__ volatile ("sti" ::: "memory");
  1168b4:	fb                   	sti    
}
  1168b5:	5a                   	pop    %rdx
  1168b6:	4c 89 e0             	mov    %r12,%rax
  1168b9:	5b                   	pop    %rbx
  1168ba:	41 5c                	pop    %r12
  1168bc:	41 5d                	pop    %r13
  1168be:	5d                   	pop    %rbp
  1168bf:	c3                   	retq   

00000000001168c0 <user_copy>:
{
  1168c0:	55                   	push   %rbp
  1168c1:	49 89 d0             	mov    %rdx,%r8
  1168c4:	48 89 e5             	mov    %rsp,%rbp
  1168c7:	41 55                	push   %r13
  1168c9:	49 89 f5             	mov    %rsi,%r13
  1168cc:	41 54                	push   %r12
  1168ce:	49 89 fc             	mov    %rdi,%r12
  1168d1:	48 83 ec 10          	sub    $0x10,%rsp
	if (to_user ? Z_SYSCALL_MEMORY_WRITE(dst, size) :
  1168d5:	84 c9                	test   %cl,%cl
  1168d7:	74 24                	je     1168fd <user_copy+0x3d>
  1168d9:	4c 89 c6             	mov    %r8,%rsi
  1168dc:	ba 01 00 00 00       	mov    $0x1,%edx
  1168e1:	4c 89 45 e8          	mov    %r8,-0x18(%rbp)
  1168e5:	e8 d2 2a ff ff       	callq  1093bc <arch_buffer_validate>
  1168ea:	4c 8b 45 e8          	mov    -0x18(%rbp),%r8
  1168ee:	85 c0                	test   %eax,%eax
  1168f0:	74 4a                	je     11693c <user_copy+0x7c>
  1168f2:	41 b9 a4 d2 11 00    	mov    $0x11d2a4,%r9d
  1168f8:	4c 89 e1             	mov    %r12,%rcx
  1168fb:	eb 22                	jmp    11691f <user_copy+0x5f>
			Z_SYSCALL_MEMORY_READ(src, size)) {
  1168fd:	31 d2                	xor    %edx,%edx
  1168ff:	4c 89 c6             	mov    %r8,%rsi
  116902:	4c 89 ef             	mov    %r13,%rdi
  116905:	4c 89 45 e8          	mov    %r8,-0x18(%rbp)
  116909:	e8 ae 2a ff ff       	callq  1093bc <arch_buffer_validate>
  11690e:	4c 8b 45 e8          	mov    -0x18(%rbp),%r8
  116912:	85 c0                	test   %eax,%eax
  116914:	74 26                	je     11693c <user_copy+0x7c>
  116916:	41 b9 de 0d 12 00    	mov    $0x120dde,%r9d
  11691c:	4c 89 e9             	mov    %r13,%rcx
  11691f:	31 c0                	xor    %eax,%eax
  116921:	ba b0 ce 11 00       	mov    $0x11ceb0,%edx
  116926:	be 45 00 00 00       	mov    $0x45,%esi
  11692b:	bf 1e cf 11 00       	mov    $0x11cf1e,%edi
  116930:	e8 91 c7 fe ff       	callq  1030c6 <z_log_minimal_printk>
	int ret = EFAULT;
  116935:	b8 0e 00 00 00       	mov    $0xe,%eax
  11693a:	eb 10                	jmp    11694c <user_copy+0x8c>
	(void)memcpy(dst, src, size);
  11693c:	4c 89 c2             	mov    %r8,%rdx
  11693f:	4c 89 ee             	mov    %r13,%rsi
  116942:	4c 89 e7             	mov    %r12,%rdi
  116945:	e8 4e 37 ff ff       	callq  10a098 <memcpy>
	ret = 0;
  11694a:	31 c0                	xor    %eax,%eax
}
  11694c:	5a                   	pop    %rdx
  11694d:	59                   	pop    %rcx
  11694e:	41 5c                	pop    %r12
  116950:	41 5d                	pop    %r13
  116952:	5d                   	pop    %rbp
  116953:	c3                   	retq   

0000000000116954 <z_mrsh_adc_channel_setup>:
}

static uintptr_t handler_no_syscall(uintptr_t arg1, uintptr_t arg2,
				    uintptr_t arg3, uintptr_t arg4,
				    uintptr_t arg5, uintptr_t arg6, void *ssf)
{
  116954:	55                   	push   %rbp
	LOG_ERR("Unimplemented system call");
  116955:	bf 94 0b 12 00       	mov    $0x120b94,%edi
  11695a:	be 45 00 00 00       	mov    $0x45,%esi
  11695f:	31 c0                	xor    %eax,%eax
{
  116961:	48 89 e5             	mov    %rsp,%rbp
	LOG_ERR("Unimplemented system call");
  116964:	e8 5d c7 fe ff       	callq  1030c6 <z_log_minimal_printk>
	arch_syscall_oops(ssf);
  116969:	48 8b 7d 10          	mov    0x10(%rbp),%rdi
  11696d:	e8 9b 32 ff ff       	callq  109c0d <arch_syscall_oops>

0000000000116972 <handler_bad_syscall>:
{
  116972:	55                   	push   %rbp
  116973:	48 89 fa             	mov    %rdi,%rdx
	LOG_ERR("Bad system call id %" PRIuPTR " invoked", bad_id);
  116976:	be 45 00 00 00       	mov    $0x45,%esi
  11697b:	bf b3 0b 12 00       	mov    $0x120bb3,%edi
  116980:	31 c0                	xor    %eax,%eax
{
  116982:	48 89 e5             	mov    %rsp,%rbp
	LOG_ERR("Bad system call id %" PRIuPTR " invoked", bad_id);
  116985:	e8 3c c7 fe ff       	callq  1030c6 <z_log_minimal_printk>
	arch_syscall_oops(ssf);
  11698a:	48 8b 7d 10          	mov    0x10(%rbp),%rdi
  11698e:	e8 7a 32 ff ff       	callq  109c0d <arch_syscall_oops>

0000000000116993 <otype_to_str>:
{
  116993:	b8 d7 0b 12 00       	mov    $0x120bd7,%eax
  116998:	83 ff 33             	cmp    $0x33,%edi
  11699b:	77 0a                	ja     1169a7 <otype_to_str+0x14>
  11699d:	89 ff                	mov    %edi,%edi
  11699f:	48 8b 04 fd e0 b1 11 	mov    0x11b1e0(,%rdi,8),%rax
  1169a6:	00 
}
  1169a7:	c3                   	retq   

00000000001169a8 <z_dynamic_object_aligned_create>:
{
  1169a8:	55                   	push   %rbp
	dyn = z_thread_aligned_alloc(align, sizeof(*dyn) + size);
  1169a9:	48 83 c6 40          	add    $0x40,%rsi
{
  1169ad:	48 89 e5             	mov    %rsp,%rbp
  1169b0:	41 54                	push   %r12
  1169b2:	53                   	push   %rbx
	dyn = z_thread_aligned_alloc(align, sizeof(*dyn) + size);
  1169b3:	e8 b8 f0 ff ff       	callq  115a70 <z_thread_aligned_alloc>
  1169b8:	49 89 c4             	mov    %rax,%r12
	if (dyn == NULL) {
  1169bb:	48 85 c0             	test   %rax,%rax
  1169be:	75 16                	jne    1169d6 <z_dynamic_object_aligned_create+0x2e>
		LOG_ERR("could not allocate kernel object, out of memory");
  1169c0:	be 45 00 00 00       	mov    $0x45,%esi
  1169c5:	bf d9 0b 12 00       	mov    $0x120bd9,%edi
  1169ca:	31 c0                	xor    %eax,%eax
  1169cc:	e8 f5 c6 fe ff       	callq  1030c6 <z_log_minimal_printk>
		return NULL;
  1169d1:	e9 f6 00 00 00       	jmpq   116acc <z_dynamic_object_aligned_create+0x124>
	dyn->kobj.name = &dyn->data;
  1169d6:	48 8d 40 40          	lea    0x40(%rax),%rax
	(void)memset(dyn->kobj.perms, 0, CONFIG_MAX_THREAD_BYTES);
  1169da:	49 8d 7c 24 08       	lea    0x8(%r12),%rdi
  1169df:	ba 04 00 00 00       	mov    $0x4,%edx
  1169e4:	31 f6                	xor    %esi,%esi
	dyn->kobj.name = &dyn->data;
  1169e6:	49 89 04 24          	mov    %rax,(%r12)
	dyn->kobj.type = K_OBJ_ANY;
  1169ea:	66 41 c7 44 24 0c 00 	movw   $0x0,0xc(%r12)
  1169f1:	00 
	(void)memset(dyn->kobj.perms, 0, CONFIG_MAX_THREAD_BYTES);
  1169f2:	e8 bb 36 ff ff       	callq  10a0b2 <memset>
  1169f7:	9c                   	pushfq 
  1169f8:	fa                   	cli    
  1169f9:	5b                   	pop    %rbx
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  1169fa:	bf 10 ce 1b 00       	mov    $0x1bce10,%edi
  1169ff:	e8 75 6e ff ff       	callq  10d879 <z_spin_lock_valid>
  116a04:	84 c0                	test   %al,%al
  116a06:	75 39                	jne    116a41 <z_dynamic_object_aligned_create+0x99>
  116a08:	b9 8e 00 00 00       	mov    $0x8e,%ecx
  116a0d:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  116a12:	be fd d1 11 00       	mov    $0x11d1fd,%esi
  116a17:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  116a1c:	e8 d7 9b fe ff       	callq  1005f8 <printk>
  116a21:	be 10 ce 1b 00       	mov    $0x1bce10,%esi
  116a26:	bf 12 d2 11 00       	mov    $0x11d212,%edi
  116a2b:	31 c0                	xor    %eax,%eax
  116a2d:	e8 c6 9b fe ff       	callq  1005f8 <printk>
  116a32:	be 8e 00 00 00       	mov    $0x8e,%esi
  116a37:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  116a3c:	e8 57 c1 fe ff       	callq  102b98 <assert_post_action>
	z_spin_lock_set_owner(l);
  116a41:	bf 10 ce 1b 00       	mov    $0x1bce10,%edi
  116a46:	e8 72 6e ff ff       	callq  10d8bd <z_spin_lock_set_owner>
	rb_insert(&obj_rb_tree, &dyn->node);
  116a4b:	bf 00 14 5e 00       	mov    $0x5e1400,%edi
  116a50:	49 8d 74 24 28       	lea    0x28(%r12),%rsi
  116a55:	e8 27 9e fe ff       	callq  100881 <rb_insert>
	sys_dlist_append(&obj_list, &dyn->dobj_list);
  116a5a:	49 8d 44 24 18       	lea    0x18(%r12),%rax
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  116a5f:	bf 10 ce 1b 00       	mov    $0x1bce10,%edi
	sys_dnode_t *const tail = list->tail;
  116a64:	48 8b 15 8d a9 4c 00 	mov    0x4ca98d(%rip),%rdx        # 5e13f8 <obj_list+0x8>
	node->next = list;
  116a6b:	49 c7 44 24 18 f0 13 	movq   $0x5e13f0,0x18(%r12)
  116a72:	5e 00 
	node->prev = tail;
  116a74:	49 89 54 24 20       	mov    %rdx,0x20(%r12)
	tail->next = node;
  116a79:	48 89 02             	mov    %rax,(%rdx)
	list->tail = node;
  116a7c:	48 89 05 75 a9 4c 00 	mov    %rax,0x4ca975(%rip)        # 5e13f8 <obj_list+0x8>
  116a83:	e8 11 6e ff ff       	callq  10d899 <z_spin_unlock_valid>
  116a88:	84 c0                	test   %al,%al
  116a8a:	75 39                	jne    116ac5 <z_dynamic_object_aligned_create+0x11d>
  116a8c:	b9 b9 00 00 00       	mov    $0xb9,%ecx
  116a91:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  116a96:	be 41 d2 11 00       	mov    $0x11d241,%esi
  116a9b:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  116aa0:	e8 53 9b fe ff       	callq  1005f8 <printk>
  116aa5:	be 10 ce 1b 00       	mov    $0x1bce10,%esi
  116aaa:	bf 58 d2 11 00       	mov    $0x11d258,%edi
  116aaf:	31 c0                	xor    %eax,%eax
  116ab1:	e8 42 9b fe ff       	callq  1005f8 <printk>
  116ab6:	be b9 00 00 00       	mov    $0xb9,%esi
  116abb:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  116ac0:	e8 d3 c0 fe ff       	callq  102b98 <assert_post_action>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  116ac5:	0f ba e3 09          	bt     $0x9,%ebx
  116ac9:	73 01                	jae    116acc <z_dynamic_object_aligned_create+0x124>
		__asm__ volatile ("sti" ::: "memory");
  116acb:	fb                   	sti    
}
  116acc:	4c 89 e0             	mov    %r12,%rax
  116acf:	5b                   	pop    %rbx
  116ad0:	41 5c                	pop    %r12
  116ad2:	5d                   	pop    %rbp
  116ad3:	c3                   	retq   

0000000000116ad4 <z_object_find>:
{
  116ad4:	55                   	push   %rbp
  116ad5:	48 89 e5             	mov    %rsp,%rbp
  116ad8:	48 83 ec 10          	sub    $0x10,%rsp
	ret = z_object_gperf_find(obj);
  116adc:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  116ae0:	e8 7d 28 00 00       	callq  119362 <z_object_gperf_find>
	if (ret == NULL) {
  116ae5:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
  116ae9:	48 85 c0             	test   %rax,%rax
  116aec:	75 06                	jne    116af4 <z_object_find+0x20>
}
  116aee:	c9                   	leaveq 
		dynamic_obj = dyn_object_find((void *)obj);
  116aef:	e9 f4 fc ff ff       	jmpq   1167e8 <dyn_object_find>
}
  116af4:	c9                   	leaveq 
  116af5:	c3                   	retq   

0000000000116af6 <thread_index_get>:
{
  116af6:	55                   	push   %rbp
  116af7:	48 89 e5             	mov    %rsp,%rbp
	ko = z_object_find(thread);
  116afa:	e8 d5 ff ff ff       	callq  116ad4 <z_object_find>
	if (ko == NULL) {
  116aff:	41 83 c8 ff          	or     $0xffffffff,%r8d
  116b03:	48 85 c0             	test   %rax,%rax
  116b06:	74 04                	je     116b0c <thread_index_get+0x16>
	return ko->data.thread_id;
  116b08:	44 8b 40 0e          	mov    0xe(%rax),%r8d
}
  116b0c:	44 89 c0             	mov    %r8d,%eax
  116b0f:	5d                   	pop    %rbp
  116b10:	c3                   	retq   

0000000000116b11 <z_object_wordlist_foreach>:
{
  116b11:	55                   	push   %rbp
  116b12:	48 89 e5             	mov    %rsp,%rbp
  116b15:	41 56                	push   %r14
  116b17:	41 55                	push   %r13
  116b19:	49 89 f5             	mov    %rsi,%r13
  116b1c:	41 54                	push   %r12
  116b1e:	49 89 fc             	mov    %rdi,%r12
  116b21:	53                   	push   %rbx
	z_object_gperf_wordlist_foreach(func, context);
  116b22:	e8 7d 28 00 00       	callq  1193a4 <z_object_gperf_wordlist_foreach>
  116b27:	9c                   	pushfq 
  116b28:	fa                   	cli    
  116b29:	41 5e                	pop    %r14
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  116b2b:	bf 10 ce 1b 00       	mov    $0x1bce10,%edi
  116b30:	e8 44 6d ff ff       	callq  10d879 <z_spin_lock_valid>
  116b35:	84 c0                	test   %al,%al
  116b37:	75 39                	jne    116b72 <z_object_wordlist_foreach+0x61>
  116b39:	b9 8e 00 00 00       	mov    $0x8e,%ecx
  116b3e:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  116b43:	be fd d1 11 00       	mov    $0x11d1fd,%esi
  116b48:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  116b4d:	e8 a6 9a fe ff       	callq  1005f8 <printk>
  116b52:	be 10 ce 1b 00       	mov    $0x1bce10,%esi
  116b57:	bf 12 d2 11 00       	mov    $0x11d212,%edi
  116b5c:	31 c0                	xor    %eax,%eax
  116b5e:	e8 95 9a fe ff       	callq  1005f8 <printk>
  116b63:	be 8e 00 00 00       	mov    $0x8e,%esi
  116b68:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  116b6d:	e8 26 c0 fe ff       	callq  102b98 <assert_post_action>
	z_spin_lock_set_owner(l);
  116b72:	bf 10 ce 1b 00       	mov    $0x1bce10,%edi
  116b77:	e8 41 6d ff ff       	callq  10d8bd <z_spin_lock_set_owner>
	return list->head == list;
  116b7c:	48 8b 1d 6d a8 4c 00 	mov    0x4ca86d(%rip),%rbx        # 5e13f0 <obj_list>
	SYS_DLIST_FOR_EACH_CONTAINER_SAFE(&obj_list, obj, next, dobj_list) {
  116b83:	48 85 db             	test   %rbx,%rbx
  116b86:	74 66                	je     116bee <z_object_wordlist_foreach+0xdd>
  116b88:	48 81 fb f0 13 5e 00 	cmp    $0x5e13f0,%rbx
  116b8f:	74 5d                	je     116bee <z_object_wordlist_foreach+0xdd>
  116b91:	48 89 df             	mov    %rbx,%rdi
  116b94:	48 83 ef 18          	sub    $0x18,%rdi
  116b98:	74 54                	je     116bee <z_object_wordlist_foreach+0xdd>
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
  116b9a:	48 85 db             	test   %rbx,%rbx
  116b9d:	74 19                	je     116bb8 <z_object_wordlist_foreach+0xa7>
	return (node == list->tail) ? NULL : node->next;
  116b9f:	48 3b 1d 52 a8 4c 00 	cmp    0x4ca852(%rip),%rbx        # 5e13f8 <obj_list+0x8>
  116ba6:	74 0e                	je     116bb6 <z_object_wordlist_foreach+0xa5>
  116ba8:	48 8b 1b             	mov    (%rbx),%rbx
  116bab:	48 85 db             	test   %rbx,%rbx
  116bae:	74 08                	je     116bb8 <z_object_wordlist_foreach+0xa7>
  116bb0:	48 83 eb 18          	sub    $0x18,%rbx
  116bb4:	eb 02                	jmp    116bb8 <z_object_wordlist_foreach+0xa7>
  116bb6:	31 db                	xor    %ebx,%ebx
		func(&obj->kobj, context);
  116bb8:	4c 89 ee             	mov    %r13,%rsi
  116bbb:	41 ff d4             	callq  *%r12
	SYS_DLIST_FOR_EACH_CONTAINER_SAFE(&obj_list, obj, next, dobj_list) {
  116bbe:	48 85 db             	test   %rbx,%rbx
  116bc1:	74 2b                	je     116bee <z_object_wordlist_foreach+0xdd>
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
  116bc3:	48 89 d8             	mov    %rbx,%rax
  116bc6:	48 83 c0 18          	add    $0x18,%rax
  116bca:	74 1a                	je     116be6 <z_object_wordlist_foreach+0xd5>
	return (node == list->tail) ? NULL : node->next;
  116bcc:	48 3b 05 25 a8 4c 00 	cmp    0x4ca825(%rip),%rax        # 5e13f8 <obj_list+0x8>
  116bd3:	74 0f                	je     116be4 <z_object_wordlist_foreach+0xd3>
  116bd5:	48 8b 43 18          	mov    0x18(%rbx),%rax
  116bd9:	48 85 c0             	test   %rax,%rax
  116bdc:	74 08                	je     116be6 <z_object_wordlist_foreach+0xd5>
  116bde:	48 83 e8 18          	sub    $0x18,%rax
  116be2:	eb 02                	jmp    116be6 <z_object_wordlist_foreach+0xd5>
  116be4:	31 c0                	xor    %eax,%eax
  116be6:	48 89 df             	mov    %rbx,%rdi
  116be9:	48 89 c3             	mov    %rax,%rbx
  116bec:	eb ca                	jmp    116bb8 <z_object_wordlist_foreach+0xa7>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  116bee:	bf 10 ce 1b 00       	mov    $0x1bce10,%edi
  116bf3:	e8 a1 6c ff ff       	callq  10d899 <z_spin_unlock_valid>
  116bf8:	84 c0                	test   %al,%al
  116bfa:	75 39                	jne    116c35 <z_object_wordlist_foreach+0x124>
  116bfc:	b9 b9 00 00 00       	mov    $0xb9,%ecx
  116c01:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  116c06:	be 41 d2 11 00       	mov    $0x11d241,%esi
  116c0b:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  116c10:	e8 e3 99 fe ff       	callq  1005f8 <printk>
  116c15:	be 10 ce 1b 00       	mov    $0x1bce10,%esi
  116c1a:	bf 58 d2 11 00       	mov    $0x11d258,%edi
  116c1f:	31 c0                	xor    %eax,%eax
  116c21:	e8 d2 99 fe ff       	callq  1005f8 <printk>
  116c26:	be b9 00 00 00       	mov    $0xb9,%esi
  116c2b:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  116c30:	e8 63 bf fe ff       	callq  102b98 <assert_post_action>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  116c35:	41 0f ba e6 09       	bt     $0x9,%r14d
  116c3a:	73 01                	jae    116c3d <z_object_wordlist_foreach+0x12c>
		__asm__ volatile ("sti" ::: "memory");
  116c3c:	fb                   	sti    
}
  116c3d:	5b                   	pop    %rbx
  116c3e:	41 5c                	pop    %r12
  116c40:	41 5d                	pop    %r13
  116c42:	41 5e                	pop    %r14
  116c44:	5d                   	pop    %rbp
  116c45:	c3                   	retq   

0000000000116c46 <z_thread_perms_inherit>:
{
  116c46:	55                   	push   %rbp
  116c47:	48 89 e5             	mov    %rsp,%rbp
  116c4a:	41 54                	push   %r12
  116c4c:	49 89 f4             	mov    %rsi,%r12
  116c4f:	53                   	push   %rbx
  116c50:	48 89 fb             	mov    %rdi,%rbx
  116c53:	48 83 ec 10          	sub    $0x10,%rsp
		thread_index_get(parent),
  116c57:	e8 9a fe ff ff       	callq  116af6 <thread_index_get>
		thread_index_get(child),
  116c5c:	4c 89 e7             	mov    %r12,%rdi
	struct perm_ctx ctx = {
  116c5f:	89 45 e0             	mov    %eax,-0x20(%rbp)
		thread_index_get(child),
  116c62:	e8 8f fe ff ff       	callq  116af6 <thread_index_get>
	if ((ctx.parent_id != -1) && (ctx.child_id != -1)) {
  116c67:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%rbp)
	struct perm_ctx ctx = {
  116c6b:	48 89 5d e8          	mov    %rbx,-0x18(%rbp)
  116c6f:	89 45 e4             	mov    %eax,-0x1c(%rbp)
	if ((ctx.parent_id != -1) && (ctx.child_id != -1)) {
  116c72:	74 12                	je     116c86 <z_thread_perms_inherit+0x40>
  116c74:	ff c0                	inc    %eax
  116c76:	74 0e                	je     116c86 <z_thread_perms_inherit+0x40>
		z_object_wordlist_foreach(wordlist_cb, &ctx);
  116c78:	48 8d 75 e0          	lea    -0x20(%rbp),%rsi
  116c7c:	bf 51 66 11 00       	mov    $0x116651,%edi
  116c81:	e8 8b fe ff ff       	callq  116b11 <z_object_wordlist_foreach>
}
  116c86:	58                   	pop    %rax
  116c87:	5a                   	pop    %rdx
  116c88:	5b                   	pop    %rbx
  116c89:	41 5c                	pop    %r12
  116c8b:	5d                   	pop    %rbp
  116c8c:	c3                   	retq   

0000000000116c8d <z_thread_perms_set>:
{
  116c8d:	55                   	push   %rbp
  116c8e:	48 89 e5             	mov    %rsp,%rbp
  116c91:	53                   	push   %rbx
  116c92:	48 89 fb             	mov    %rdi,%rbx
  116c95:	48 89 f7             	mov    %rsi,%rdi
  116c98:	52                   	push   %rdx
	int index = thread_index_get(thread);
  116c99:	e8 58 fe ff ff       	callq  116af6 <thread_index_get>
	if (index != -1) {
  116c9e:	83 f8 ff             	cmp    $0xffffffff,%eax
  116ca1:	74 04                	je     116ca7 <z_thread_perms_set+0x1a>
	__asm__ volatile("btsl %1, %0"
  116ca3:	0f ab 43 08          	bts    %eax,0x8(%rbx)
}
  116ca7:	58                   	pop    %rax
  116ca8:	5b                   	pop    %rbx
  116ca9:	5d                   	pop    %rbp
  116caa:	c3                   	retq   

0000000000116cab <z_impl_k_object_alloc>:
{
  116cab:	55                   	push   %rbp
  116cac:	48 89 e5             	mov    %rsp,%rbp
  116caf:	41 55                	push   %r13
  116cb1:	41 89 fd             	mov    %edi,%r13d
  116cb4:	41 54                	push   %r12
	if (otype <= K_OBJ_ANY || otype >= K_OBJ_LAST) {
  116cb6:	44 8d 67 ff          	lea    -0x1(%rdi),%r12d
{
  116cba:	53                   	push   %rbx
  116cbb:	48 83 ec 18          	sub    $0x18,%rsp
	if (otype <= K_OBJ_ANY || otype >= K_OBJ_LAST) {
  116cbf:	41 83 fc 32          	cmp    $0x32,%r12d
  116cc3:	76 15                	jbe    116cda <z_impl_k_object_alloc+0x2f>
		LOG_ERR("bad object type %d requested", otype);
  116cc5:	89 fa                	mov    %edi,%edx
  116cc7:	be 45 00 00 00       	mov    $0x45,%esi
  116ccc:	bf 0e 0c 12 00       	mov    $0x120c0e,%edi
  116cd1:	31 c0                	xor    %eax,%eax
  116cd3:	e8 ee c3 fe ff       	callq  1030c6 <z_log_minimal_printk>
		return NULL;
  116cd8:	eb 6f                	jmp    116d49 <z_impl_k_object_alloc+0x9e>
	switch (otype) {
  116cda:	83 ff 0c             	cmp    $0xc,%edi
  116cdd:	77 11                	ja     116cf0 <z_impl_k_object_alloc+0x45>
  116cdf:	83 ff 0a             	cmp    $0xa,%edi
  116ce2:	77 69                	ja     116d4d <z_impl_k_object_alloc+0xa2>
  116ce4:	31 d2                	xor    %edx,%edx
  116ce6:	83 c9 ff             	or     $0xffffffff,%ecx
  116ce9:	83 ff 09             	cmp    $0x9,%edi
  116cec:	74 0c                	je     116cfa <z_impl_k_object_alloc+0x4f>
  116cee:	eb 7b                	jmp    116d6b <z_impl_k_object_alloc+0xc0>
  116cf0:	8d 47 f2             	lea    -0xe(%rdi),%eax
  116cf3:	83 f8 01             	cmp    $0x1,%eax
  116cf6:	77 73                	ja     116d6b <z_impl_k_object_alloc+0xc0>
  116cf8:	eb 53                	jmp    116d4d <z_impl_k_object_alloc+0xa2>
  116cfa:	0f b6 82 00 50 6e 00 	movzbl 0x6e5000(%rdx),%eax
  116d01:	8d 34 d5 00 00 00 00 	lea    0x0(,%rdx,8),%esi
  116d08:	0f bc c0             	bsf    %eax,%eax
  116d0b:	0f 44 c1             	cmove  %ecx,%eax
		if (idx != 0) {
  116d0e:	ff c0                	inc    %eax
  116d10:	74 1d                	je     116d2f <z_impl_k_object_alloc+0x84>
			*tidx = base + (idx - 1);
  116d12:	8d 44 30 ff          	lea    -0x1(%rax,%rsi,1),%eax
  116d16:	48 63 d8             	movslq %eax,%rbx
	__asm__ volatile("btrl %1, %0"
  116d19:	0f b3 05 e0 e2 5c 00 	btr    %eax,0x5ce2e0(%rip)        # 6e5000 <_thread_idx_map>
			z_object_wordlist_foreach(clear_perms_cb,
  116d20:	bf e3 67 11 00       	mov    $0x1167e3,%edi
  116d25:	48 89 de             	mov    %rbx,%rsi
  116d28:	e8 e4 fd ff ff       	callq  116b11 <z_object_wordlist_foreach>
	switch (otype) {
  116d2d:	eb 49                	jmp    116d78 <z_impl_k_object_alloc+0xcd>
	for (i = 0; i < CONFIG_MAX_THREAD_BYTES; i++) {
  116d2f:	48 ff c2             	inc    %rdx
  116d32:	48 83 fa 04          	cmp    $0x4,%rdx
  116d36:	75 c2                	jne    116cfa <z_impl_k_object_alloc+0x4f>
			LOG_ERR("out of free thread indexes");
  116d38:	be 45 00 00 00       	mov    $0x45,%esi
  116d3d:	bf 30 0c 12 00       	mov    $0x120c30,%edi
  116d42:	31 c0                	xor    %eax,%eax
  116d44:	e8 7d c3 fe ff       	callq  1030c6 <z_log_minimal_printk>
			return NULL;
  116d49:	31 c0                	xor    %eax,%eax
  116d4b:	eb 7b                	jmp    116dc8 <z_impl_k_object_alloc+0x11d>
		LOG_ERR("forbidden object type '%s' requested",
  116d4d:	44 89 ef             	mov    %r13d,%edi
  116d50:	be 45 00 00 00       	mov    $0x45,%esi
  116d55:	e8 39 fc ff ff       	callq  116993 <otype_to_str>
  116d5a:	bf 50 0c 12 00       	mov    $0x120c50,%edi
  116d5f:	48 89 c2             	mov    %rax,%rdx
  116d62:	31 c0                	xor    %eax,%eax
  116d64:	e8 5d c3 fe ff       	callq  1030c6 <z_log_minimal_printk>
		return NULL;
  116d69:	eb de                	jmp    116d49 <z_impl_k_object_alloc+0x9e>
	uintptr_t tidx = 0;
  116d6b:	31 db                	xor    %ebx,%ebx
  116d6d:	be 30 00 00 00       	mov    $0x30,%esi
  116d72:	41 83 fc 0f          	cmp    $0xf,%r12d
  116d76:	77 09                	ja     116d81 <z_impl_k_object_alloc+0xd6>
  116d78:	43 0f b7 b4 24 80 b3 	movzwl 0x11b380(%r12,%r12,1),%esi
  116d7f:	11 00 
		ret = sizeof(void *);
  116d81:	31 ff                	xor    %edi,%edi
  116d83:	41 83 fd 09          	cmp    $0x9,%r13d
  116d87:	40 0f 94 c7          	sete   %dil
  116d8b:	48 8d 3c fd 08 00 00 	lea    0x8(,%rdi,8),%rdi
  116d92:	00 
	zo = z_dynamic_object_aligned_create(obj_align_get(otype),
  116d93:	e8 10 fc ff ff       	callq  1169a8 <z_dynamic_object_aligned_create>
	if (zo == NULL) {
  116d98:	48 85 c0             	test   %rax,%rax
  116d9b:	74 2b                	je     116dc8 <z_impl_k_object_alloc+0x11d>
	zo->type = otype;
  116d9d:	44 88 68 0c          	mov    %r13b,0xc(%rax)
	if (otype == K_OBJ_THREAD) {
  116da1:	41 83 fd 09          	cmp    $0x9,%r13d
  116da5:	75 03                	jne    116daa <z_impl_k_object_alloc+0xff>
		zo->data.thread_id = tidx;
  116da7:	89 58 0e             	mov    %ebx,0xe(%rax)
	z_thread_perms_set(zo, _current);
  116daa:	48 8b 35 9f 19 01 00 	mov    0x1199f(%rip),%rsi        # 128750 <_kernel+0x10>
  116db1:	48 89 c7             	mov    %rax,%rdi
  116db4:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  116db8:	e8 d0 fe ff ff       	callq  116c8d <z_thread_perms_set>
	zo->flags |= K_OBJ_FLAG_ALLOC;
  116dbd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  116dc1:	80 48 0d 04          	orb    $0x4,0xd(%rax)
	return zo->name;
  116dc5:	48 8b 00             	mov    (%rax),%rax
}
  116dc8:	48 83 c4 18          	add    $0x18,%rsp
  116dcc:	5b                   	pop    %rbx
  116dcd:	41 5c                	pop    %r12
  116dcf:	41 5d                	pop    %r13
  116dd1:	5d                   	pop    %rbp
  116dd2:	c3                   	retq   

0000000000116dd3 <z_thread_perms_clear>:
{
  116dd3:	55                   	push   %rbp
  116dd4:	48 89 e5             	mov    %rsp,%rbp
  116dd7:	41 54                	push   %r12
  116dd9:	49 89 fc             	mov    %rdi,%r12
  116ddc:	48 89 f7             	mov    %rsi,%rdi
  116ddf:	51                   	push   %rcx
	int index = thread_index_get(thread);
  116de0:	e8 11 fd ff ff       	callq  116af6 <thread_index_get>
	if (index != -1) {
  116de5:	83 f8 ff             	cmp    $0xffffffff,%eax
  116de8:	74 15                	je     116dff <z_thread_perms_clear+0x2c>
  116dea:	41 0f b3 44 24 08    	btr    %eax,0x8(%r12)
}
  116df0:	5a                   	pop    %rdx
		unref_check(ko, index);
  116df1:	4c 89 e7             	mov    %r12,%rdi
  116df4:	48 63 f0             	movslq %eax,%rsi
}
  116df7:	41 5c                	pop    %r12
  116df9:	5d                   	pop    %rbp
		unref_check(ko, index);
  116dfa:	e9 9d f8 ff ff       	jmpq   11669c <unref_check>
}
  116dff:	58                   	pop    %rax
  116e00:	41 5c                	pop    %r12
  116e02:	5d                   	pop    %rbp
  116e03:	c3                   	retq   

0000000000116e04 <z_thread_perms_all_clear>:
{
  116e04:	55                   	push   %rbp
  116e05:	48 89 e5             	mov    %rsp,%rbp
	uintptr_t index = thread_index_get(thread);
  116e08:	e8 e9 fc ff ff       	callq  116af6 <thread_index_get>
	if ((int)index != -1) {
  116e0d:	83 f8 ff             	cmp    $0xffffffff,%eax
  116e10:	74 0d                	je     116e1f <z_thread_perms_all_clear+0x1b>
	uintptr_t index = thread_index_get(thread);
  116e12:	89 c6                	mov    %eax,%esi
		z_object_wordlist_foreach(clear_perms_cb, (void *)index);
  116e14:	bf e3 67 11 00       	mov    $0x1167e3,%edi
}
  116e19:	5d                   	pop    %rbp
		z_object_wordlist_foreach(clear_perms_cb, (void *)index);
  116e1a:	e9 f2 fc ff ff       	jmpq   116b11 <z_object_wordlist_foreach>
}
  116e1f:	5d                   	pop    %rbp
  116e20:	c3                   	retq   

0000000000116e21 <z_dump_object_error>:
{
  116e21:	55                   	push   %rbp
  116e22:	48 89 e5             	mov    %rsp,%rbp
  116e25:	53                   	push   %rbx
  116e26:	53                   	push   %rbx
  116e27:	48 89 d3             	mov    %rdx,%rbx
	switch (retval) {
  116e2a:	83 ff f7             	cmp    $0xfffffff7,%edi
  116e2d:	0f 84 95 00 00 00    	je     116ec8 <z_dump_object_error+0xa7>
  116e33:	83 ff f8             	cmp    $0xfffffff8,%edi
  116e36:	7d 24                	jge    116e5c <z_dump_object_error+0x3b>
  116e38:	83 ff 90             	cmp    $0xffffff90,%edi
  116e3b:	0f 84 e0 00 00 00    	je     116f21 <z_dump_object_error+0x100>
  116e41:	83 ff ea             	cmp    $0xffffffea,%edi
  116e44:	0f 85 f9 00 00 00    	jne    116f43 <z_dump_object_error+0x122>
		LOG_ERR("%p used before initialization", obj);
  116e4a:	48 89 f2             	mov    %rsi,%rdx
  116e4d:	bf 2c 0d 12 00       	mov    $0x120d2c,%edi
  116e52:	be 45 00 00 00       	mov    $0x45,%esi
  116e57:	e9 ba 00 00 00       	jmpq   116f16 <z_dump_object_error+0xf5>
	switch (retval) {
  116e5c:	ff c7                	inc    %edi
  116e5e:	0f 85 df 00 00 00    	jne    116f43 <z_dump_object_error+0x122>
	int index = thread_index_get(_current);
  116e64:	48 8b 3d e5 18 01 00 	mov    0x118e5(%rip),%rdi        # 128750 <_kernel+0x10>
  116e6b:	e8 86 fc ff ff       	callq  116af6 <thread_index_get>
	LOG_ERR("thread %p (%d) does not have permission on %s %p",
  116e70:	0f b6 7b 0c          	movzbl 0xc(%rbx),%edi
  116e74:	be 45 00 00 00       	mov    $0x45,%esi
	int index = thread_index_get(_current);
  116e79:	89 c1                	mov    %eax,%ecx
	LOG_ERR("thread %p (%d) does not have permission on %s %p",
  116e7b:	e8 13 fb ff ff       	callq  116993 <otype_to_str>
  116e80:	4c 8b 0b             	mov    (%rbx),%r9
  116e83:	bf dc 0c 12 00       	mov    $0x120cdc,%edi
  116e88:	48 8b 15 c1 18 01 00 	mov    0x118c1(%rip),%rdx        # 128750 <_kernel+0x10>
  116e8f:	49 89 c0             	mov    %rax,%r8
  116e92:	31 c0                	xor    %eax,%eax
  116e94:	e8 2d c2 fe ff       	callq  1030c6 <z_log_minimal_printk>
	__asm__ volatile ("mov %%cs, %[cs_val]" : [cs_val] "=r" (cs));
  116e99:	8c c8                	mov    %cs,%eax
	LOG_HEXDUMP_ERR(ko->perms, sizeof(ko->perms), "permission bitmap");
  116e9b:	ba 12 0d 12 00       	mov    $0x120d12,%edx
  116ea0:	be 45 00 00 00       	mov    $0x45,%esi
  116ea5:	bf 24 0d 12 00       	mov    $0x120d24,%edi
  116eaa:	31 c0                	xor    %eax,%eax
  116eac:	e8 15 c2 fe ff       	callq  1030c6 <z_log_minimal_printk>
}
  116eb1:	41 5a                	pop    %r10
	LOG_HEXDUMP_ERR(ko->perms, sizeof(ko->perms), "permission bitmap");
  116eb3:	48 8d 73 08          	lea    0x8(%rbx),%rsi
  116eb7:	ba 04 00 00 00       	mov    $0x4,%edx
}
  116ebc:	5b                   	pop    %rbx
	LOG_HEXDUMP_ERR(ko->perms, sizeof(ko->perms), "permission bitmap");
  116ebd:	bf 01 00 00 00       	mov    $0x1,%edi
}
  116ec2:	5d                   	pop    %rbp
	LOG_HEXDUMP_ERR(ko->perms, sizeof(ko->perms), "permission bitmap");
  116ec3:	e9 8b c2 fe ff       	jmpq   103153 <z_log_minimal_hexdump_print>
		LOG_ERR("%p is not a valid %s", obj, otype_to_str(otype));
  116ec8:	89 cf                	mov    %ecx,%edi
  116eca:	48 89 f2             	mov    %rsi,%rdx
  116ecd:	be 45 00 00 00       	mov    $0x45,%esi
  116ed2:	e8 bc fa ff ff       	callq  116993 <otype_to_str>
  116ed7:	bf 7a 0c 12 00       	mov    $0x120c7a,%edi
  116edc:	48 89 c1             	mov    %rax,%rcx
  116edf:	31 c0                	xor    %eax,%eax
  116ee1:	e8 e0 c1 fe ff       	callq  1030c6 <z_log_minimal_printk>
		if (ko == NULL) {
  116ee6:	48 85 db             	test   %rbx,%rbx
  116ee9:	75 15                	jne    116f00 <z_dump_object_error+0xdf>
}
  116eeb:	41 5b                	pop    %r11
			LOG_ERR("address is not a known kernel object");
  116eed:	be 45 00 00 00       	mov    $0x45,%esi
}
  116ef2:	5b                   	pop    %rbx
			LOG_ERR("address is not a known kernel object");
  116ef3:	bf 94 0c 12 00       	mov    $0x120c94,%edi
  116ef8:	31 c0                	xor    %eax,%eax
}
  116efa:	5d                   	pop    %rbp
			LOG_ERR("address is not a known kernel object");
  116efb:	e9 c6 c1 fe ff       	jmpq   1030c6 <z_log_minimal_printk>
			LOG_ERR("address is actually a %s",
  116f00:	0f b6 7b 0c          	movzbl 0xc(%rbx),%edi
  116f04:	be 45 00 00 00       	mov    $0x45,%esi
  116f09:	e8 85 fa ff ff       	callq  116993 <otype_to_str>
  116f0e:	bf be 0c 12 00       	mov    $0x120cbe,%edi
  116f13:	48 89 c2             	mov    %rax,%rdx
}
  116f16:	41 59                	pop    %r9
		LOG_ERR("%p used before initialization", obj);
  116f18:	31 c0                	xor    %eax,%eax
}
  116f1a:	5b                   	pop    %rbx
  116f1b:	5d                   	pop    %rbp
		LOG_ERR("%p used before initialization", obj);
  116f1c:	e9 a5 c1 fe ff       	jmpq   1030c6 <z_log_minimal_printk>
		LOG_ERR("%p %s in use", obj, otype_to_str(otype));
  116f21:	89 cf                	mov    %ecx,%edi
  116f23:	48 89 f2             	mov    %rsi,%rdx
  116f26:	be 45 00 00 00       	mov    $0x45,%esi
  116f2b:	e8 63 fa ff ff       	callq  116993 <otype_to_str>
}
  116f30:	41 58                	pop    %r8
		LOG_ERR("%p %s in use", obj, otype_to_str(otype));
  116f32:	bf 4f 0d 12 00       	mov    $0x120d4f,%edi
}
  116f37:	5b                   	pop    %rbx
		LOG_ERR("%p %s in use", obj, otype_to_str(otype));
  116f38:	48 89 c1             	mov    %rax,%rcx
}
  116f3b:	5d                   	pop    %rbp
		LOG_ERR("%p %s in use", obj, otype_to_str(otype));
  116f3c:	31 c0                	xor    %eax,%eax
  116f3e:	e9 83 c1 fe ff       	jmpq   1030c6 <z_log_minimal_printk>
}
  116f43:	58                   	pop    %rax
  116f44:	5b                   	pop    %rbx
  116f45:	5d                   	pop    %rbp
  116f46:	c3                   	retq   

0000000000116f47 <z_impl_k_object_access_grant>:
{
  116f47:	55                   	push   %rbp
  116f48:	48 89 e5             	mov    %rsp,%rbp
  116f4b:	48 83 ec 10          	sub    $0x10,%rsp
  116f4f:	48 89 75 f8          	mov    %rsi,-0x8(%rbp)
	struct z_object *ko = z_object_find(object);
  116f53:	e8 7c fb ff ff       	callq  116ad4 <z_object_find>
	if (ko != NULL) {
  116f58:	48 85 c0             	test   %rax,%rax
  116f5b:	74 0d                	je     116f6a <z_impl_k_object_access_grant+0x23>
		z_thread_perms_set(ko, thread);
  116f5d:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  116f61:	48 89 c7             	mov    %rax,%rdi
}
  116f64:	c9                   	leaveq 
		z_thread_perms_set(ko, thread);
  116f65:	e9 23 fd ff ff       	jmpq   116c8d <z_thread_perms_set>
}
  116f6a:	c9                   	leaveq 
  116f6b:	c3                   	retq   

0000000000116f6c <z_object_validate>:
{
  116f6c:	55                   	push   %rbp
  116f6d:	48 89 e5             	mov    %rsp,%rbp
  116f70:	41 54                	push   %r12
  116f72:	53                   	push   %rbx
	if (unlikely((ko == NULL) ||
  116f73:	48 85 ff             	test   %rdi,%rdi
  116f76:	74 66                	je     116fde <z_object_validate+0x72>
  116f78:	48 89 fb             	mov    %rdi,%rbx
  116f7b:	41 89 d4             	mov    %edx,%r12d
  116f7e:	85 f6                	test   %esi,%esi
  116f80:	74 08                	je     116f8a <z_object_validate+0x1e>
  116f82:	0f b6 47 0c          	movzbl 0xc(%rdi),%eax
  116f86:	39 f0                	cmp    %esi,%eax
  116f88:	75 54                	jne    116fde <z_object_validate+0x72>
	if ((ko->flags & K_OBJ_FLAG_PUBLIC) != 0U) {
  116f8a:	f6 43 0d 02          	testb  $0x2,0xd(%rbx)
  116f8e:	74 14                	je     116fa4 <z_object_validate+0x38>
	if (likely(init == _OBJ_INIT_TRUE)) {
  116f90:	45 85 e4             	test   %r12d,%r12d
  116f93:	75 32                	jne    116fc7 <z_object_validate+0x5b>
			return -EINVAL;
  116f95:	f6 43 0d 01          	testb  $0x1,0xd(%rbx)
  116f99:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
  116f9e:	44 0f 44 e0          	cmove  %eax,%r12d
  116fa2:	eb 45                	jmp    116fe9 <z_object_validate+0x7d>
	index = thread_index_get(_current);
  116fa4:	48 8b 3d a5 17 01 00 	mov    0x117a5(%rip),%rdi        # 128750 <_kernel+0x10>
  116fab:	e8 46 fb ff ff       	callq  116af6 <thread_index_get>
	if (index != -1) {
  116fb0:	83 f8 ff             	cmp    $0xffffffff,%eax
  116fb3:	75 06                	jne    116fbb <z_object_validate+0x4f>
		return -EPERM;
  116fb5:	41 83 cc ff          	or     $0xffffffff,%r12d
  116fb9:	eb 2e                	jmp    116fe9 <z_object_validate+0x7d>
	__asm__ volatile("btl %2, %1;"
  116fbb:	0f a3 43 08          	bt     %eax,0x8(%rbx)
  116fbf:	19 c0                	sbb    %eax,%eax
	if (unlikely(thread_perms_test(ko) == 0)) {
  116fc1:	85 c0                	test   %eax,%eax
  116fc3:	75 cb                	jne    116f90 <z_object_validate+0x24>
  116fc5:	eb ee                	jmp    116fb5 <z_object_validate+0x49>
	} else if (init == _OBJ_INIT_FALSE) { /* _OBJ_INIT_FALSE case */
  116fc7:	41 ff c4             	inc    %r12d
  116fca:	75 1a                	jne    116fe6 <z_object_validate+0x7a>
		if (unlikely((ko->flags & K_OBJ_FLAG_INITIALIZED) != 0U)) {
  116fcc:	44 8a 63 0d          	mov    0xd(%rbx),%r12b
			return -EADDRINUSE;
  116fd0:	41 c1 e4 1f          	shl    $0x1f,%r12d
  116fd4:	41 c1 fc 1f          	sar    $0x1f,%r12d
  116fd8:	41 83 e4 90          	and    $0xffffff90,%r12d
  116fdc:	eb 0b                	jmp    116fe9 <z_object_validate+0x7d>
		return -EBADF;
  116fde:	41 bc f7 ff ff ff    	mov    $0xfffffff7,%r12d
  116fe4:	eb 03                	jmp    116fe9 <z_object_validate+0x7d>
	return 0;
  116fe6:	45 31 e4             	xor    %r12d,%r12d
}
  116fe9:	44 89 e0             	mov    %r12d,%eax
  116fec:	5b                   	pop    %rbx
  116fed:	41 5c                	pop    %r12
  116fef:	5d                   	pop    %rbp
  116ff0:	c3                   	retq   

0000000000116ff1 <z_object_init>:
{
  116ff1:	55                   	push   %rbp
  116ff2:	48 89 e5             	mov    %rsp,%rbp
	ko = z_object_find(obj);
  116ff5:	e8 da fa ff ff       	callq  116ad4 <z_object_find>
	if (ko == NULL) {
  116ffa:	48 85 c0             	test   %rax,%rax
  116ffd:	74 04                	je     117003 <z_object_init+0x12>
	ko->flags |= K_OBJ_FLAG_INITIALIZED;
  116fff:	80 48 0d 01          	orb    $0x1,0xd(%rax)
}
  117003:	5d                   	pop    %rbp
  117004:	c3                   	retq   

0000000000117005 <z_object_uninit>:
{
  117005:	55                   	push   %rbp
  117006:	48 89 e5             	mov    %rsp,%rbp
	ko = z_object_find(obj);
  117009:	e8 c6 fa ff ff       	callq  116ad4 <z_object_find>
	if (ko == NULL) {
  11700e:	48 85 c0             	test   %rax,%rax
  117011:	74 04                	je     117017 <z_object_uninit+0x12>
	ko->flags &= ~K_OBJ_FLAG_INITIALIZED;
  117013:	80 60 0d fe          	andb   $0xfe,0xd(%rax)
}
  117017:	5d                   	pop    %rbp
  117018:	c3                   	retq   

0000000000117019 <z_user_from_copy>:
	return user_copy(dst, src, size, false);
  117019:	31 c9                	xor    %ecx,%ecx
  11701b:	e9 a0 f8 ff ff       	jmpq   1168c0 <user_copy>

0000000000117020 <z_user_to_copy>:
	return user_copy(dst, src, size, true);
  117020:	b9 01 00 00 00       	mov    $0x1,%ecx
  117025:	e9 96 f8 ff ff       	jmpq   1168c0 <user_copy>

000000000011702a <z_user_string_copy>:
{
  11702a:	55                   	push   %rbp
  11702b:	48 89 e5             	mov    %rsp,%rbp
  11702e:	41 55                	push   %r13
  117030:	49 89 f5             	mov    %rsi,%r13
  117033:	41 54                	push   %r12
  117035:	49 89 fc             	mov    %rdi,%r12
	return arch_user_string_nlen(src, maxlen, err);
  117038:	4c 89 ef             	mov    %r13,%rdi
  11703b:	53                   	push   %rbx
  11703c:	48 89 d3             	mov    %rdx,%rbx
  11703f:	48 8d 55 dc          	lea    -0x24(%rbp),%rdx
  117043:	48 89 de             	mov    %rbx,%rsi
  117046:	48 83 ec 18          	sub    $0x18,%rsp
  11704a:	e8 f2 90 fe ff       	callq  100141 <arch_user_string_nlen>
	if (err != 0) {
  11704f:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  117053:	48 89 c1             	mov    %rax,%rcx
		ret = EFAULT;
  117056:	b8 0e 00 00 00       	mov    $0xe,%eax
	if (err != 0) {
  11705b:	75 50                	jne    1170ad <z_user_string_copy+0x83>
	if (actual_len == maxlen) {
  11705d:	48 39 d9             	cmp    %rbx,%rcx
  117060:	75 16                	jne    117078 <z_user_string_copy+0x4e>
		LOG_ERR("string too long %p (%zu)", src, actual_len);
  117062:	4c 89 ea             	mov    %r13,%rdx
  117065:	be 45 00 00 00       	mov    $0x45,%esi
  11706a:	bf 61 0d 12 00       	mov    $0x120d61,%edi
  11706f:	31 c0                	xor    %eax,%eax
  117071:	e8 50 c0 fe ff       	callq  1030c6 <z_log_minimal_printk>
		goto out;
  117076:	eb 30                	jmp    1170a8 <z_user_string_copy+0x7e>
  117078:	48 83 c1 01          	add    $0x1,%rcx
  11707c:	48 89 cb             	mov    %rcx,%rbx
  11707f:	72 16                	jb     117097 <z_user_string_copy+0x6d>
	ret = z_user_from_copy(dst, src, actual_len);
  117081:	48 89 ca             	mov    %rcx,%rdx
  117084:	4c 89 ee             	mov    %r13,%rsi
  117087:	4c 89 e7             	mov    %r12,%rdi
  11708a:	e8 8a ff ff ff       	callq  117019 <z_user_from_copy>
	dst[actual_len - 1] = '\0';
  11708f:	41 c6 44 1c ff 00    	movb   $0x0,-0x1(%r12,%rbx,1)
  117095:	eb 16                	jmp    1170ad <z_user_string_copy+0x83>
		LOG_ERR("overflow");
  117097:	be 45 00 00 00       	mov    $0x45,%esi
  11709c:	bf 7f 0d 12 00       	mov    $0x120d7f,%edi
  1170a1:	31 c0                	xor    %eax,%eax
  1170a3:	e8 1e c0 fe ff       	callq  1030c6 <z_log_minimal_printk>
		ret = EINVAL;
  1170a8:	b8 16 00 00 00       	mov    $0x16,%eax
}
  1170ad:	48 83 c4 18          	add    $0x18,%rsp
  1170b1:	5b                   	pop    %rbx
  1170b2:	41 5c                	pop    %r12
  1170b4:	41 5d                	pop    %r13
  1170b6:	5d                   	pop    %rbp
  1170b7:	c3                   	retq   

00000000001170b8 <boot_banner>:
		k_busy_wait(CONFIG_BOOT_DELAY * USEC_PER_MSEC);
	}

#if defined(CONFIG_BOOT_BANNER)
#ifdef BUILD_VERSION
	printk("*** Booting Zephyr OS build %s %s ***\n",
  1170b8:	ba 24 fc 11 00       	mov    $0x11fc24,%edx
  1170bd:	be e3 0f 12 00       	mov    $0x120fe3,%esi
  1170c2:	bf 03 10 12 00       	mov    $0x121003,%edi
  1170c7:	31 c0                	xor    %eax,%eax
  1170c9:	e9 2a 95 fe ff       	jmpq   1005f8 <printk>

00000000001170ce <k_heap_init>:
  1170ce:	48 8d 47 18          	lea    0x18(%rdi),%rax
	list->head = (sys_dnode_t *)list;
  1170d2:	48 89 47 18          	mov    %rax,0x18(%rdi)
	list->tail = (sys_dnode_t *)list;
  1170d6:	48 89 47 20          	mov    %rax,0x20(%rdi)
#include <linker/linker-defs.h>

void k_heap_init(struct k_heap *h, void *mem, size_t bytes)
{
	z_waitq_init(&h->wait_q);
	sys_heap_init(&h->heap, mem, bytes);
  1170da:	e9 18 a5 fe ff       	jmpq   1015f7 <sys_heap_init>

00000000001170df <statics_init>:

	SYS_PORT_TRACING_OBJ_INIT(k_heap, h);
}

static int statics_init(const struct device *unused)
{
  1170df:	55                   	push   %rbp
  1170e0:	48 89 e5             	mov    %rsp,%rbp
  1170e3:	53                   	push   %rbx
	ARG_UNUSED(unused);
	STRUCT_SECTION_FOREACH(k_heap, h) {
  1170e4:	bb 70 14 5e 00       	mov    $0x5e1470,%ebx
{
  1170e9:	51                   	push   %rcx
	STRUCT_SECTION_FOREACH(k_heap, h) {
  1170ea:	48 81 fb d0 14 5e 00 	cmp    $0x5e14d0,%rbx
  1170f1:	76 36                	jbe    117129 <statics_init+0x4a>
  1170f3:	be 4c 10 12 00       	mov    $0x12104c,%esi
  1170f8:	b9 18 00 00 00       	mov    $0x18,%ecx
  1170fd:	ba 2a 10 12 00       	mov    $0x12102a,%edx
  117102:	31 c0                	xor    %eax,%eax
  117104:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  117109:	e8 ea 94 fe ff       	callq  1005f8 <printk>
  11710e:	bf b6 f6 11 00       	mov    $0x11f6b6,%edi
  117113:	31 c0                	xor    %eax,%eax
  117115:	e8 de 94 fe ff       	callq  1005f8 <printk>
  11711a:	be 18 00 00 00       	mov    $0x18,%esi
  11711f:	bf 2a 10 12 00       	mov    $0x12102a,%edi
  117124:	e8 6f ba fe ff       	callq  102b98 <assert_post_action>
  117129:	48 81 fb d0 14 5e 00 	cmp    $0x5e14d0,%rbx
  117130:	73 16                	jae    117148 <statics_init+0x69>
		}

		if (do_clear)
#endif /* CONFIG_DEMAND_PAGING && !CONFIG_LINKER_GENERIC_SECTIONS_PRESENT_AT_BOOT */
		{
			k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
  117132:	48 8b 53 10          	mov    0x10(%rbx),%rdx
  117136:	48 8b 73 08          	mov    0x8(%rbx),%rsi
  11713a:	48 89 df             	mov    %rbx,%rdi
	STRUCT_SECTION_FOREACH(k_heap, h) {
  11713d:	48 83 c3 30          	add    $0x30,%rbx
			k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
  117141:	e8 88 ff ff ff       	callq  1170ce <k_heap_init>
	STRUCT_SECTION_FOREACH(k_heap, h) {
  117146:	eb a2                	jmp    1170ea <statics_init+0xb>
		}
	}
	return 0;
}
  117148:	5a                   	pop    %rdx
  117149:	31 c0                	xor    %eax,%eax
  11714b:	5b                   	pop    %rbx
  11714c:	5d                   	pop    %rbp
  11714d:	c3                   	retq   

000000000011714e <k_heap_aligned_alloc>:
SYS_INIT(statics_init, POST_KERNEL, 0);
#endif /* CONFIG_DEMAND_PAGING && !CONFIG_LINKER_GENERIC_SECTIONS_PRESENT_AT_BOOT */

void *k_heap_aligned_alloc(struct k_heap *h, size_t align, size_t bytes,
			k_timeout_t timeout)
{
  11714e:	55                   	push   %rbp
  11714f:	48 89 e5             	mov    %rsp,%rbp
  117152:	41 57                	push   %r15
  117154:	41 56                	push   %r14
  117156:	49 89 ce             	mov    %rcx,%r14
  117159:	41 55                	push   %r13
  11715b:	41 54                	push   %r12
  11715d:	53                   	push   %rbx
  11715e:	48 89 fb             	mov    %rdi,%rbx
	int64_t now, end = sys_clock_timeout_end_calc(timeout);
  117161:	48 89 cf             	mov    %rcx,%rdi
	void *ret = NULL;
	k_spinlock_key_t key = k_spin_lock(&h->lock);
  117164:	4c 8d 63 28          	lea    0x28(%rbx),%r12
{
  117168:	48 83 ec 28          	sub    $0x28,%rsp
  11716c:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  117170:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
	int64_t now, end = sys_clock_timeout_end_calc(timeout);
  117174:	e8 00 c5 ff ff       	callq  113679 <sys_clock_timeout_end_calc>
  117179:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  11717d:	9c                   	pushfq 
  11717e:	fa                   	cli    
  11717f:	41 5d                	pop    %r13
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  117181:	4c 89 e7             	mov    %r12,%rdi
  117184:	e8 f0 66 ff ff       	callq  10d879 <z_spin_lock_valid>
  117189:	84 c0                	test   %al,%al
  11718b:	75 37                	jne    1171c4 <k_heap_aligned_alloc+0x76>
  11718d:	b9 8e 00 00 00       	mov    $0x8e,%ecx
  117192:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  117197:	be fd d1 11 00       	mov    $0x11d1fd,%esi
  11719c:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  1171a1:	e8 52 94 fe ff       	callq  1005f8 <printk>
  1171a6:	4c 89 e6             	mov    %r12,%rsi
  1171a9:	bf 12 d2 11 00       	mov    $0x11d212,%edi
  1171ae:	31 c0                	xor    %eax,%eax
  1171b0:	e8 43 94 fe ff       	callq  1005f8 <printk>
  1171b5:	be 8e 00 00 00       	mov    $0x8e,%esi
  1171ba:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  1171bf:	e8 d4 b9 fe ff       	callq  102b98 <assert_post_action>
	z_spin_lock_set_owner(l);
  1171c4:	4c 89 e7             	mov    %r12,%rdi
  1171c7:	e8 f1 66 ff ff       	callq  10d8bd <z_spin_lock_set_owner>

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_heap, aligned_alloc, h, timeout);

	__ASSERT(!arch_is_in_isr() || K_TIMEOUT_EQ(timeout, K_NO_WAIT), "");
  1171cc:	83 3d 6d 15 01 00 00 	cmpl   $0x0,0x1156d(%rip)        # 128740 <_kernel>
  1171d3:	74 3b                	je     117210 <k_heap_aligned_alloc+0xc2>
  1171d5:	4d 85 f6             	test   %r14,%r14
  1171d8:	74 36                	je     117210 <k_heap_aligned_alloc+0xc2>
  1171da:	be dd fb 11 00       	mov    $0x11fbdd,%esi
  1171df:	b9 49 00 00 00       	mov    $0x49,%ecx
  1171e4:	ba 2a 10 12 00       	mov    $0x12102a,%edx
  1171e9:	31 c0                	xor    %eax,%eax
  1171eb:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  1171f0:	e8 03 94 fe ff       	callq  1005f8 <printk>
  1171f5:	bf 22 fc 11 00       	mov    $0x11fc22,%edi
  1171fa:	31 c0                	xor    %eax,%eax
  1171fc:	e8 f7 93 fe ff       	callq  1005f8 <printk>
  117201:	be 49 00 00 00       	mov    $0x49,%esi
  117206:	bf 2a 10 12 00       	mov    $0x12102a,%edi
  11720b:	e8 88 b9 fe ff       	callq  102b98 <assert_post_action>
			/**
			 * @todo	Trace attempt to avoid empty trace segments
			 */
		}

		(void) z_pend_curr(&h->lock, key, &h->wait_q,
  117210:	4c 8d 7b 18          	lea    0x18(%rbx),%r15
		ret = sys_heap_aligned_alloc(&h->heap, align, bytes);
  117214:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  117218:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  11721c:	48 89 df             	mov    %rbx,%rdi
  11721f:	e8 57 a2 fe ff       	callq  10147b <sys_heap_aligned_alloc>
  117224:	49 89 c6             	mov    %rax,%r14
		now = sys_clock_tick_get();
  117227:	e8 e0 c2 ff ff       	callq  11350c <sys_clock_tick_get>
		if (!IS_ENABLED(CONFIG_MULTITHREADING) ||
  11722c:	4d 85 f6             	test   %r14,%r14
  11722f:	75 6e                	jne    11729f <k_heap_aligned_alloc+0x151>
		    (ret != NULL) || ((end - now) <= 0)) {
  117231:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  117235:	48 29 c1             	sub    %rax,%rcx
  117238:	48 85 c9             	test   %rcx,%rcx
  11723b:	7e 62                	jle    11729f <k_heap_aligned_alloc+0x151>
		(void) z_pend_curr(&h->lock, key, &h->wait_q,
  11723d:	4c 89 fa             	mov    %r15,%rdx
  117240:	44 89 ee             	mov    %r13d,%esi
  117243:	4c 89 e7             	mov    %r12,%rdi
  117246:	e8 9d a7 ff ff       	callq  1119e8 <z_pend_curr>
  11724b:	9c                   	pushfq 
  11724c:	fa                   	cli    
  11724d:	41 5d                	pop    %r13
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  11724f:	4c 89 e7             	mov    %r12,%rdi
  117252:	e8 22 66 ff ff       	callq  10d879 <z_spin_lock_valid>
  117257:	84 c0                	test   %al,%al
  117259:	75 37                	jne    117292 <k_heap_aligned_alloc+0x144>
  11725b:	b9 8e 00 00 00       	mov    $0x8e,%ecx
  117260:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  117265:	be fd d1 11 00       	mov    $0x11d1fd,%esi
  11726a:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  11726f:	e8 84 93 fe ff       	callq  1005f8 <printk>
  117274:	4c 89 e6             	mov    %r12,%rsi
  117277:	bf 12 d2 11 00       	mov    $0x11d212,%edi
  11727c:	31 c0                	xor    %eax,%eax
  11727e:	e8 75 93 fe ff       	callq  1005f8 <printk>
  117283:	be 8e 00 00 00       	mov    $0x8e,%esi
  117288:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  11728d:	e8 06 b9 fe ff       	callq  102b98 <assert_post_action>
	z_spin_lock_set_owner(l);
  117292:	4c 89 e7             	mov    %r12,%rdi
  117295:	e8 23 66 ff ff       	callq  10d8bd <z_spin_lock_set_owner>
	return k;
  11729a:	e9 75 ff ff ff       	jmpq   117214 <k_heap_aligned_alloc+0xc6>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  11729f:	4c 89 e7             	mov    %r12,%rdi
  1172a2:	e8 f2 65 ff ff       	callq  10d899 <z_spin_unlock_valid>
  1172a7:	84 c0                	test   %al,%al
  1172a9:	75 39                	jne    1172e4 <k_heap_aligned_alloc+0x196>
  1172ab:	b9 b9 00 00 00       	mov    $0xb9,%ecx
  1172b0:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  1172b5:	be 41 d2 11 00       	mov    $0x11d241,%esi
  1172ba:	31 c0                	xor    %eax,%eax
  1172bc:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  1172c1:	e8 32 93 fe ff       	callq  1005f8 <printk>
  1172c6:	4c 89 e6             	mov    %r12,%rsi
  1172c9:	bf 58 d2 11 00       	mov    $0x11d258,%edi
  1172ce:	31 c0                	xor    %eax,%eax
  1172d0:	e8 23 93 fe ff       	callq  1005f8 <printk>
  1172d5:	be b9 00 00 00       	mov    $0xb9,%esi
  1172da:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  1172df:	e8 b4 b8 fe ff       	callq  102b98 <assert_post_action>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  1172e4:	41 0f ba e5 09       	bt     $0x9,%r13d
  1172e9:	73 01                	jae    1172ec <k_heap_aligned_alloc+0x19e>
		__asm__ volatile ("sti" ::: "memory");
  1172eb:	fb                   	sti    

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_heap, aligned_alloc, h, timeout, ret);

	k_spin_unlock(&h->lock, key);
	return ret;
}
  1172ec:	48 83 c4 28          	add    $0x28,%rsp
  1172f0:	4c 89 f0             	mov    %r14,%rax
  1172f3:	5b                   	pop    %rbx
  1172f4:	41 5c                	pop    %r12
  1172f6:	41 5d                	pop    %r13
  1172f8:	41 5e                	pop    %r14
  1172fa:	41 5f                	pop    %r15
  1172fc:	5d                   	pop    %rbp
  1172fd:	c3                   	retq   

00000000001172fe <k_heap_free>:

	return ret;
}

void k_heap_free(struct k_heap *h, void *mem)
{
  1172fe:	55                   	push   %rbp
  1172ff:	48 89 e5             	mov    %rsp,%rbp
  117302:	41 56                	push   %r14
  117304:	41 55                	push   %r13
  117306:	49 89 f5             	mov    %rsi,%r13
  117309:	41 54                	push   %r12
	k_spinlock_key_t key = k_spin_lock(&h->lock);
  11730b:	4c 8d 67 28          	lea    0x28(%rdi),%r12
{
  11730f:	53                   	push   %rbx
  117310:	48 89 fb             	mov    %rdi,%rbx
  117313:	9c                   	pushfq 
  117314:	fa                   	cli    
  117315:	41 5e                	pop    %r14
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  117317:	4c 89 e7             	mov    %r12,%rdi
  11731a:	e8 5a 65 ff ff       	callq  10d879 <z_spin_lock_valid>
  11731f:	84 c0                	test   %al,%al
  117321:	75 37                	jne    11735a <k_heap_free+0x5c>
  117323:	b9 8e 00 00 00       	mov    $0x8e,%ecx
  117328:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  11732d:	be fd d1 11 00       	mov    $0x11d1fd,%esi
  117332:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  117337:	e8 bc 92 fe ff       	callq  1005f8 <printk>
  11733c:	4c 89 e6             	mov    %r12,%rsi
  11733f:	bf 12 d2 11 00       	mov    $0x11d212,%edi
  117344:	31 c0                	xor    %eax,%eax
  117346:	e8 ad 92 fe ff       	callq  1005f8 <printk>
  11734b:	be 8e 00 00 00       	mov    $0x8e,%esi
  117350:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  117355:	e8 3e b8 fe ff       	callq  102b98 <assert_post_action>
	z_spin_lock_set_owner(l);
  11735a:	4c 89 e7             	mov    %r12,%rdi
  11735d:	e8 5b 65 ff ff       	callq  10d8bd <z_spin_lock_set_owner>

	sys_heap_free(&h->heap, mem);
  117362:	48 89 df             	mov    %rbx,%rdi
  117365:	4c 89 ee             	mov    %r13,%rsi
  117368:	e8 c0 9f fe ff       	callq  10132d <sys_heap_free>

	SYS_PORT_TRACING_OBJ_FUNC(k_heap, free, h);
	if (IS_ENABLED(CONFIG_MULTITHREADING) && z_unpend_all(&h->wait_q) != 0) {
  11736d:	48 8d 7b 18          	lea    0x18(%rbx),%rdi
  117371:	e8 bd ac ff ff       	callq  112033 <z_unpend_all>
  117376:	85 c0                	test   %eax,%eax
  117378:	74 13                	je     11738d <k_heap_free+0x8f>
		z_reschedule(&h->lock, key);
	} else {
		k_spin_unlock(&h->lock, key);
	}
}
  11737a:	5b                   	pop    %rbx
		z_reschedule(&h->lock, key);
  11737b:	44 89 f6             	mov    %r14d,%esi
  11737e:	4c 89 e7             	mov    %r12,%rdi
}
  117381:	41 5c                	pop    %r12
  117383:	41 5d                	pop    %r13
  117385:	41 5e                	pop    %r14
  117387:	5d                   	pop    %rbp
		z_reschedule(&h->lock, key);
  117388:	e9 d4 99 ff ff       	jmpq   110d61 <z_reschedule>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  11738d:	4c 89 e7             	mov    %r12,%rdi
  117390:	e8 04 65 ff ff       	callq  10d899 <z_spin_unlock_valid>
  117395:	84 c0                	test   %al,%al
  117397:	75 37                	jne    1173d0 <k_heap_free+0xd2>
  117399:	b9 b9 00 00 00       	mov    $0xb9,%ecx
  11739e:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  1173a3:	be 41 d2 11 00       	mov    $0x11d241,%esi
  1173a8:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  1173ad:	e8 46 92 fe ff       	callq  1005f8 <printk>
  1173b2:	4c 89 e6             	mov    %r12,%rsi
  1173b5:	bf 58 d2 11 00       	mov    $0x11d258,%edi
  1173ba:	31 c0                	xor    %eax,%eax
  1173bc:	e8 37 92 fe ff       	callq  1005f8 <printk>
  1173c1:	be b9 00 00 00       	mov    $0xb9,%esi
  1173c6:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  1173cb:	e8 c8 b7 fe ff       	callq  102b98 <assert_post_action>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  1173d0:	41 0f ba e6 09       	bt     $0x9,%r14d
  1173d5:	73 01                	jae    1173d8 <k_heap_free+0xda>
		__asm__ volatile ("sti" ::: "memory");
  1173d7:	fb                   	sti    
}
  1173d8:	5b                   	pop    %rbx
  1173d9:	41 5c                	pop    %r12
  1173db:	41 5d                	pop    %r13
  1173dd:	41 5e                	pop    %r14
  1173df:	5d                   	pop    %rbp
  1173e0:	c3                   	retq   

00000000001173e1 <sys_dlist_get>:
	return list->head == list;
  1173e1:	48 8b 07             	mov    (%rdi),%rax
	if (!sys_dlist_is_empty(list)) {
  1173e4:	48 39 f8             	cmp    %rdi,%rax
  1173e7:	74 1e                	je     117407 <sys_dlist_get+0x26>
	sys_dnode_t *const prev = node->prev;
  1173e9:	48 8b 48 08          	mov    0x8(%rax),%rcx
	sys_dnode_t *const next = node->next;
  1173ed:	48 8b 10             	mov    (%rax),%rdx
	prev->next = next;
  1173f0:	48 89 11             	mov    %rdx,(%rcx)
	next->prev = prev;
  1173f3:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
	node->next = NULL;
  1173f7:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	node->prev = NULL;
  1173fe:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  117405:	00 
}
  117406:	c3                   	retq   
	sys_dnode_t *node = NULL;
  117407:	31 c0                	xor    %eax,%eax
		node = list->head;
		sys_dlist_remove(node);
	}

	return node;
}
  117409:	c3                   	retq   

000000000011740a <pipe_xfer>:
 * @return Number of bytes copied
 */
static size_t pipe_xfer(unsigned char *dest, size_t dest_size,
			 const unsigned char *src, size_t src_size)
{
	size_t num_bytes = MIN(dest_size, src_size);
  11740a:	48 39 f1             	cmp    %rsi,%rcx
  11740d:	48 89 f0             	mov    %rsi,%rax
{
  117410:	49 89 d0             	mov    %rdx,%r8
	size_t num_bytes = MIN(dest_size, src_size);
  117413:	48 0f 46 c1          	cmovbe %rcx,%rax
	const unsigned char *end = src + num_bytes;

	while (src != end) {
  117417:	31 d2                	xor    %edx,%edx
  117419:	48 39 d0             	cmp    %rdx,%rax
  11741c:	74 0c                	je     11742a <pipe_xfer+0x20>
		*dest = *src;
  11741e:	41 8a 0c 10          	mov    (%r8,%rdx,1),%cl
  117422:	88 0c 17             	mov    %cl,(%rdi,%rdx,1)
		dest++;
		src++;
  117425:	48 ff c2             	inc    %rdx
  117428:	eb ef                	jmp    117419 <pipe_xfer+0xf>
	}

	return num_bytes;
}
  11742a:	c3                   	retq   

000000000011742b <pipe_buffer_put>:
 *
 * @return Number of bytes written to the pipe's circular buffer
 */
static size_t pipe_buffer_put(struct k_pipe *pipe,
			       const unsigned char *src, size_t src_size)
{
  11742b:	55                   	push   %rbp
  11742c:	49 89 f9             	mov    %rdi,%r9
  11742f:	49 89 f3             	mov    %rsi,%r11
	size_t  bytes_copied;
	size_t  run_length;
	size_t  num_bytes_written = 0;
  117432:	45 31 d2             	xor    %r10d,%r10d
{
  117435:	48 89 e5             	mov    %rsp,%rbp
  117438:	41 54                	push   %r12
  11743a:	41 bc 02 00 00 00    	mov    $0x2,%r12d
  117440:	53                   	push   %rbx
  117441:	48 89 d3             	mov    %rdx,%rbx
	int     i;


	for (i = 0; i < 2; i++) {
		run_length = MIN(pipe->size - pipe->bytes_used,
  117444:	49 8b 71 08          	mov    0x8(%r9),%rsi
  117448:	49 8b 79 20          	mov    0x20(%r9),%rdi
				 pipe->size - pipe->write_index);

		bytes_copied = pipe_xfer(pipe->buffer + pipe->write_index,
  11744c:	48 89 d9             	mov    %rbx,%rcx
  11744f:	4b 8d 14 13          	lea    (%r11,%r10,1),%rdx
  117453:	4c 29 d1             	sub    %r10,%rcx
		run_length = MIN(pipe->size - pipe->bytes_used,
  117456:	48 89 f0             	mov    %rsi,%rax
  117459:	48 29 fe             	sub    %rdi,%rsi
  11745c:	49 2b 41 10          	sub    0x10(%r9),%rax
  117460:	48 39 f0             	cmp    %rsi,%rax
  117463:	48 0f 46 f0          	cmovbe %rax,%rsi
		bytes_copied = pipe_xfer(pipe->buffer + pipe->write_index,
  117467:	49 03 39             	add    (%r9),%rdi
  11746a:	e8 9b ff ff ff       	callq  11740a <pipe_xfer>
					  run_length,
					  src + num_bytes_written,
					  src_size - num_bytes_written);

		num_bytes_written += bytes_copied;
		pipe->bytes_used += bytes_copied;
  11746f:	49 01 41 10          	add    %rax,0x10(%r9)
		num_bytes_written += bytes_copied;
  117473:	49 01 c2             	add    %rax,%r10
		pipe->write_index += bytes_copied;
  117476:	49 03 41 20          	add    0x20(%r9),%rax
  11747a:	49 89 41 20          	mov    %rax,0x20(%r9)
		if (pipe->write_index == pipe->size) {
  11747e:	49 3b 41 08          	cmp    0x8(%r9),%rax
  117482:	75 08                	jne    11748c <pipe_buffer_put+0x61>
			pipe->write_index = 0;
  117484:	49 c7 41 20 00 00 00 	movq   $0x0,0x20(%r9)
  11748b:	00 
	for (i = 0; i < 2; i++) {
  11748c:	41 ff cc             	dec    %r12d
  11748f:	74 08                	je     117499 <pipe_buffer_put+0x6e>
  117491:	41 bc 01 00 00 00    	mov    $0x1,%r12d
  117497:	eb ab                	jmp    117444 <pipe_buffer_put+0x19>
		}
	}

	return num_bytes_written;
}
  117499:	5b                   	pop    %rbx
  11749a:	4c 89 d0             	mov    %r10,%rax
  11749d:	41 5c                	pop    %r12
  11749f:	5d                   	pop    %rbp
  1174a0:	c3                   	retq   

00000000001174a1 <pipe_xfer_prepare>:
			       _wait_q_t        *wait_q,
			       size_t            pipe_space,
			       size_t            bytes_to_xfer,
			       size_t            min_xfer,
			       k_timeout_t           timeout)
{
  1174a1:	55                   	push   %rbp
  1174a2:	48 89 e5             	mov    %rsp,%rbp
  1174a5:	41 57                	push   %r15
  1174a7:	49 89 f7             	mov    %rsi,%r15
  1174aa:	41 56                	push   %r14
  1174ac:	4d 89 c6             	mov    %r8,%r14
  1174af:	41 55                	push   %r13
  1174b1:	49 89 d5             	mov    %rdx,%r13
  1174b4:	41 54                	push   %r12
  1174b6:	49 89 fc             	mov    %rdi,%r12
  1174b9:	53                   	push   %rbx
  1174ba:	48 83 ec 18          	sub    $0x18,%rsp
	struct k_thread  *thread;
	struct k_pipe_desc *desc;
	size_t num_bytes = 0;

	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
  1174be:	48 83 7d 10 00       	cmpq   $0x0,0x10(%rbp)
  1174c3:	75 38                	jne    1174fd <pipe_xfer_prepare+0x5c>
	return list->head == list;
  1174c5:	49 8b 45 00          	mov    0x0(%r13),%rax
  1174c9:	48 89 ca             	mov    %rcx,%rdx
  1174cc:	31 c9                	xor    %ecx,%ecx
		_WAIT_Q_FOR_EACH(wait_q, thread) {
  1174ce:	48 85 c0             	test   %rax,%rax
  1174d1:	74 20                	je     1174f3 <pipe_xfer_prepare+0x52>
  1174d3:	4c 39 e8             	cmp    %r13,%rax
  1174d6:	74 1b                	je     1174f3 <pipe_xfer_prepare+0x52>
			desc = (struct k_pipe_desc *)thread->base.swap_data;

			num_bytes += desc->bytes_to_xfer;
  1174d8:	48 8b 70 20          	mov    0x20(%rax),%rsi
  1174dc:	48 03 4e 08          	add    0x8(%rsi),%rcx

			if (num_bytes >= bytes_to_xfer) {
  1174e0:	4c 39 f1             	cmp    %r14,%rcx
  1174e3:	73 0e                	jae    1174f3 <pipe_xfer_prepare+0x52>
	return (node == list->tail) ? NULL : node->next;
  1174e5:	49 3b 45 08          	cmp    0x8(%r13),%rax
  1174e9:	74 08                	je     1174f3 <pipe_xfer_prepare+0x52>
  1174eb:	48 8b 00             	mov    (%rax),%rax
		_WAIT_Q_FOR_EACH(wait_q, thread) {
  1174ee:	48 85 c0             	test   %rax,%rax
  1174f1:	eb e3                	jmp    1174d6 <pipe_xfer_prepare+0x35>
				break;
			}
		}

		if (num_bytes + pipe_space < min_xfer) {
  1174f3:	48 01 d1             	add    %rdx,%rcx
			return false;
  1174f6:	31 c0                	xor    %eax,%eax
		if (num_bytes + pipe_space < min_xfer) {
  1174f8:	4c 39 c9             	cmp    %r9,%rcx
  1174fb:	72 53                	jb     117550 <pipe_xfer_prepare+0xaf>
	list->head = (sys_dnode_t *)list;
  1174fd:	4d 89 24 24          	mov    %r12,(%r12)
	 * Either @a timeout is not K_NO_WAIT (so the thread may pend) or
	 * the entire request can be satisfied. Generate the working list.
	 */

	sys_dlist_init(xfer_list);
	num_bytes = 0;
  117501:	31 c0                	xor    %eax,%eax
	list->tail = (sys_dnode_t *)list;
  117503:	4d 89 64 24 08       	mov    %r12,0x8(%r12)
	return list->head == list;
  117508:	49 8b 5d 00          	mov    0x0(%r13),%rbx

	while ((thread = z_waitq_head(wait_q)) != NULL) {
  11750c:	48 85 db             	test   %rbx,%rbx
  11750f:	74 38                	je     117549 <pipe_xfer_prepare+0xa8>
  117511:	4c 39 eb             	cmp    %r13,%rbx
  117514:	74 33                	je     117549 <pipe_xfer_prepare+0xa8>
		desc = (struct k_pipe_desc *)thread->base.swap_data;
		num_bytes += desc->bytes_to_xfer;
  117516:	48 8b 53 20          	mov    0x20(%rbx),%rdx
  11751a:	48 03 42 08          	add    0x8(%rdx),%rax

		if (num_bytes > bytes_to_xfer) {
  11751e:	49 39 c6             	cmp    %rax,%r14
  117521:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  117525:	72 24                	jb     11754b <pipe_xfer_prepare+0xaa>
		 * This request can be fully satisfied.
		 * Remove it from the wait_q.
		 * Abort its timeout.
		 * Add it to the transfer list.
		 */
		z_unpend_thread(thread);
  117527:	48 89 df             	mov    %rbx,%rdi
  11752a:	e8 fb 9a ff ff       	callq  11102a <z_unpend_thread>
	sys_dnode_t *const tail = list->tail;
  11752f:	49 8b 54 24 08       	mov    0x8(%r12),%rdx
	list->tail = node;
  117534:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
	node->next = list;
  117538:	4c 89 23             	mov    %r12,(%rbx)
	node->prev = tail;
  11753b:	48 89 53 08          	mov    %rdx,0x8(%rbx)
	tail->next = node;
  11753f:	48 89 1a             	mov    %rbx,(%rdx)
	list->tail = node;
  117542:	49 89 5c 24 08       	mov    %rbx,0x8(%r12)
}
  117547:	eb bf                	jmp    117508 <pipe_xfer_prepare+0x67>
  117549:	31 db                	xor    %ebx,%ebx
		sys_dlist_append(xfer_list, &thread->base.qnode_dlist);
	}

	*waiter = (num_bytes > bytes_to_xfer) ? thread : NULL;
  11754b:	49 89 1f             	mov    %rbx,(%r15)

	return true;
  11754e:	b0 01                	mov    $0x1,%al
}
  117550:	48 83 c4 18          	add    $0x18,%rsp
  117554:	5b                   	pop    %rbx
  117555:	41 5c                	pop    %r12
  117557:	41 5d                	pop    %r13
  117559:	41 5e                	pop    %r14
  11755b:	41 5f                	pop    %r15
  11755d:	5d                   	pop    %rbp
  11755e:	c3                   	retq   

000000000011755f <z_sched_lock>:
{
  11755f:	55                   	push   %rbp
	__ASSERT(!arch_is_in_isr(), "");
  117560:	83 3d d9 11 01 00 00 	cmpl   $0x0,0x111d9(%rip)        # 128740 <_kernel>
{
  117567:	48 89 e5             	mov    %rsp,%rbp
	__ASSERT(!arch_is_in_isr(), "");
  11756a:	74 36                	je     1175a2 <z_sched_lock+0x43>
  11756c:	be 49 f9 11 00       	mov    $0x11f949,%esi
  117571:	b9 fd 00 00 00       	mov    $0xfd,%ecx
  117576:	ba 83 fc 11 00       	mov    $0x11fc83,%edx
  11757b:	31 c0                	xor    %eax,%eax
  11757d:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  117582:	e8 71 90 fe ff       	callq  1005f8 <printk>
  117587:	bf 22 fc 11 00       	mov    $0x11fc22,%edi
  11758c:	31 c0                	xor    %eax,%eax
  11758e:	e8 65 90 fe ff       	callq  1005f8 <printk>
  117593:	be fd 00 00 00       	mov    $0xfd,%esi
  117598:	bf 83 fc 11 00       	mov    $0x11fc83,%edi
  11759d:	e8 f6 b5 fe ff       	callq  102b98 <assert_post_action>
	__ASSERT(_current->base.sched_locked != 1U, "");
  1175a2:	48 8b 05 a7 11 01 00 	mov    0x111a7(%rip),%rax        # 128750 <_kernel+0x10>
  1175a9:	80 78 1b 01          	cmpb   $0x1,0x1b(%rax)
  1175ad:	75 36                	jne    1175e5 <z_sched_lock+0x86>
  1175af:	be ae fc 11 00       	mov    $0x11fcae,%esi
  1175b4:	b9 fe 00 00 00       	mov    $0xfe,%ecx
  1175b9:	ba 83 fc 11 00       	mov    $0x11fc83,%edx
  1175be:	31 c0                	xor    %eax,%eax
  1175c0:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  1175c5:	e8 2e 90 fe ff       	callq  1005f8 <printk>
  1175ca:	bf 22 fc 11 00       	mov    $0x11fc22,%edi
  1175cf:	31 c0                	xor    %eax,%eax
  1175d1:	e8 22 90 fe ff       	callq  1005f8 <printk>
  1175d6:	be fe 00 00 00       	mov    $0xfe,%esi
  1175db:	bf 83 fc 11 00       	mov    $0x11fc83,%edi
  1175e0:	e8 b3 b5 fe ff       	callq  102b98 <assert_post_action>
	--_current->base.sched_locked;
  1175e5:	48 8b 05 64 11 01 00 	mov    0x11164(%rip),%rax        # 128750 <_kernel+0x10>
  1175ec:	fe 48 1b             	decb   0x1b(%rax)

	compiler_barrier();
}
  1175ef:	5d                   	pop    %rbp
  1175f0:	c3                   	retq   

00000000001175f1 <z_obj_validation_check.constprop.0>:
static inline int z_obj_validation_check(struct z_object *ko,
  1175f1:	55                   	push   %rbp
  1175f2:	48 89 e5             	mov    %rsp,%rbp
  1175f5:	41 56                	push   %r14
  1175f7:	49 89 f6             	mov    %rsi,%r14
	ret = z_object_validate(ko, otype, init);
  1175fa:	be 04 00 00 00       	mov    $0x4,%esi
static inline int z_obj_validation_check(struct z_object *ko,
  1175ff:	41 55                	push   %r13
  117601:	49 89 fd             	mov    %rdi,%r13
  117604:	48 83 ec 10          	sub    $0x10,%rsp
	ret = z_object_validate(ko, otype, init);
  117608:	e8 5f f9 ff ff       	callq  116f6c <z_object_validate>
	if (ret != 0) {
  11760d:	85 c0                	test   %eax,%eax
  11760f:	74 18                	je     117629 <z_obj_validation_check.constprop.0+0x38>
		z_dump_object_error(ret, obj, ko, otype);
  117611:	89 c7                	mov    %eax,%edi
  117613:	b9 04 00 00 00       	mov    $0x4,%ecx
  117618:	4c 89 ea             	mov    %r13,%rdx
  11761b:	4c 89 f6             	mov    %r14,%rsi
  11761e:	89 45 ec             	mov    %eax,-0x14(%rbp)
  117621:	e8 fb f7 ff ff       	callq  116e21 <z_dump_object_error>
  117626:	8b 45 ec             	mov    -0x14(%rbp),%eax
}
  117629:	5a                   	pop    %rdx
  11762a:	59                   	pop    %rcx
  11762b:	41 5d                	pop    %r13
  11762d:	41 5e                	pop    %r14
  11762f:	5d                   	pop    %rbp
  117630:	c3                   	retq   

0000000000117631 <init_pipes_module>:
{
  117631:	55                   	push   %rbp
  117632:	48 89 e5             	mov    %rsp,%rbp
  117635:	53                   	push   %rbx
  117636:	bb 40 50 5d 00       	mov    $0x5d5040,%ebx
  11763b:	51                   	push   %rcx
		async_msg[i].thread.swap_data = &async_msg[i].desc;
  11763c:	48 8d 43 48          	lea    0x48(%rbx),%rax
		async_msg[i].thread.thread_state = _THREAD_DUMMY;
  117640:	c6 43 19 01          	movb   $0x1,0x19(%rbx)
		async_msg[i].thread.swap_data = &async_msg[i].desc;
  117644:	48 89 43 20          	mov    %rax,0x20(%rbx)
	node->next = NULL;
  117648:	48 c7 43 28 00 00 00 	movq   $0x0,0x28(%rbx)
  11764f:	00 
	node->prev = NULL;
  117650:	48 c7 43 30 00 00 00 	movq   $0x0,0x30(%rbx)
  117657:	00 
	return z_impl_k_stack_push(stack, data);
  117658:	bf d0 14 5e 00       	mov    $0x5e14d0,%edi
  11765d:	48 89 de             	mov    %rbx,%rsi
	for (int i = 0; i < CONFIG_NUM_PIPE_ASYNC_MSGS; i++) {
  117660:	48 83 c3 78          	add    $0x78,%rbx
  117664:	e8 71 10 00 00       	callq  1186da <z_impl_k_stack_push>
  117669:	48 81 fb f0 54 5d 00 	cmp    $0x5d54f0,%rbx
  117670:	75 ca                	jne    11763c <init_pipes_module+0xb>
}
  117672:	5a                   	pop    %rdx
  117673:	31 c0                	xor    %eax,%eax
  117675:	5b                   	pop    %rbx
  117676:	5d                   	pop    %rbp
  117677:	c3                   	retq   

0000000000117678 <k_pipe_init>:
  117678:	48 8d 47 40          	lea    0x40(%rdi),%rax
	pipe->buffer = buffer;
  11767c:	48 89 37             	mov    %rsi,(%rdi)
	list->head = (sys_dnode_t *)list;
  11767f:	48 89 47 40          	mov    %rax,0x40(%rdi)
	list->tail = (sys_dnode_t *)list;
  117683:	48 89 47 48          	mov    %rax,0x48(%rdi)
  117687:	48 8d 47 30          	lea    0x30(%rdi),%rax
	pipe->size = size;
  11768b:	48 89 57 08          	mov    %rdx,0x8(%rdi)
	pipe->bytes_used = 0;
  11768f:	48 c7 47 10 00 00 00 	movq   $0x0,0x10(%rdi)
  117696:	00 
	pipe->read_index = 0;
  117697:	48 c7 47 18 00 00 00 	movq   $0x0,0x18(%rdi)
  11769e:	00 
	pipe->write_index = 0;
  11769f:	48 c7 47 20 00 00 00 	movq   $0x0,0x20(%rdi)
  1176a6:	00 
	pipe->lock = (struct k_spinlock){};
  1176a7:	48 c7 47 28 00 00 00 	movq   $0x0,0x28(%rdi)
  1176ae:	00 
	list->head = (sys_dnode_t *)list;
  1176af:	48 89 47 30          	mov    %rax,0x30(%rdi)
	list->tail = (sys_dnode_t *)list;
  1176b3:	48 89 47 38          	mov    %rax,0x38(%rdi)
	pipe->flags = 0;
  1176b7:	c6 47 50 00          	movb   $0x0,0x50(%rdi)
	z_object_init(pipe);
  1176bb:	e9 31 f9 ff ff       	jmpq   116ff1 <z_object_init>

00000000001176c0 <z_impl_k_pipe_alloc_init>:
{
  1176c0:	55                   	push   %rbp
  1176c1:	48 89 e5             	mov    %rsp,%rbp
  1176c4:	41 55                	push   %r13
  1176c6:	41 54                	push   %r12
  1176c8:	49 89 fc             	mov    %rdi,%r12
	if (size != 0U) {
  1176cb:	48 85 f6             	test   %rsi,%rsi
  1176ce:	74 2a                	je     1176fa <z_impl_k_pipe_alloc_init+0x3a>
	return z_thread_aligned_alloc(0, size);
  1176d0:	31 ff                	xor    %edi,%edi
  1176d2:	49 89 f5             	mov    %rsi,%r13
  1176d5:	e8 96 e3 ff ff       	callq  115a70 <z_thread_aligned_alloc>
  1176da:	48 89 c6             	mov    %rax,%rsi
			ret = -ENOMEM;
  1176dd:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
		if (buffer != NULL) {
  1176e2:	48 85 f6             	test   %rsi,%rsi
  1176e5:	74 1e                	je     117705 <z_impl_k_pipe_alloc_init+0x45>
			k_pipe_init(pipe, buffer, size);
  1176e7:	4c 89 ea             	mov    %r13,%rdx
  1176ea:	4c 89 e7             	mov    %r12,%rdi
  1176ed:	e8 86 ff ff ff       	callq  117678 <k_pipe_init>
			pipe->flags = K_PIPE_FLAG_ALLOC;
  1176f2:	41 c6 44 24 50 01    	movb   $0x1,0x50(%r12)
			ret = 0;
  1176f8:	eb 09                	jmp    117703 <z_impl_k_pipe_alloc_init+0x43>
		k_pipe_init(pipe, NULL, 0);
  1176fa:	31 d2                	xor    %edx,%edx
  1176fc:	31 f6                	xor    %esi,%esi
  1176fe:	e8 75 ff ff ff       	callq  117678 <k_pipe_init>
		ret = 0;
  117703:	31 c0                	xor    %eax,%eax
}
  117705:	41 5c                	pop    %r12
  117707:	41 5d                	pop    %r13
  117709:	5d                   	pop    %rbp
  11770a:	c3                   	retq   

000000000011770b <z_mrsh_k_pipe_alloc_init>:
#include <syscalls/kernel.h>

extern int z_vrfy_k_pipe_alloc_init(struct k_pipe * pipe, size_t size);
uintptr_t z_mrsh_k_pipe_alloc_init(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
  11770b:	55                   	push   %rbp
	_current->syscall_frame = ssf;
  11770c:	48 8b 05 3d 10 01 00 	mov    0x1103d(%rip),%rax        # 128750 <_kernel+0x10>
{
  117713:	48 89 e5             	mov    %rsp,%rbp
  117716:	41 55                	push   %r13
  117718:	49 89 f5             	mov    %rsi,%r13
	_current->syscall_frame = ssf;
  11771b:	48 8b 55 10          	mov    0x10(%rbp),%rdx
{
  11771f:	41 54                	push   %r12
  117721:	49 89 fc             	mov    %rdi,%r12
	_current->syscall_frame = ssf;
  117724:	48 89 90 40 01 00 00 	mov    %rdx,0x140(%rax)
	Z_OOPS(Z_SYSCALL_OBJ_NEVER_INIT(pipe, K_OBJ_PIPE));
  11772b:	e8 a4 f3 ff ff       	callq  116ad4 <z_object_find>
  117730:	83 ca ff             	or     $0xffffffff,%edx
  117733:	4c 89 e6             	mov    %r12,%rsi
  117736:	48 89 c7             	mov    %rax,%rdi
  117739:	e8 b3 fe ff ff       	callq  1175f1 <z_obj_validation_check.constprop.0>
  11773e:	85 c0                	test   %eax,%eax
  117740:	74 29                	je     11776b <z_mrsh_k_pipe_alloc_init+0x60>
  117742:	bf 23 f3 11 00       	mov    $0x11f323,%edi
  117747:	31 c0                	xor    %eax,%eax
  117749:	ba a0 c7 11 00       	mov    $0x11c7a0,%edx
  11774e:	be 45 00 00 00       	mov    $0x45,%esi
  117753:	e8 6e b9 fe ff       	callq  1030c6 <z_log_minimal_printk>
  117758:	48 8b 05 f1 0f 01 00 	mov    0x10ff1(%rip),%rax        # 128750 <_kernel+0x10>
  11775f:	48 8b b8 40 01 00 00 	mov    0x140(%rax),%rdi
  117766:	e8 a2 24 ff ff       	callq  109c0d <arch_syscall_oops>
	return z_impl_k_pipe_alloc_init(pipe, size);
  11776b:	4c 89 ee             	mov    %r13,%rsi
  11776e:	4c 89 e7             	mov    %r12,%rdi
  117771:	e8 4a ff ff ff       	callq  1176c0 <z_impl_k_pipe_alloc_init>
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	int ret = z_vrfy_k_pipe_alloc_init(*(struct k_pipe **)&arg0, *(size_t*)&arg1)
;
	_current->syscall_frame = NULL;
  117776:	48 8b 15 d3 0f 01 00 	mov    0x10fd3(%rip),%rdx        # 128750 <_kernel+0x10>
	return (uintptr_t) ret;
  11777d:	48 98                	cltq   
	_current->syscall_frame = NULL;
  11777f:	48 c7 82 40 01 00 00 	movq   $0x0,0x140(%rdx)
  117786:	00 00 00 00 
}
  11778a:	41 5c                	pop    %r12
  11778c:	41 5d                	pop    %r13
  11778e:	5d                   	pop    %rbp
  11778f:	c3                   	retq   

0000000000117790 <k_pipe_cleanup>:
{
  117790:	55                   	push   %rbp
	return (struct k_thread *)sys_dlist_peek_head(&w->waitq);
  117791:	48 8d 57 30          	lea    0x30(%rdi),%rdx
  117795:	48 89 e5             	mov    %rsp,%rbp
  117798:	41 54                	push   %r12
  11779a:	53                   	push   %rbx
	return list->head == list;
  11779b:	48 8b 47 30          	mov    0x30(%rdi),%rax
  11779f:	48 89 fb             	mov    %rdi,%rbx
	CHECKIF(z_waitq_head(&pipe->wait_q.readers) != NULL ||
  1177a2:	48 39 d0             	cmp    %rdx,%rax
  1177a5:	74 0b                	je     1177b2 <k_pipe_cleanup+0x22>
		return -EAGAIN;
  1177a7:	41 bc f5 ff ff ff    	mov    $0xfffffff5,%r12d
	CHECKIF(z_waitq_head(&pipe->wait_q.readers) != NULL ||
  1177ad:	48 85 c0             	test   %rax,%rax
  1177b0:	75 34                	jne    1177e6 <k_pipe_cleanup+0x56>
  1177b2:	48 8b 43 40          	mov    0x40(%rbx),%rax
  1177b6:	48 85 c0             	test   %rax,%rax
  1177b9:	74 0f                	je     1177ca <k_pipe_cleanup+0x3a>
  1177bb:	48 8d 53 40          	lea    0x40(%rbx),%rdx
		return -EAGAIN;
  1177bf:	41 bc f5 ff ff ff    	mov    $0xfffffff5,%r12d
	CHECKIF(z_waitq_head(&pipe->wait_q.readers) != NULL ||
  1177c5:	48 39 d0             	cmp    %rdx,%rax
  1177c8:	75 1c                	jne    1177e6 <k_pipe_cleanup+0x56>
	return 0;
  1177ca:	45 31 e4             	xor    %r12d,%r12d
	if ((pipe->flags & K_PIPE_FLAG_ALLOC) != 0U) {
  1177cd:	f6 43 50 01          	testb  $0x1,0x50(%rbx)
  1177d1:	74 13                	je     1177e6 <k_pipe_cleanup+0x56>
		k_free(pipe->buffer);
  1177d3:	48 8b 3b             	mov    (%rbx),%rdi
  1177d6:	e8 82 e2 ff ff       	callq  115a5d <k_free>
		pipe->flags &= ~K_PIPE_FLAG_ALLOC;
  1177db:	80 63 50 fe          	andb   $0xfe,0x50(%rbx)
		pipe->buffer = NULL;
  1177df:	48 c7 03 00 00 00 00 	movq   $0x0,(%rbx)
}
  1177e6:	44 89 e0             	mov    %r12d,%eax
  1177e9:	5b                   	pop    %rbx
  1177ea:	41 5c                	pop    %r12
  1177ec:	5d                   	pop    %rbp
  1177ed:	c3                   	retq   

00000000001177ee <z_pipe_put_internal>:
 */
int z_pipe_put_internal(struct k_pipe *pipe, struct k_pipe_async *async_desc,
			 unsigned char *data, size_t bytes_to_write,
			 size_t *bytes_written, size_t min_xfer,
			 k_timeout_t timeout)
{
  1177ee:	55                   	push   %rbp
  1177ef:	48 89 e5             	mov    %rsp,%rbp
  1177f2:	41 57                	push   %r15
  1177f4:	41 56                	push   %r14
  1177f6:	41 55                	push   %r13
  1177f8:	41 54                	push   %r12
  1177fa:	53                   	push   %rbx
  1177fb:	48 83 ec 68          	sub    $0x68,%rsp
  1177ff:	48 89 95 70 ff ff ff 	mov    %rdx,-0x90(%rbp)
  117806:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
	ARG_UNUSED(async_desc);
#endif

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_pipe, put, pipe, timeout);

	CHECKIF((min_xfer > bytes_to_write) || bytes_written == NULL) {
  11780d:	49 39 c9             	cmp    %rcx,%r9
  117810:	0f 87 3b 03 00 00    	ja     117b51 <z_pipe_put_internal+0x363>
  117816:	4d 89 c7             	mov    %r8,%r15
  117819:	4d 85 c0             	test   %r8,%r8
  11781c:	0f 84 2f 03 00 00    	je     117b51 <z_pipe_put_internal+0x363>
  117822:	49 89 fe             	mov    %rdi,%r14
  117825:	49 89 cc             	mov    %rcx,%r12
		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_pipe, put, pipe, timeout, -EINVAL);

		return -EINVAL;
	}

	k_spinlock_key_t key = k_spin_lock(&pipe->lock);
  117828:	4c 8d 6f 28          	lea    0x28(%rdi),%r13
  11782c:	9c                   	pushfq 
  11782d:	fa                   	cli    
  11782e:	5b                   	pop    %rbx
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  11782f:	4c 89 ef             	mov    %r13,%rdi
  117832:	e8 42 60 ff ff       	callq  10d879 <z_spin_lock_valid>
  117837:	84 c0                	test   %al,%al
  117839:	75 37                	jne    117872 <z_pipe_put_internal+0x84>
  11783b:	b9 8e 00 00 00       	mov    $0x8e,%ecx
  117840:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  117845:	be fd d1 11 00       	mov    $0x11d1fd,%esi
  11784a:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  11784f:	e8 a4 8d fe ff       	callq  1005f8 <printk>
  117854:	4c 89 ee             	mov    %r13,%rsi
  117857:	bf 12 d2 11 00       	mov    $0x11d212,%edi
  11785c:	31 c0                	xor    %eax,%eax
  11785e:	e8 95 8d fe ff       	callq  1005f8 <printk>
  117863:	be 8e 00 00 00       	mov    $0x8e,%esi
  117868:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  11786d:	e8 26 b3 fe ff       	callq  102b98 <assert_post_action>
	z_spin_lock_set_owner(l);
  117872:	4c 89 ef             	mov    %r13,%rdi
  117875:	e8 43 60 ff ff       	callq  10d8bd <z_spin_lock_set_owner>
	/*
	 * Create a list of "working readers" into which the data will be
	 * directly copied.
	 */

	if (!pipe_xfer_prepare(&xfer_list, &reader, &pipe->wait_q.readers,
  11787a:	49 8b 4e 08          	mov    0x8(%r14),%rcx
  11787e:	49 2b 4e 10          	sub    0x10(%r14),%rcx
  117882:	4d 89 e0             	mov    %r12,%r8
  117885:	50                   	push   %rax
  117886:	4c 8b 8d 78 ff ff ff 	mov    -0x88(%rbp),%r9
  11788d:	49 8d 56 30          	lea    0x30(%r14),%rdx
  117891:	48 8d 75 88          	lea    -0x78(%rbp),%rsi
  117895:	ff 75 10             	pushq  0x10(%rbp)
  117898:	48 8d 7d 90          	lea    -0x70(%rbp),%rdi
  11789c:	e8 00 fc ff ff       	callq  1174a1 <pipe_xfer_prepare>
  1178a1:	5a                   	pop    %rdx
  1178a2:	59                   	pop    %rcx
  1178a3:	84 c0                	test   %al,%al
  1178a5:	75 5b                	jne    117902 <z_pipe_put_internal+0x114>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  1178a7:	4c 89 ef             	mov    %r13,%rdi
  1178aa:	e8 ea 5f ff ff       	callq  10d899 <z_spin_unlock_valid>
  1178af:	84 c0                	test   %al,%al
  1178b1:	75 37                	jne    1178ea <z_pipe_put_internal+0xfc>
  1178b3:	b9 b9 00 00 00       	mov    $0xb9,%ecx
  1178b8:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  1178bd:	be 41 d2 11 00       	mov    $0x11d241,%esi
  1178c2:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  1178c7:	e8 2c 8d fe ff       	callq  1005f8 <printk>
  1178cc:	4c 89 ee             	mov    %r13,%rsi
  1178cf:	bf 58 d2 11 00       	mov    $0x11d258,%edi
  1178d4:	31 c0                	xor    %eax,%eax
  1178d6:	e8 1d 8d fe ff       	callq  1005f8 <printk>
  1178db:	be b9 00 00 00       	mov    $0xb9,%esi
  1178e0:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  1178e5:	e8 ae b2 fe ff       	callq  102b98 <assert_post_action>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  1178ea:	0f ba e3 09          	bt     $0x9,%ebx
  1178ee:	73 01                	jae    1178f1 <z_pipe_put_internal+0x103>
		__asm__ volatile ("sti" ::: "memory");
  1178f0:	fb                   	sti    
				pipe->size - pipe->bytes_used, bytes_to_write,
				min_xfer, timeout)) {
		k_spin_unlock(&pipe->lock, key);
		*bytes_written = 0;
  1178f1:	49 c7 07 00 00 00 00 	movq   $0x0,(%r15)

		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_pipe, put, pipe, timeout, -EIO);

		return -EIO;
  1178f8:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
  1178fd:	e9 54 02 00 00       	jmpq   117b56 <z_pipe_put_internal+0x368>
	}

	SYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_pipe, put, pipe, timeout);

	z_sched_lock();
  117902:	e8 58 fc ff ff       	callq  11755f <z_sched_lock>
  117907:	4c 89 ef             	mov    %r13,%rdi
  11790a:	e8 8a 5f ff ff       	callq  10d899 <z_spin_unlock_valid>
  11790f:	84 c0                	test   %al,%al
  117911:	75 37                	jne    11794a <z_pipe_put_internal+0x15c>
  117913:	b9 b9 00 00 00       	mov    $0xb9,%ecx
  117918:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  11791d:	be 41 d2 11 00       	mov    $0x11d241,%esi
  117922:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  117927:	e8 cc 8c fe ff       	callq  1005f8 <printk>
  11792c:	4c 89 ee             	mov    %r13,%rsi
  11792f:	bf 58 d2 11 00       	mov    $0x11d258,%edi
  117934:	31 c0                	xor    %eax,%eax
  117936:	e8 bd 8c fe ff       	callq  1005f8 <printk>
  11793b:	be b9 00 00 00       	mov    $0xb9,%esi
  117940:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  117945:	e8 4e b2 fe ff       	callq  102b98 <assert_post_action>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  11794a:	0f ba e3 09          	bt     $0x9,%ebx
  11794e:	73 01                	jae    117951 <z_pipe_put_internal+0x163>
		__asm__ volatile ("sti" ::: "memory");
  117950:	fb                   	sti    
	 * still have a pointer to it, but it can not execute until this call
	 * is complete so it is still safe to copy data to it.
	 */

	struct k_thread *thread = (struct k_thread *)
				  sys_dlist_get(&xfer_list);
  117951:	48 8d 7d 90          	lea    -0x70(%rbp),%rdi
	size_t         num_bytes_written = 0;
  117955:	31 db                	xor    %ebx,%ebx
				  sys_dlist_get(&xfer_list);
  117957:	e8 85 fa ff ff       	callq  1173e1 <sys_dlist_get>
  11795c:	49 89 c1             	mov    %rax,%r9
	while (thread != NULL) {
		desc = (struct k_pipe_desc *)thread->base.swap_data;
		bytes_copied = pipe_xfer(desc->buffer, desc->bytes_to_xfer,
					  data + num_bytes_written,
  11795f:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
		bytes_copied = pipe_xfer(desc->buffer, desc->bytes_to_xfer,
  117966:	4c 89 e1             	mov    %r12,%rcx
  117969:	48 29 d9             	sub    %rbx,%rcx
					  data + num_bytes_written,
  11796c:	48 8d 14 18          	lea    (%rax,%rbx,1),%rdx
	while (thread != NULL) {
  117970:	4d 85 c9             	test   %r9,%r9
  117973:	74 30                	je     1179a5 <z_pipe_put_internal+0x1b7>
		desc = (struct k_pipe_desc *)thread->base.swap_data;
  117975:	4d 8b 51 20          	mov    0x20(%r9),%r10
		bytes_copied = pipe_xfer(desc->buffer, desc->bytes_to_xfer,
  117979:	49 8b 3a             	mov    (%r10),%rdi
  11797c:	49 8b 72 08          	mov    0x8(%r10),%rsi
  117980:	e8 85 fa ff ff       	callq  11740a <pipe_xfer>
					  bytes_to_write - num_bytes_written);

		num_bytes_written   += bytes_copied;
		desc->buffer        += bytes_copied;
  117985:	49 01 02             	add    %rax,(%r10)
		desc->bytes_to_xfer -= bytes_copied;

		/* The thread's read request has been satisfied. Ready it. */
		z_ready_thread(thread);
  117988:	4c 89 cf             	mov    %r9,%rdi
		desc->bytes_to_xfer -= bytes_copied;
  11798b:	49 29 42 08          	sub    %rax,0x8(%r10)
		num_bytes_written   += bytes_copied;
  11798f:	48 01 c3             	add    %rax,%rbx
		z_ready_thread(thread);
  117992:	e8 b3 9a ff ff       	callq  11144a <z_ready_thread>

		thread = (struct k_thread *)sys_dlist_get(&xfer_list);
  117997:	48 8d 7d 90          	lea    -0x70(%rbp),%rdi
  11799b:	e8 41 fa ff ff       	callq  1173e1 <sys_dlist_get>
  1179a0:	49 89 c1             	mov    %rax,%r9
  1179a3:	eb ba                	jmp    11795f <z_pipe_put_internal+0x171>

	/*
	 * Copy any data to the reader that we left on the wait_q.
	 * It is possible no data will be copied.
	 */
	if (reader != NULL) {
  1179a5:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  1179a9:	48 85 c0             	test   %rax,%rax
  1179ac:	74 1a                	je     1179c8 <z_pipe_put_internal+0x1da>
		desc = (struct k_pipe_desc *)reader->base.swap_data;
  1179ae:	4c 8b 48 20          	mov    0x20(%rax),%r9
		bytes_copied = pipe_xfer(desc->buffer, desc->bytes_to_xfer,
  1179b2:	49 8b 71 08          	mov    0x8(%r9),%rsi
  1179b6:	49 8b 39             	mov    (%r9),%rdi
  1179b9:	e8 4c fa ff ff       	callq  11740a <pipe_xfer>
					  data + num_bytes_written,
					  bytes_to_write - num_bytes_written);

		num_bytes_written   += bytes_copied;
		desc->buffer        += bytes_copied;
  1179be:	49 01 01             	add    %rax,(%r9)
		desc->bytes_to_xfer -= bytes_copied;
  1179c1:	49 29 41 08          	sub    %rax,0x8(%r9)
		num_bytes_written   += bytes_copied;
  1179c5:	48 01 c3             	add    %rax,%rbx
	 * As much data as possible has been directly copied to any waiting
	 * readers. Add as much as possible to the pipe's circular buffer.
	 */

	num_bytes_written +=
		pipe_buffer_put(pipe, data + num_bytes_written,
  1179c8:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  1179cf:	4c 89 e2             	mov    %r12,%rdx
  1179d2:	4c 89 f7             	mov    %r14,%rdi
  1179d5:	48 29 da             	sub    %rbx,%rdx
  1179d8:	48 8d 34 18          	lea    (%rax,%rbx,1),%rsi
  1179dc:	e8 4a fa ff ff       	callq  11742b <pipe_buffer_put>
	num_bytes_written +=
  1179e1:	48 01 c3             	add    %rax,%rbx
				 bytes_to_write - num_bytes_written);

	if (num_bytes_written == bytes_to_write) {
  1179e4:	49 39 dc             	cmp    %rbx,%r12
  1179e7:	75 05                	jne    1179ee <z_pipe_put_internal+0x200>
		*bytes_written = num_bytes_written;
  1179e9:	4d 89 27             	mov    %r12,(%r15)
		k_sched_unlock();
  1179ec:	eb 1d                	jmp    117a0b <z_pipe_put_internal+0x21d>
		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_pipe, put, pipe, timeout, 0);

		return 0;
	}

	if (!K_TIMEOUT_EQ(timeout, K_NO_WAIT)
  1179ee:	48 83 7d 10 00       	cmpq   $0x0,0x10(%rbp)
  1179f3:	74 22                	je     117a17 <z_pipe_put_internal+0x229>
	    && num_bytes_written >= min_xfer
	    && min_xfer > 0U) {
  1179f5:	48 39 9d 78 ff ff ff 	cmp    %rbx,-0x88(%rbp)
  1179fc:	77 19                	ja     117a17 <z_pipe_put_internal+0x229>
  1179fe:	48 83 bd 78 ff ff ff 	cmpq   $0x0,-0x88(%rbp)
  117a05:	00 
  117a06:	74 0f                	je     117a17 <z_pipe_put_internal+0x229>
		*bytes_written = num_bytes_written;
  117a08:	49 89 1f             	mov    %rbx,(%r15)
		k_sched_unlock();
  117a0b:	e8 3e a3 ff ff       	callq  111d4e <k_sched_unlock>

		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_pipe, put, pipe, timeout, 0);

		return 0;
  117a10:	31 c0                	xor    %eax,%eax
  117a12:	e9 3f 01 00 00       	jmpq   117b56 <z_pipe_put_internal+0x368>

	/* Not all data was copied */

	struct k_pipe_desc  pipe_desc;

	pipe_desc.buffer         = data + num_bytes_written;
  117a17:	48 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%rdx
	pipe_desc.bytes_to_xfer  = bytes_to_write - num_bytes_written;
  117a1e:	4c 89 e0             	mov    %r12,%rax
  117a21:	48 29 d8             	sub    %rbx,%rax
	pipe_desc.buffer         = data + num_bytes_written;
  117a24:	48 01 da             	add    %rbx,%rdx

	if (!K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
  117a27:	48 83 7d 10 00       	cmpq   $0x0,0x10(%rbp)
	pipe_desc.bytes_to_xfer  = bytes_to_write - num_bytes_written;
  117a2c:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
	pipe_desc.buffer         = data + num_bytes_written;
  117a30:	48 89 55 a0          	mov    %rdx,-0x60(%rbp)
	if (!K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
  117a34:	0f 84 fd 00 00 00    	je     117b37 <z_pipe_put_internal+0x349>
		_current->base.swap_data = &pipe_desc;
  117a3a:	48 8b 05 0f 0d 01 00 	mov    0x10d0f(%rip),%rax        # 128750 <_kernel+0x10>
  117a41:	48 8d 55 a0          	lea    -0x60(%rbp),%rdx
  117a45:	48 89 50 20          	mov    %rdx,0x20(%rax)
  117a49:	9c                   	pushfq 
  117a4a:	fa                   	cli    
  117a4b:	5b                   	pop    %rbx
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  117a4c:	4c 89 ef             	mov    %r13,%rdi
  117a4f:	e8 25 5e ff ff       	callq  10d879 <z_spin_lock_valid>
  117a54:	84 c0                	test   %al,%al
  117a56:	75 37                	jne    117a8f <z_pipe_put_internal+0x2a1>
  117a58:	b9 8e 00 00 00       	mov    $0x8e,%ecx
  117a5d:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  117a62:	be fd d1 11 00       	mov    $0x11d1fd,%esi
  117a67:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  117a6c:	e8 87 8b fe ff       	callq  1005f8 <printk>
  117a71:	4c 89 ee             	mov    %r13,%rsi
  117a74:	bf 12 d2 11 00       	mov    $0x11d212,%edi
  117a79:	31 c0                	xor    %eax,%eax
  117a7b:	e8 78 8b fe ff       	callq  1005f8 <printk>
  117a80:	be 8e 00 00 00       	mov    $0x8e,%esi
  117a85:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  117a8a:	e8 09 b1 fe ff       	callq  102b98 <assert_post_action>
	z_spin_lock_set_owner(l);
  117a8f:	4c 89 ef             	mov    %r13,%rdi
  117a92:	e8 26 5e ff ff       	callq  10d8bd <z_spin_lock_set_owner>

static ALWAYS_INLINE void z_sched_unlock_no_reschedule(void)
{
	__ASSERT(!arch_is_in_isr(), "");
  117a97:	83 3d a2 0c 01 00 00 	cmpl   $0x0,0x10ca2(%rip)        # 128740 <_kernel>
  117a9e:	74 36                	je     117ad6 <z_pipe_put_internal+0x2e8>
  117aa0:	be 49 f9 11 00       	mov    $0x11f949,%esi
  117aa5:	b9 07 01 00 00       	mov    $0x107,%ecx
  117aaa:	ba 83 fc 11 00       	mov    $0x11fc83,%edx
  117aaf:	31 c0                	xor    %eax,%eax
  117ab1:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  117ab6:	e8 3d 8b fe ff       	callq  1005f8 <printk>
  117abb:	bf 22 fc 11 00       	mov    $0x11fc22,%edi
  117ac0:	31 c0                	xor    %eax,%eax
  117ac2:	e8 31 8b fe ff       	callq  1005f8 <printk>
  117ac7:	be 07 01 00 00       	mov    $0x107,%esi
  117acc:	bf 83 fc 11 00       	mov    $0x11fc83,%edi
  117ad1:	e8 c2 b0 fe ff       	callq  102b98 <assert_post_action>
	__ASSERT(_current->base.sched_locked != 0U, "");
  117ad6:	48 8b 05 73 0c 01 00 	mov    0x10c73(%rip),%rax        # 128750 <_kernel+0x10>
  117add:	80 78 1b 00          	cmpb   $0x0,0x1b(%rax)
  117ae1:	75 36                	jne    117b19 <z_pipe_put_internal+0x32b>
  117ae3:	be cd fd 11 00       	mov    $0x11fdcd,%esi
  117ae8:	b9 08 01 00 00       	mov    $0x108,%ecx
  117aed:	ba 83 fc 11 00       	mov    $0x11fc83,%edx
  117af2:	31 c0                	xor    %eax,%eax
  117af4:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  117af9:	e8 fa 8a fe ff       	callq  1005f8 <printk>
  117afe:	bf 22 fc 11 00       	mov    $0x11fc22,%edi
  117b03:	31 c0                	xor    %eax,%eax
  117b05:	e8 ee 8a fe ff       	callq  1005f8 <printk>
  117b0a:	be 08 01 00 00       	mov    $0x108,%esi
  117b0f:	bf 83 fc 11 00       	mov    $0x11fc83,%edi
  117b14:	e8 7f b0 fe ff       	callq  102b98 <assert_post_action>

	compiler_barrier();

	++_current->base.sched_locked;
  117b19:	48 8b 05 30 0c 01 00 	mov    0x10c30(%rip),%rax        # 128750 <_kernel+0x10>
		 * Lock interrupts and unlock the scheduler before
		 * manipulating the writers wait_q.
		 */
		k_spinlock_key_t key2 = k_spin_lock(&pipe->lock);
		z_sched_unlock_no_reschedule();
		(void)z_pend_curr(&pipe->lock, key2,
  117b20:	48 8b 4d 10          	mov    0x10(%rbp),%rcx
  117b24:	89 de                	mov    %ebx,%esi
  117b26:	4c 89 ef             	mov    %r13,%rdi
  117b29:	49 8d 56 40          	lea    0x40(%r14),%rdx
  117b2d:	fe 40 1b             	incb   0x1b(%rax)
  117b30:	e8 b3 9e ff ff       	callq  1119e8 <z_pend_curr>
  117b35:	eb 05                	jmp    117b3c <z_pipe_put_internal+0x34e>
				 &pipe->wait_q.writers, timeout);
	} else {
		k_sched_unlock();
  117b37:	e8 12 a2 ff ff       	callq  111d4e <k_sched_unlock>
	}

	*bytes_written = bytes_to_write - pipe_desc.bytes_to_xfer;
  117b3c:	4c 2b 65 a8          	sub    -0x58(%rbp),%r12
		return 0;
  117b40:	4c 3b a5 78 ff ff ff 	cmp    -0x88(%rbp),%r12
  117b47:	19 c0                	sbb    %eax,%eax
	*bytes_written = bytes_to_write - pipe_desc.bytes_to_xfer;
  117b49:	4d 89 27             	mov    %r12,(%r15)
		return 0;
  117b4c:	83 e0 f5             	and    $0xfffffff5,%eax
  117b4f:	eb 05                	jmp    117b56 <z_pipe_put_internal+0x368>
		return -EINVAL;
  117b51:	b8 ea ff ff ff       	mov    $0xffffffea,%eax

	int ret = pipe_return_code(min_xfer, pipe_desc.bytes_to_xfer,
				 bytes_to_write);
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_pipe, put, pipe, timeout, ret);
	return ret;
}
  117b56:	48 8d 65 d8          	lea    -0x28(%rbp),%rsp
  117b5a:	5b                   	pop    %rbx
  117b5b:	41 5c                	pop    %r12
  117b5d:	41 5d                	pop    %r13
  117b5f:	41 5e                	pop    %r14
  117b61:	41 5f                	pop    %r15
  117b63:	5d                   	pop    %rbp
  117b64:	c3                   	retq   

0000000000117b65 <z_impl_k_pipe_get>:

int z_impl_k_pipe_get(struct k_pipe *pipe, void *data, size_t bytes_to_read,
		     size_t *bytes_read, size_t min_xfer, k_timeout_t timeout)
{
  117b65:	55                   	push   %rbp
  117b66:	48 89 e5             	mov    %rsp,%rbp
  117b69:	41 57                	push   %r15
  117b6b:	41 56                	push   %r14
  117b6d:	41 55                	push   %r13
  117b6f:	41 54                	push   %r12
  117b71:	53                   	push   %rbx
  117b72:	48 81 ec 88 00 00 00 	sub    $0x88,%rsp
  117b79:	48 89 b5 68 ff ff ff 	mov    %rsi,-0x98(%rbp)
  117b80:	4c 89 85 78 ff ff ff 	mov    %r8,-0x88(%rbp)
  117b87:	4c 89 8d 70 ff ff ff 	mov    %r9,-0x90(%rbp)
	size_t         num_bytes_read = 0;
	size_t         bytes_copied;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_pipe, get, pipe, timeout);

	CHECKIF((min_xfer > bytes_to_read) || bytes_read == NULL) {
  117b8e:	49 39 d0             	cmp    %rdx,%r8
  117b91:	0f 87 57 04 00 00    	ja     117fee <z_impl_k_pipe_get+0x489>
  117b97:	49 89 cf             	mov    %rcx,%r15
  117b9a:	48 85 c9             	test   %rcx,%rcx
  117b9d:	0f 84 4b 04 00 00    	je     117fee <z_impl_k_pipe_get+0x489>
  117ba3:	48 89 fb             	mov    %rdi,%rbx
  117ba6:	49 89 d5             	mov    %rdx,%r13
		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_pipe, get, pipe, timeout, -EINVAL);

		return -EINVAL;
	}

	k_spinlock_key_t key = k_spin_lock(&pipe->lock);
  117ba9:	4c 8d 77 28          	lea    0x28(%rdi),%r14
  117bad:	9c                   	pushfq 
  117bae:	fa                   	cli    
  117baf:	41 5c                	pop    %r12
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  117bb1:	4c 89 f7             	mov    %r14,%rdi
  117bb4:	e8 c0 5c ff ff       	callq  10d879 <z_spin_lock_valid>
  117bb9:	84 c0                	test   %al,%al
  117bbb:	75 37                	jne    117bf4 <z_impl_k_pipe_get+0x8f>
  117bbd:	b9 8e 00 00 00       	mov    $0x8e,%ecx
  117bc2:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  117bc7:	be fd d1 11 00       	mov    $0x11d1fd,%esi
  117bcc:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  117bd1:	e8 22 8a fe ff       	callq  1005f8 <printk>
  117bd6:	4c 89 f6             	mov    %r14,%rsi
  117bd9:	bf 12 d2 11 00       	mov    $0x11d212,%edi
  117bde:	31 c0                	xor    %eax,%eax
  117be0:	e8 13 8a fe ff       	callq  1005f8 <printk>
  117be5:	be 8e 00 00 00       	mov    $0x8e,%esi
  117bea:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  117bef:	e8 a4 af fe ff       	callq  102b98 <assert_post_action>
	z_spin_lock_set_owner(l);
  117bf4:	4c 89 f7             	mov    %r14,%rdi
  117bf7:	e8 c1 5c ff ff       	callq  10d8bd <z_spin_lock_set_owner>

	/*
	 * Create a list of "working readers" into which the data will be
	 * directly copied.
	 */
	if (!pipe_xfer_prepare(&xfer_list, &writer, &pipe->wait_q.writers,
  117bfc:	48 8b 4b 10          	mov    0x10(%rbx),%rcx
  117c00:	48 8d 53 40          	lea    0x40(%rbx),%rdx
  117c04:	4d 89 e8             	mov    %r13,%r8
  117c07:	50                   	push   %rax
  117c08:	4c 8b 8d 78 ff ff ff 	mov    -0x88(%rbp),%r9
  117c0f:	48 8d 75 88          	lea    -0x78(%rbp),%rsi
  117c13:	48 8d 7d 90          	lea    -0x70(%rbp),%rdi
  117c17:	ff b5 70 ff ff ff    	pushq  -0x90(%rbp)
  117c1d:	e8 7f f8 ff ff       	callq  1174a1 <pipe_xfer_prepare>
  117c22:	5a                   	pop    %rdx
  117c23:	59                   	pop    %rcx
  117c24:	84 c0                	test   %al,%al
  117c26:	75 5c                	jne    117c84 <z_impl_k_pipe_get+0x11f>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  117c28:	4c 89 f7             	mov    %r14,%rdi
  117c2b:	e8 69 5c ff ff       	callq  10d899 <z_spin_unlock_valid>
  117c30:	84 c0                	test   %al,%al
  117c32:	75 37                	jne    117c6b <z_impl_k_pipe_get+0x106>
  117c34:	b9 b9 00 00 00       	mov    $0xb9,%ecx
  117c39:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  117c3e:	be 41 d2 11 00       	mov    $0x11d241,%esi
  117c43:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  117c48:	e8 ab 89 fe ff       	callq  1005f8 <printk>
  117c4d:	4c 89 f6             	mov    %r14,%rsi
  117c50:	bf 58 d2 11 00       	mov    $0x11d258,%edi
  117c55:	31 c0                	xor    %eax,%eax
  117c57:	e8 9c 89 fe ff       	callq  1005f8 <printk>
  117c5c:	be b9 00 00 00       	mov    $0xb9,%esi
  117c61:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  117c66:	e8 2d af fe ff       	callq  102b98 <assert_post_action>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  117c6b:	41 0f ba e4 09       	bt     $0x9,%r12d
  117c70:	73 01                	jae    117c73 <z_impl_k_pipe_get+0x10e>
		__asm__ volatile ("sti" ::: "memory");
  117c72:	fb                   	sti    
				pipe->bytes_used, bytes_to_read,
				min_xfer, timeout)) {
		k_spin_unlock(&pipe->lock, key);
		*bytes_read = 0;
  117c73:	49 c7 07 00 00 00 00 	movq   $0x0,(%r15)

		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_pipe, get, pipe, timeout, -EIO);

		return -EIO;
  117c7a:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
  117c7f:	e9 6f 03 00 00       	jmpq   117ff3 <z_impl_k_pipe_get+0x48e>
	}

	SYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_pipe, get, pipe, timeout);

	z_sched_lock();
  117c84:	e8 d6 f8 ff ff       	callq  11755f <z_sched_lock>
  117c89:	4c 89 f7             	mov    %r14,%rdi
  117c8c:	e8 08 5c ff ff       	callq  10d899 <z_spin_unlock_valid>
  117c91:	84 c0                	test   %al,%al
  117c93:	75 37                	jne    117ccc <z_impl_k_pipe_get+0x167>
  117c95:	b9 b9 00 00 00       	mov    $0xb9,%ecx
  117c9a:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  117c9f:	be 41 d2 11 00       	mov    $0x11d241,%esi
  117ca4:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  117ca9:	e8 4a 89 fe ff       	callq  1005f8 <printk>
  117cae:	4c 89 f6             	mov    %r14,%rsi
  117cb1:	bf 58 d2 11 00       	mov    $0x11d258,%edi
  117cb6:	31 c0                	xor    %eax,%eax
  117cb8:	e8 3b 89 fe ff       	callq  1005f8 <printk>
  117cbd:	be b9 00 00 00       	mov    $0xb9,%esi
  117cc2:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  117cc7:	e8 cc ae fe ff       	callq  102b98 <assert_post_action>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  117ccc:	41 0f ba e4 09       	bt     $0x9,%r12d
  117cd1:	73 01                	jae    117cd4 <z_impl_k_pipe_get+0x16f>
		__asm__ volatile ("sti" ::: "memory");
  117cd3:	fb                   	sti    
{
  117cd4:	41 b9 02 00 00 00    	mov    $0x2,%r9d
  117cda:	45 31 e4             	xor    %r12d,%r12d
		run_length = MIN(pipe->bytes_used,
  117cdd:	48 8b 53 18          	mov    0x18(%rbx),%rdx
  117ce1:	48 8b 4b 08          	mov    0x8(%rbx),%rcx
		bytes_copied = pipe_xfer(dest + num_bytes_read,
  117ce5:	4c 89 ee             	mov    %r13,%rsi
		run_length = MIN(pipe->bytes_used,
  117ce8:	48 8b 43 10          	mov    0x10(%rbx),%rax
  117cec:	48 29 d1             	sub    %rdx,%rcx
  117cef:	48 39 c1             	cmp    %rax,%rcx
  117cf2:	48 0f 47 c8          	cmova  %rax,%rcx
		bytes_copied = pipe_xfer(dest + num_bytes_read,
  117cf6:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  117cfd:	4c 29 e6             	sub    %r12,%rsi
					  pipe->buffer + pipe->read_index,
  117d00:	48 03 13             	add    (%rbx),%rdx
		bytes_copied = pipe_xfer(dest + num_bytes_read,
  117d03:	4a 8d 3c 20          	lea    (%rax,%r12,1),%rdi
  117d07:	e8 fe f6 ff ff       	callq  11740a <pipe_xfer>
		pipe->bytes_used -= bytes_copied;
  117d0c:	48 29 43 10          	sub    %rax,0x10(%rbx)
		num_bytes_read += bytes_copied;
  117d10:	49 01 c4             	add    %rax,%r12
		pipe->read_index += bytes_copied;
  117d13:	48 03 43 18          	add    0x18(%rbx),%rax
  117d17:	48 89 43 18          	mov    %rax,0x18(%rbx)
		if (pipe->read_index == pipe->size) {
  117d1b:	48 3b 43 08          	cmp    0x8(%rbx),%rax
  117d1f:	75 08                	jne    117d29 <z_impl_k_pipe_get+0x1c4>
			pipe->read_index = 0;
  117d21:	48 c7 43 18 00 00 00 	movq   $0x0,0x18(%rbx)
  117d28:	00 
	for (i = 0; i < 2; i++) {
  117d29:	41 ff c9             	dec    %r9d
  117d2c:	74 5a                	je     117d88 <z_impl_k_pipe_get+0x223>
  117d2e:	41 b9 01 00 00 00    	mov    $0x1,%r9d
  117d34:	eb a7                	jmp    117cdd <z_impl_k_pipe_get+0x178>
	 *    call is complete so it is still safe to copy data from it.
	 */

	struct k_thread *thread = (struct k_thread *)
				  sys_dlist_get(&xfer_list);
	while ((thread != NULL) && (num_bytes_read < bytes_to_read)) {
  117d36:	4d 39 ec             	cmp    %r13,%r12
  117d39:	73 5e                	jae    117d99 <z_impl_k_pipe_get+0x234>
		desc = (struct k_pipe_desc *)thread->base.swap_data;
  117d3b:	4d 8b 48 20          	mov    0x20(%r8),%r9
		bytes_copied = pipe_xfer((uint8_t *)data + num_bytes_read,
  117d3f:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  117d46:	4c 89 ee             	mov    %r13,%rsi
		desc = (struct k_pipe_desc *)thread->base.swap_data;
  117d49:	4c 89 85 60 ff ff ff 	mov    %r8,-0xa0(%rbp)
		bytes_copied = pipe_xfer((uint8_t *)data + num_bytes_read,
  117d50:	4c 29 e6             	sub    %r12,%rsi
  117d53:	49 8b 49 08          	mov    0x8(%r9),%rcx
  117d57:	49 8b 11             	mov    (%r9),%rdx
  117d5a:	4a 8d 3c 20          	lea    (%rax,%r12,1),%rdi
  117d5e:	e8 a7 f6 ff ff       	callq  11740a <pipe_xfer>
					  bytes_to_read - num_bytes_read,
					  desc->buffer, desc->bytes_to_xfer);

		num_bytes_read       += bytes_copied;
		desc->buffer         += bytes_copied;
  117d63:	49 01 01             	add    %rax,(%r9)
		 * It is expected that the write request will be satisfied.
		 * However, if the read request was satisfied before the
		 * write request was satisfied, then the write request must
		 * finish later when writing to the pipe's circular buffer.
		 */
		if (num_bytes_read == bytes_to_read) {
  117d66:	4c 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%r8
		num_bytes_read       += bytes_copied;
  117d6d:	49 01 c4             	add    %rax,%r12
		desc->bytes_to_xfer  -= bytes_copied;
  117d70:	49 29 41 08          	sub    %rax,0x8(%r9)
		if (num_bytes_read == bytes_to_read) {
  117d74:	4d 39 e5             	cmp    %r12,%r13
  117d77:	74 20                	je     117d99 <z_impl_k_pipe_get+0x234>
	if ((thread->base.thread_state & _THREAD_DUMMY) != 0U) {
  117d79:	41 f6 40 19 01       	testb  $0x1,0x19(%r8)
  117d7e:	75 08                	jne    117d88 <z_impl_k_pipe_get+0x223>
	z_ready_thread(thread);
  117d80:	4c 89 c7             	mov    %r8,%rdi
  117d83:	e8 c2 96 ff ff       	callq  11144a <z_ready_thread>
			break;
		}
		pipe_thread_ready(thread);

		thread = (struct k_thread *)sys_dlist_get(&xfer_list);
  117d88:	48 8d 7d 90          	lea    -0x70(%rbp),%rdi
  117d8c:	e8 50 f6 ff ff       	callq  1173e1 <sys_dlist_get>
  117d91:	49 89 c0             	mov    %rax,%r8
	while ((thread != NULL) && (num_bytes_read < bytes_to_read)) {
  117d94:	48 85 c0             	test   %rax,%rax
  117d97:	75 9d                	jne    117d36 <z_impl_k_pipe_get+0x1d1>
	}

	if ((writer != NULL) && (num_bytes_read < bytes_to_read)) {
  117d99:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  117d9d:	4d 39 ec             	cmp    %r13,%r12
  117da0:	0f 83 95 00 00 00    	jae    117e3b <z_impl_k_pipe_get+0x2d6>
  117da6:	48 85 c0             	test   %rax,%rax
  117da9:	0f 84 8c 00 00 00    	je     117e3b <z_impl_k_pipe_get+0x2d6>
		desc = (struct k_pipe_desc *)writer->base.swap_data;
  117daf:	4c 8b 48 20          	mov    0x20(%rax),%r9
		bytes_copied = pipe_xfer((uint8_t *)data + num_bytes_read,
  117db3:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  117dba:	4c 89 ee             	mov    %r13,%rsi
  117dbd:	4c 89 85 60 ff ff ff 	mov    %r8,-0xa0(%rbp)
  117dc4:	4c 29 e6             	sub    %r12,%rsi
  117dc7:	49 8b 49 08          	mov    0x8(%r9),%rcx
  117dcb:	49 8b 11             	mov    (%r9),%rdx
  117dce:	4a 8d 3c 20          	lea    (%rax,%r12,1),%rdi
  117dd2:	e8 33 f6 ff ff       	callq  11740a <pipe_xfer>
					  bytes_to_read - num_bytes_read,
					  desc->buffer, desc->bytes_to_xfer);

		num_bytes_read       += bytes_copied;
  117dd7:	4c 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%r8
		desc->buffer         += bytes_copied;
  117dde:	49 01 01             	add    %rax,(%r9)
		desc->bytes_to_xfer  -= bytes_copied;
  117de1:	49 29 41 08          	sub    %rax,0x8(%r9)
		num_bytes_read       += bytes_copied;
  117de5:	49 01 c4             	add    %rax,%r12
		desc->bytes_to_xfer  -= bytes_copied;
  117de8:	eb 51                	jmp    117e3b <z_impl_k_pipe_get+0x2d6>
	 * Copy as much data as possible from the writers (if any)
	 * into the pipe's circular buffer.
	 */

	while (thread != NULL) {
		desc = (struct k_pipe_desc *)thread->base.swap_data;
  117dea:	49 8b 48 20          	mov    0x20(%r8),%rcx
		bytes_copied = pipe_buffer_put(pipe, desc->buffer,
  117dee:	48 89 df             	mov    %rbx,%rdi
		desc = (struct k_pipe_desc *)thread->base.swap_data;
  117df1:	4c 89 85 58 ff ff ff 	mov    %r8,-0xa8(%rbp)
		bytes_copied = pipe_buffer_put(pipe, desc->buffer,
  117df8:	48 8b 51 08          	mov    0x8(%rcx),%rdx
  117dfc:	48 8b 31             	mov    (%rcx),%rsi
  117dff:	48 89 8d 60 ff ff ff 	mov    %rcx,-0xa0(%rbp)
  117e06:	e8 20 f6 ff ff       	callq  11742b <pipe_buffer_put>
						desc->bytes_to_xfer);

		desc->buffer         += bytes_copied;
  117e0b:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
	if ((thread->base.thread_state & _THREAD_DUMMY) != 0U) {
  117e12:	4c 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%r8
		desc->buffer         += bytes_copied;
  117e19:	48 01 01             	add    %rax,(%rcx)
		desc->bytes_to_xfer  -= bytes_copied;
  117e1c:	48 29 41 08          	sub    %rax,0x8(%rcx)
	if ((thread->base.thread_state & _THREAD_DUMMY) != 0U) {
  117e20:	41 f6 40 19 01       	testb  $0x1,0x19(%r8)
  117e25:	75 08                	jne    117e2f <z_impl_k_pipe_get+0x2ca>
	z_ready_thread(thread);
  117e27:	4c 89 c7             	mov    %r8,%rdi
  117e2a:	e8 1b 96 ff ff       	callq  11144a <z_ready_thread>

		/* Write request has been satisfied */
		pipe_thread_ready(thread);

		thread = (struct k_thread *)sys_dlist_get(&xfer_list);
  117e2f:	48 8d 7d 90          	lea    -0x70(%rbp),%rdi
  117e33:	e8 a9 f5 ff ff       	callq  1173e1 <sys_dlist_get>
  117e38:	49 89 c0             	mov    %rax,%r8
	while (thread != NULL) {
  117e3b:	4d 85 c0             	test   %r8,%r8
  117e3e:	75 aa                	jne    117dea <z_impl_k_pipe_get+0x285>
	}

	if (writer != NULL) {
  117e40:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  117e44:	48 85 c0             	test   %rax,%rax
  117e47:	74 28                	je     117e71 <z_impl_k_pipe_get+0x30c>
		desc = (struct k_pipe_desc *)writer->base.swap_data;
  117e49:	48 8b 48 20          	mov    0x20(%rax),%rcx
		bytes_copied = pipe_buffer_put(pipe, desc->buffer,
  117e4d:	48 89 df             	mov    %rbx,%rdi
  117e50:	48 8b 51 08          	mov    0x8(%rcx),%rdx
  117e54:	48 8b 31             	mov    (%rcx),%rsi
  117e57:	48 89 8d 60 ff ff ff 	mov    %rcx,-0xa0(%rbp)
  117e5e:	e8 c8 f5 ff ff       	callq  11742b <pipe_buffer_put>
						desc->bytes_to_xfer);

		desc->buffer         += bytes_copied;
  117e63:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  117e6a:	48 01 01             	add    %rax,(%rcx)
		desc->bytes_to_xfer  -= bytes_copied;
  117e6d:	48 29 41 08          	sub    %rax,0x8(%rcx)
	}

	if (num_bytes_read == bytes_to_read) {
  117e71:	4d 39 e5             	cmp    %r12,%r13
  117e74:	75 0a                	jne    117e80 <z_impl_k_pipe_get+0x31b>
		k_sched_unlock();
  117e76:	e8 d3 9e ff ff       	callq  111d4e <k_sched_unlock>

		*bytes_read = num_bytes_read;
  117e7b:	4d 89 2f             	mov    %r13,(%r15)

		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_pipe, get, pipe, timeout, 0);

		return 0;
  117e7e:	eb 25                	jmp    117ea5 <z_impl_k_pipe_get+0x340>
	}

	if (!K_TIMEOUT_EQ(timeout, K_NO_WAIT)
  117e80:	48 83 bd 70 ff ff ff 	cmpq   $0x0,-0x90(%rbp)
  117e87:	00 
  117e88:	74 22                	je     117eac <z_impl_k_pipe_get+0x347>
	    && num_bytes_read >= min_xfer
	    && min_xfer > 0U) {
  117e8a:	4c 39 a5 78 ff ff ff 	cmp    %r12,-0x88(%rbp)
  117e91:	77 19                	ja     117eac <z_impl_k_pipe_get+0x347>
  117e93:	48 83 bd 78 ff ff ff 	cmpq   $0x0,-0x88(%rbp)
  117e9a:	00 
  117e9b:	74 0f                	je     117eac <z_impl_k_pipe_get+0x347>
		k_sched_unlock();
  117e9d:	e8 ac 9e ff ff       	callq  111d4e <k_sched_unlock>

		*bytes_read = num_bytes_read;
  117ea2:	4d 89 27             	mov    %r12,(%r15)

		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_pipe, get, pipe, timeout, 0);

		return 0;
  117ea5:	31 c0                	xor    %eax,%eax
  117ea7:	e9 47 01 00 00       	jmpq   117ff3 <z_impl_k_pipe_get+0x48e>

	/* Not all data was read */

	struct k_pipe_desc  pipe_desc;

	pipe_desc.buffer        = (uint8_t *)data + num_bytes_read;
  117eac:	48 8b b5 68 ff ff ff 	mov    -0x98(%rbp),%rsi
	pipe_desc.bytes_to_xfer = bytes_to_read - num_bytes_read;
  117eb3:	4c 89 e8             	mov    %r13,%rax
  117eb6:	4c 29 e0             	sub    %r12,%rax
	pipe_desc.buffer        = (uint8_t *)data + num_bytes_read;
  117eb9:	4c 01 e6             	add    %r12,%rsi

	if (!K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
  117ebc:	48 83 bd 70 ff ff ff 	cmpq   $0x0,-0x90(%rbp)
  117ec3:	00 
	pipe_desc.bytes_to_xfer = bytes_to_read - num_bytes_read;
  117ec4:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
	pipe_desc.buffer        = (uint8_t *)data + num_bytes_read;
  117ec8:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
	if (!K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
  117ecc:	0f 84 02 01 00 00    	je     117fd4 <z_impl_k_pipe_get+0x46f>
		_current->base.swap_data = &pipe_desc;
  117ed2:	48 8b 05 77 08 01 00 	mov    0x10877(%rip),%rax        # 128750 <_kernel+0x10>
  117ed9:	48 8d 55 a0          	lea    -0x60(%rbp),%rdx
  117edd:	48 89 50 20          	mov    %rdx,0x20(%rax)
  117ee1:	9c                   	pushfq 
  117ee2:	fa                   	cli    
  117ee3:	41 5c                	pop    %r12
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  117ee5:	4c 89 f7             	mov    %r14,%rdi
  117ee8:	e8 8c 59 ff ff       	callq  10d879 <z_spin_lock_valid>
  117eed:	84 c0                	test   %al,%al
  117eef:	75 37                	jne    117f28 <z_impl_k_pipe_get+0x3c3>
  117ef1:	b9 8e 00 00 00       	mov    $0x8e,%ecx
  117ef6:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  117efb:	be fd d1 11 00       	mov    $0x11d1fd,%esi
  117f00:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  117f05:	e8 ee 86 fe ff       	callq  1005f8 <printk>
  117f0a:	4c 89 f6             	mov    %r14,%rsi
  117f0d:	bf 12 d2 11 00       	mov    $0x11d212,%edi
  117f12:	31 c0                	xor    %eax,%eax
  117f14:	e8 df 86 fe ff       	callq  1005f8 <printk>
  117f19:	be 8e 00 00 00       	mov    $0x8e,%esi
  117f1e:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  117f23:	e8 70 ac fe ff       	callq  102b98 <assert_post_action>
	z_spin_lock_set_owner(l);
  117f28:	4c 89 f7             	mov    %r14,%rdi
  117f2b:	e8 8d 59 ff ff       	callq  10d8bd <z_spin_lock_set_owner>
	__ASSERT(!arch_is_in_isr(), "");
  117f30:	83 3d 09 08 01 00 00 	cmpl   $0x0,0x10809(%rip)        # 128740 <_kernel>
  117f37:	74 36                	je     117f6f <z_impl_k_pipe_get+0x40a>
  117f39:	be 49 f9 11 00       	mov    $0x11f949,%esi
  117f3e:	b9 07 01 00 00       	mov    $0x107,%ecx
  117f43:	ba 83 fc 11 00       	mov    $0x11fc83,%edx
  117f48:	31 c0                	xor    %eax,%eax
  117f4a:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  117f4f:	e8 a4 86 fe ff       	callq  1005f8 <printk>
  117f54:	bf 22 fc 11 00       	mov    $0x11fc22,%edi
  117f59:	31 c0                	xor    %eax,%eax
  117f5b:	e8 98 86 fe ff       	callq  1005f8 <printk>
  117f60:	be 07 01 00 00       	mov    $0x107,%esi
  117f65:	bf 83 fc 11 00       	mov    $0x11fc83,%edi
  117f6a:	e8 29 ac fe ff       	callq  102b98 <assert_post_action>
	__ASSERT(_current->base.sched_locked != 0U, "");
  117f6f:	48 8b 05 da 07 01 00 	mov    0x107da(%rip),%rax        # 128750 <_kernel+0x10>
  117f76:	80 78 1b 00          	cmpb   $0x0,0x1b(%rax)
  117f7a:	75 36                	jne    117fb2 <z_impl_k_pipe_get+0x44d>
  117f7c:	be cd fd 11 00       	mov    $0x11fdcd,%esi
  117f81:	b9 08 01 00 00       	mov    $0x108,%ecx
  117f86:	ba 83 fc 11 00       	mov    $0x11fc83,%edx
  117f8b:	31 c0                	xor    %eax,%eax
  117f8d:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  117f92:	e8 61 86 fe ff       	callq  1005f8 <printk>
  117f97:	bf 22 fc 11 00       	mov    $0x11fc22,%edi
  117f9c:	31 c0                	xor    %eax,%eax
  117f9e:	e8 55 86 fe ff       	callq  1005f8 <printk>
  117fa3:	be 08 01 00 00       	mov    $0x108,%esi
  117fa8:	bf 83 fc 11 00       	mov    $0x11fc83,%edi
  117fad:	e8 e6 ab fe ff       	callq  102b98 <assert_post_action>
	++_current->base.sched_locked;
  117fb2:	48 8b 05 97 07 01 00 	mov    0x10797(%rip),%rax        # 128750 <_kernel+0x10>
		k_spinlock_key_t key2 = k_spin_lock(&pipe->lock);

		z_sched_unlock_no_reschedule();
		(void)z_pend_curr(&pipe->lock, key2,
  117fb9:	48 8b 8d 70 ff ff ff 	mov    -0x90(%rbp),%rcx
  117fc0:	44 89 e6             	mov    %r12d,%esi
  117fc3:	4c 89 f7             	mov    %r14,%rdi
  117fc6:	48 8d 53 30          	lea    0x30(%rbx),%rdx
  117fca:	fe 40 1b             	incb   0x1b(%rax)
  117fcd:	e8 16 9a ff ff       	callq  1119e8 <z_pend_curr>
  117fd2:	eb 05                	jmp    117fd9 <z_impl_k_pipe_get+0x474>
				 &pipe->wait_q.readers, timeout);
	} else {
		k_sched_unlock();
  117fd4:	e8 75 9d ff ff       	callq  111d4e <k_sched_unlock>
	}

	*bytes_read = bytes_to_read - pipe_desc.bytes_to_xfer;
  117fd9:	4c 2b 6d a8          	sub    -0x58(%rbp),%r13
		return 0;
  117fdd:	4c 3b ad 78 ff ff ff 	cmp    -0x88(%rbp),%r13
  117fe4:	19 c0                	sbb    %eax,%eax
	*bytes_read = bytes_to_read - pipe_desc.bytes_to_xfer;
  117fe6:	4d 89 2f             	mov    %r13,(%r15)
		return 0;
  117fe9:	83 e0 f5             	and    $0xfffffff5,%eax
  117fec:	eb 05                	jmp    117ff3 <z_impl_k_pipe_get+0x48e>
		return -EINVAL;
  117fee:	b8 ea ff ff ff       	mov    $0xffffffea,%eax

	int ret = pipe_return_code(min_xfer, pipe_desc.bytes_to_xfer,
				 bytes_to_read);
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_pipe, get, pipe, timeout, ret);
	return ret;
}
  117ff3:	48 8d 65 d8          	lea    -0x28(%rbp),%rsp
  117ff7:	5b                   	pop    %rbx
  117ff8:	41 5c                	pop    %r12
  117ffa:	41 5d                	pop    %r13
  117ffc:	41 5e                	pop    %r14
  117ffe:	41 5f                	pop    %r15
  118000:	5d                   	pop    %rbp
  118001:	c3                   	retq   

0000000000118002 <z_vrfy_k_pipe_get>:

#ifdef CONFIG_USERSPACE
int z_vrfy_k_pipe_get(struct k_pipe *pipe, void *data, size_t bytes_to_read,
		      size_t *bytes_read, size_t min_xfer, k_timeout_t timeout)
{
  118002:	55                   	push   %rbp
  118003:	48 89 e5             	mov    %rsp,%rbp
  118006:	41 57                	push   %r15
  118008:	4d 89 cf             	mov    %r9,%r15
  11800b:	41 56                	push   %r14
  11800d:	49 89 d6             	mov    %rdx,%r14
  118010:	41 55                	push   %r13
  118012:	49 89 f5             	mov    %rsi,%r13
  118015:	41 54                	push   %r12
  118017:	49 89 fc             	mov    %rdi,%r12
  11801a:	53                   	push   %rbx
  11801b:	4c 89 c3             	mov    %r8,%rbx
  11801e:	48 83 ec 18          	sub    $0x18,%rsp
  118022:	48 89 4d c8          	mov    %rcx,-0x38(%rbp)
	Z_OOPS(Z_SYSCALL_OBJ(pipe, K_OBJ_PIPE));
  118026:	e8 a9 ea ff ff       	callq  116ad4 <z_object_find>
  11802b:	31 d2                	xor    %edx,%edx
  11802d:	4c 89 e6             	mov    %r12,%rsi
  118030:	48 89 c7             	mov    %rax,%rdi
  118033:	e8 b9 f5 ff ff       	callq  1175f1 <z_obj_validation_check.constprop.0>
  118038:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  11803c:	85 c0                	test   %eax,%eax
  11803e:	74 18                	je     118058 <z_vrfy_k_pipe_get+0x56>
  118040:	ba 80 c7 11 00       	mov    $0x11c780,%edx
  118045:	be 45 00 00 00       	mov    $0x45,%esi
  11804a:	bf 23 f3 11 00       	mov    $0x11f323,%edi
  11804f:	31 c0                	xor    %eax,%eax
  118051:	e8 70 b0 fe ff       	callq  1030c6 <z_log_minimal_printk>
  118056:	eb 40                	jmp    118098 <z_vrfy_k_pipe_get+0x96>
	Z_OOPS(Z_SYSCALL_MEMORY_WRITE(bytes_read, sizeof(*bytes_read)));
  118058:	48 89 cf             	mov    %rcx,%rdi
  11805b:	ba 01 00 00 00       	mov    $0x1,%edx
  118060:	be 08 00 00 00       	mov    $0x8,%esi
  118065:	48 89 4d c8          	mov    %rcx,-0x38(%rbp)
  118069:	e8 4e 13 ff ff       	callq  1093bc <arch_buffer_validate>
  11806e:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  118072:	85 c0                	test   %eax,%eax
  118074:	74 35                	je     1180ab <z_vrfy_k_pipe_get+0xa9>
  118076:	41 b9 a4 d2 11 00    	mov    $0x11d2a4,%r9d
  11807c:	41 b8 08 00 00 00    	mov    $0x8,%r8d
  118082:	ba 80 c7 11 00       	mov    $0x11c780,%edx
  118087:	be 45 00 00 00       	mov    $0x45,%esi
  11808c:	bf 1e cf 11 00       	mov    $0x11cf1e,%edi
  118091:	31 c0                	xor    %eax,%eax
  118093:	e8 2e b0 fe ff       	callq  1030c6 <z_log_minimal_printk>
  118098:	48 8b 05 b1 06 01 00 	mov    0x106b1(%rip),%rax        # 128750 <_kernel+0x10>
  11809f:	48 8b b8 40 01 00 00 	mov    0x140(%rax),%rdi
  1180a6:	e8 62 1b ff ff       	callq  109c0d <arch_syscall_oops>
	Z_OOPS(Z_SYSCALL_MEMORY_WRITE((void *)data, bytes_to_read));
  1180ab:	ba 01 00 00 00       	mov    $0x1,%edx
  1180b0:	4c 89 f6             	mov    %r14,%rsi
  1180b3:	4c 89 ef             	mov    %r13,%rdi
  1180b6:	48 89 4d c8          	mov    %rcx,-0x38(%rbp)
  1180ba:	e8 fd 12 ff ff       	callq  1093bc <arch_buffer_validate>
  1180bf:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  1180c3:	85 c0                	test   %eax,%eax
  1180c5:	74 0e                	je     1180d5 <z_vrfy_k_pipe_get+0xd3>
  1180c7:	41 b9 a4 d2 11 00    	mov    $0x11d2a4,%r9d
  1180cd:	4d 89 f0             	mov    %r14,%r8
  1180d0:	4c 89 e9             	mov    %r13,%rcx
  1180d3:	eb ad                	jmp    118082 <z_vrfy_k_pipe_get+0x80>

	return z_impl_k_pipe_get((struct k_pipe *)pipe, (void *)data,
				bytes_to_read, bytes_read, min_xfer,
				timeout);
}
  1180d5:	48 83 c4 18          	add    $0x18,%rsp
	return z_impl_k_pipe_get((struct k_pipe *)pipe, (void *)data,
  1180d9:	4d 89 f9             	mov    %r15,%r9
  1180dc:	49 89 d8             	mov    %rbx,%r8
  1180df:	4c 89 f2             	mov    %r14,%rdx
}
  1180e2:	5b                   	pop    %rbx
	return z_impl_k_pipe_get((struct k_pipe *)pipe, (void *)data,
  1180e3:	4c 89 ee             	mov    %r13,%rsi
  1180e6:	4c 89 e7             	mov    %r12,%rdi
}
  1180e9:	41 5c                	pop    %r12
  1180eb:	41 5d                	pop    %r13
  1180ed:	41 5e                	pop    %r14
  1180ef:	41 5f                	pop    %r15
  1180f1:	5d                   	pop    %rbp
	return z_impl_k_pipe_get((struct k_pipe *)pipe, (void *)data,
  1180f2:	e9 6e fa ff ff       	jmpq   117b65 <z_impl_k_pipe_get>

00000000001180f7 <z_mrsh_k_pipe_get>:
#include <syscalls/kernel.h>

extern int z_vrfy_k_pipe_get(struct k_pipe * pipe, void * data, size_t bytes_to_read, size_t * bytes_read, size_t min_xfer, k_timeout_t timeout);
uintptr_t z_mrsh_k_pipe_get(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
  1180f7:	55                   	push   %rbp
  1180f8:	48 89 e5             	mov    %rsp,%rbp
  1180fb:	48 83 ec 10          	sub    $0x10,%rsp
	_current->syscall_frame = ssf;
  1180ff:	48 8b 05 4a 06 01 00 	mov    0x1064a(%rip),%rax        # 128750 <_kernel+0x10>
  118106:	4c 8b 55 10          	mov    0x10(%rbp),%r10
{
  11810a:	4c 89 4d f8          	mov    %r9,-0x8(%rbp)
	_current->syscall_frame = ssf;
  11810e:	4c 89 90 40 01 00 00 	mov    %r10,0x140(%rax)
	int ret = z_vrfy_k_pipe_get(*(struct k_pipe **)&arg0, *(void **)&arg1, *(size_t*)&arg2, *(size_t **)&arg3, *(size_t*)&arg4, *(k_timeout_t*)&arg5)
  118115:	e8 e8 fe ff ff       	callq  118002 <z_vrfy_k_pipe_get>
;
	_current->syscall_frame = NULL;
  11811a:	48 8b 15 2f 06 01 00 	mov    0x1062f(%rip),%rdx        # 128750 <_kernel+0x10>
	return (uintptr_t) ret;
  118121:	48 98                	cltq   
	_current->syscall_frame = NULL;
  118123:	48 c7 82 40 01 00 00 	movq   $0x0,0x140(%rdx)
  11812a:	00 00 00 00 
}
  11812e:	c9                   	leaveq 
  11812f:	c3                   	retq   

0000000000118130 <z_impl_k_pipe_put>:
#endif

int z_impl_k_pipe_put(struct k_pipe *pipe, void *data, size_t bytes_to_write,
		     size_t *bytes_written, size_t min_xfer,
		      k_timeout_t timeout)
{
  118130:	55                   	push   %rbp
  118131:	48 89 e5             	mov    %rsp,%rbp
	return z_pipe_put_internal(pipe, NULL, data,
  118134:	50                   	push   %rax
  118135:	41 51                	push   %r9
  118137:	4d 89 c1             	mov    %r8,%r9
  11813a:	49 89 c8             	mov    %rcx,%r8
  11813d:	48 89 d1             	mov    %rdx,%rcx
  118140:	48 89 f2             	mov    %rsi,%rdx
  118143:	31 f6                	xor    %esi,%esi
  118145:	e8 a4 f6 ff ff       	callq  1177ee <z_pipe_put_internal>
  11814a:	5a                   	pop    %rdx
  11814b:	59                   	pop    %rcx
				    bytes_to_write, bytes_written,
				    min_xfer, timeout);
}
  11814c:	c9                   	leaveq 
  11814d:	c3                   	retq   

000000000011814e <z_vrfy_k_pipe_put>:

#ifdef CONFIG_USERSPACE
int z_vrfy_k_pipe_put(struct k_pipe *pipe, void *data, size_t bytes_to_write,
		     size_t *bytes_written, size_t min_xfer,
		      k_timeout_t timeout)
{
  11814e:	55                   	push   %rbp
  11814f:	48 89 e5             	mov    %rsp,%rbp
  118152:	41 57                	push   %r15
  118154:	4d 89 cf             	mov    %r9,%r15
  118157:	41 56                	push   %r14
  118159:	49 89 d6             	mov    %rdx,%r14
  11815c:	41 55                	push   %r13
  11815e:	49 89 f5             	mov    %rsi,%r13
  118161:	41 54                	push   %r12
  118163:	49 89 fc             	mov    %rdi,%r12
  118166:	53                   	push   %rbx
  118167:	4c 89 c3             	mov    %r8,%rbx
  11816a:	48 83 ec 18          	sub    $0x18,%rsp
  11816e:	48 89 4d c8          	mov    %rcx,-0x38(%rbp)
	Z_OOPS(Z_SYSCALL_OBJ(pipe, K_OBJ_PIPE));
  118172:	e8 5d e9 ff ff       	callq  116ad4 <z_object_find>
  118177:	31 d2                	xor    %edx,%edx
  118179:	4c 89 e6             	mov    %r12,%rsi
  11817c:	48 89 c7             	mov    %rax,%rdi
  11817f:	e8 6d f4 ff ff       	callq  1175f1 <z_obj_validation_check.constprop.0>
  118184:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  118188:	85 c0                	test   %eax,%eax
  11818a:	74 18                	je     1181a4 <z_vrfy_k_pipe_put+0x56>
  11818c:	ba 60 c7 11 00       	mov    $0x11c760,%edx
  118191:	be 45 00 00 00       	mov    $0x45,%esi
  118196:	bf 23 f3 11 00       	mov    $0x11f323,%edi
  11819b:	31 c0                	xor    %eax,%eax
  11819d:	e8 24 af fe ff       	callq  1030c6 <z_log_minimal_printk>
  1181a2:	eb 40                	jmp    1181e4 <z_vrfy_k_pipe_put+0x96>
	Z_OOPS(Z_SYSCALL_MEMORY_WRITE(bytes_written, sizeof(*bytes_written)));
  1181a4:	48 89 cf             	mov    %rcx,%rdi
  1181a7:	ba 01 00 00 00       	mov    $0x1,%edx
  1181ac:	be 08 00 00 00       	mov    $0x8,%esi
  1181b1:	48 89 4d c8          	mov    %rcx,-0x38(%rbp)
  1181b5:	e8 02 12 ff ff       	callq  1093bc <arch_buffer_validate>
  1181ba:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  1181be:	85 c0                	test   %eax,%eax
  1181c0:	74 35                	je     1181f7 <z_vrfy_k_pipe_put+0xa9>
  1181c2:	41 b9 a4 d2 11 00    	mov    $0x11d2a4,%r9d
  1181c8:	41 b8 08 00 00 00    	mov    $0x8,%r8d
  1181ce:	ba 60 c7 11 00       	mov    $0x11c760,%edx
  1181d3:	be 45 00 00 00       	mov    $0x45,%esi
  1181d8:	bf 1e cf 11 00       	mov    $0x11cf1e,%edi
  1181dd:	31 c0                	xor    %eax,%eax
  1181df:	e8 e2 ae fe ff       	callq  1030c6 <z_log_minimal_printk>
  1181e4:	48 8b 05 65 05 01 00 	mov    0x10565(%rip),%rax        # 128750 <_kernel+0x10>
  1181eb:	48 8b b8 40 01 00 00 	mov    0x140(%rax),%rdi
  1181f2:	e8 16 1a ff ff       	callq  109c0d <arch_syscall_oops>
	Z_OOPS(Z_SYSCALL_MEMORY_READ((void *)data, bytes_to_write));
  1181f7:	31 d2                	xor    %edx,%edx
  1181f9:	4c 89 f6             	mov    %r14,%rsi
  1181fc:	4c 89 ef             	mov    %r13,%rdi
  1181ff:	48 89 4d c8          	mov    %rcx,-0x38(%rbp)
  118203:	e8 b4 11 ff ff       	callq  1093bc <arch_buffer_validate>
  118208:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  11820c:	85 c0                	test   %eax,%eax
  11820e:	74 0e                	je     11821e <z_vrfy_k_pipe_put+0xd0>
  118210:	41 b9 de 0d 12 00    	mov    $0x120dde,%r9d
  118216:	4d 89 f0             	mov    %r14,%r8
  118219:	4c 89 e9             	mov    %r13,%rcx
  11821c:	eb b0                	jmp    1181ce <z_vrfy_k_pipe_put+0x80>

	return z_impl_k_pipe_put((struct k_pipe *)pipe, (void *)data,
				bytes_to_write, bytes_written, min_xfer,
				timeout);
}
  11821e:	48 83 c4 18          	add    $0x18,%rsp
	return z_impl_k_pipe_put((struct k_pipe *)pipe, (void *)data,
  118222:	4d 89 f9             	mov    %r15,%r9
  118225:	49 89 d8             	mov    %rbx,%r8
  118228:	4c 89 f2             	mov    %r14,%rdx
}
  11822b:	5b                   	pop    %rbx
	return z_impl_k_pipe_put((struct k_pipe *)pipe, (void *)data,
  11822c:	4c 89 ee             	mov    %r13,%rsi
  11822f:	4c 89 e7             	mov    %r12,%rdi
}
  118232:	41 5c                	pop    %r12
  118234:	41 5d                	pop    %r13
  118236:	41 5e                	pop    %r14
  118238:	41 5f                	pop    %r15
  11823a:	5d                   	pop    %rbp
	return z_impl_k_pipe_put((struct k_pipe *)pipe, (void *)data,
  11823b:	e9 f0 fe ff ff       	jmpq   118130 <z_impl_k_pipe_put>

0000000000118240 <z_mrsh_k_pipe_put>:
#include <syscalls/kernel.h>

extern int z_vrfy_k_pipe_put(struct k_pipe * pipe, void * data, size_t bytes_to_write, size_t * bytes_written, size_t min_xfer, k_timeout_t timeout);
uintptr_t z_mrsh_k_pipe_put(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
  118240:	55                   	push   %rbp
  118241:	48 89 e5             	mov    %rsp,%rbp
  118244:	48 83 ec 10          	sub    $0x10,%rsp
	_current->syscall_frame = ssf;
  118248:	48 8b 05 01 05 01 00 	mov    0x10501(%rip),%rax        # 128750 <_kernel+0x10>
  11824f:	4c 8b 55 10          	mov    0x10(%rbp),%r10
{
  118253:	4c 89 4d f8          	mov    %r9,-0x8(%rbp)
	_current->syscall_frame = ssf;
  118257:	4c 89 90 40 01 00 00 	mov    %r10,0x140(%rax)
	int ret = z_vrfy_k_pipe_put(*(struct k_pipe **)&arg0, *(void **)&arg1, *(size_t*)&arg2, *(size_t **)&arg3, *(size_t*)&arg4, *(k_timeout_t*)&arg5)
  11825e:	e8 eb fe ff ff       	callq  11814e <z_vrfy_k_pipe_put>
;
	_current->syscall_frame = NULL;
  118263:	48 8b 15 e6 04 01 00 	mov    0x104e6(%rip),%rdx        # 128750 <_kernel+0x10>
	return (uintptr_t) ret;
  11826a:	48 98                	cltq   
	_current->syscall_frame = NULL;
  11826c:	48 c7 82 40 01 00 00 	movq   $0x0,0x140(%rdx)
  118273:	00 00 00 00 
}
  118277:	c9                   	leaveq 
  118278:	c3                   	retq   

0000000000118279 <z_impl_k_pipe_read_avail>:
#include <syscalls/k_pipe_put_mrsh.c>
#endif

size_t z_impl_k_pipe_read_avail(struct k_pipe *pipe)
{
  118279:	55                   	push   %rbp
  11827a:	48 89 e5             	mov    %rsp,%rbp
  11827d:	41 56                	push   %r14
  11827f:	41 55                	push   %r13
  118281:	41 54                	push   %r12
	size_t res;
	k_spinlock_key_t key;

	/* Buffer and size are fixed. No need to spin. */
	if (pipe->buffer == NULL || pipe->size == 0U) {
		res = 0;
  118283:	45 31 e4             	xor    %r12d,%r12d
{
  118286:	53                   	push   %rbx
	if (pipe->buffer == NULL || pipe->size == 0U) {
  118287:	48 83 3f 00          	cmpq   $0x0,(%rdi)
  11828b:	0f 84 c8 00 00 00    	je     118359 <z_impl_k_pipe_read_avail+0xe0>
  118291:	4c 8b 67 08          	mov    0x8(%rdi),%r12
  118295:	49 89 fe             	mov    %rdi,%r14
  118298:	4d 85 e4             	test   %r12,%r12
  11829b:	0f 84 b8 00 00 00    	je     118359 <z_impl_k_pipe_read_avail+0xe0>
		goto out;
	}

	key = k_spin_lock(&pipe->lock);
  1182a1:	4c 8d 6f 28          	lea    0x28(%rdi),%r13
  1182a5:	9c                   	pushfq 
  1182a6:	fa                   	cli    
  1182a7:	5b                   	pop    %rbx
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  1182a8:	4c 89 ef             	mov    %r13,%rdi
  1182ab:	e8 c9 55 ff ff       	callq  10d879 <z_spin_lock_valid>
  1182b0:	84 c0                	test   %al,%al
  1182b2:	75 37                	jne    1182eb <z_impl_k_pipe_read_avail+0x72>
  1182b4:	b9 8e 00 00 00       	mov    $0x8e,%ecx
  1182b9:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  1182be:	be fd d1 11 00       	mov    $0x11d1fd,%esi
  1182c3:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  1182c8:	e8 2b 83 fe ff       	callq  1005f8 <printk>
  1182cd:	4c 89 ee             	mov    %r13,%rsi
  1182d0:	bf 12 d2 11 00       	mov    $0x11d212,%edi
  1182d5:	31 c0                	xor    %eax,%eax
  1182d7:	e8 1c 83 fe ff       	callq  1005f8 <printk>
  1182dc:	be 8e 00 00 00       	mov    $0x8e,%esi
  1182e1:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  1182e6:	e8 ad a8 fe ff       	callq  102b98 <assert_post_action>
	z_spin_lock_set_owner(l);
  1182eb:	4c 89 ef             	mov    %r13,%rdi
  1182ee:	e8 ca 55 ff ff       	callq  10d8bd <z_spin_lock_set_owner>

	if (pipe->read_index == pipe->write_index) {
  1182f3:	49 8b 46 18          	mov    0x18(%r14),%rax
  1182f7:	4d 8b 66 20          	mov    0x20(%r14),%r12
  1182fb:	4c 39 e0             	cmp    %r12,%rax
  1182fe:	75 06                	jne    118306 <z_impl_k_pipe_read_avail+0x8d>
		res = pipe->bytes_used;
  118300:	4d 8b 66 10          	mov    0x10(%r14),%r12
  118304:	eb 09                	jmp    11830f <z_impl_k_pipe_read_avail+0x96>
	} else if (pipe->read_index < pipe->write_index) {
  118306:	72 04                	jb     11830c <z_impl_k_pipe_read_avail+0x93>
		res = pipe->write_index - pipe->read_index;
	} else {
		res = pipe->size - (pipe->read_index - pipe->write_index);
  118308:	4d 03 66 08          	add    0x8(%r14),%r12
  11830c:	49 29 c4             	sub    %rax,%r12
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  11830f:	4c 89 ef             	mov    %r13,%rdi
  118312:	e8 82 55 ff ff       	callq  10d899 <z_spin_unlock_valid>
  118317:	84 c0                	test   %al,%al
  118319:	75 37                	jne    118352 <z_impl_k_pipe_read_avail+0xd9>
  11831b:	b9 b9 00 00 00       	mov    $0xb9,%ecx
  118320:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  118325:	be 41 d2 11 00       	mov    $0x11d241,%esi
  11832a:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  11832f:	e8 c4 82 fe ff       	callq  1005f8 <printk>
  118334:	4c 89 ee             	mov    %r13,%rsi
  118337:	bf 58 d2 11 00       	mov    $0x11d258,%edi
  11833c:	31 c0                	xor    %eax,%eax
  11833e:	e8 b5 82 fe ff       	callq  1005f8 <printk>
  118343:	be b9 00 00 00       	mov    $0xb9,%esi
  118348:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  11834d:	e8 46 a8 fe ff       	callq  102b98 <assert_post_action>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  118352:	0f ba e3 09          	bt     $0x9,%ebx
  118356:	73 01                	jae    118359 <z_impl_k_pipe_read_avail+0xe0>
		__asm__ volatile ("sti" ::: "memory");
  118358:	fb                   	sti    

	k_spin_unlock(&pipe->lock, key);

out:
	return res;
}
  118359:	5b                   	pop    %rbx
  11835a:	4c 89 e0             	mov    %r12,%rax
  11835d:	41 5c                	pop    %r12
  11835f:	41 5d                	pop    %r13
  118361:	41 5e                	pop    %r14
  118363:	5d                   	pop    %rbp
  118364:	c3                   	retq   

0000000000118365 <z_vrfy_k_pipe_read_avail>:

#ifdef CONFIG_USERSPACE
size_t z_vrfy_k_pipe_read_avail(struct k_pipe *pipe)
{
  118365:	55                   	push   %rbp
  118366:	48 89 e5             	mov    %rsp,%rbp
  118369:	41 54                	push   %r12
  11836b:	49 89 fc             	mov    %rdi,%r12
  11836e:	52                   	push   %rdx
	Z_OOPS(Z_SYSCALL_OBJ(pipe, K_OBJ_PIPE));
  11836f:	e8 60 e7 ff ff       	callq  116ad4 <z_object_find>
  118374:	31 d2                	xor    %edx,%edx
  118376:	4c 89 e6             	mov    %r12,%rsi
  118379:	48 89 c7             	mov    %rax,%rdi
  11837c:	e8 70 f2 ff ff       	callq  1175f1 <z_obj_validation_check.constprop.0>
  118381:	85 c0                	test   %eax,%eax
  118383:	74 29                	je     1183ae <z_vrfy_k_pipe_read_avail+0x49>
  118385:	bf 23 f3 11 00       	mov    $0x11f323,%edi
  11838a:	31 c0                	xor    %eax,%eax
  11838c:	ba 40 c7 11 00       	mov    $0x11c740,%edx
  118391:	be 45 00 00 00       	mov    $0x45,%esi
  118396:	e8 2b ad fe ff       	callq  1030c6 <z_log_minimal_printk>
  11839b:	48 8b 05 ae 03 01 00 	mov    0x103ae(%rip),%rax        # 128750 <_kernel+0x10>
  1183a2:	48 8b b8 40 01 00 00 	mov    0x140(%rax),%rdi
  1183a9:	e8 5f 18 ff ff       	callq  109c0d <arch_syscall_oops>

	return z_impl_k_pipe_read_avail(pipe);
}
  1183ae:	58                   	pop    %rax
	return z_impl_k_pipe_read_avail(pipe);
  1183af:	4c 89 e7             	mov    %r12,%rdi
}
  1183b2:	41 5c                	pop    %r12
  1183b4:	5d                   	pop    %rbp
	return z_impl_k_pipe_read_avail(pipe);
  1183b5:	e9 bf fe ff ff       	jmpq   118279 <z_impl_k_pipe_read_avail>

00000000001183ba <z_mrsh_k_pipe_read_avail>:
#include <syscalls/kernel.h>

extern size_t z_vrfy_k_pipe_read_avail(struct k_pipe * pipe);
uintptr_t z_mrsh_k_pipe_read_avail(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
  1183ba:	55                   	push   %rbp
	_current->syscall_frame = ssf;
  1183bb:	48 8b 05 8e 03 01 00 	mov    0x1038e(%rip),%rax        # 128750 <_kernel+0x10>
{
  1183c2:	48 89 e5             	mov    %rsp,%rbp
	_current->syscall_frame = ssf;
  1183c5:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  1183c9:	48 89 90 40 01 00 00 	mov    %rdx,0x140(%rax)
	(void) arg1;	/* unused */
	(void) arg2;	/* unused */
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	size_t ret = z_vrfy_k_pipe_read_avail(*(struct k_pipe **)&arg0)
  1183d0:	e8 90 ff ff ff       	callq  118365 <z_vrfy_k_pipe_read_avail>
;
	_current->syscall_frame = NULL;
  1183d5:	48 8b 15 74 03 01 00 	mov    0x10374(%rip),%rdx        # 128750 <_kernel+0x10>
  1183dc:	48 c7 82 40 01 00 00 	movq   $0x0,0x140(%rdx)
  1183e3:	00 00 00 00 
	return (uintptr_t) ret;
}
  1183e7:	5d                   	pop    %rbp
  1183e8:	c3                   	retq   

00000000001183e9 <z_impl_k_pipe_write_avail>:
#include <syscalls/k_pipe_read_avail_mrsh.c>
#endif

size_t z_impl_k_pipe_write_avail(struct k_pipe *pipe)
{
  1183e9:	55                   	push   %rbp
  1183ea:	48 89 e5             	mov    %rsp,%rbp
  1183ed:	41 56                	push   %r14
  1183ef:	41 55                	push   %r13
  1183f1:	41 54                	push   %r12
	size_t res;
	k_spinlock_key_t key;

	/* Buffer and size are fixed. No need to spin. */
	if (pipe->buffer == NULL || pipe->size == 0U) {
		res = 0;
  1183f3:	45 31 e4             	xor    %r12d,%r12d
{
  1183f6:	53                   	push   %rbx
	if (pipe->buffer == NULL || pipe->size == 0U) {
  1183f7:	48 83 3f 00          	cmpq   $0x0,(%rdi)
  1183fb:	0f 84 cc 00 00 00    	je     1184cd <z_impl_k_pipe_write_avail+0xe4>
  118401:	4c 8b 67 08          	mov    0x8(%rdi),%r12
  118405:	49 89 fe             	mov    %rdi,%r14
  118408:	4d 85 e4             	test   %r12,%r12
  11840b:	0f 84 bc 00 00 00    	je     1184cd <z_impl_k_pipe_write_avail+0xe4>
		goto out;
	}

	key = k_spin_lock(&pipe->lock);
  118411:	4c 8d 6f 28          	lea    0x28(%rdi),%r13
  118415:	9c                   	pushfq 
  118416:	fa                   	cli    
  118417:	5b                   	pop    %rbx
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  118418:	4c 89 ef             	mov    %r13,%rdi
  11841b:	e8 59 54 ff ff       	callq  10d879 <z_spin_lock_valid>
  118420:	84 c0                	test   %al,%al
  118422:	75 37                	jne    11845b <z_impl_k_pipe_write_avail+0x72>
  118424:	b9 8e 00 00 00       	mov    $0x8e,%ecx
  118429:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  11842e:	be fd d1 11 00       	mov    $0x11d1fd,%esi
  118433:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  118438:	e8 bb 81 fe ff       	callq  1005f8 <printk>
  11843d:	4c 89 ee             	mov    %r13,%rsi
  118440:	bf 12 d2 11 00       	mov    $0x11d212,%edi
  118445:	31 c0                	xor    %eax,%eax
  118447:	e8 ac 81 fe ff       	callq  1005f8 <printk>
  11844c:	be 8e 00 00 00       	mov    $0x8e,%esi
  118451:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  118456:	e8 3d a7 fe ff       	callq  102b98 <assert_post_action>
	z_spin_lock_set_owner(l);
  11845b:	4c 89 ef             	mov    %r13,%rdi
  11845e:	e8 5a 54 ff ff       	callq  10d8bd <z_spin_lock_set_owner>

	if (pipe->write_index == pipe->read_index) {
  118463:	49 8b 46 20          	mov    0x20(%r14),%rax
  118467:	4d 8b 66 18          	mov    0x18(%r14),%r12
  11846b:	4c 39 e0             	cmp    %r12,%rax
  11846e:	75 0a                	jne    11847a <z_impl_k_pipe_write_avail+0x91>
		res = pipe->size - pipe->bytes_used;
  118470:	4d 8b 66 08          	mov    0x8(%r14),%r12
  118474:	4d 2b 66 10          	sub    0x10(%r14),%r12
  118478:	eb 09                	jmp    118483 <z_impl_k_pipe_write_avail+0x9a>
	} else if (pipe->write_index < pipe->read_index) {
  11847a:	72 04                	jb     118480 <z_impl_k_pipe_write_avail+0x97>
		res = pipe->read_index - pipe->write_index;
	} else {
		res = pipe->size - (pipe->write_index - pipe->read_index);
  11847c:	4d 03 66 08          	add    0x8(%r14),%r12
  118480:	49 29 c4             	sub    %rax,%r12
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  118483:	4c 89 ef             	mov    %r13,%rdi
  118486:	e8 0e 54 ff ff       	callq  10d899 <z_spin_unlock_valid>
  11848b:	84 c0                	test   %al,%al
  11848d:	75 37                	jne    1184c6 <z_impl_k_pipe_write_avail+0xdd>
  11848f:	b9 b9 00 00 00       	mov    $0xb9,%ecx
  118494:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  118499:	be 41 d2 11 00       	mov    $0x11d241,%esi
  11849e:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  1184a3:	e8 50 81 fe ff       	callq  1005f8 <printk>
  1184a8:	4c 89 ee             	mov    %r13,%rsi
  1184ab:	bf 58 d2 11 00       	mov    $0x11d258,%edi
  1184b0:	31 c0                	xor    %eax,%eax
  1184b2:	e8 41 81 fe ff       	callq  1005f8 <printk>
  1184b7:	be b9 00 00 00       	mov    $0xb9,%esi
  1184bc:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  1184c1:	e8 d2 a6 fe ff       	callq  102b98 <assert_post_action>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  1184c6:	0f ba e3 09          	bt     $0x9,%ebx
  1184ca:	73 01                	jae    1184cd <z_impl_k_pipe_write_avail+0xe4>
		__asm__ volatile ("sti" ::: "memory");
  1184cc:	fb                   	sti    

	k_spin_unlock(&pipe->lock, key);

out:
	return res;
}
  1184cd:	5b                   	pop    %rbx
  1184ce:	4c 89 e0             	mov    %r12,%rax
  1184d1:	41 5c                	pop    %r12
  1184d3:	41 5d                	pop    %r13
  1184d5:	41 5e                	pop    %r14
  1184d7:	5d                   	pop    %rbp
  1184d8:	c3                   	retq   

00000000001184d9 <z_vrfy_k_pipe_write_avail>:

#ifdef CONFIG_USERSPACE
size_t z_vrfy_k_pipe_write_avail(struct k_pipe *pipe)
{
  1184d9:	55                   	push   %rbp
  1184da:	48 89 e5             	mov    %rsp,%rbp
  1184dd:	41 54                	push   %r12
  1184df:	49 89 fc             	mov    %rdi,%r12
  1184e2:	52                   	push   %rdx
	Z_OOPS(Z_SYSCALL_OBJ(pipe, K_OBJ_PIPE));
  1184e3:	e8 ec e5 ff ff       	callq  116ad4 <z_object_find>
  1184e8:	31 d2                	xor    %edx,%edx
  1184ea:	4c 89 e6             	mov    %r12,%rsi
  1184ed:	48 89 c7             	mov    %rax,%rdi
  1184f0:	e8 fc f0 ff ff       	callq  1175f1 <z_obj_validation_check.constprop.0>
  1184f5:	85 c0                	test   %eax,%eax
  1184f7:	74 29                	je     118522 <z_vrfy_k_pipe_write_avail+0x49>
  1184f9:	bf 23 f3 11 00       	mov    $0x11f323,%edi
  1184fe:	31 c0                	xor    %eax,%eax
  118500:	ba 20 c7 11 00       	mov    $0x11c720,%edx
  118505:	be 45 00 00 00       	mov    $0x45,%esi
  11850a:	e8 b7 ab fe ff       	callq  1030c6 <z_log_minimal_printk>
	Z_OOPS(Z_SYSCALL_OBJ(pipe, K_OBJ_PIPE));
  11850f:	48 8b 05 3a 02 01 00 	mov    0x1023a(%rip),%rax        # 128750 <_kernel+0x10>
  118516:	48 8b b8 40 01 00 00 	mov    0x140(%rax),%rdi
  11851d:	e8 eb 16 ff ff       	callq  109c0d <arch_syscall_oops>

	return z_impl_k_pipe_write_avail(pipe);
}
  118522:	58                   	pop    %rax
	return z_impl_k_pipe_write_avail(pipe);
  118523:	4c 89 e7             	mov    %r12,%rdi
}
  118526:	41 5c                	pop    %r12
  118528:	5d                   	pop    %rbp
	return z_impl_k_pipe_write_avail(pipe);
  118529:	e9 bb fe ff ff       	jmpq   1183e9 <z_impl_k_pipe_write_avail>

000000000011852e <z_mrsh_k_pipe_write_avail>:
#include <syscalls/kernel.h>

extern size_t z_vrfy_k_pipe_write_avail(struct k_pipe * pipe);
uintptr_t z_mrsh_k_pipe_write_avail(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
  11852e:	55                   	push   %rbp
	_current->syscall_frame = ssf;
  11852f:	48 8b 05 1a 02 01 00 	mov    0x1021a(%rip),%rax        # 128750 <_kernel+0x10>
{
  118536:	48 89 e5             	mov    %rsp,%rbp
	_current->syscall_frame = ssf;
  118539:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  11853d:	48 89 90 40 01 00 00 	mov    %rdx,0x140(%rax)
	(void) arg1;	/* unused */
	(void) arg2;	/* unused */
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	size_t ret = z_vrfy_k_pipe_write_avail(*(struct k_pipe **)&arg0)
  118544:	e8 90 ff ff ff       	callq  1184d9 <z_vrfy_k_pipe_write_avail>
;
	_current->syscall_frame = NULL;
  118549:	48 8b 15 00 02 01 00 	mov    0x10200(%rip),%rdx        # 128750 <_kernel+0x10>
  118550:	48 c7 82 40 01 00 00 	movq   $0x0,0x140(%rdx)
  118557:	00 00 00 00 
	return (uintptr_t) ret;
}
  11855b:	5d                   	pop    %rbp
  11855c:	c3                   	retq   

000000000011855d <z_obj_validation_check.constprop.0>:
static inline int z_obj_validation_check(struct z_object *ko,
  11855d:	55                   	push   %rbp
  11855e:	48 89 e5             	mov    %rsp,%rbp
  118561:	41 56                	push   %r14
  118563:	49 89 f6             	mov    %rsi,%r14
	ret = z_object_validate(ko, otype, init);
  118566:	be 08 00 00 00       	mov    $0x8,%esi
static inline int z_obj_validation_check(struct z_object *ko,
  11856b:	41 55                	push   %r13
  11856d:	49 89 fd             	mov    %rdi,%r13
  118570:	48 83 ec 10          	sub    $0x10,%rsp
	ret = z_object_validate(ko, otype, init);
  118574:	e8 f3 e9 ff ff       	callq  116f6c <z_object_validate>
	if (ret != 0) {
  118579:	85 c0                	test   %eax,%eax
  11857b:	74 18                	je     118595 <z_obj_validation_check.constprop.0+0x38>
		z_dump_object_error(ret, obj, ko, otype);
  11857d:	89 c7                	mov    %eax,%edi
  11857f:	b9 08 00 00 00       	mov    $0x8,%ecx
  118584:	4c 89 ea             	mov    %r13,%rdx
  118587:	4c 89 f6             	mov    %r14,%rsi
  11858a:	89 45 ec             	mov    %eax,-0x14(%rbp)
  11858d:	e8 8f e8 ff ff       	callq  116e21 <z_dump_object_error>
  118592:	8b 45 ec             	mov    -0x14(%rbp),%eax
}
  118595:	5a                   	pop    %rdx
  118596:	59                   	pop    %rcx
  118597:	41 5d                	pop    %r13
  118599:	41 5e                	pop    %r14
  11859b:	5d                   	pop    %rbp
  11859c:	c3                   	retq   

000000000011859d <k_stack_init>:
		  uint32_t num_entries)
{
	z_waitq_init(&stack->wait_q);
	stack->lock = (struct k_spinlock) {};
	stack->next = stack->base = buffer;
	stack->top = stack->base + num_entries;
  11859d:	89 d2                	mov    %edx,%edx
	list->head = (sys_dnode_t *)list;
  11859f:	48 89 3f             	mov    %rdi,(%rdi)
  1185a2:	48 8d 04 d6          	lea    (%rsi,%rdx,8),%rax
	list->tail = (sys_dnode_t *)list;
  1185a6:	48 89 7f 08          	mov    %rdi,0x8(%rdi)
	stack->lock = (struct k_spinlock) {};
  1185aa:	48 c7 47 10 00 00 00 	movq   $0x0,0x10(%rdi)
  1185b1:	00 
	stack->next = stack->base = buffer;
  1185b2:	48 89 77 18          	mov    %rsi,0x18(%rdi)
  1185b6:	48 89 77 20          	mov    %rsi,0x20(%rdi)
	stack->top = stack->base + num_entries;
  1185ba:	48 89 47 28          	mov    %rax,0x28(%rdi)

	SYS_PORT_TRACING_OBJ_INIT(k_stack, stack);
	z_object_init(stack);
  1185be:	e9 2e ea ff ff       	jmpq   116ff1 <z_object_init>

00000000001185c3 <z_impl_k_stack_alloc_init>:
}

int32_t z_impl_k_stack_alloc_init(struct k_stack *stack, uint32_t num_entries)
{
  1185c3:	55                   	push   %rbp
  1185c4:	89 f6                	mov    %esi,%esi
  1185c6:	48 89 e5             	mov    %rsp,%rbp
  1185c9:	41 54                	push   %r12
  1185cb:	49 89 f4             	mov    %rsi,%r12
	void *buffer;
	int32_t ret;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_stack, alloc_init, stack);

	buffer = z_thread_malloc(num_entries * sizeof(stack_data_t));
  1185ce:	48 c1 e6 03          	shl    $0x3,%rsi
{
  1185d2:	53                   	push   %rbx
  1185d3:	48 89 fb             	mov    %rdi,%rbx
  1185d6:	31 ff                	xor    %edi,%edi
  1185d8:	e8 93 d4 ff ff       	callq  115a70 <z_thread_aligned_alloc>
  1185dd:	48 89 c6             	mov    %rax,%rsi
	if (buffer != NULL) {
  1185e0:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
  1185e5:	48 85 f6             	test   %rsi,%rsi
  1185e8:	74 11                	je     1185fb <z_impl_k_stack_alloc_init+0x38>
		k_stack_init(stack, buffer, num_entries);
  1185ea:	44 89 e2             	mov    %r12d,%edx
  1185ed:	48 89 df             	mov    %rbx,%rdi
  1185f0:	e8 a8 ff ff ff       	callq  11859d <k_stack_init>
		stack->flags = K_STACK_FLAG_ALLOC;
  1185f5:	c6 43 30 01          	movb   $0x1,0x30(%rbx)
		ret = (int32_t)0;
  1185f9:	31 c0                	xor    %eax,%eax
	}

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_stack, alloc_init, stack, ret);

	return ret;
}
  1185fb:	5b                   	pop    %rbx
  1185fc:	41 5c                	pop    %r12
  1185fe:	5d                   	pop    %rbp
  1185ff:	c3                   	retq   

0000000000118600 <z_mrsh_k_stack_alloc_init>:
#include <syscalls/kernel.h>

extern int32_t z_vrfy_k_stack_alloc_init(struct k_stack * stack, uint32_t num_entries);
uintptr_t z_mrsh_k_stack_alloc_init(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
  118600:	55                   	push   %rbp
	_current->syscall_frame = ssf;
  118601:	48 8b 05 48 01 01 00 	mov    0x10148(%rip),%rax        # 128750 <_kernel+0x10>
{
  118608:	48 89 e5             	mov    %rsp,%rbp
  11860b:	41 54                	push   %r12
  11860d:	49 89 fc             	mov    %rdi,%r12
	_current->syscall_frame = ssf;
  118610:	48 8b 55 10          	mov    0x10(%rbp),%rdx
{
  118614:	53                   	push   %rbx
  118615:	48 89 f3             	mov    %rsi,%rbx
	_current->syscall_frame = ssf;
  118618:	48 89 90 40 01 00 00 	mov    %rdx,0x140(%rax)

#ifdef CONFIG_USERSPACE
static inline int32_t z_vrfy_k_stack_alloc_init(struct k_stack *stack,
					      uint32_t num_entries)
{
	Z_OOPS(Z_SYSCALL_OBJ_NEVER_INIT(stack, K_OBJ_STACK));
  11861f:	e8 b0 e4 ff ff       	callq  116ad4 <z_object_find>
  118624:	83 ca ff             	or     $0xffffffff,%edx
  118627:	4c 89 e6             	mov    %r12,%rsi
  11862a:	48 89 c7             	mov    %rax,%rdi
  11862d:	e8 2b ff ff ff       	callq  11855d <z_obj_validation_check.constprop.0>
  118632:	85 c0                	test   %eax,%eax
  118634:	74 11                	je     118647 <z_mrsh_k_stack_alloc_init+0x47>
  118636:	ba 00 c8 11 00       	mov    $0x11c800,%edx
  11863b:	be 45 00 00 00       	mov    $0x45,%esi
  118640:	bf 23 f3 11 00       	mov    $0x11f323,%edi
  118645:	eb 13                	jmp    11865a <z_mrsh_k_stack_alloc_init+0x5a>
	Z_OOPS(Z_SYSCALL_VERIFY(num_entries > 0));
  118647:	85 db                	test   %ebx,%ebx
  118649:	75 29                	jne    118674 <z_mrsh_k_stack_alloc_init+0x74>
  11864b:	ba 00 c8 11 00       	mov    $0x11c800,%edx
  118650:	be 45 00 00 00       	mov    $0x45,%esi
  118655:	bf 62 10 12 00       	mov    $0x121062,%edi
  11865a:	31 c0                	xor    %eax,%eax
  11865c:	e8 65 aa fe ff       	callq  1030c6 <z_log_minimal_printk>
  118661:	48 8b 05 e8 00 01 00 	mov    0x100e8(%rip),%rax        # 128750 <_kernel+0x10>
  118668:	48 8b b8 40 01 00 00 	mov    0x140(%rax),%rdi
  11866f:	e8 99 15 ff ff       	callq  109c0d <arch_syscall_oops>
	return z_impl_k_stack_alloc_init(stack, num_entries);
  118674:	89 de                	mov    %ebx,%esi
  118676:	4c 89 e7             	mov    %r12,%rdi
  118679:	e8 45 ff ff ff       	callq  1185c3 <z_impl_k_stack_alloc_init>
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	int32_t ret = z_vrfy_k_stack_alloc_init(*(struct k_stack **)&arg0, *(uint32_t*)&arg1)
;
	_current->syscall_frame = NULL;
  11867e:	48 8b 15 cb 00 01 00 	mov    0x100cb(%rip),%rdx        # 128750 <_kernel+0x10>
	return (uintptr_t) ret;
  118685:	48 98                	cltq   
	_current->syscall_frame = NULL;
  118687:	48 c7 82 40 01 00 00 	movq   $0x0,0x140(%rdx)
  11868e:	00 00 00 00 
}
  118692:	5b                   	pop    %rbx
  118693:	41 5c                	pop    %r12
  118695:	5d                   	pop    %rbp
  118696:	c3                   	retq   

0000000000118697 <k_stack_cleanup>:
}
#include <syscalls/k_stack_alloc_init_mrsh.c>
#endif

int k_stack_cleanup(struct k_stack *stack)
{
  118697:	55                   	push   %rbp
  118698:	48 89 e5             	mov    %rsp,%rbp
  11869b:	41 54                	push   %r12
  11869d:	53                   	push   %rbx
	return list->head == list;
  11869e:	48 8b 07             	mov    (%rdi),%rax
  1186a1:	48 89 fb             	mov    %rdi,%rbx
	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_stack, cleanup, stack);

	CHECKIF(z_waitq_head(&stack->wait_q) != NULL) {
  1186a4:	48 39 c7             	cmp    %rax,%rdi
  1186a7:	74 0b                	je     1186b4 <k_stack_cleanup+0x1d>
		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_stack, cleanup, stack, -EAGAIN);

		return -EAGAIN;
  1186a9:	41 bc f5 ff ff ff    	mov    $0xfffffff5,%r12d
	CHECKIF(z_waitq_head(&stack->wait_q) != NULL) {
  1186af:	48 85 c0             	test   %rax,%rax
  1186b2:	75 1e                	jne    1186d2 <k_stack_cleanup+0x3b>
		stack->flags &= ~K_STACK_FLAG_ALLOC;
	}

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_stack, cleanup, stack, 0);

	return 0;
  1186b4:	45 31 e4             	xor    %r12d,%r12d
	if ((stack->flags & K_STACK_FLAG_ALLOC) != (uint8_t)0) {
  1186b7:	f6 43 30 01          	testb  $0x1,0x30(%rbx)
  1186bb:	74 15                	je     1186d2 <k_stack_cleanup+0x3b>
		k_free(stack->base);
  1186bd:	48 8b 7b 18          	mov    0x18(%rbx),%rdi
  1186c1:	e8 97 d3 ff ff       	callq  115a5d <k_free>
		stack->flags &= ~K_STACK_FLAG_ALLOC;
  1186c6:	80 63 30 fe          	andb   $0xfe,0x30(%rbx)
		stack->base = NULL;
  1186ca:	48 c7 43 18 00 00 00 	movq   $0x0,0x18(%rbx)
  1186d1:	00 
}
  1186d2:	44 89 e0             	mov    %r12d,%eax
  1186d5:	5b                   	pop    %rbx
  1186d6:	41 5c                	pop    %r12
  1186d8:	5d                   	pop    %rbp
  1186d9:	c3                   	retq   

00000000001186da <z_impl_k_stack_push>:

int z_impl_k_stack_push(struct k_stack *stack, stack_data_t data)
{
  1186da:	55                   	push   %rbp
  1186db:	48 89 e5             	mov    %rsp,%rbp
  1186de:	41 56                	push   %r14
  1186e0:	41 55                	push   %r13
  1186e2:	49 89 f5             	mov    %rsi,%r13
  1186e5:	41 54                	push   %r12
	struct k_thread *first_pending_thread;
	int ret = 0;
	k_spinlock_key_t key = k_spin_lock(&stack->lock);
  1186e7:	4c 8d 67 10          	lea    0x10(%rdi),%r12
{
  1186eb:	53                   	push   %rbx
  1186ec:	48 89 fb             	mov    %rdi,%rbx
  1186ef:	9c                   	pushfq 
  1186f0:	fa                   	cli    
  1186f1:	41 5e                	pop    %r14
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  1186f3:	4c 89 e7             	mov    %r12,%rdi
  1186f6:	e8 7e 51 ff ff       	callq  10d879 <z_spin_lock_valid>
  1186fb:	84 c0                	test   %al,%al
  1186fd:	75 37                	jne    118736 <z_impl_k_stack_push+0x5c>
  1186ff:	b9 8e 00 00 00       	mov    $0x8e,%ecx
  118704:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  118709:	be fd d1 11 00       	mov    $0x11d1fd,%esi
  11870e:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  118713:	e8 e0 7e fe ff       	callq  1005f8 <printk>
  118718:	4c 89 e6             	mov    %r12,%rsi
  11871b:	bf 12 d2 11 00       	mov    $0x11d212,%edi
  118720:	31 c0                	xor    %eax,%eax
  118722:	e8 d1 7e fe ff       	callq  1005f8 <printk>
  118727:	be 8e 00 00 00       	mov    $0x8e,%esi
  11872c:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  118731:	e8 62 a4 fe ff       	callq  102b98 <assert_post_action>
	z_spin_lock_set_owner(l);
  118736:	4c 89 e7             	mov    %r12,%rdi
  118739:	e8 7f 51 ff ff       	callq  10d8bd <z_spin_lock_set_owner>

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_stack, push, stack);

	CHECKIF(stack->next == stack->top) {
  11873e:	48 8b 43 28          	mov    0x28(%rbx),%rax
  118742:	48 39 43 20          	cmp    %rax,0x20(%rbx)
  118746:	74 47                	je     11878f <z_impl_k_stack_push+0xb5>
		ret = -ENOMEM;
		goto out;
	}

	first_pending_thread = z_unpend_first_thread(&stack->wait_q);
  118748:	48 89 df             	mov    %rbx,%rdi
  11874b:	e8 0d 98 ff ff       	callq  111f5d <z_unpend_first_thread>
  118750:	48 89 c7             	mov    %rax,%rdi

	if (first_pending_thread != NULL) {
  118753:	48 85 c0             	test   %rax,%rax
  118756:	74 23                	je     11877b <z_impl_k_stack_push+0xa1>
	thread->base.swap_data = data;
  118758:	4c 89 68 20          	mov    %r13,0x20(%rax)
	int ret = 0;
  11875c:	45 31 ed             	xor    %r13d,%r13d
	thread->swap_retval = value;
  11875f:	c7 80 48 01 00 00 00 	movl   $0x0,0x148(%rax)
  118766:	00 00 00 
		z_thread_return_value_set_with_data(first_pending_thread,
						   0, (void *)data);

		z_ready_thread(first_pending_thread);
  118769:	e8 dc 8c ff ff       	callq  11144a <z_ready_thread>
		z_reschedule(&stack->lock, key);
  11876e:	44 89 f6             	mov    %r14d,%esi
  118771:	4c 89 e7             	mov    %r12,%rdi
  118774:	e8 e8 85 ff ff       	callq  110d61 <z_reschedule>
		goto end;
  118779:	eb 65                	jmp    1187e0 <z_impl_k_stack_push+0x106>
	} else {
		*(stack->next) = data;
  11877b:	48 8b 43 20          	mov    0x20(%rbx),%rax
  11877f:	4c 89 28             	mov    %r13,(%rax)
		stack->next++;
  118782:	48 83 c0 08          	add    $0x8,%rax
	int ret = 0;
  118786:	45 31 ed             	xor    %r13d,%r13d
		stack->next++;
  118789:	48 89 43 20          	mov    %rax,0x20(%rbx)
		goto out;
  11878d:	eb 06                	jmp    118795 <z_impl_k_stack_push+0xbb>
		ret = -ENOMEM;
  11878f:	41 bd f4 ff ff ff    	mov    $0xfffffff4,%r13d
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  118795:	4c 89 e7             	mov    %r12,%rdi
  118798:	e8 fc 50 ff ff       	callq  10d899 <z_spin_unlock_valid>
  11879d:	84 c0                	test   %al,%al
  11879f:	75 37                	jne    1187d8 <z_impl_k_stack_push+0xfe>
  1187a1:	b9 b9 00 00 00       	mov    $0xb9,%ecx
  1187a6:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  1187ab:	be 41 d2 11 00       	mov    $0x11d241,%esi
  1187b0:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  1187b5:	e8 3e 7e fe ff       	callq  1005f8 <printk>
  1187ba:	4c 89 e6             	mov    %r12,%rsi
  1187bd:	bf 58 d2 11 00       	mov    $0x11d258,%edi
  1187c2:	31 c0                	xor    %eax,%eax
  1187c4:	e8 2f 7e fe ff       	callq  1005f8 <printk>
  1187c9:	be b9 00 00 00       	mov    $0xb9,%esi
  1187ce:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  1187d3:	e8 c0 a3 fe ff       	callq  102b98 <assert_post_action>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  1187d8:	41 0f ba e6 09       	bt     $0x9,%r14d
  1187dd:	73 01                	jae    1187e0 <z_impl_k_stack_push+0x106>
		__asm__ volatile ("sti" ::: "memory");
  1187df:	fb                   	sti    

end:
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_stack, push, stack, ret);

	return ret;
}
  1187e0:	5b                   	pop    %rbx
  1187e1:	44 89 e8             	mov    %r13d,%eax
  1187e4:	41 5c                	pop    %r12
  1187e6:	41 5d                	pop    %r13
  1187e8:	41 5e                	pop    %r14
  1187ea:	5d                   	pop    %rbp
  1187eb:	c3                   	retq   

00000000001187ec <z_mrsh_k_stack_push>:
#include <syscalls/kernel.h>

extern int z_vrfy_k_stack_push(struct k_stack * stack, stack_data_t data);
uintptr_t z_mrsh_k_stack_push(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
  1187ec:	55                   	push   %rbp
	_current->syscall_frame = ssf;
  1187ed:	48 8b 05 5c ff 00 00 	mov    0xff5c(%rip),%rax        # 128750 <_kernel+0x10>
{
  1187f4:	48 89 e5             	mov    %rsp,%rbp
  1187f7:	41 55                	push   %r13
  1187f9:	49 89 f5             	mov    %rsi,%r13
	_current->syscall_frame = ssf;
  1187fc:	48 8b 55 10          	mov    0x10(%rbp),%rdx
{
  118800:	41 54                	push   %r12
  118802:	49 89 fc             	mov    %rdi,%r12
	_current->syscall_frame = ssf;
  118805:	48 89 90 40 01 00 00 	mov    %rdx,0x140(%rax)

#ifdef CONFIG_USERSPACE
static inline int z_vrfy_k_stack_push(struct k_stack *stack, stack_data_t data)
{
	Z_OOPS(Z_SYSCALL_OBJ(stack, K_OBJ_STACK));
  11880c:	e8 c3 e2 ff ff       	callq  116ad4 <z_object_find>
  118811:	31 d2                	xor    %edx,%edx
  118813:	4c 89 e6             	mov    %r12,%rsi
  118816:	48 89 c7             	mov    %rax,%rdi
  118819:	e8 3f fd ff ff       	callq  11855d <z_obj_validation_check.constprop.0>
  11881e:	85 c0                	test   %eax,%eax
  118820:	74 29                	je     11884b <z_mrsh_k_stack_push+0x5f>
  118822:	bf 23 f3 11 00       	mov    $0x11f323,%edi
  118827:	31 c0                	xor    %eax,%eax
  118829:	ba e0 c7 11 00       	mov    $0x11c7e0,%edx
  11882e:	be 45 00 00 00       	mov    $0x45,%esi
  118833:	e8 8e a8 fe ff       	callq  1030c6 <z_log_minimal_printk>
  118838:	48 8b 05 11 ff 00 00 	mov    0xff11(%rip),%rax        # 128750 <_kernel+0x10>
  11883f:	48 8b b8 40 01 00 00 	mov    0x140(%rax),%rdi
  118846:	e8 c2 13 ff ff       	callq  109c0d <arch_syscall_oops>

	return z_impl_k_stack_push(stack, data);
  11884b:	4c 89 ee             	mov    %r13,%rsi
  11884e:	4c 89 e7             	mov    %r12,%rdi
  118851:	e8 84 fe ff ff       	callq  1186da <z_impl_k_stack_push>
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	int ret = z_vrfy_k_stack_push(*(struct k_stack **)&arg0, *(stack_data_t*)&arg1)
;
	_current->syscall_frame = NULL;
  118856:	48 8b 15 f3 fe 00 00 	mov    0xfef3(%rip),%rdx        # 128750 <_kernel+0x10>
	return (uintptr_t) ret;
  11885d:	48 98                	cltq   
	_current->syscall_frame = NULL;
  11885f:	48 c7 82 40 01 00 00 	movq   $0x0,0x140(%rdx)
  118866:	00 00 00 00 
}
  11886a:	41 5c                	pop    %r12
  11886c:	41 5d                	pop    %r13
  11886e:	5d                   	pop    %rbp
  11886f:	c3                   	retq   

0000000000118870 <z_impl_k_stack_pop>:
#include <syscalls/k_stack_push_mrsh.c>
#endif

int z_impl_k_stack_pop(struct k_stack *stack, stack_data_t *data,
		       k_timeout_t timeout)
{
  118870:	55                   	push   %rbp
  118871:	48 89 e5             	mov    %rsp,%rbp
  118874:	41 57                	push   %r15
  118876:	49 89 d7             	mov    %rdx,%r15
  118879:	41 56                	push   %r14
  11887b:	41 55                	push   %r13
  11887d:	49 89 fd             	mov    %rdi,%r13
  118880:	41 54                	push   %r12
	k_spinlock_key_t key;
	int result;

	key = k_spin_lock(&stack->lock);
  118882:	4c 8d 67 10          	lea    0x10(%rdi),%r12
{
  118886:	53                   	push   %rbx
  118887:	48 89 f3             	mov    %rsi,%rbx
  11888a:	51                   	push   %rcx
  11888b:	9c                   	pushfq 
  11888c:	fa                   	cli    
  11888d:	41 5e                	pop    %r14
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  11888f:	4c 89 e7             	mov    %r12,%rdi
  118892:	e8 e2 4f ff ff       	callq  10d879 <z_spin_lock_valid>
  118897:	84 c0                	test   %al,%al
  118899:	75 37                	jne    1188d2 <z_impl_k_stack_pop+0x62>
  11889b:	b9 8e 00 00 00       	mov    $0x8e,%ecx
  1188a0:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  1188a5:	be fd d1 11 00       	mov    $0x11d1fd,%esi
  1188aa:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  1188af:	e8 44 7d fe ff       	callq  1005f8 <printk>
  1188b4:	4c 89 e6             	mov    %r12,%rsi
  1188b7:	bf 12 d2 11 00       	mov    $0x11d212,%edi
  1188bc:	31 c0                	xor    %eax,%eax
  1188be:	e8 35 7d fe ff       	callq  1005f8 <printk>
  1188c3:	be 8e 00 00 00       	mov    $0x8e,%esi
  1188c8:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  1188cd:	e8 c6 a2 fe ff       	callq  102b98 <assert_post_action>
	z_spin_lock_set_owner(l);
  1188d2:	4c 89 e7             	mov    %r12,%rdi
  1188d5:	e8 e3 4f ff ff       	callq  10d8bd <z_spin_lock_set_owner>

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_stack, pop, stack, timeout);

	if (likely(stack->next > stack->base)) {
  1188da:	49 8b 45 20          	mov    0x20(%r13),%rax
  1188de:	49 3b 45 18          	cmp    0x18(%r13),%rax
  1188e2:	76 56                	jbe    11893a <z_impl_k_stack_pop+0xca>
		stack->next--;
  1188e4:	48 8d 50 f8          	lea    -0x8(%rax),%rdx
		*data = *(stack->next);
  1188e8:	48 8b 40 f8          	mov    -0x8(%rax),%rax
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  1188ec:	4c 89 e7             	mov    %r12,%rdi
		stack->next--;
  1188ef:	49 89 55 20          	mov    %rdx,0x20(%r13)
		*data = *(stack->next);
  1188f3:	48 89 03             	mov    %rax,(%rbx)
  1188f6:	e8 9e 4f ff ff       	callq  10d899 <z_spin_unlock_valid>
  1188fb:	84 c0                	test   %al,%al
  1188fd:	75 37                	jne    118936 <z_impl_k_stack_pop+0xc6>
  1188ff:	b9 b9 00 00 00       	mov    $0xb9,%ecx
  118904:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  118909:	be 41 d2 11 00       	mov    $0x11d241,%esi
  11890e:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  118913:	e8 e0 7c fe ff       	callq  1005f8 <printk>
  118918:	4c 89 e6             	mov    %r12,%rsi
  11891b:	bf 58 d2 11 00       	mov    $0x11d258,%edi
  118920:	31 c0                	xor    %eax,%eax
  118922:	e8 d1 7c fe ff       	callq  1005f8 <printk>
  118927:	be b9 00 00 00       	mov    $0xb9,%esi
  11892c:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  118931:	e8 62 a2 fe ff       	callq  102b98 <assert_post_action>
		k_spin_unlock(&stack->lock, key);

		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_stack, pop, stack, timeout, 0);

		return 0;
  118936:	31 c0                	xor    %eax,%eax
  118938:	eb 4d                	jmp    118987 <z_impl_k_stack_pop+0x117>
	}

	SYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_stack, pop, stack, timeout);

	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
  11893a:	4d 85 ff             	test   %r15,%r15
  11893d:	75 52                	jne    118991 <z_impl_k_stack_pop+0x121>
  11893f:	4c 89 e7             	mov    %r12,%rdi
  118942:	e8 52 4f ff ff       	callq  10d899 <z_spin_unlock_valid>
  118947:	84 c0                	test   %al,%al
  118949:	75 37                	jne    118982 <z_impl_k_stack_pop+0x112>
  11894b:	b9 b9 00 00 00       	mov    $0xb9,%ecx
  118950:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  118955:	be 41 d2 11 00       	mov    $0x11d241,%esi
  11895a:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  11895f:	e8 94 7c fe ff       	callq  1005f8 <printk>
  118964:	4c 89 e6             	mov    %r12,%rsi
  118967:	bf 58 d2 11 00       	mov    $0x11d258,%edi
  11896c:	31 c0                	xor    %eax,%eax
  11896e:	e8 85 7c fe ff       	callq  1005f8 <printk>
  118973:	be b9 00 00 00       	mov    $0xb9,%esi
  118978:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  11897d:	e8 16 a2 fe ff       	callq  102b98 <assert_post_action>
		k_spin_unlock(&stack->lock, key);

		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_stack, pop, stack, timeout, -EBUSY);

		return -EBUSY;
  118982:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  118987:	41 0f ba e6 09       	bt     $0x9,%r14d
  11898c:	73 29                	jae    1189b7 <z_impl_k_stack_pop+0x147>
		__asm__ volatile ("sti" ::: "memory");
  11898e:	fb                   	sti    
  11898f:	eb 26                	jmp    1189b7 <z_impl_k_stack_pop+0x147>
	}

	result = z_pend_curr(&stack->lock, key, &stack->wait_q, timeout);
  118991:	4c 89 f9             	mov    %r15,%rcx
  118994:	4c 89 ea             	mov    %r13,%rdx
  118997:	44 89 f6             	mov    %r14d,%esi
  11899a:	4c 89 e7             	mov    %r12,%rdi
  11899d:	e8 46 90 ff ff       	callq  1119e8 <z_pend_curr>
	if (result == -EAGAIN) {
  1189a2:	83 f8 f5             	cmp    $0xfffffff5,%eax
  1189a5:	74 10                	je     1189b7 <z_impl_k_stack_pop+0x147>
		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_stack, pop, stack, timeout, -EAGAIN);

		return -EAGAIN;
	}

	*data = (stack_data_t)_current->base.swap_data;
  1189a7:	48 8b 05 a2 fd 00 00 	mov    0xfda2(%rip),%rax        # 128750 <_kernel+0x10>
  1189ae:	48 8b 40 20          	mov    0x20(%rax),%rax
  1189b2:	48 89 03             	mov    %rax,(%rbx)

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_stack, pop, stack, timeout, 0);

	return 0;
  1189b5:	31 c0                	xor    %eax,%eax
}
  1189b7:	5a                   	pop    %rdx
  1189b8:	5b                   	pop    %rbx
  1189b9:	41 5c                	pop    %r12
  1189bb:	41 5d                	pop    %r13
  1189bd:	41 5e                	pop    %r14
  1189bf:	41 5f                	pop    %r15
  1189c1:	5d                   	pop    %rbp
  1189c2:	c3                   	retq   

00000000001189c3 <z_mrsh_k_stack_pop>:
#include <syscalls/kernel.h>

extern int z_vrfy_k_stack_pop(struct k_stack * stack, stack_data_t * data, k_timeout_t timeout);
uintptr_t z_mrsh_k_stack_pop(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
  1189c3:	55                   	push   %rbp
  1189c4:	48 89 e5             	mov    %rsp,%rbp
  1189c7:	41 56                	push   %r14
  1189c9:	49 89 d6             	mov    %rdx,%r14
  1189cc:	41 55                	push   %r13
  1189ce:	49 89 fd             	mov    %rdi,%r13
  1189d1:	41 54                	push   %r12
  1189d3:	49 89 f4             	mov    %rsi,%r12
  1189d6:	48 83 ec 18          	sub    $0x18,%rsp
  1189da:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	_current->syscall_frame = ssf;
  1189de:	48 8b 05 6b fd 00 00 	mov    0xfd6b(%rip),%rax        # 128750 <_kernel+0x10>
  1189e5:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  1189e9:	48 89 90 40 01 00 00 	mov    %rdx,0x140(%rax)

#ifdef CONFIG_USERSPACE
static inline int z_vrfy_k_stack_pop(struct k_stack *stack,
				     stack_data_t *data, k_timeout_t timeout)
{
	Z_OOPS(Z_SYSCALL_OBJ(stack, K_OBJ_STACK));
  1189f0:	e8 df e0 ff ff       	callq  116ad4 <z_object_find>
  1189f5:	31 d2                	xor    %edx,%edx
  1189f7:	4c 89 ee             	mov    %r13,%rsi
  1189fa:	48 89 c7             	mov    %rax,%rdi
  1189fd:	e8 5b fb ff ff       	callq  11855d <z_obj_validation_check.constprop.0>
  118a02:	85 c0                	test   %eax,%eax
  118a04:	74 18                	je     118a1e <z_mrsh_k_stack_pop+0x5b>
  118a06:	ba c0 c7 11 00       	mov    $0x11c7c0,%edx
  118a0b:	be 45 00 00 00       	mov    $0x45,%esi
  118a10:	bf 23 f3 11 00       	mov    $0x11f323,%edi
  118a15:	31 c0                	xor    %eax,%eax
  118a17:	e8 aa a6 fe ff       	callq  1030c6 <z_log_minimal_printk>
  118a1c:	eb 3b                	jmp    118a59 <z_mrsh_k_stack_pop+0x96>
	Z_OOPS(Z_SYSCALL_MEMORY_WRITE(data, sizeof(stack_data_t)));
  118a1e:	ba 01 00 00 00       	mov    $0x1,%edx
  118a23:	be 08 00 00 00       	mov    $0x8,%esi
  118a28:	4c 89 e7             	mov    %r12,%rdi
  118a2b:	e8 8c 09 ff ff       	callq  1093bc <arch_buffer_validate>
  118a30:	85 c0                	test   %eax,%eax
  118a32:	74 38                	je     118a6c <z_mrsh_k_stack_pop+0xa9>
  118a34:	41 b9 a4 d2 11 00    	mov    $0x11d2a4,%r9d
  118a3a:	4c 89 e1             	mov    %r12,%rcx
  118a3d:	ba c0 c7 11 00       	mov    $0x11c7c0,%edx
  118a42:	31 c0                	xor    %eax,%eax
  118a44:	41 b8 08 00 00 00    	mov    $0x8,%r8d
  118a4a:	be 45 00 00 00       	mov    $0x45,%esi
  118a4f:	bf 1e cf 11 00       	mov    $0x11cf1e,%edi
  118a54:	e8 6d a6 fe ff       	callq  1030c6 <z_log_minimal_printk>
  118a59:	48 8b 05 f0 fc 00 00 	mov    0xfcf0(%rip),%rax        # 128750 <_kernel+0x10>
  118a60:	48 8b b8 40 01 00 00 	mov    0x140(%rax),%rdi
  118a67:	e8 a1 11 ff ff       	callq  109c0d <arch_syscall_oops>
	return z_impl_k_stack_pop(stack, data, timeout);
  118a6c:	4c 89 f2             	mov    %r14,%rdx
  118a6f:	4c 89 e6             	mov    %r12,%rsi
  118a72:	4c 89 ef             	mov    %r13,%rdi
  118a75:	e8 f6 fd ff ff       	callq  118870 <z_impl_k_stack_pop>
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	int ret = z_vrfy_k_stack_pop(*(struct k_stack **)&arg0, *(stack_data_t **)&arg1, *(k_timeout_t*)&arg2)
;
	_current->syscall_frame = NULL;
  118a7a:	48 8b 15 cf fc 00 00 	mov    0xfccf(%rip),%rdx        # 128750 <_kernel+0x10>
	return (uintptr_t) ret;
  118a81:	48 98                	cltq   
	_current->syscall_frame = NULL;
  118a83:	48 c7 82 40 01 00 00 	movq   $0x0,0x140(%rdx)
  118a8a:	00 00 00 00 
}
  118a8e:	48 83 c4 18          	add    $0x18,%rsp
  118a92:	41 5c                	pop    %r12
  118a94:	41 5d                	pop    %r13
  118a96:	41 5e                	pop    %r14
  118a98:	5d                   	pop    %rbp
  118a99:	c3                   	retq   

0000000000118a9a <k_sys_work_q_init>:
			     CONFIG_SYSTEM_WORKQUEUE_STACK_SIZE);

struct k_work_q k_sys_work_q;

static int k_sys_work_q_init(const struct device *dev)
{
  118a9a:	55                   	push   %rbp
	struct k_work_queue_config cfg = {
		.name = "sysworkq",
		.no_yield = IS_ENABLED(CONFIG_SYSTEM_WORKQUEUE_NO_YIELD),
	};

	k_work_queue_start(&k_sys_work_q,
  118a9b:	83 c9 ff             	or     $0xffffffff,%ecx
  118a9e:	ba 00 20 00 00       	mov    $0x2000,%edx
  118aa3:	be 00 20 5d 00       	mov    $0x5d2000,%esi
  118aa8:	bf c0 c8 1b 00       	mov    $0x1bc8c0,%edi
{
  118aad:	48 89 e5             	mov    %rsp,%rbp
  118ab0:	48 83 ec 10          	sub    $0x10,%rsp
	k_work_queue_start(&k_sys_work_q,
  118ab4:	4c 8d 45 f0          	lea    -0x10(%rbp),%r8
	struct k_work_queue_config cfg = {
  118ab8:	48 c7 45 f0 90 10 12 	movq   $0x121090,-0x10(%rbp)
  118abf:	00 
  118ac0:	c6 45 f8 00          	movb   $0x0,-0x8(%rbp)
	k_work_queue_start(&k_sys_work_q,
  118ac4:	e8 7c 05 00 00       	callq  119045 <k_work_queue_start>
			    sys_work_q_stack,
			    K_KERNEL_STACK_SIZEOF(sys_work_q_stack),
			    CONFIG_SYSTEM_WORKQUEUE_PRIORITY, &cfg);
	return 0;
}
  118ac9:	31 c0                	xor    %eax,%eax
  118acb:	c9                   	leaveq 
  118acc:	c3                   	retq   

0000000000118acd <flag_test_and_clear>:
}

static inline bool flag_test(const uint32_t *flagp,
			     uint32_t bit)
{
	return (*flagp & BIT(bit)) != 0U;
  118acd:	8b 07                	mov    (%rdi),%eax
}

static inline bool flag_test_and_clear(uint32_t *flagp,
				       int bit)
{
  118acf:	89 f1                	mov    %esi,%ecx
	*flagp &= ~BIT(bit);
  118ad1:	48 c7 c2 fe ff ff ff 	mov    $0xfffffffffffffffe,%rdx
  118ad8:	48 d3 c2             	rol    %cl,%rdx
  118adb:	21 c2                	and    %eax,%edx
	return (*flagp & BIT(bit)) != 0U;
  118add:	48 d3 e8             	shr    %cl,%rax
	*flagp &= ~BIT(bit);
  118ae0:	89 17                	mov    %edx,(%rdi)
	return (*flagp & BIT(bit)) != 0U;
  118ae2:	83 e0 01             	and    $0x1,%eax
	bool ret = flag_test(flagp, bit);

	flag_clear(flagp, bit);

	return ret;
}
  118ae5:	c3                   	retq   

0000000000118ae6 <notify_queue_locked.isra.0>:
 */
static inline bool notify_queue_locked(struct k_work_q *queue)
{
	bool rv = false;

	if (queue != NULL) {
  118ae6:	48 85 ff             	test   %rdi,%rdi
  118ae9:	74 10                	je     118afb <notify_queue_locked.isra.0+0x15>
		rv = z_sched_wake(&queue->notifyq, 0, NULL);
  118aeb:	48 81 c7 f0 03 00 00 	add    $0x3f0,%rdi
  118af2:	31 d2                	xor    %edx,%edx
  118af4:	31 f6                	xor    %esi,%esi
  118af6:	e9 e7 a0 ff ff       	jmpq   112be2 <z_sched_wake>
	}

	return rv;
}
  118afb:	c3                   	retq   

0000000000118afc <work_queue_main>:
/* Loop executed by a work queue thread.
 *
 * @param workq_ptr pointer to the work queue structure
 */
static void work_queue_main(void *workq_ptr, void *p2, void *p3)
{
  118afc:	55                   	push   %rbp
  118afd:	48 89 e5             	mov    %rsp,%rbp
  118b00:	41 57                	push   %r15
  118b02:	41 56                	push   %r14
  118b04:	41 55                	push   %r13
  118b06:	41 54                	push   %r12
  118b08:	53                   	push   %rbx
  118b09:	48 89 fb             	mov    %rdi,%rbx
  118b0c:	50                   	push   %rax
  118b0d:	9c                   	pushfq 
  118b0e:	fa                   	cli    
  118b0f:	41 5d                	pop    %r13
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  118b11:	bf 18 ce 1b 00       	mov    $0x1bce18,%edi
  118b16:	e8 5e 4d ff ff       	callq  10d879 <z_spin_lock_valid>
  118b1b:	84 c0                	test   %al,%al
  118b1d:	75 39                	jne    118b58 <work_queue_main+0x5c>
  118b1f:	b9 8e 00 00 00       	mov    $0x8e,%ecx
  118b24:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  118b29:	be fd d1 11 00       	mov    $0x11d1fd,%esi
  118b2e:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  118b33:	e8 c0 7a fe ff       	callq  1005f8 <printk>
  118b38:	be 18 ce 1b 00       	mov    $0x1bce18,%esi
  118b3d:	bf 12 d2 11 00       	mov    $0x11d212,%edi
  118b42:	31 c0                	xor    %eax,%eax
  118b44:	e8 af 7a fe ff       	callq  1005f8 <printk>
  118b49:	be 8e 00 00 00       	mov    $0x8e,%esi
  118b4e:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  118b53:	e8 40 a0 fe ff       	callq  102b98 <assert_post_action>
	z_spin_lock_set_owner(l);
  118b58:	bf 18 ce 1b 00       	mov    $0x1bce18,%edi
  118b5d:	e8 5b 4d ff ff       	callq  10d8bd <z_spin_lock_set_owner>
	return list->head;
  118b62:	4c 8b a3 e0 03 00 00 	mov    0x3e0(%rbx),%r12
 *
 * @return A pointer to the first node of the list (or NULL if empty)
 */
static inline sys_snode_t *sys_slist_get(sys_slist_t *list);

Z_GENLIST_GET(slist, snode)
  118b69:	4d 85 e4             	test   %r12,%r12
  118b6c:	75 35                	jne    118ba3 <work_queue_main+0xa7>
			 * which should never happen, even line 'if (work != NULL)'
			 * ensures that.
			 * This means that if node is not NULL, then work will not be NULL.
			 */
			handler = work->handler;
		} else if (flag_test_and_clear(&queue->flags,
  118b6e:	48 8d bb 10 04 00 00 	lea    0x410(%rbx),%rdi
  118b75:	be 02 00 00 00       	mov    $0x2,%esi
  118b7a:	e8 4e ff ff ff       	callq  118acd <flag_test_and_clear>
  118b7f:	84 c0                	test   %al,%al
  118b81:	75 3d                	jne    118bc0 <work_queue_main+0xc4>
			 * the lock, and we didn't find work nor got asked to
			 * stop.  Just go to sleep: when something happens the
			 * work thread will be woken and we can check again.
			 */

			(void)z_sched_wait(&lock, key, &queue->notifyq,
  118b83:	45 31 c0             	xor    %r8d,%r8d
  118b86:	48 83 c9 ff          	or     $0xffffffffffffffff,%rcx
  118b8a:	44 89 ee             	mov    %r13d,%esi
  118b8d:	bf 18 ce 1b 00       	mov    $0x1bce18,%edi
  118b92:	48 8d 93 f0 03 00 00 	lea    0x3f0(%rbx),%rdx
  118b99:	e8 49 a1 ff ff       	callq  112ce7 <z_sched_wait>
					   K_FOREVER, NULL);
			continue;
  118b9e:	e9 6a ff ff ff       	jmpq   118b0d <work_queue_main+0x11>
	return node->next;
  118ba3:	49 8b 04 24          	mov    (%r12),%rax
	list->head = node;
  118ba7:	48 89 83 e0 03 00 00 	mov    %rax,0x3e0(%rbx)
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
  118bae:	4c 3b a3 e8 03 00 00 	cmp    0x3e8(%rbx),%r12
  118bb5:	75 25                	jne    118bdc <work_queue_main+0xe0>
	list->tail = node;
  118bb7:	48 89 83 e8 03 00 00 	mov    %rax,0x3e8(%rbx)
}
  118bbe:	eb 1c                	jmp    118bdc <work_queue_main+0xe0>
			(void)z_sched_wake_all(&queue->drainq, 1, NULL);
  118bc0:	4c 8d a3 00 04 00 00 	lea    0x400(%rbx),%r12
static inline bool z_sched_wake_all(_wait_q_t *wait_q, int swap_retval,
				    void *swap_data)
{
	bool woken = false;

	while (z_sched_wake(wait_q, swap_retval, swap_data)) {
  118bc7:	31 d2                	xor    %edx,%edx
  118bc9:	be 01 00 00 00       	mov    $0x1,%esi
  118bce:	4c 89 e7             	mov    %r12,%rdi
  118bd1:	e8 0c a0 ff ff       	callq  112be2 <z_sched_wake>
  118bd6:	84 c0                	test   %al,%al
  118bd8:	75 ed                	jne    118bc7 <work_queue_main+0xcb>
  118bda:	eb a7                	jmp    118b83 <work_queue_main+0x87>
	*flagp |= BIT(bit);
  118bdc:	83 8b 10 04 00 00 02 	orl    $0x2,0x410(%rbx)
	*flagp &= ~BIT(bit);
  118be3:	41 8b 44 24 18       	mov    0x18(%r12),%eax
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  118be8:	bf 18 ce 1b 00       	mov    $0x1bce18,%edi
			handler = work->handler;
  118bed:	4d 8b 74 24 08       	mov    0x8(%r12),%r14
	*flagp &= ~BIT(bit);
  118bf2:	83 e0 fb             	and    $0xfffffffb,%eax
  118bf5:	83 c8 01             	or     $0x1,%eax
  118bf8:	41 89 44 24 18       	mov    %eax,0x18(%r12)
  118bfd:	e8 97 4c ff ff       	callq  10d899 <z_spin_unlock_valid>
  118c02:	84 c0                	test   %al,%al
  118c04:	75 3b                	jne    118c41 <work_queue_main+0x145>
  118c06:	b9 b9 00 00 00       	mov    $0xb9,%ecx
  118c0b:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  118c10:	be 41 d2 11 00       	mov    $0x11d241,%esi
  118c15:	31 c0                	xor    %eax,%eax
  118c17:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  118c1c:	e8 d7 79 fe ff       	callq  1005f8 <printk>
  118c21:	be 18 ce 1b 00       	mov    $0x1bce18,%esi
  118c26:	bf 58 d2 11 00       	mov    $0x11d258,%edi
  118c2b:	31 c0                	xor    %eax,%eax
  118c2d:	e8 c6 79 fe ff       	callq  1005f8 <printk>
  118c32:	be b9 00 00 00       	mov    $0xb9,%esi
  118c37:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  118c3c:	e8 57 9f fe ff       	callq  102b98 <assert_post_action>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  118c41:	41 0f ba e5 09       	bt     $0x9,%r13d
  118c46:	73 01                	jae    118c49 <work_queue_main+0x14d>
		__asm__ volatile ("sti" ::: "memory");
  118c48:	fb                   	sti    
		k_spin_unlock(&lock, key);

		if (work != NULL) {
			bool yield;

			__ASSERT_NO_MSG(handler != NULL);
  118c49:	4d 85 f6             	test   %r14,%r14
  118c4c:	75 2a                	jne    118c78 <work_queue_main+0x17c>
  118c4e:	be ba 10 12 00       	mov    $0x1210ba,%esi
  118c53:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  118c58:	b9 8a 02 00 00       	mov    $0x28a,%ecx
  118c5d:	31 c0                	xor    %eax,%eax
  118c5f:	ba 99 10 12 00       	mov    $0x121099,%edx
  118c64:	e8 8f 79 fe ff       	callq  1005f8 <printk>
  118c69:	be 8a 02 00 00       	mov    $0x28a,%esi
  118c6e:	bf 99 10 12 00       	mov    $0x121099,%edi
  118c73:	e8 20 9f fe ff       	callq  102b98 <assert_post_action>
			handler(work);
  118c78:	4c 89 e7             	mov    %r12,%rdi
  118c7b:	41 ff d6             	callq  *%r14
  118c7e:	9c                   	pushfq 
  118c7f:	fa                   	cli    
  118c80:	41 5d                	pop    %r13
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  118c82:	bf 18 ce 1b 00       	mov    $0x1bce18,%edi
  118c87:	e8 ed 4b ff ff       	callq  10d879 <z_spin_lock_valid>
  118c8c:	84 c0                	test   %al,%al
  118c8e:	75 39                	jne    118cc9 <work_queue_main+0x1cd>
  118c90:	b9 8e 00 00 00       	mov    $0x8e,%ecx
  118c95:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  118c9a:	be fd d1 11 00       	mov    $0x11d1fd,%esi
  118c9f:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  118ca4:	e8 4f 79 fe ff       	callq  1005f8 <printk>
  118ca9:	be 18 ce 1b 00       	mov    $0x1bce18,%esi
  118cae:	bf 12 d2 11 00       	mov    $0x11d212,%edi
  118cb3:	31 c0                	xor    %eax,%eax
  118cb5:	e8 3e 79 fe ff       	callq  1005f8 <printk>
  118cba:	be 8e 00 00 00       	mov    $0x8e,%esi
  118cbf:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  118cc4:	e8 cf 9e fe ff       	callq  102b98 <assert_post_action>
	z_spin_lock_set_owner(l);
  118cc9:	bf 18 ce 1b 00       	mov    $0x1bce18,%edi
  118cce:	e8 ea 4b ff ff       	callq  10d8bd <z_spin_lock_set_owner>
	*flagp &= ~BIT(bit);
  118cd3:	41 8b 44 24 18       	mov    0x18(%r12),%eax
  118cd8:	89 c2                	mov    %eax,%edx
  118cda:	83 e2 fe             	and    $0xfffffffe,%edx
			 * starving other threads.
			 */
			key = k_spin_lock(&lock);

			flag_clear(&work->flags, K_WORK_RUNNING_BIT);
			if (flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
  118cdd:	a8 02                	test   $0x2,%al
  118cdf:	75 70                	jne    118d51 <work_queue_main+0x255>
	*flagp &= ~BIT(bit);
  118ce1:	41 89 54 24 18       	mov    %edx,0x18(%r12)
  118ce6:	8b 83 10 04 00 00    	mov    0x410(%rbx),%eax
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  118cec:	bf 18 ce 1b 00       	mov    $0x1bce18,%edi
  118cf1:	83 e0 fd             	and    $0xfffffffd,%eax
  118cf4:	89 83 10 04 00 00    	mov    %eax,0x410(%rbx)
	return (*flagp & BIT(bit)) != 0U;
  118cfa:	48 c1 e8 08          	shr    $0x8,%rax
  118cfe:	83 e0 01             	and    $0x1,%eax
  118d01:	49 89 c4             	mov    %rax,%r12
  118d04:	e8 90 4b ff ff       	callq  10d899 <z_spin_unlock_valid>
  118d09:	84 c0                	test   %al,%al
  118d0b:	0f 85 c1 00 00 00    	jne    118dd2 <work_queue_main+0x2d6>
  118d11:	b9 b9 00 00 00       	mov    $0xb9,%ecx
  118d16:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  118d1b:	31 c0                	xor    %eax,%eax
  118d1d:	be 41 d2 11 00       	mov    $0x11d241,%esi
  118d22:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  118d27:	e8 cc 78 fe ff       	callq  1005f8 <printk>
  118d2c:	be 18 ce 1b 00       	mov    $0x1bce18,%esi
  118d31:	bf 58 d2 11 00       	mov    $0x11d258,%edi
  118d36:	31 c0                	xor    %eax,%eax
  118d38:	e8 bb 78 fe ff       	callq  1005f8 <printk>
  118d3d:	be b9 00 00 00       	mov    $0xb9,%esi
  118d42:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  118d47:	e8 4c 9e fe ff       	callq  102b98 <assert_post_action>
  118d4c:	e9 81 00 00 00       	jmpq   118dd2 <work_queue_main+0x2d6>
	return list->head;
  118d51:	48 8b 3d e8 3f 0a 00 	mov    0xa3fe8(%rip),%rdi        # 1bcd40 <pending_cancels>
	*flagp &= ~BIT(bit);
  118d58:	83 e0 fc             	and    $0xfffffffc,%eax
  118d5b:	41 89 44 24 18       	mov    %eax,0x18(%r12)
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&pending_cancels, wc, tmp, node) {
  118d60:	48 85 ff             	test   %rdi,%rdi
  118d63:	74 81                	je     118ce6 <work_queue_main+0x1ea>
	return node->next;
  118d65:	4c 8b 3f             	mov    (%rdi),%r15
  118d68:	45 31 f6             	xor    %r14d,%r14d
			sys_slist_remove(&pending_cancels, prev, &wc->node);
  118d6b:	48 89 f8             	mov    %rdi,%rax
		if (wc->work == work) {
  118d6e:	4c 3b 67 08          	cmp    0x8(%rdi),%r12
  118d72:	75 4a                	jne    118dbe <work_queue_main+0x2c2>
  118d74:	48 8b 07             	mov    (%rdi),%rax
 */
static inline void sys_slist_remove(sys_slist_t *list,
				    sys_snode_t *prev_node,
				    sys_snode_t *node);

Z_GENLIST_REMOVE(slist, snode)
  118d77:	4d 85 f6             	test   %r14,%r14
  118d7a:	75 19                	jne    118d95 <work_queue_main+0x299>
  118d7c:	48 39 3d c5 3f 0a 00 	cmp    %rdi,0xa3fc5(%rip)        # 1bcd48 <pending_cancels+0x8>
	list->head = node;
  118d83:	48 89 05 b6 3f 0a 00 	mov    %rax,0xa3fb6(%rip)        # 1bcd40 <pending_cancels>
Z_GENLIST_REMOVE(slist, snode)
  118d8a:	75 1f                	jne    118dab <work_queue_main+0x2af>
	list->tail = node;
  118d8c:	48 89 05 b5 3f 0a 00 	mov    %rax,0xa3fb5(%rip)        # 1bcd48 <pending_cancels+0x8>
}
  118d93:	eb 16                	jmp    118dab <work_queue_main+0x2af>
	return list->tail;
  118d95:	48 8b 15 ac 3f 0a 00 	mov    0xa3fac(%rip),%rdx        # 1bcd48 <pending_cancels+0x8>
	parent->next = child;
  118d9c:	49 89 06             	mov    %rax,(%r14)
Z_GENLIST_REMOVE(slist, snode)
  118d9f:	48 39 fa             	cmp    %rdi,%rdx
  118da2:	75 07                	jne    118dab <work_queue_main+0x2af>
	list->tail = node;
  118da4:	4c 89 35 9d 3f 0a 00 	mov    %r14,0xa3f9d(%rip)        # 1bcd48 <pending_cancels+0x8>
	parent->next = child;
  118dab:	48 c7 07 00 00 00 00 	movq   $0x0,(%rdi)
			k_sem_give(&wc->sem);
  118db2:	48 83 c7 10          	add    $0x10,%rdi
	z_impl_k_sem_give(sem);
  118db6:	e8 cb 74 ff ff       	callq  110286 <z_impl_k_sem_give>
  118dbb:	4c 89 f0             	mov    %r14,%rax
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&pending_cancels, wc, tmp, node) {
  118dbe:	4d 85 ff             	test   %r15,%r15
  118dc1:	0f 84 1f ff ff ff    	je     118ce6 <work_queue_main+0x1ea>
	return node->next;
  118dc7:	4c 89 ff             	mov    %r15,%rdi
  118dca:	49 89 c6             	mov    %rax,%r14
  118dcd:	4d 8b 3f             	mov    (%r15),%r15
  118dd0:	eb 99                	jmp    118d6b <work_queue_main+0x26f>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  118dd2:	41 0f ba e5 09       	bt     $0x9,%r13d
  118dd7:	73 01                	jae    118dda <work_queue_main+0x2de>
		__asm__ volatile ("sti" ::: "memory");
  118dd9:	fb                   	sti    
			k_spin_unlock(&lock, key);

			/* Optionally yield to prevent the work queue from
			 * starving other threads.
			 */
			if (yield) {
  118dda:	45 84 e4             	test   %r12b,%r12b
  118ddd:	0f 85 2a fd ff ff    	jne    118b0d <work_queue_main+0x11>
	z_impl_k_yield();
  118de3:	e8 87 94 ff ff       	callq  11226f <z_impl_k_yield>
  118de8:	e9 20 fd ff ff       	jmpq   118b0d <work_queue_main+0x11>

0000000000118ded <submit_to_queue_locked>:
{
  118ded:	55                   	push   %rbp
  118dee:	48 89 e5             	mov    %rsp,%rbp
  118df1:	41 56                	push   %r14
  118df3:	41 55                	push   %r13
  118df5:	41 54                	push   %r12
  118df7:	49 89 f4             	mov    %rsi,%r12
  118dfa:	53                   	push   %rbx
	return (*flagp & BIT(bit)) != 0U;
  118dfb:	8b 57 18             	mov    0x18(%rdi),%edx
  118dfe:	48 89 d0             	mov    %rdx,%rax
	if (flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
  118e01:	a8 02                	test   $0x2,%al
  118e03:	0f 85 fe 00 00 00    	jne    118f07 <submit_to_queue_locked+0x11a>
	} else if (!flag_test(&work->flags, K_WORK_QUEUED_BIT)) {
  118e09:	80 e2 04             	and    $0x4,%dl
  118e0c:	0f 85 fd 00 00 00    	jne    118f0f <submit_to_queue_locked+0x122>
		if (*queuep == NULL) {
  118e12:	48 83 3e 00          	cmpq   $0x0,(%rsi)
  118e16:	48 89 fb             	mov    %rdi,%rbx
  118e19:	75 07                	jne    118e22 <submit_to_queue_locked+0x35>
			*queuep = work->queue;
  118e1b:	48 8b 57 10          	mov    0x10(%rdi),%rdx
  118e1f:	48 89 16             	mov    %rdx,(%rsi)
		ret = 1;
  118e22:	41 be 01 00 00 00    	mov    $0x1,%r14d
		if (flag_test(&work->flags, K_WORK_RUNNING_BIT)) {
  118e28:	a8 01                	test   $0x1,%al
  118e2a:	74 3f                	je     118e6b <submit_to_queue_locked+0x7e>
			__ASSERT_NO_MSG(work->queue != NULL);
  118e2c:	48 83 7b 10 00       	cmpq   $0x0,0x10(%rbx)
  118e31:	75 2a                	jne    118e5d <submit_to_queue_locked+0x70>
  118e33:	be d1 10 12 00       	mov    $0x1210d1,%esi
  118e38:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  118e3d:	b9 4e 01 00 00       	mov    $0x14e,%ecx
  118e42:	31 c0                	xor    %eax,%eax
  118e44:	ba 99 10 12 00       	mov    $0x121099,%edx
  118e49:	e8 aa 77 fe ff       	callq  1005f8 <printk>
  118e4e:	be 4e 01 00 00       	mov    $0x14e,%esi
  118e53:	bf 99 10 12 00       	mov    $0x121099,%edi
  118e58:	e8 3b 9d fe ff       	callq  102b98 <assert_post_action>
			*queuep = work->queue;
  118e5d:	48 8b 43 10          	mov    0x10(%rbx),%rax
			ret = 2;
  118e61:	41 be 02 00 00 00    	mov    $0x2,%r14d
			*queuep = work->queue;
  118e67:	49 89 04 24          	mov    %rax,(%r12)
		int rc = queue_submit_locked(*queuep, work);
  118e6b:	4d 8b 2c 24          	mov    (%r12),%r13
	if (queue == NULL) {
  118e6f:	4d 85 ed             	test   %r13,%r13
  118e72:	0f 84 9c 00 00 00    	je     118f14 <submit_to_queue_locked+0x127>
	bool chained = (_current == &queue->thread) && !k_is_in_isr();
  118e78:	31 c0                	xor    %eax,%eax
  118e7a:	4c 39 2d cf f8 00 00 	cmp    %r13,0xf8cf(%rip)        # 128750 <_kernel+0x10>
  118e81:	75 0b                	jne    118e8e <submit_to_queue_locked+0xa1>
  118e83:	e8 19 47 ff ff       	callq  10d5a1 <k_is_in_isr>
  118e88:	83 f0 01             	xor    $0x1,%eax
  118e8b:	0f b6 c0             	movzbl %al,%eax
	return (*flagp & BIT(bit)) != 0U;
  118e8e:	41 8b 95 10 04 00 00 	mov    0x410(%r13),%edx
	bool chained = (_current == &queue->thread) && !k_is_in_isr();
  118e95:	83 e0 01             	and    $0x1,%eax
	return (*flagp & BIT(bit)) != 0U;
  118e98:	48 89 d1             	mov    %rdx,%rcx
  118e9b:	48 89 d6             	mov    %rdx,%rsi
  118e9e:	48 c1 ea 03          	shr    $0x3,%rdx
  118ea2:	48 c1 e9 02          	shr    $0x2,%rcx
  118ea6:	83 e2 01             	and    $0x1,%edx
  118ea9:	83 e1 01             	and    $0x1,%ecx
	if (!flag_test(&queue->flags, K_WORK_QUEUE_STARTED_BIT)) {
  118eac:	40 80 e6 01          	and    $0x1,%sil
  118eb0:	74 6a                	je     118f1c <submit_to_queue_locked+0x12f>
	} else if (draining && !chained) {
  118eb2:	84 c0                	test   %al,%al
  118eb4:	75 06                	jne    118ebc <submit_to_queue_locked+0xcf>
  118eb6:	84 c9                	test   %cl,%cl
  118eb8:	74 06                	je     118ec0 <submit_to_queue_locked+0xd3>
  118eba:	eb 4b                	jmp    118f07 <submit_to_queue_locked+0x11a>
	} else if (plugged && !draining) {
  118ebc:	84 c9                	test   %cl,%cl
  118ebe:	75 04                	jne    118ec4 <submit_to_queue_locked+0xd7>
  118ec0:	84 d2                	test   %dl,%dl
  118ec2:	75 43                	jne    118f07 <submit_to_queue_locked+0x11a>
	return list->tail;
  118ec4:	49 8b 85 e8 03 00 00 	mov    0x3e8(%r13),%rax
	parent->next = child;
  118ecb:	48 c7 03 00 00 00 00 	movq   $0x0,(%rbx)
Z_GENLIST_APPEND(slist, snode)
  118ed2:	48 85 c0             	test   %rax,%rax
  118ed5:	75 10                	jne    118ee7 <submit_to_queue_locked+0xfa>
	list->tail = node;
  118ed7:	49 89 9d e8 03 00 00 	mov    %rbx,0x3e8(%r13)
	list->head = node;
  118ede:	49 89 9d e0 03 00 00 	mov    %rbx,0x3e0(%r13)
}
  118ee5:	eb 0a                	jmp    118ef1 <submit_to_queue_locked+0x104>
	parent->next = child;
  118ee7:	48 89 18             	mov    %rbx,(%rax)
	list->tail = node;
  118eea:	49 89 9d e8 03 00 00 	mov    %rbx,0x3e8(%r13)
		(void)notify_queue_locked(queue);
  118ef1:	4c 89 ef             	mov    %r13,%rdi
  118ef4:	e8 ed fb ff ff       	callq  118ae6 <notify_queue_locked.isra.0>
			work->queue = *queuep;
  118ef9:	49 8b 04 24          	mov    (%r12),%rax
	*flagp |= BIT(bit);
  118efd:	83 4b 18 04          	orl    $0x4,0x18(%rbx)
			work->queue = *queuep;
  118f01:	48 89 43 10          	mov    %rax,0x10(%rbx)
	if (ret <= 0) {
  118f05:	eb 23                	jmp    118f2a <submit_to_queue_locked+0x13d>
		ret = -EBUSY;
  118f07:	41 be f0 ff ff ff    	mov    $0xfffffff0,%r14d
  118f0d:	eb 13                	jmp    118f22 <submit_to_queue_locked+0x135>
	int ret = 0;
  118f0f:	45 31 f6             	xor    %r14d,%r14d
  118f12:	eb 0e                	jmp    118f22 <submit_to_queue_locked+0x135>
		return -EINVAL;
  118f14:	41 be ea ff ff ff    	mov    $0xffffffea,%r14d
  118f1a:	eb 06                	jmp    118f22 <submit_to_queue_locked+0x135>
		ret = -ENODEV;
  118f1c:	41 be ed ff ff ff    	mov    $0xffffffed,%r14d
		*queuep = NULL;
  118f22:	49 c7 04 24 00 00 00 	movq   $0x0,(%r12)
  118f29:	00 
}
  118f2a:	5b                   	pop    %rbx
  118f2b:	44 89 f0             	mov    %r14d,%eax
  118f2e:	41 5c                	pop    %r12
  118f30:	41 5d                	pop    %r13
  118f32:	41 5e                	pop    %r14
  118f34:	5d                   	pop    %rbp
  118f35:	c3                   	retq   

0000000000118f36 <k_work_submit_to_queue>:
{
  118f36:	55                   	push   %rbp
  118f37:	48 89 e5             	mov    %rsp,%rbp
  118f3a:	41 54                	push   %r12
  118f3c:	49 89 f4             	mov    %rsi,%r12
  118f3f:	53                   	push   %rbx
  118f40:	48 83 ec 10          	sub    $0x10,%rsp
  118f44:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	__ASSERT_NO_MSG(work != NULL);
  118f48:	48 85 f6             	test   %rsi,%rsi
  118f4b:	75 2a                	jne    118f77 <k_work_submit_to_queue+0x41>
  118f4d:	be ec 10 12 00       	mov    $0x1210ec,%esi
  118f52:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  118f57:	b9 69 01 00 00       	mov    $0x169,%ecx
  118f5c:	31 c0                	xor    %eax,%eax
  118f5e:	ba 99 10 12 00       	mov    $0x121099,%edx
  118f63:	e8 90 76 fe ff       	callq  1005f8 <printk>
  118f68:	be 69 01 00 00       	mov    $0x169,%esi
  118f6d:	bf 99 10 12 00       	mov    $0x121099,%edi
  118f72:	e8 21 9c fe ff       	callq  102b98 <assert_post_action>
  118f77:	9c                   	pushfq 
  118f78:	fa                   	cli    
  118f79:	5b                   	pop    %rbx
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  118f7a:	bf 18 ce 1b 00       	mov    $0x1bce18,%edi
  118f7f:	e8 f5 48 ff ff       	callq  10d879 <z_spin_lock_valid>
  118f84:	84 c0                	test   %al,%al
  118f86:	75 39                	jne    118fc1 <k_work_submit_to_queue+0x8b>
  118f88:	b9 8e 00 00 00       	mov    $0x8e,%ecx
  118f8d:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  118f92:	be fd d1 11 00       	mov    $0x11d1fd,%esi
  118f97:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  118f9c:	e8 57 76 fe ff       	callq  1005f8 <printk>
  118fa1:	be 18 ce 1b 00       	mov    $0x1bce18,%esi
  118fa6:	bf 12 d2 11 00       	mov    $0x11d212,%edi
  118fab:	31 c0                	xor    %eax,%eax
  118fad:	e8 46 76 fe ff       	callq  1005f8 <printk>
  118fb2:	be 8e 00 00 00       	mov    $0x8e,%esi
  118fb7:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  118fbc:	e8 d7 9b fe ff       	callq  102b98 <assert_post_action>
	z_spin_lock_set_owner(l);
  118fc1:	bf 18 ce 1b 00       	mov    $0x1bce18,%edi
  118fc6:	e8 f2 48 ff ff       	callq  10d8bd <z_spin_lock_set_owner>
	int ret = submit_to_queue_locked(work, &queue);
  118fcb:	4c 89 e7             	mov    %r12,%rdi
  118fce:	48 8d 75 e8          	lea    -0x18(%rbp),%rsi
  118fd2:	e8 16 fe ff ff       	callq  118ded <submit_to_queue_locked>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  118fd7:	bf 18 ce 1b 00       	mov    $0x1bce18,%edi
  118fdc:	41 89 c4             	mov    %eax,%r12d
  118fdf:	e8 b5 48 ff ff       	callq  10d899 <z_spin_unlock_valid>
  118fe4:	84 c0                	test   %al,%al
  118fe6:	75 39                	jne    119021 <k_work_submit_to_queue+0xeb>
  118fe8:	b9 b9 00 00 00       	mov    $0xb9,%ecx
  118fed:	ba d7 d1 11 00       	mov    $0x11d1d7,%edx
  118ff2:	be 41 d2 11 00       	mov    $0x11d241,%esi
  118ff7:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  118ffc:	e8 f7 75 fe ff       	callq  1005f8 <printk>
  119001:	be 18 ce 1b 00       	mov    $0x1bce18,%esi
  119006:	bf 58 d2 11 00       	mov    $0x11d258,%edi
  11900b:	31 c0                	xor    %eax,%eax
  11900d:	e8 e6 75 fe ff       	callq  1005f8 <printk>
  119012:	be b9 00 00 00       	mov    $0xb9,%esi
  119017:	bf d7 d1 11 00       	mov    $0x11d1d7,%edi
  11901c:	e8 77 9b fe ff       	callq  102b98 <assert_post_action>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  119021:	0f ba e3 09          	bt     $0x9,%ebx
  119025:	73 01                	jae    119028 <k_work_submit_to_queue+0xf2>
		__asm__ volatile ("sti" ::: "memory");
  119027:	fb                   	sti    
	if ((ret > 0) && (k_is_preempt_thread() != 0)) {
  119028:	45 85 e4             	test   %r12d,%r12d
  11902b:	7e 0e                	jle    11903b <k_work_submit_to_queue+0x105>
	return z_impl_k_is_preempt_thread();
  11902d:	e8 37 97 ff ff       	callq  112769 <z_impl_k_is_preempt_thread>
  119032:	85 c0                	test   %eax,%eax
  119034:	74 05                	je     11903b <k_work_submit_to_queue+0x105>
	z_impl_k_yield();
  119036:	e8 34 92 ff ff       	callq  11226f <z_impl_k_yield>
}
  11903b:	5a                   	pop    %rdx
  11903c:	44 89 e0             	mov    %r12d,%eax
  11903f:	59                   	pop    %rcx
  119040:	5b                   	pop    %rbx
  119041:	41 5c                	pop    %r12
  119043:	5d                   	pop    %rbp
  119044:	c3                   	retq   

0000000000119045 <k_work_queue_start>:
void k_work_queue_start(struct k_work_q *queue,
			k_thread_stack_t *stack,
			size_t stack_size,
			int prio,
			const struct k_work_queue_config *cfg)
{
  119045:	55                   	push   %rbp
  119046:	48 89 e5             	mov    %rsp,%rbp
  119049:	41 57                	push   %r15
  11904b:	41 89 cf             	mov    %ecx,%r15d
  11904e:	41 56                	push   %r14
  119050:	49 89 d6             	mov    %rdx,%r14
  119053:	41 55                	push   %r13
  119055:	49 89 f5             	mov    %rsi,%r13
  119058:	41 54                	push   %r12
  11905a:	49 89 fc             	mov    %rdi,%r12
  11905d:	53                   	push   %rbx
  11905e:	4c 89 c3             	mov    %r8,%rbx
  119061:	50                   	push   %rax
	__ASSERT_NO_MSG(queue);
  119062:	48 85 ff             	test   %rdi,%rdi
  119065:	75 2a                	jne    119091 <k_work_queue_start+0x4c>
  119067:	be b8 0d 12 00       	mov    $0x120db8,%esi
  11906c:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  119071:	b9 b8 02 00 00       	mov    $0x2b8,%ecx
  119076:	31 c0                	xor    %eax,%eax
  119078:	ba 99 10 12 00       	mov    $0x121099,%edx
  11907d:	e8 76 75 fe ff       	callq  1005f8 <printk>
  119082:	be b8 02 00 00       	mov    $0x2b8,%esi
  119087:	bf 99 10 12 00       	mov    $0x121099,%edi
  11908c:	e8 07 9b fe ff       	callq  102b98 <assert_post_action>
	__ASSERT_NO_MSG(stack);
  119091:	4d 85 ed             	test   %r13,%r13
  119094:	75 2a                	jne    1190c0 <k_work_queue_start+0x7b>
  119096:	be d4 0d 12 00       	mov    $0x120dd4,%esi
  11909b:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  1190a0:	b9 b9 02 00 00       	mov    $0x2b9,%ecx
  1190a5:	31 c0                	xor    %eax,%eax
  1190a7:	ba 99 10 12 00       	mov    $0x121099,%edx
  1190ac:	e8 47 75 fe ff       	callq  1005f8 <printk>
  1190b1:	be b9 02 00 00       	mov    $0x2b9,%esi
  1190b6:	bf 99 10 12 00       	mov    $0x121099,%edi
  1190bb:	e8 d8 9a fe ff       	callq  102b98 <assert_post_action>
	__ASSERT_NO_MSG(!flag_test(&queue->flags, K_WORK_QUEUE_STARTED_BIT));
  1190c0:	41 f6 84 24 10 04 00 	testb  $0x1,0x410(%r12)
  1190c7:	00 01 
  1190c9:	74 2a                	je     1190f5 <k_work_queue_start+0xb0>
  1190cb:	be 00 11 12 00       	mov    $0x121100,%esi
  1190d0:	bf aa cf 11 00       	mov    $0x11cfaa,%edi
  1190d5:	b9 ba 02 00 00       	mov    $0x2ba,%ecx
  1190da:	31 c0                	xor    %eax,%eax
  1190dc:	ba 99 10 12 00       	mov    $0x121099,%edx
  1190e1:	e8 12 75 fe ff       	callq  1005f8 <printk>
  1190e6:	be ba 02 00 00       	mov    $0x2ba,%esi
  1190eb:	bf 99 10 12 00       	mov    $0x121099,%edi
  1190f0:	e8 a3 9a fe ff       	callq  102b98 <assert_post_action>
	sys_dlist_init(&w->waitq);
  1190f5:	49 8d 84 24 f0 03 00 	lea    0x3f0(%r12),%rax
  1190fc:	00 
	list->head = NULL;
  1190fd:	49 c7 84 24 e0 03 00 	movq   $0x0,0x3e0(%r12)
  119104:	00 00 00 00 00 
	list->head = (sys_dnode_t *)list;
  119109:	49 89 84 24 f0 03 00 	mov    %rax,0x3f0(%r12)
  119110:	00 
	list->tail = (sys_dnode_t *)list;
  119111:	49 89 84 24 f8 03 00 	mov    %rax,0x3f8(%r12)
  119118:	00 
  119119:	49 8d 84 24 00 04 00 	lea    0x400(%r12),%rax
  119120:	00 
	list->head = (sys_dnode_t *)list;
  119121:	49 89 84 24 00 04 00 	mov    %rax,0x400(%r12)
  119128:	00 
	list->tail = (sys_dnode_t *)list;
  119129:	49 89 84 24 08 04 00 	mov    %rax,0x408(%r12)
  119130:	00 
	uint32_t flags = K_WORK_QUEUE_STARTED;
  119131:	b8 01 00 00 00       	mov    $0x1,%eax
	list->tail = NULL;
  119136:	49 c7 84 24 e8 03 00 	movq   $0x0,0x3e8(%r12)
  11913d:	00 00 00 00 00 

	sys_slist_init(&queue->pending);
	z_waitq_init(&queue->notifyq);
	z_waitq_init(&queue->drainq);

	if ((cfg != NULL) && cfg->no_yield) {
  119142:	48 85 db             	test   %rbx,%rbx
  119145:	74 0d                	je     119154 <k_work_queue_start+0x10f>
		flags |= K_WORK_QUEUE_NO_YIELD;
  119147:	80 7b 08 01          	cmpb   $0x1,0x8(%rbx)
  11914b:	19 c0                	sbb    %eax,%eax
  11914d:	30 c0                	xor    %al,%al
  11914f:	05 01 01 00 00       	add    $0x101,%eax
	*flagp = flags;
  119154:	41 89 84 24 10 04 00 	mov    %eax,0x410(%r12)
  11915b:	00 
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
  11915c:	6a ff                	pushq  $0xffffffffffffffff
  11915e:	45 31 c9             	xor    %r9d,%r9d
  119161:	4d 89 e0             	mov    %r12,%r8
  119164:	b9 fc 8a 11 00       	mov    $0x118afc,%ecx
  119169:	6a 00                	pushq  $0x0
  11916b:	4c 89 f2             	mov    %r14,%rdx
  11916e:	4c 89 ee             	mov    %r13,%rsi
  119171:	4c 89 e7             	mov    %r12,%rdi
  119174:	41 57                	push   %r15
  119176:	6a 00                	pushq  $0x0
  119178:	e8 f8 4c ff ff       	callq  10de75 <z_impl_k_thread_create>
  11917d:	48 83 c4 20          	add    $0x20,%rsp

	(void)k_thread_create(&queue->thread, stack, stack_size,
			      work_queue_main, queue, NULL, NULL,
			      prio, 0, K_FOREVER);

	if ((cfg != NULL) && (cfg->name != NULL)) {
  119181:	48 85 db             	test   %rbx,%rbx
  119184:	74 10                	je     119196 <k_work_queue_start+0x151>
  119186:	48 8b 33             	mov    (%rbx),%rsi
  119189:	48 85 f6             	test   %rsi,%rsi
  11918c:	74 08                	je     119196 <k_work_queue_start+0x151>
	return z_impl_k_thread_name_set(thread, str);
  11918e:	4c 89 e7             	mov    %r12,%rdi
  119191:	e8 4c 44 ff ff       	callq  10d5e2 <z_impl_k_thread_name_set>
	}

	k_thread_start(&queue->thread);

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_work_queue, start, queue);
}
  119196:	48 8d 65 d8          	lea    -0x28(%rbp),%rsp
	z_impl_k_thread_start(thread);
  11919a:	4c 89 e7             	mov    %r12,%rdi
  11919d:	5b                   	pop    %rbx
  11919e:	41 5c                	pop    %r12
  1191a0:	41 5d                	pop    %r13
  1191a2:	41 5e                	pop    %r14
  1191a4:	41 5f                	pop    %r15
  1191a6:	5d                   	pop    %rbp
  1191a7:	e9 36 46 ff ff       	jmpq   10d7e2 <z_impl_k_thread_start>

00000000001191ac <validate_any_object>:
#include <kernel.h>
#include <syscall_handler.h>
#include <kernel_structs.h>

static struct z_object *validate_any_object(const void *obj)
{
  1191ac:	55                   	push   %rbp
  1191ad:	48 89 e5             	mov    %rsp,%rbp
  1191b0:	41 54                	push   %r12
  1191b2:	49 89 fc             	mov    %rdi,%r12
  1191b5:	53                   	push   %rbx
	struct z_object *ko;
	int ret;

	ko = z_object_find(obj);
  1191b6:	e8 19 d9 ff ff       	callq  116ad4 <z_object_find>

	/* This can be any kernel object and it doesn't have to be
	 * initialized
	 */
	ret = z_object_validate(ko, K_OBJ_ANY, _OBJ_INIT_ANY);
  1191bb:	31 f6                	xor    %esi,%esi
  1191bd:	ba 01 00 00 00       	mov    $0x1,%edx
  1191c2:	48 89 c7             	mov    %rax,%rdi
	ko = z_object_find(obj);
  1191c5:	48 89 c3             	mov    %rax,%rbx
	ret = z_object_validate(ko, K_OBJ_ANY, _OBJ_INIT_ANY);
  1191c8:	e8 9f dd ff ff       	callq  116f6c <z_object_validate>
	if (ret != 0) {
  1191cd:	85 c0                	test   %eax,%eax
  1191cf:	74 11                	je     1191e2 <validate_any_object+0x36>
#ifdef CONFIG_LOG
		z_dump_object_error(ret, obj, ko, K_OBJ_ANY);
  1191d1:	48 89 da             	mov    %rbx,%rdx
  1191d4:	89 c7                	mov    %eax,%edi
  1191d6:	31 c9                	xor    %ecx,%ecx
  1191d8:	4c 89 e6             	mov    %r12,%rsi
  1191db:	e8 41 dc ff ff       	callq  116e21 <z_dump_object_error>
#endif
		return NULL;
  1191e0:	31 db                	xor    %ebx,%ebx
	}

	return ko;
}
  1191e2:	48 89 d8             	mov    %rbx,%rax
  1191e5:	5b                   	pop    %rbx
  1191e6:	41 5c                	pop    %r12
  1191e8:	5d                   	pop    %rbp
  1191e9:	c3                   	retq   

00000000001191ea <z_mrsh_k_object_access_grant>:
#include <syscalls/kobject.h>

extern void z_vrfy_k_object_access_grant(const void * object, struct k_thread * thread);
uintptr_t z_mrsh_k_object_access_grant(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
  1191ea:	55                   	push   %rbp
  1191eb:	48 89 e5             	mov    %rsp,%rbp
  1191ee:	41 56                	push   %r14
  1191f0:	41 55                	push   %r13
  1191f2:	49 89 fd             	mov    %rdi,%r13
static inline void z_vrfy_k_object_access_grant(const void *object,
						struct k_thread *thread)
{
	struct z_object *ko;

	Z_OOPS(Z_SYSCALL_OBJ_INIT(thread, K_OBJ_THREAD));
  1191f5:	48 89 f7             	mov    %rsi,%rdi
  1191f8:	41 54                	push   %r12
  1191fa:	49 89 f4             	mov    %rsi,%r12
  1191fd:	51                   	push   %rcx
	_current->syscall_frame = ssf;
  1191fe:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  119202:	48 8b 05 47 f5 00 00 	mov    0xf547(%rip),%rax        # 128750 <_kernel+0x10>
  119209:	48 89 90 40 01 00 00 	mov    %rdx,0x140(%rax)
  119210:	e8 bf d8 ff ff       	callq  116ad4 <z_object_find>
	ret = z_object_validate(ko, otype, init);
  119215:	ba 01 00 00 00       	mov    $0x1,%edx
  11921a:	be 09 00 00 00       	mov    $0x9,%esi
  11921f:	48 89 c7             	mov    %rax,%rdi
  119222:	49 89 c6             	mov    %rax,%r14
  119225:	e8 42 dd ff ff       	callq  116f6c <z_object_validate>
	if (ret != 0) {
  11922a:	85 c0                	test   %eax,%eax
  11922c:	74 2a                	je     119258 <z_mrsh_k_object_access_grant+0x6e>
  11922e:	89 c7                	mov    %eax,%edi
		z_dump_object_error(ret, obj, ko, otype);
  119230:	4c 89 f2             	mov    %r14,%rdx
  119233:	4c 89 e6             	mov    %r12,%rsi
  119236:	b9 09 00 00 00       	mov    $0x9,%ecx
  11923b:	e8 e1 db ff ff       	callq  116e21 <z_dump_object_error>
  119240:	ba 40 c8 11 00       	mov    $0x11c840,%edx
  119245:	be 45 00 00 00       	mov    $0x45,%esi
  11924a:	31 c0                	xor    %eax,%eax
  11924c:	bf 23 f3 11 00       	mov    $0x11f323,%edi
  119251:	e8 70 9e fe ff       	callq  1030c6 <z_log_minimal_printk>
  119256:	eb 29                	jmp    119281 <z_mrsh_k_object_access_grant+0x97>
	ko = validate_any_object(object);
  119258:	4c 89 ef             	mov    %r13,%rdi
  11925b:	e8 4c ff ff ff       	callq  1191ac <validate_any_object>
  119260:	48 89 c7             	mov    %rax,%rdi
	Z_OOPS(Z_SYSCALL_VERIFY_MSG(ko != NULL, "object %p access denied",
  119263:	48 85 c0             	test   %rax,%rax
  119266:	75 2c                	jne    119294 <z_mrsh_k_object_access_grant+0xaa>
  119268:	4c 89 e9             	mov    %r13,%rcx
  11926b:	ba 40 c8 11 00       	mov    $0x11c840,%edx
  119270:	be 45 00 00 00       	mov    $0x45,%esi
  119275:	31 c0                	xor    %eax,%eax
  119277:	bf 34 11 12 00       	mov    $0x121134,%edi
  11927c:	e8 45 9e fe ff       	callq  1030c6 <z_log_minimal_printk>
  119281:	48 8b 05 c8 f4 00 00 	mov    0xf4c8(%rip),%rax        # 128750 <_kernel+0x10>
  119288:	48 8b b8 40 01 00 00 	mov    0x140(%rax),%rdi
  11928f:	e8 79 09 ff ff       	callq  109c0d <arch_syscall_oops>
				    object));
	z_thread_perms_set(ko, thread);
  119294:	4c 89 e6             	mov    %r12,%rsi
  119297:	e8 f1 d9 ff ff       	callq  116c8d <z_thread_perms_set>
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	z_vrfy_k_object_access_grant(*(const void **)&arg0, *(struct k_thread **)&arg1)
;
	_current->syscall_frame = NULL;
  11929c:	48 8b 05 ad f4 00 00 	mov    0xf4ad(%rip),%rax        # 128750 <_kernel+0x10>
  1192a3:	48 c7 80 40 01 00 00 	movq   $0x0,0x140(%rax)
  1192aa:	00 00 00 00 
	return 0;
}
  1192ae:	31 c0                	xor    %eax,%eax
  1192b0:	5a                   	pop    %rdx
  1192b1:	41 5c                	pop    %r12
  1192b3:	41 5d                	pop    %r13
  1192b5:	41 5e                	pop    %r14
  1192b7:	5d                   	pop    %rbp
  1192b8:	c3                   	retq   

00000000001192b9 <z_mrsh_k_object_release>:
#include <syscalls/kobject.h>

extern void z_vrfy_k_object_release(const void * object);
uintptr_t z_mrsh_k_object_release(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
  1192b9:	55                   	push   %rbp
  1192ba:	48 89 e5             	mov    %rsp,%rbp
  1192bd:	41 54                	push   %r12
  1192bf:	49 89 fc             	mov    %rdi,%r12
  1192c2:	51                   	push   %rcx
	_current->syscall_frame = ssf;
  1192c3:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  1192c7:	48 8b 05 82 f4 00 00 	mov    0xf482(%rip),%rax        # 128750 <_kernel+0x10>
  1192ce:	48 89 90 40 01 00 00 	mov    %rdx,0x140(%rax)

static inline void z_vrfy_k_object_release(const void *object)
{
	struct z_object *ko;

	ko = validate_any_object((void *)object);
  1192d5:	e8 d2 fe ff ff       	callq  1191ac <validate_any_object>
	Z_OOPS(Z_SYSCALL_VERIFY_MSG(ko != NULL, "object %p access denied",
  1192da:	48 85 c0             	test   %rax,%rax
  1192dd:	75 2c                	jne    11930b <z_mrsh_k_object_release+0x52>
  1192df:	bf 34 11 12 00       	mov    $0x121134,%edi
  1192e4:	31 c0                	xor    %eax,%eax
  1192e6:	4c 89 e1             	mov    %r12,%rcx
  1192e9:	ba 20 c8 11 00       	mov    $0x11c820,%edx
  1192ee:	be 45 00 00 00       	mov    $0x45,%esi
  1192f3:	e8 ce 9d fe ff       	callq  1030c6 <z_log_minimal_printk>
  1192f8:	48 8b 05 51 f4 00 00 	mov    0xf451(%rip),%rax        # 128750 <_kernel+0x10>
  1192ff:	48 8b b8 40 01 00 00 	mov    0x140(%rax),%rdi
  119306:	e8 02 09 ff ff       	callq  109c0d <arch_syscall_oops>
				    (void *)object));
	z_thread_perms_clear(ko, _current);
  11930b:	48 8b 35 3e f4 00 00 	mov    0xf43e(%rip),%rsi        # 128750 <_kernel+0x10>
  119312:	48 89 c7             	mov    %rax,%rdi
  119315:	e8 b9 da ff ff       	callq  116dd3 <z_thread_perms_clear>
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	z_vrfy_k_object_release(*(const void **)&arg0)
;
	_current->syscall_frame = NULL;
  11931a:	48 8b 05 2f f4 00 00 	mov    0xf42f(%rip),%rax        # 128750 <_kernel+0x10>
  119321:	48 c7 80 40 01 00 00 	movq   $0x0,0x140(%rax)
  119328:	00 00 00 00 
	return 0;
}
  11932c:	31 c0                	xor    %eax,%eax
  11932e:	5a                   	pop    %rdx
  11932f:	41 5c                	pop    %r12
  119331:	5d                   	pop    %rbp
  119332:	c3                   	retq   

0000000000119333 <z_mrsh_k_object_alloc>:
#include <syscalls/kobject.h>

extern void * z_vrfy_k_object_alloc(enum k_objects otype);
uintptr_t z_mrsh_k_object_alloc(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
  119333:	55                   	push   %rbp
	_current->syscall_frame = ssf;
  119334:	48 8b 05 15 f4 00 00 	mov    0xf415(%rip),%rax        # 128750 <_kernel+0x10>
{
  11933b:	48 89 e5             	mov    %rsp,%rbp
	_current->syscall_frame = ssf;
  11933e:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  119342:	48 89 90 40 01 00 00 	mov    %rdx,0x140(%rax)
}
#include <syscalls/k_object_release_mrsh.c>

static inline void *z_vrfy_k_object_alloc(enum k_objects otype)
{
	return z_impl_k_object_alloc(otype);
  119349:	e8 5d d9 ff ff       	callq  116cab <z_impl_k_object_alloc>
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	void * ret = z_vrfy_k_object_alloc(*(enum k_objects*)&arg0)
;
	_current->syscall_frame = NULL;
  11934e:	48 8b 15 fb f3 00 00 	mov    0xf3fb(%rip),%rdx        # 128750 <_kernel+0x10>
  119355:	48 c7 82 40 01 00 00 	movq   $0x0,0x140(%rdx)
  11935c:	00 00 00 00 
	return (uintptr_t) ret;
}
  119360:	5d                   	pop    %rbp
  119361:	c3                   	retq   

0000000000119362 <z_object_gperf_find>:
  119362:	48 89 fa             	mov    %rdi,%rdx
  119365:	40 0f b6 cf          	movzbl %dil,%ecx
  119369:	45 31 c0             	xor    %r8d,%r8d
  11936c:	0f b6 c6             	movzbl %dh,%eax
  11936f:	0f b6 89 00 20 12 00 	movzbl 0x122000(%rcx),%ecx
  119376:	0f b6 80 00 20 12 00 	movzbl 0x122000(%rax),%eax
  11937d:	01 c8                	add    %ecx,%eax
  11937f:	83 f8 1a             	cmp    $0x1a,%eax
  119382:	7f 1c                	jg     1193a0 <z_object_gperf_find+0x3e>
  119384:	89 c1                	mov    %eax,%ecx
  119386:	48 6b c9 18          	imul   $0x18,%rcx,%rcx
  11938a:	48 3b b9 20 50 6e 00 	cmp    0x6e5020(%rcx),%rdi
  119391:	75 0d                	jne    1193a0 <z_object_gperf_find+0x3e>
  119393:	48 98                	cltq   
  119395:	48 6b c0 18          	imul   $0x18,%rax,%rax
  119399:	4c 8d 80 20 50 6e 00 	lea    0x6e5020(%rax),%r8
  1193a0:	4c 89 c0             	mov    %r8,%rax
  1193a3:	c3                   	retq   

00000000001193a4 <z_object_gperf_wordlist_foreach>:
  1193a4:	55                   	push   %rbp
  1193a5:	48 89 e5             	mov    %rsp,%rbp
  1193a8:	41 55                	push   %r13
  1193aa:	49 89 f5             	mov    %rsi,%r13
  1193ad:	41 54                	push   %r12
  1193af:	49 89 fc             	mov    %rdi,%r12
  1193b2:	53                   	push   %rbx
  1193b3:	bb 20 50 6e 00       	mov    $0x6e5020,%ebx
  1193b8:	52                   	push   %rdx
  1193b9:	48 83 3b 00          	cmpq   $0x0,(%rbx)
  1193bd:	74 09                	je     1193c8 <z_object_gperf_wordlist_foreach+0x24>
  1193bf:	4c 89 ee             	mov    %r13,%rsi
  1193c2:	48 89 df             	mov    %rbx,%rdi
  1193c5:	41 ff d4             	callq  *%r12
  1193c8:	48 83 c3 18          	add    $0x18,%rbx
  1193cc:	48 81 fb a8 52 6e 00 	cmp    $0x6e52a8,%rbx
  1193d3:	75 e4                	jne    1193b9 <z_object_gperf_wordlist_foreach+0x15>
  1193d5:	58                   	pop    %rax
  1193d6:	5b                   	pop    %rbx
  1193d7:	41 5c                	pop    %r12
  1193d9:	41 5d                	pop    %r13
  1193db:	5d                   	pop    %rbp
  1193dc:	c3                   	retq   

00000000001193dd <_kobject_text_area_end>:
  1193dd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1193e4:	00 00 00 
  1193e7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1193ee:	00 00 00 
  1193f1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1193f8:	00 00 00 
  1193fb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119402:	00 00 00 
  119405:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  11940c:	00 00 00 
  11940f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119416:	00 00 00 
  119419:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119420:	00 00 00 
  119423:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  11942a:	00 00 00 
  11942d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119434:	00 00 00 
  119437:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  11943e:	00 00 00 
  119441:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119448:	00 00 00 
  11944b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119452:	00 00 00 
  119455:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  11945c:	00 00 00 
  11945f:	0f 1f 00             	nopl   (%rax)
  119462:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119469:	00 00 00 
  11946c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119473:	00 00 00 
  119476:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  11947d:	00 00 00 
  119480:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119487:	00 00 00 
  11948a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119491:	00 00 00 
  119494:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  11949b:	00 00 00 
  11949e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1194a5:	00 00 00 
  1194a8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1194af:	00 00 00 
  1194b2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1194b9:	00 00 00 
  1194bc:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1194c3:	00 00 00 
  1194c6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1194cd:	00 00 00 
  1194d0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1194d7:	00 00 00 
  1194da:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1194e1:	00 00 00 
  1194e4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1194eb:	00 00 00 
  1194ee:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1194f5:	00 00 00 
  1194f8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1194ff:	00 00 00 
  119502:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119509:	00 00 00 
  11950c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119513:	00 00 00 
  119516:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  11951d:	00 00 00 
  119520:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119527:	00 00 00 
  11952a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119531:	00 00 00 
  119534:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  11953b:	00 00 00 
  11953e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119545:	00 00 00 
  119548:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  11954f:	00 00 00 
  119552:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119559:	00 00 00 
  11955c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119563:	00 00 00 
  119566:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  11956d:	00 00 00 
  119570:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119577:	00 00 00 
  11957a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119581:	00 00 00 
  119584:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  11958b:	00 00 00 
  11958e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119595:	00 00 00 
  119598:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  11959f:	00 00 00 
  1195a2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1195a9:	00 00 00 
  1195ac:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1195b3:	00 00 00 
  1195b6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1195bd:	00 00 00 
  1195c0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1195c7:	00 00 00 
  1195ca:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1195d1:	00 00 00 
  1195d4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1195db:	00 00 00 
  1195de:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1195e5:	00 00 00 
  1195e8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1195ef:	00 00 00 
  1195f2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1195f9:	00 00 00 
  1195fc:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119603:	00 00 00 
  119606:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  11960d:	00 00 00 
  119610:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119617:	00 00 00 
  11961a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119621:	00 00 00 
  119624:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  11962b:	00 00 00 
  11962e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119635:	00 00 00 
  119638:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  11963f:	00 00 00 
  119642:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119649:	00 00 00 
  11964c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119653:	00 00 00 
  119656:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  11965d:	00 00 00 
  119660:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119667:	00 00 00 
  11966a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119671:	00 00 00 
  119674:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  11967b:	00 00 00 
  11967e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119685:	00 00 00 
  119688:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  11968f:	00 00 00 
  119692:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119699:	00 00 00 
  11969c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1196a3:	00 00 00 
  1196a6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1196ad:	00 00 00 
  1196b0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1196b7:	00 00 00 
  1196ba:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1196c1:	00 00 00 
  1196c4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1196cb:	00 00 00 
  1196ce:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1196d5:	00 00 00 
  1196d8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1196df:	00 00 00 
  1196e2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1196e9:	00 00 00 
  1196ec:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1196f3:	00 00 00 
  1196f6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1196fd:	00 00 00 
  119700:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119707:	00 00 00 
  11970a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119711:	00 00 00 
  119714:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  11971b:	00 00 00 
  11971e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119725:	00 00 00 
  119728:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  11972f:	00 00 00 
  119732:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119739:	00 00 00 
  11973c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119743:	00 00 00 
  119746:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  11974d:	00 00 00 
  119750:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119757:	00 00 00 
  11975a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119761:	00 00 00 
  119764:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  11976b:	00 00 00 
  11976e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119775:	00 00 00 
  119778:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  11977f:	00 00 00 
  119782:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119789:	00 00 00 
  11978c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119793:	00 00 00 
  119796:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  11979d:	00 00 00 
  1197a0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1197a7:	00 00 00 
  1197aa:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1197b1:	00 00 00 
  1197b4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1197bb:	00 00 00 
  1197be:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1197c5:	00 00 00 
  1197c8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1197cf:	00 00 00 
  1197d2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1197d9:	00 00 00 
  1197dc:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1197e3:	00 00 00 
  1197e6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1197ed:	00 00 00 
  1197f0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1197f7:	00 00 00 
  1197fa:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119801:	00 00 00 
  119804:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  11980b:	00 00 00 
  11980e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119815:	00 00 00 
  119818:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  11981f:	00 00 00 
  119822:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119829:	00 00 00 
  11982c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119833:	00 00 00 
  119836:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  11983d:	00 00 00 
  119840:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119847:	00 00 00 
  11984a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119851:	00 00 00 
  119854:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  11985b:	00 00 00 
  11985e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119865:	00 00 00 
  119868:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  11986f:	00 00 00 
  119872:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119879:	00 00 00 
  11987c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119883:	00 00 00 
  119886:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  11988d:	00 00 00 
  119890:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119897:	00 00 00 
  11989a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1198a1:	00 00 00 
  1198a4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1198ab:	00 00 00 
  1198ae:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1198b5:	00 00 00 
  1198b8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1198bf:	00 00 00 
  1198c2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1198c9:	00 00 00 
  1198cc:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1198d3:	00 00 00 
  1198d6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1198dd:	00 00 00 
  1198e0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1198e7:	00 00 00 
  1198ea:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1198f1:	00 00 00 
  1198f4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1198fb:	00 00 00 
  1198fe:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119905:	00 00 00 
  119908:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  11990f:	00 00 00 
  119912:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119919:	00 00 00 
  11991c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119923:	00 00 00 
  119926:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  11992d:	00 00 00 
  119930:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119937:	00 00 00 
  11993a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119941:	00 00 00 
  119944:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  11994b:	00 00 00 
  11994e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119955:	00 00 00 
  119958:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  11995f:	00 00 00 
  119962:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119969:	00 00 00 
  11996c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119973:	00 00 00 
  119976:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  11997d:	00 00 00 
  119980:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119987:	00 00 00 
  11998a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119991:	00 00 00 
  119994:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  11999b:	00 00 00 
  11999e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1199a5:	00 00 00 
  1199a8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1199af:	00 00 00 
  1199b2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1199b9:	00 00 00 
  1199bc:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1199c3:	00 00 00 
  1199c6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1199cd:	00 00 00 
  1199d0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1199d7:	00 00 00 
  1199da:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1199e1:	00 00 00 
  1199e4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1199eb:	00 00 00 
  1199ee:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1199f5:	00 00 00 
  1199f8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1199ff:	00 00 00 
  119a02:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119a09:	00 00 00 
  119a0c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119a13:	00 00 00 
  119a16:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119a1d:	00 00 00 
  119a20:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119a27:	00 00 00 
  119a2a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119a31:	00 00 00 
  119a34:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119a3b:	00 00 00 
  119a3e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119a45:	00 00 00 
  119a48:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119a4f:	00 00 00 
  119a52:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119a59:	00 00 00 
  119a5c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119a63:	00 00 00 
  119a66:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119a6d:	00 00 00 
  119a70:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119a77:	00 00 00 
  119a7a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119a81:	00 00 00 
  119a84:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119a8b:	00 00 00 
  119a8e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119a95:	00 00 00 
  119a98:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119a9f:	00 00 00 
  119aa2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119aa9:	00 00 00 
  119aac:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119ab3:	00 00 00 
  119ab6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119abd:	00 00 00 
  119ac0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119ac7:	00 00 00 
  119aca:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119ad1:	00 00 00 
  119ad4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119adb:	00 00 00 
  119ade:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119ae5:	00 00 00 
  119ae8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119aef:	00 00 00 
  119af2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119af9:	00 00 00 
  119afc:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119b03:	00 00 00 
  119b06:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119b0d:	00 00 00 
  119b10:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119b17:	00 00 00 
  119b1a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119b21:	00 00 00 
  119b24:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119b2b:	00 00 00 
  119b2e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119b35:	00 00 00 
  119b38:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119b3f:	00 00 00 
  119b42:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119b49:	00 00 00 
  119b4c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119b53:	00 00 00 
  119b56:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119b5d:	00 00 00 
  119b60:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119b67:	00 00 00 
  119b6a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119b71:	00 00 00 
  119b74:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119b7b:	00 00 00 
  119b7e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119b85:	00 00 00 
  119b88:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119b8f:	00 00 00 
  119b92:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119b99:	00 00 00 
  119b9c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119ba3:	00 00 00 
  119ba6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119bad:	00 00 00 
  119bb0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119bb7:	00 00 00 
  119bba:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119bc1:	00 00 00 
  119bc4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119bcb:	00 00 00 
  119bce:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119bd5:	00 00 00 
  119bd8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119bdf:	00 00 00 
  119be2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119be9:	00 00 00 
  119bec:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119bf3:	00 00 00 
  119bf6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119bfd:	00 00 00 
  119c00:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119c07:	00 00 00 
  119c0a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119c11:	00 00 00 
  119c14:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119c1b:	00 00 00 
  119c1e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119c25:	00 00 00 
  119c28:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119c2f:	00 00 00 
  119c32:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119c39:	00 00 00 
  119c3c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119c43:	00 00 00 
  119c46:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119c4d:	00 00 00 
  119c50:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119c57:	00 00 00 
  119c5a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119c61:	00 00 00 
  119c64:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119c6b:	00 00 00 
  119c6e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119c75:	00 00 00 
  119c78:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119c7f:	00 00 00 
  119c82:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119c89:	00 00 00 
  119c8c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119c93:	00 00 00 
  119c96:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119c9d:	00 00 00 
  119ca0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119ca7:	00 00 00 
  119caa:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119cb1:	00 00 00 
  119cb4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119cbb:	00 00 00 
  119cbe:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119cc5:	00 00 00 
  119cc8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119ccf:	00 00 00 
  119cd2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119cd9:	00 00 00 
  119cdc:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119ce3:	00 00 00 
  119ce6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119ced:	00 00 00 
  119cf0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119cf7:	00 00 00 
  119cfa:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119d01:	00 00 00 
  119d04:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119d0b:	00 00 00 
  119d0e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119d15:	00 00 00 
  119d18:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119d1f:	00 00 00 
  119d22:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119d29:	00 00 00 
  119d2c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119d33:	00 00 00 
  119d36:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119d3d:	00 00 00 
  119d40:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119d47:	00 00 00 
  119d4a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119d51:	00 00 00 
  119d54:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119d5b:	00 00 00 
  119d5e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119d65:	00 00 00 
  119d68:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119d6f:	00 00 00 
  119d72:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119d79:	00 00 00 
  119d7c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119d83:	00 00 00 
  119d86:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119d8d:	00 00 00 
  119d90:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119d97:	00 00 00 
  119d9a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119da1:	00 00 00 
  119da4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119dab:	00 00 00 
  119dae:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119db5:	00 00 00 
  119db8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119dbf:	00 00 00 
  119dc2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119dc9:	00 00 00 
  119dcc:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119dd3:	00 00 00 
  119dd6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119ddd:	00 00 00 
  119de0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119de7:	00 00 00 
  119dea:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119df1:	00 00 00 
  119df4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119dfb:	00 00 00 
  119dfe:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119e05:	00 00 00 
  119e08:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119e0f:	00 00 00 
  119e12:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119e19:	00 00 00 
  119e1c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119e23:	00 00 00 
  119e26:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119e2d:	00 00 00 
  119e30:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119e37:	00 00 00 
  119e3a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119e41:	00 00 00 
  119e44:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119e4b:	00 00 00 
  119e4e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119e55:	00 00 00 
  119e58:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119e5f:	00 00 00 
  119e62:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119e69:	00 00 00 
  119e6c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119e73:	00 00 00 
  119e76:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119e7d:	00 00 00 
  119e80:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119e87:	00 00 00 
  119e8a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119e91:	00 00 00 
  119e94:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119e9b:	00 00 00 
  119e9e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119ea5:	00 00 00 
  119ea8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119eaf:	00 00 00 
  119eb2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119eb9:	00 00 00 
  119ebc:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119ec3:	00 00 00 
  119ec6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119ecd:	00 00 00 
  119ed0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119ed7:	00 00 00 
  119eda:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119ee1:	00 00 00 
  119ee4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119eeb:	00 00 00 
  119eee:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119ef5:	00 00 00 
  119ef8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119eff:	00 00 00 
  119f02:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119f09:	00 00 00 
  119f0c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119f13:	00 00 00 
  119f16:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119f1d:	00 00 00 
  119f20:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119f27:	00 00 00 
  119f2a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119f31:	00 00 00 
  119f34:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119f3b:	00 00 00 
  119f3e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119f45:	00 00 00 
  119f48:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119f4f:	00 00 00 
  119f52:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119f59:	00 00 00 
  119f5c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119f63:	00 00 00 
  119f66:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119f6d:	00 00 00 
  119f70:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119f77:	00 00 00 
  119f7a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119f81:	00 00 00 
  119f84:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119f8b:	00 00 00 
  119f8e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119f95:	00 00 00 
  119f98:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119f9f:	00 00 00 
  119fa2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119fa9:	00 00 00 
  119fac:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119fb3:	00 00 00 
  119fb6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119fbd:	00 00 00 
  119fc0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119fc7:	00 00 00 
  119fca:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119fd1:	00 00 00 
  119fd4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119fdb:	00 00 00 
  119fde:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119fe5:	00 00 00 
  119fe8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119fef:	00 00 00 
  119ff2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  119ff9:	00 00 00 
  119ffc:	0f 1f 40 00          	nopl   0x0(%rax)
